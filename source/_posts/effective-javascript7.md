---
title: effective-javascript7
date: 2017-03-9 08:34:20
tags:
  - js
  - effective javascript
  - note
---

## 并发
JS是一种嵌入式的脚本语言, JS程序不是作为独立的应用程序运行的,而是作为大型应用程序环境下的脚本运行的. 比如Web浏览器, 具有多个窗体(Window)和标签(Tab), 没个程序需要响应不同的输入和事件, 如键盘,鼠标,网络,定时任务等.

在JS中,编写响应多个并发事件的程序非常简单, 而且有时编写者甚至都不知道自己的代码是并发的. 这得益于JS的一个简单的执行模型, 即事件队列(事件循环并发) 和 异步API. 

但在官方ES标准中,并没有提及并发.

### 61. 不要阻塞I/O事件队列
在JS中,大多的I/O操作都提供了异步的或非阻塞的API, 给程序提供一个回调函数, 一旦输入完成就可以被系统调用,而不是将程序阻塞在等待结果的线程上. 比如浏览器在加载网页过程中下载资源.
```js
downloadAsync('http://example.com/file.txt', function(txt){
    ...
});
```
系统在程序调用的时候, 会适时的介入其中, 在完成操作的瞬间调用回调函数. 系统维护了一个按事件发生顺序排列的内部事件队列, 一次调用一个已注册的回调函数.

所以JS并发的最重要的规则是不要在应用程序事件队列中使用阻塞I/O的API.

异步的API在基于事件的环境中是安全的, 因为他们迫使应用程序逻辑在一个独立的事件循环"轮询"中继续处理. 

在上述下载文件的例子中, 假设下载资源需要一段时间, 在这段时间内, 有极其庞大的其他事件很可能发生. 在同步是实现中, 这些事件会堆积在事件队列中, 而事件循环将停留等待该JS代码执行完成, 这将阻塞任何其他事件的处理. 

但在异步版本中, JS代码注册一个事件处理程序并立即返回, 在下载完成之前, 允许其他事件处理程序处理这期间的事件.

比如,Web中的`Worker`的API使大量的并行计算成为可能. 不同于传统的线程执行, Workers在一个完全隔离的状态下执行, 没有获取全局作用域或主线程页面内容的能力. 因此,他们不会阻塞主事件队列中运行的代码的执行. 在一个Worker中, 使用`XMLHttpRequest`同步的版本很少出问题, 下载的操作会阻塞Worker的执行, 但并不阻止页面的渲染或事件队列中的事件响应.

在服务端环境, 阻塞的API在启动开始(在服务器开始接收响应输入的请求之前)是没问题的, 但在处理请求期间, 浏览器事件队列中存在阻塞API就是灾难.

1. **异步API使用回调函数来延缓处理代价高昂的操作以避免阻塞主应用程序**
2. **JS并发地接收事件,但会使用一个事件队列按序处理事件**
3. **在程序事件队列中不要使用阻塞的I/O**

### 62. 在异步序列中使用嵌套或命名的回调函数
借助闭包, 使用嵌套能将异步操作按照"顺序"执行. 但嵌套的异步操作很容易看懂, 但当扩展到更多的操作时, 序列会变得很笨拙.
```js
downloadAsync('url1', function(url){
    downloadAsync(url, function(file){
        downloadAsync('a.txt', function(a){
            downloadAsync('b.txt', function(b){
                ...
            });
        });
    });
});
```

减少过多嵌套的方法之一是将回调函数作为命名函数, 并将它们需要的附加数据作为额外的参数传递. 

# 此条笔记不完整,原因如下:
现在已经有`Promise`能结构良好的定义异步嵌套以及顺序调用的问题了.


### 63. 当心丢弃错误
管理异步编程的一个问题是对错误的处理, 对同步的代码, 通过`try`语句块包装一段代码很容易处理所有的错误.
```js
try{
    f();
    g();
    h();
} catch(e){
    // ...
}
```

对于异步的代码, 多步的处理通常被分割到事件队列的单独轮次中, 因此, 不可能将他们全部包在一个try语句中. 

事实上, 异步API甚至根本不抛出异常, 因为当一个异步错误发生时, 没有一个明显的执行上下文来抛出异常! 相反, 异步API倾向于将错误表示为回调函数的特定参数, 或使用一个附加的错误处理回调函数(也被称为errbacks).
```js
downloadAsync('url1', function(url){
    // ...
}, function(err){
    console.log(err);
});
```

还有一种错误处理的风格由Node.js而起, 将回调函数的第一个参数作为错误标识, 若有错误发生就表示为错误, 否则就是一个假值, 如`null`. 对这种错误, 可以定义一个通用的错误处理函数, 使用`if`语句来控制每个回调函数.
```js
function onErr(err){
    console.log(err);
}

downloadAsync('url1', function(err, url){
    if(err) return onErr(err);
    // ...
});
```

1. **通过编写共享的错误处理函数来避免复制和粘贴错误处理代码**
2. **确保明确的处理所有的错误条件以避免丢弃错误**

### 64. 对异步循环使用递归
将循环实现为一个函数
```js
function downloadOneAsync(urls, onsuccess, onfailure){
    var n = urls.length;
    function tryNextURL(i){
        if(i >= n){
            onfailure("all download failed");
            return;
        }

        downloadOneAsync(urls[i], onsuccess, function(){
            tryNextURL(i+1);
        });
    }
    tryNextURL(0);
}
```

通常情况下, 递归函数在调用自身太多后会产生运行错误, 由于耗尽栈空间, 最终抛出异常(栈溢出).

但异步回调函数不会耗尽栈空间, 因为异步API在其回调函数被调用前会立即返回, 其栈帧在任何递归调用将新的栈帧推入栈前, 会从调用栈中弹出.

事实上,回调函数总是在事件循环的单独轮次中被调用, 事件循环在每个轮次中调用其事件处理程序的调用栈最初是空的, 所以无论回调函数需要迭代调用多少次, 都不会耗尽栈空间.

1. **循环不能是异步的**
2. **使用递归函数在事件循环的单独轮次中执行迭代**
3. **在事件循环的单独轮次中执行递归, 并不会导致调用栈溢出**

### 65. 不要在计算时阻塞事件队列
为了保持客户端应用程序的高度交互性和确保所有传入的请求在服务器程序中得到了充分的服务,保持事件循环的每轮次尽可能短是很重要的. 否则,事件队列会滞销, 其增长速度会超过分发处理事件程序的速度.

1. **避免在主事件队列中执行代价高昂的算法**
2. **在支持Worker API的平台, 该API可以用来在一个独立的事件队列中运行长计算程序**
3. **在Worker API不可用或代价昂贵的环境中, 考虑将计算程序分解到事件循环的多个轮次中**

### 66. 使用计数器来执行并行操作
并发事件是JS中不确定性的主要来源, 程序的执行顺序并不能保证与事件发生的顺序一致.

当一个程序依赖于特定的时间顺序才能正常工作时, 这个程序会遭受数据竞争, 数据竞争是指多个并发操作可以修改共享的数据结构, 这取决于他们的发生顺序.

1. **JS程序中的事件发生是不确定的,即顺序是不可预测的**
2. **使用计数器避免并行操作中数据竞争**

### 67. 绝不要同步调用异步的回调函数

1. **即使可以立即得到数据,也绝不要同步地调用异步回调函数**
2. **同步地调用异步的回调函数扰乱了预期的操作序列, 并可能导致意向不到的交错代码**
3. **同步调用异步的回调函数可能导致栈溢出或错误的处理异常**
4. **使用异步的API, 比如setTimeout函数来调度异步回调函数,使其运行于另一个回合**

### 68. 使用Promise模式清洁异步逻辑

1. **promise代表最终值, 即并行操作完成时最终产生的结果**
2. **使用promise组合不同的并行操作**
3. **使用promise模式的API避免数据竞争**
4. **在要求有意的竞争条件时使用select(也被称为choose)**