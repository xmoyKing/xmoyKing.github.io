---
title: JavaScript高级程序设计-6-变量、作用域和内存问题1-基本类型和引用类型的值
categories: js
tags:
  - js
  - js-pro
date: 2016-08-06 17:18:11
updated:
---

按ECMA-262的定义，js的变量与其他语言有很大区别，js变量本质是松散类型，决定了它仅仅只是在特定的时间用于保存特定值的一个名字而已。由于这种灵活性，js变量很容易引发一些问题，同时能变得非常复杂。

### 基本类型和引用类型的值
ES变量可能包含两种不同类型的值：基本类型和引用类型。基本类型值指的是简单的数据段，而引用类型值指的是那些可能由多个值构成的对象。

在将一个值赋给变量时，解析器必须确定这个值是基本类型还是引用类型，5种基本类型是按值访问的，因为可以操作保持在变量中的实际的值。

引用类型的值是保存在内存中的对象，与其他语言不同，js不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象，所以，引用类型的值是按引用访问的。

注：其他语言中字符串是以对象的形式访问的，是引用类型的，但ES不是。

#### 动态的属性
定义基本类型和引用类型的方法是类似的，创建一个变量并为变量赋值即可。但保存到变量中后，不同类型的值可执行的操作却大不一样。对应引用类型的值，可以为其添加属性和方法，也可以改变和删除其上的属性和方法。

只能给引用类型的值动态添加属性，对基本类型的值添加属性和方法虽然不会报错，但是不会有任何效果。
```js
var name = "king";
name.age = 25;
console.log(name.age); // undefined
```

#### 复制变量值
对于基本类型来说，将一个变量复制给另一个变量其实是在变量对象上创建一个新值，然后将该值复制到为新办理分配的位置上。两个变量都独立。
```js
var num1 = 5;
var num2 = num1; // num2也等5，但num1和num2是彼此独立的。
```
![基本类型变量的复制](1.png)

但引用类型的复制则不同，复制操作结束后，两个变量实际上引用同一个对象，因此改变其在一个变量，会影响另一个变量。
```js
var obj1 = new Object();
var obj2 = obj1;
obj1.name = 'king';
console.log(obj2.name); // king
```
![引用类型变量的复制](2.png)

#### 传递参数
**ES中所有函数的参数都是按值传递的。**也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型的传递同基本类型变量的复制一样，而引用类型值的传递则同引用类型变量的复制一样。

当向参数传递基本类型的值时，被传递的值会背复制给一个局部变量（即命名参数，其实就是arguments对象的一个元素）。当向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此，这个局部变量的变化会反映在函数的外部。
```js
function setName(obj){
  obj.name = "king";
}
var person = new Object();
setName(person);
console.log(person.name); // "king"
```
上例中，在函数调用时，person对象被传递到setName函数中后就背复制给了obj，因为在函数内部obj和person引用的是同一个对象。即使这个对象是俺值传递的，obj也会按引用来访问同一个对象，所以在函数内部obj添加name属性会影响到函数外部的person对象。究其原因是因为person指向的对象在堆内存中只有一个，而且是全局对象。与下例做对比，更能体现函数参数是俺值传递的。
```js
function setName(obj){
  obj.name = "king";
  obj = new Object();
  obj.name = "new value";
}
var person = new Object();
setName(person);
console.log(person.name); // "king"
```
这个例子唯一的不同就是在setName多做了两个事儿，重新定义obj对象，同时为这个obj对象定义了一个带有不同值的name属性。在把person传递给setName后，其name属性被设置为king（因为此时obj和person指向同一个内存地址）。然后又将一个新对象赋值给obj，最后将这个其name属性改为new value。

若函数参数是按引用传递，则外部的person.name将会被更新为new value。而事实上却仍然是king，因为obj的引用在被修改为一个本地对象后，原person对象的引用就被obj丢弃了，所以原引用的修改就保持不变。这说明即使函数内部修改了参数的值，原始引用依然不变，实际上，当在函数内部重写obj时，obj变量引用的就是一个局部对象了，这个局部对象在函数执行完毕后就立即被销毁了。

#### 检测类型
要检测一个变量的类型是不是属于基本类型可以用typeof操作符，但当被检测变量是引用类型时，typeof仅仅只会返回object，但其实需要的不仅仅是“其是否为对象”，而是想知道其“具体是什么类型”的对象，为此，ES提供了instanceof操作符。

instanceof操作符判断给定引用类型是否为某个构造函数的实例，用法为`result = variable instanceof constructor`，result是一个布尔值。

### 执行环境及作用域
执行环境（execution context），也被称为“上下文”或“环境”，是js中最为重要的一个概念，执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的**变量对象（variable object）**,环境中定义的所有变量和函数都保存在这个对象中，程序员编写的代码无法访问这个对象，是供解析器在处理数据时使用的。

全局执行环境是最外围的一个执行环境，根据ES实现所在的宿主环境不同，表示执行环境的对象也不一样，在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出，比如：关闭网页或浏览器，时才退出）。

每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，将控制权返回给之前的执行环境，ES中的执行流就是由这种栈机制控制的。

当代码在一个环境中执行时，会创建变量对象的一个**作用域链（scope chain）**，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。若这个环境是函数，则将其**活动对象（activation object）**作为变量对象，活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象来自下一个包含环境，这样一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。

标识符解析是沿着作用域链一级一级的搜索标识符的过程，搜索过程始终从作用域链的前端开始，然后逐级的向后回溯，直到找到标识符为止，若找不到则可能报错或返回undefined。

```js
var color = 'blue';
function changeColor(){
  if(color === 'blue'){
    color = 'red';
  }
}
changeColor();
```
上例中，函数changeColor的作用域链包含两个对象：它自己的变量对象（其中定义了arguments对象）和全局环境的变量对象。

#### 延长作用域链
虽然执行环境的类型只有两种：全局和局部（函数），但有一些语句可以在作用域链的前端临时添加一个变量对象，这些临时变量对象会在代码执行后被移除，即除了函数之外，还有语句能够创建一个独立的作用域。分别是with语句和try-catch的catch块。

对with来说，将指定的对象添加到作用域链中。对catch块来说，则是创建一个新的变量对象，其内包含的是被抛出的错误对象的声明。

#### 没有块级作用域
由于js没有块级作用域，所以在条件语句中定义的变量将能被条件语句外访问，包括for循环初始化语句中定义的变量。

##### 声明变量
使用var声明的变量将会被自动添加到最接近的环境中，在函数内部，则这个环境就是函数的局部环境。所以这也是为什么不使用var声明变量时，变量会被自动添加到全局环境。

##### 查询标识符
由于作用域链，查询标识符（变量名或属性名）时将沿着作用域链依次回溯，直到找到，则立即返回。所以当在局部环境中定义的局部变量覆盖了全局变量后，想要访问全局变量则需要用window.name，或者访问预先保存的父级作用域对象。


