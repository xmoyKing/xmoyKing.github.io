---
title: Nodejs-事件、监听器、定时器、回调
categories:
  - Nodejs
tags:
  - nodejs
  - events
date: 2017-04-26 19:32:34
updated: 2017-04-26 19:32:34
---

node通过事件驱动模型提供了强大的扩展性和性能，node不同于其他Web服务器采用的传统线程模型

## 事件模型
node应用是在一个单线程的事件驱动模型中运行的，虽然node在后台实现了一个线程池，但是应用程序本身不具备多线程的概念。

### 比较事件回调和线程模型
传统线程网络模型中，请求进入一个Web服务器，并被分配给一个可用的线程，对于该请求的处理工作继续在该线程上进行，直到请求完成并发回响应。

Node不是在各个线程为每个请求执行所有的工作，而是将工作添加到一个事件队列中，然后有一个单独的线程运行一个事件循环把这个工作提取出来。 事件循环抓取队列中最上面的任务，执行，然后抓取下一个。

当执行长期运行或有阻塞I/O的代码时，它不是直接调用该函数，而是把函数随同一个要在此函数完成执行的回调一起添加到事件队列，当node事件队列中所有的事件都被执行完成时，应用停止。

比如有两个请求：GetFile和GetData，GetFile请求打开文件读取内容，然后在响应中将数据返回，GetData请求链接数据库，查询所需数据，然后返回。

在线程模型中，这些操作都是在独立的按顺序发生的。

![线程模型](1.png)

在事件回调方式中，node将GetFile和GetData请求添加到事件队列，然后先提取GetFile，执行，并指定Open回调函数添加到事件队列来完成它，然后提取GetData，执行，并指定Connect回调函数。
这种情况直到没有任何回调函数要执行。

![事件回调](2.png)
上图中，每个线程的事件并不完全遵守直接交错顺序。比如：Connect连接请求比Read读请求需要更长时间，所以Send()操作在Query查询之前调用。

### Node中的阻塞I/O
阻塞I/O停止当前线程的执行并等待一个