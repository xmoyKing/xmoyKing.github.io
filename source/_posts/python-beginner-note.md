---
title: python3入门-廖雪峰python3教程笔记
categories:
  - it
tags:
  - python
  - note
date: 2017-08-02 08:36:58
updated: 2017-08-02 08:36:58
---

主要记录下自己学习过程中的一些小笔记和疑问，以备复习巩固，主要学习资料为：[Python3入门-by廖雪峰](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)

### 函数返回值
参考：[定义函数](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431679203477b5b364aeba8c4e05a9bd4ec1b32911e2000)

一个函数可以返回多个值，用逗号分隔开即可，其实是被隐式的转换为一个tuple元组了,然后在调用函数后使用多个变量去接收这个tuple，而能够依次对应tuple中的每一个值，这种方式与js6中的解构赋值的新特性非常相似。
```python
import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
```

使用：
```python
x, y = move(100, 100, 60, math.pi / 6)
print(x, y)
151.96152422706632 70.0
```

### 函数的参数 
参考：[函数的参数](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000)

一个函数,传入一个list，添加一个END再返回：
```python
def add_end(L=[]):
    L.append('END')
    return L
```
普通传入数组的情况下是能正常使用的，
```python
add_end([1, 2, 3])
[1, 2, 3, 'END']
add_end(['x', 'y', 'z'])
['x', 'y', 'z', 'END']
```
但是若连续多次使用默认参数则会出现如下问题：
```python
add_end()
['END', 'END']
add_end()
['END', 'END', 'END']
```
似乎提到了这样的问题：关于多次调用同一个函数且不提供参数覆盖默认参数时会出现默认参数不销毁的问题（从其他高级语言如java,c++等类比，理论上函数调用后所有的局部变量都会被销毁）

博主的解释是python中函数定义的时候即将参数值初始化（而不是运行时再初始化）导致的，而解决的方法就是将默认参数指向不变对象，比如改为`None`，然后在函数内首先判断是否为`None`即可解决此问题：
```python
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
```
初一看发现没看懂为什么，但是琢磨一下，发现其实此解释也可以这样理解：因为一个数组`[]`是变量，即我们看到的变量名L其实是指向内存中的一个地址，该地址在默认情况下在定义的时候已经确定了，若不传入新的数组变量名，则变量名L地址不会被改变，而传入变量名的地址会覆盖原定义的L变量名，所以若不是连续调用，则不会出现这个问题。

同时，python中的函数参数定义非常非常灵活，与其他语言有较大差别，需要多用多记。

参数类型共有5种：必选参数、默认参数、可变参数、命名关键字参数和关键字参数

同时由于tuple和dict的特色结构，即:
> 对于任意的函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。

### 尾递归
参考:[递归函数](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756044276a15558a759ec43de8e30eb0ed169fb11000)

>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

### 由filter学到的求素数的方法

[用filter求素数](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431821084171d2e0f22e7cc24305ae03aa0214d0ef29000)

在很多面试或者OJ中都有这样的求素数的题目，而用埃氏筛法可以非常简单而快速的求出指定区间内的所有素数。思想如下：从小开始，将每一个该素数的倍数都筛选掉即可。

>首先，列出从2开始的所有自然数，构造一个序列：
2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：
3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：
5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数5，然后用5把序列的5的倍数筛掉：
7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
不断筛下去，就可以得到所有的素数。

