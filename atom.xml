<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KING · NOTE</title>
  
  <subtitle>前端·笔记·学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/xmoyKING/"/>
  <updated>2017-12-21T12:04:03.000Z</updated>
  <id>https://github.com/xmoyKING/</id>
  
  <author>
    <name>KING</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript框架设计笔记-4-选择器引擎</title>
    <link href="https://github.com/xmoyKING/2017/12/21/js-framework4/"/>
    <id>https://github.com/xmoyKING/2017/12/21/js-framework4/</id>
    <published>2017-12-21T12:04:03.000Z</published>
    <updated>2017-12-21T12:04:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何从头到尾制造一个选择器引擎，同时围观一下前人大神的努力。</p><p><em>getElementsBySelector，最古老的选择器引擎，它规定了今后许多选择器的发展方向。源码实现的思想就是利用正则切割css选择器，支持<code>#aa p.bb [cc==dd]</code>的形式，但CSS选择器不能超过两种，且其中一种为标签。</em></p><h4 id="选择器引擎涉及的知识点"><a href="#选择器引擎涉及的知识点" class="headerlink" title="选择器引擎涉及的知识点"></a>选择器引擎涉及的知识点</h4><p>主要时学习一些概念和术语，有关选择器引擎实现的概念大多时从Sizzle中抽取出来的，而CSS表达符部分则从W3C可以找到。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> &#123; <span class="attribute">color</span>: red; <span class="attribute">font-size</span>: <span class="number">14px</span>; &#125;</span><br></pre></td></tr></table></figure></p><p>上面的CSS样式规则中，<code>h2</code>为选择符，<code>color:red;</code>和<code>font-size: 14px;</code>为声明，<code>color</code>和<code>font-size</code>为属性，冒号后面的<code>red</code>和<code>14px</code>为值。</p><p>一般来说，选择符非常复杂，会混杂大量标记，能分割为许多更细的单元，不包括无法操作的伪元素的话，大致分为4大类17种。</p><p>4大类：</p><ul><li>并联选择器：逗号<code>,</code>，一种不是选择器的选择器，用于合并多个分组的结果</li><li>简单选择器：ID、标签、类、属性、通配符</li><li>关系选择器：亲子、后代、相邻、兄长</li><li>伪类：动作、目标、语言、状态、结构、取反</li></ul><p>其中简单选择器又称为基本选择器，通过<code>/isTag = !/\W/.test(part)</code>就可以进行判断（jQuery的方法），原生API也有很多支持，比如getElementById，getElementsByTagName,getElementsByClassName, document.all, 属性选择器用getAttribute，getAttributeNode，attributes、hasAttribute等，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习如何从头到尾制造一个选择器引擎，同时围观一下前人大神的努力。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;getElementsBySelector，最古老的选择器引擎，它规定了今后许多选择器的发展方向。源码实现的思想就是利用正则切割css选择器，支持&lt;code&gt;#aa p.bb [cc==
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="js-framework" scheme="https://github.com/xmoyKING/tags/js-framework/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript框架设计笔记-3-类工厂</title>
    <link href="https://github.com/xmoyKING/2017/12/18/js-framework3/"/>
    <id>https://github.com/xmoyKING/2017/12/18/js-framework3/</id>
    <published>2017-12-18T09:25:38.000Z</published>
    <updated>2017-12-18T09:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>直到ES6之前，JS没有真正传统的类，但可以模拟实现，所以类工厂是很多框架的标配，本篇主要学习各种类的实现。（PS:其实ES6中的<code>class</code>是一个语法糖，看着像传统的类而已，本质没变过，- -。）</p><h4 id="JS对类的支持"><a href="#JS对类的支持" class="headerlink" title="JS对类的支持"></a>JS对类的支持</h4><p>传统OO语言中，类的实例都通过构造函数new出来，JS存在new操作符，并且它的所有函数都作可以为构造器。</p><p>JS从其他语言借鉴了原型机制，prototype作为一个特殊的对象属性存在每一个函数上，当一个函数通过new操作符“创建”出“实例”，这个实例对象就拥有了这个函数的prototype对象所有一切成员，从而实现所有实例对象都共享一组方法或属性。JS的类通过修改这个prototype对象，以区别原生对象及其他自定义“类”。比如在浏览器中，Node类基于Object修改而来，而Element则基于Node，HTMLElement基于Element….</p><p>一般创建自己的类实现重用和共享：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 外观上，构造器和普通函数没有什么区别。习惯上大写首字母</span></span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  aa: <span class="string">'aa'</span>, <span class="comment">// 原型属性</span></span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 原型方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A; <span class="comment">// 创建实例a</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A; <span class="comment">// 创建实例b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.aa === b.aa); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.method === b.method); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>一般把定义在原型上的成员（方法/属性）叫原型成员，它为所有实例所共享。直接在构造器（通过this指定或直接var声明）内指定的方法叫特权成员，这些特权成员每一个实例一个副本，不会相互影响，因此通常把共享的用于操作数据的方法放在原型，把私有数据放在特权属性中。但若放在this上，则实例可在任何时候直接访问，当放在函数体内的作用域而不是this上时，就变成了私有属性（通过实例也无法访问，只有通过实例的方法能访问）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>; <span class="comment">// 私有属性</span></span><br><span class="line">  <span class="keyword">this</span>.aa = <span class="string">'aa'</span>; <span class="comment">// 特权属性</span></span><br><span class="line">  <span class="keyword">this</span>.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> count; &#125;; <span class="comment">// 特权方法</span></span><br><span class="line">  <span class="keyword">this</span>.obj = &#123;&#125;; <span class="comment">// 特权属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  aa: <span class="string">'aa'</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.aa === b.aa); <span class="comment">// true， 由于aa的值为基本类型，所以比较的是原始值，但其实有不同的内存地址</span></span><br><span class="line"><span class="built_in">console</span>.log(a.obj === b.obj); <span class="comment">// false 由于obj的值为引用类型，所以比较的是内存地址，可以看出是不同的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(a.method === b.method); <span class="comment">// false，函数其实也是特殊的对象，同引用类型的规则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> a.method;</span><br><span class="line"><span class="built_in">console</span>.log(a.method === A.prototype.method); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上例中的特权成员将同名的原型成员遮盖了，若将这些特权的成员删除，就又能访问原型成员了。</p><p>在Java中，原型方法与特权方法都被归为实例方法（即通过实例访问的，而不是通过类访问的），在Java中，还有一种类成员的东西，是通过类访问的，实例无法访问。JS中模拟则直接在类上定义即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A.method2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'A.method2'</span>) &#125;; <span class="comment">// 模拟Java的类方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> A;</span><br><span class="line"><span class="built_in">console</span>.log(c.method2); <span class="comment">// undefined</span></span><br><span class="line">A.method2(); <span class="comment">// A.method2</span></span><br></pre></td></tr></table></figure></p><p>继承的实现：即，只要prototype有啥，实例就有啥，无论这个成员是什么时候添加的。而若将prototype对象赋值为另一个类的原型（prototype），那么就能将另一个类的所有原型成员“偷”（或者叫“继承”）过来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  aaa: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">B.prototype = A.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B;</span><br><span class="line"><span class="built_in">console</span>.log(b.aaa); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">A.prototype.bbb = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.bbb); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>由于prototype引用的是相同对象，所以修改A类的原型（prototype属性），也等同于修改了B类的原型。而传统的继承却不是这样的，修改子类的原型不应该影响到父类原型，因此最好不要将一个原型对象赋给两个类。方法一，通过<code>for in</code>把父类的原型成员逐一赋给子类的原型（简单粗暴，直接添加/覆盖到子类原型）；方法二，子类的原型不是直接指向父类原型，而是先将此父类的原型赋给一个函数的原型，然后将这个函数的实例作为子类的原型（这样通过这个实例可以获取父类的原型成员，而且可以一直追溯到Object）。</p><p>方法一，通常是先自定义一个mixin(也叫extend)方法，该方法很简单，就是将一个对象中所有的属性都copy到另一个对象中，但问题是无法使用<code>instanceof</code>操作符获取是否是某类的实例的判断了（对传统继承而言，是否是某类的实例是非常重要的，许多设计模式或者判断需要依据类实例判断结果）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用时，传入的都是原型，将source中的成员都添加到destination，但会覆盖同名成员</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">destination, source</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> source)&#123;</span><br><span class="line">    destination[property] = source[property];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法二，被称为原型继承的经典方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  aa: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">1</span>) &#125;,</span><br><span class="line">  aaa: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bridge</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">bridge.prototype = A.prototype;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">B.prototype = <span class="keyword">new</span> bridge; <span class="comment">// 此处的new bridge操作得到了一个实例，</span></span><br><span class="line"><span class="comment">// 通过该实例能访问父类的原型成员，因为该实例的类的原型就是父类原型，</span></span><br><span class="line"><span class="comment">// 而在子类原型（其实是一个父类原型的实例）上添加新成员</span></span><br><span class="line"><span class="comment">// PS: 此处其实还有一个B.prototype.constructor的指向问题</span></span><br><span class="line"><span class="comment">//    实例的constructor（其实是创建一个函数的时候就自动添加到原型上的）指向其构造器</span></span><br><span class="line"><span class="comment">//    可参考：[深入分析js中的constructor 和prototype](https://www.cnblogs.com/yupeng/archive/2012/04/06/2435386.html)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(A.prototype == B.prototype); <span class="comment">// false,说明子类和父类的原型对象不是同一个对象了，成功分离</span></span><br><span class="line"><span class="built_in">console</span>.log(a.aa === b.aa); <span class="comment">// true,子类共享父类的原型方法</span></span><br><span class="line"></span><br><span class="line">A.prototype.bb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">2</span>) &#125; <span class="comment">// 为父类动态添加原型方法</span></span><br><span class="line"><span class="built_in">console</span>.log(a.bb === b.bb); <span class="comment">// true,子类总会共享父类的原型成员</span></span><br><span class="line"></span><br><span class="line">B.prototype.cc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">3</span>) &#125; <span class="comment">// 为子类动态添加原型方法</span></span><br><span class="line"><span class="built_in">console</span>.log(a.cc === b.cc); <span class="comment">// false,父类不会获取到子类修改后的原型成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof操作符能正确检测是否是实例</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> A); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> B); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>以上的实现方式其实在ES5中已经内置了，即Object.create方法。其原理类似上面的方法二，实现如下（排除第二个参数后的实现）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的o是一个原型对象（其实也可以是任意普通的对象）</span></span><br><span class="line"><span class="comment">// 返回子类的原型</span></span><br><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 相当于bridge函数，</span></span><br><span class="line">  F.prototype = o; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype); <span class="comment">// 如此即可指定B的原型为A的原型的一个实例，即B继承A</span></span><br></pre></td></tr></table></figure></p><p>但上面的方法二遗漏了一些东西，当父类有类成员和特权成员时，由于不是定义在父类原型中的，所以方法二的子类原型无法获取到，但传统的类中，子类其实是可以获取到父类的特权成员的（私有成员无法获取）。</p><p>在JS中的原型继承没有让子类获取到父类的类成员和特权成员，只能手动添加，这样就需要用到上面的方法一了，特权成员可以在子类的构造器中通过apply实现（即绑定this到父类上）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">init, Parent, proto</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个构造器，即真正的子类</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Parent.apply(<span class="keyword">this</span>, argument); <span class="comment">// 先继承父类的特权成员</span></span><br><span class="line">    init.apply(<span class="keyword">this</span>, argument); <span class="comment">// 再执行自己的构造器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于Object.create可能不是原生的，因此避免使用第二个参数,而是用一个空对象代替</span></span><br><span class="line">  Son.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;&#125;);</span><br><span class="line">  <span class="comment">// IE下子类无法自动通过父类原型实例获取到父类的toString和valueOf方法</span></span><br><span class="line">  Son.prototype.toString = Parent.prototype.toString;</span><br><span class="line">  Son.prototype.valueOf = Parent.prototype.valueOf;</span><br><span class="line">  Son.prototype.constructor = Son; <span class="comment">// 此处确保构造器的正确指向，而不是Object，</span></span><br><span class="line"></span><br><span class="line">  extend(Son.prototype, proto); <span class="comment">// 向子类添加自定义的原型成员</span></span><br><span class="line">  extend(Son, Parent); <span class="comment">// 向子类添加父类的类成员</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Son; <span class="comment">// 最后返回子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当访问实例的一个属性时，先找其特权成员，有则返回，没有就找原型，再没有则找父类的原型，直到Object，这就是实例的属性查找机制（即回溯机制）</p><p>对属性查找机制的测试如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  aa: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A;</span><br><span class="line"><span class="built_in">console</span>.log(a.aa); <span class="comment">// ƒ ()&#123; console.log(1) &#125; 即 function()&#123; console.log(1) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将A的整个原型换掉</span></span><br><span class="line">A.prototype = &#123;<span class="attr">aa</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.aa); <span class="comment">// 不影响，还是ƒ ()&#123; console.log(1) &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试是否能被constructor修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">B.prototype = &#123;</span><br><span class="line">  aa: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">a.constructor = B; </span><br><span class="line"><span class="built_in">console</span>.log(a.aa); <span class="comment">// 不影响</span></span><br></pre></td></tr></table></figure></p><p>上述的测试可以发现，无论修改类原型还是实例的constructor属性，都无法影响到实例查找某个原型上的属性，即回溯查找机制不是通过上面的prototype和constructor属性实现的。</p><p>ECMA规定每一个对象都有一个内部属性<code>[[Prototype]]</code>，它保存着当new该对象时构造器所引用的prototype指向，在浏览器中对象有一个属性<code>__proto__</code>可以访问这个内部属性，而这个属性就是回溯机制的关键，只要不动<code>__proto__</code>，实例的属性查找永远不会改变。</p><p>使用new操作符时发生的操作如下：</p><ol><li>创建一个空对象instance</li><li><code>instance.__proto__ = instanceClass.prototype</code></li><li>设置构造器函数里的<code>this = instance</code></li><li>执行构造器函数中的代码</li><li>判断是否有返回值，没有返回值默认为undefined，有引用类型的返回值则返回该引用，否则返回this</li></ol><p>验证如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.__proto__.aa); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">this</span>.aa = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  aa: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A;</span><br><span class="line"><span class="built_in">console</span>.log(a.aa); <span class="comment">// 2</span></span><br><span class="line">a.__proto__ = &#123;</span><br><span class="line">  aa: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> a.aa; <span class="comment">// 删除特权属性，暴露原型链上的同名属性</span></span><br><span class="line"><span class="built_in">console</span>.log(a.aa); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>有了<code>__proto__</code>属性句可以将原型继承变得简洁：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  aa: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B;</span><br><span class="line"><span class="built_in">console</span>.log(b.aa); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.constructor); <span class="comment">// ƒ B()&#123;&#125; 即 function B()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> A); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> B); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__ === B.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>相当于做了如下操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  aa: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bridge</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">bridge.prototype = A.prototype;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">B.prototype = <span class="keyword">new</span> bridge;</span><br><span class="line">B.prototype.constructor = B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B;</span><br><span class="line">B.prototype.cc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">3</span>); &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__ === B.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__.__proto__ === A.prototype); <span class="comment">// true 父类的原型对象</span></span><br></pre></td></tr></table></figure></p><p>因为<code>b.__proto__.constructor</code>指向<code>B</code>,而B的原型（<code>B.prototype</code>）是从bridge中得到的（是bridge的一个实例），而<code>bridge.prototype = A.prototype</code>。反过来，在定义时，让<code>B.prototype.__proto__ = A.prototype</code>就能轻松实现原型继承了。</p><h4 id="各种类工厂的实现"><a href="#各种类工厂的实现" class="headerlink" title="各种类工厂的实现"></a>各种类工厂的实现</h4><p>由于主流框架类工厂的实现太依赖于各种庞杂的工具函数，而一个精巧的类工厂不过百行左右，只要传入相应的参数或按一定简单格式就能创建一个类。</p><h5 id="P-js"><a href="#P-js" class="headerlink" title="P.js"></a>P.js</h5><p><a href="https://github.com/jneen/pjs">https://github.com/jneen/pjs</a></p><p>在调用父类的同名方法时，直接将父类的原型给出，省了_super的过程。</p><h5 id="JS-Class"><a href="#JS-Class" class="headerlink" title="JS.Class"></a>JS.Class</h5><p><a href="https://github.com/dkraczkowski/js.class">https://github.com/dkraczkowski/js.class</a></p><p>通过父类构造器的extend方法来产生自己的子类，里面存在一个开关，防止在生成类时无意执行construct方法。</p><p>在创建子类时，不通过中间的函数来断开双方的原型链，而是使用父类的实例来做子类的原型。</p><h5 id="simple-inheritance"><a href="#simple-inheritance" class="headerlink" title="simple-inheritance"></a>simple-inheritance</h5><p><a href="https://github.com/html5crew/simple-inheritance">https://github.com/html5crew/simple-inheritance</a></p><p>特点是方法链的实现非常优雅，节俭！</p><h5 id="def-js"><a href="#def-js" class="headerlink" title="def.js"></a>def.js</h5><p><a href="https://github.com/tobytailor/def.js">https://github.com/tobytailor/def.js</a></p><p>体现JS的灵活性，在形式上模拟Ruby继承，让学过Ruby的人一眼看出哪个是父类，哪个是子类。</p><h4 id="ES5属性描述符对OO库的影响"><a href="#ES5属性描述符对OO库的影响" class="headerlink" title="ES5属性描述符对OO库的影响"></a>ES5属性描述符对OO库的影响</h4><p>ES5中为对象引入属性描述符，能对属性进行更精细的控制，比如，属性是否可以修改，是否可以在for in循环中枚举出来，是否可以删除等。</p><p>Object提供的新方法如下：</p><ul><li>Object.keys</li><li>Object.getOwnPropertyNames</li><li>Object.getPrototypeOf</li><li>Object.defineProperty</li><li>Object.defineProperties</li><li>Object.getOwnPropertyDescriptor</li><li>Object.create</li><li>Object.seal</li><li>Object.freeze</li><li>Object.preventExtensions</li><li>Object.isSealed</li><li>Object.isFrozen</li><li>Object.isExtensible</li></ul><p>关于如上方法的介绍和基本用法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">MDN/Object</a></p><p>Object.create让原型继承更方便了，但在增加子类的专有原型成员或类成员时，若它们的属性的enumerable为false，单纯的for in循环已经不管用了，就需要用到Object.getOwnPropertyNames, 另外，访问器属性的复制只有通过Object.getOwnPropertyDescriptor和Object.defineProperty才能完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直到ES6之前，JS没有真正传统的类，但可以模拟实现，所以类工厂是很多框架的标配，本篇主要学习各种类的实现。（PS:其实ES6中的&lt;code&gt;class&lt;/code&gt;是一个语法糖，看着像传统的类而已，本质没变过，- -。）&lt;/p&gt;
&lt;h4 id=&quot;JS对类的支持&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="js-framework" scheme="https://github.com/xmoyKING/tags/js-framework/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript框架设计笔记-2-语言模块</title>
    <link href="https://github.com/xmoyKING/2017/12/17/js-framework2/"/>
    <id>https://github.com/xmoyKING/2017/12/17/js-framework2/</id>
    <published>2017-12-17T09:52:05.000Z</published>
    <updated>2017-12-17T09:52:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器提供的原生API总是不够的，因此各个框架都创造了许多方法来弥补这缺陷。这就是语言模块的来源，即添加许多对字符串、数组、函数…的方法来修复或增强语言的能力。主要介绍了一些非常底层的知识点，让我们更熟悉这门语言。</p><h4 id="字符串的扩展与修复"><a href="#字符串的扩展与修复" class="headerlink" title="字符串的扩展与修复"></a>字符串的扩展与修复</h4><p>脚本语言都对字符串特别关注，有关它的方法特别多。<br><img src="1.png" alt="String扩展"><br>wbr来自Tangram，用于软换行，</p><p>contains 方法：判定一个字符串是否包含另一个字符串。常规思维是使用正则表达式。但每次都要用new RegExp来构造，性能太差，转而使用原生字符串方法，如indexOf、lastIndexOf、search。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">target, it</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//indexOf改成search，lastIndexOf也行得通</span></span><br><span class="line">   <span class="keyword">return</span> target.indexOf(it) != <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>startsWith方法：判定目标字符串是否位于原字符串的开始之处，可以说是contains方法的变种。endsWith方法：与startsWith方法相反。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最后一个参数是忽略大小写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startsWith</span>(<span class="params">target, str, ignorecase</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start_str = target.substr(<span class="number">0</span>, str.length);</span><br><span class="line">    <span class="keyword">return</span> ignorecase ? start_str.toLowerCase() === str.toLowerCase() :</span><br><span class="line">            start_str === str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个参数是忽略大小写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">endsWith</span>(<span class="params">target, str, ignorecase</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> end_str = target.substring(target.length - str.length);</span><br><span class="line">    <span class="keyword">return</span> ignorecase ? end_str.toLowerCase() === str.toLowerCase() :</span><br><span class="line">            end_str === str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>repeat方法：将一个字符串重复自身N次，如repeat（”ruby”, 2）得到rubyruby。<br>其中有很多方法（具体实现就不写了，给出思想）：<br>版本1：利用空数组的join方法。<br>版本2：版本1的改良版。创建一个对象，使其拥有length属性，然后利用call方法去调用数组原型的join方法，省去创建数组这一步，性能大为提高。重复次数越多，两者对比越明显。另外，之所以要创建一个带length属性的对象，是因为要调用数组的原型方法，需要指定call的第一个参数为类数组对象，而类数组对象的必要条件是其length属性的值为非负整数。<br>版本3：版本2的改良版。利用闭包将类数组对象与数组原型的join方法缓存起来，避免每次都重复创建与寻找方法。<br>版本 4：从算法上着手，使用二分法，比如我们将ruby重复5次，其实我们在第二次已得到rubyruby，那么第3次直接用rubyruby进行操作，而不是用ruby。<br>版本5：版本4的变种，免去创建数组与使用jion方法。它的短处在于它在循环中创建的字符串比要求的还长，需要回减一下。<br>版本6：版本4的改良版。<br>版本7：与版本6相近。不过在浏览器下递归好像都做了优化（包括IE6），与其他版本相比，属于上乘方案之一。<br>版本8：通过用数组concat方法，使用递归的方式，可以说是一个反例，很慢，不过实际上它还是可行的，因为实际上没有人将n设成上百成千。</p><p>版本6在各浏览器的得分是最高的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">target, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = target, total = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            total += s;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        s += s;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>byteLen方法：取得一个字符串所有字节的长度。这是一个后端过来的方法，如果将一个英文字符插入数据库char、varchar、text类型的字段时占用一个字节，而将一个中文字符插入时占用两个字节。为了避免插入溢出，就需要事先判断字符串的字节长度。在前端，如果我们要用户填写文本，限制字节上的长短，比如发短信，也要用到此方法。随着浏览器普及对二进制的操作，该方法也越来越常用。</p><p>truncate方法：用于对字符串进行截断处理。当超过限定长度，默认添加3个点号。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">target, length, truncation</span>) </span>&#123;</span><br><span class="line">    length = length || <span class="number">30</span>;</span><br><span class="line">    truncation = truncation === <span class="keyword">void</span>(<span class="number">0</span>) ? <span class="string">'...'</span> : truncation;</span><br><span class="line">    <span class="keyword">return</span> target.length &gt; length ?</span><br><span class="line">            target.slice(<span class="number">0</span>, length - truncation.length) + truncation : <span class="built_in">String</span>(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>camelize方法：转换为驼峰风格。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target.indexOf(<span class="string">'-'</span>) &lt; <span class="number">0</span> &amp;&amp; target.indexOf(<span class="string">'_'</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;<span class="comment">//提前判断，提高getStyle等的效率</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.replace(<span class="regexp">/[-_][^-_]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match.charAt(<span class="number">1</span>).toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>underscored方法：转换为下划线风格。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">underscored</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target.replace(<span class="regexp">/([a-z\d])([A-Z])/g</span>, <span class="string">'$1_$2'</span>).</span><br><span class="line">            replace(<span class="regexp">/\-/g</span>, <span class="string">'_'</span>).toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>capitalize方法：首字母大写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target.charAt(<span class="number">0</span>).toUpperCase() + target.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>stripTags 方法：移除字符串中的html标签。比如，我们需要实现一个HTMLParser，这时就要处理option元素的innerText问题。此元素的内部只能接受文本节点，如果用户在里面添加了span、strong等标签，我们就需要用此方法将这些标签移除。在Prototype.js中，它与strip、stripScripts是一组方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rtag = <span class="regexp">/&lt;\w+(\s+("[^"]*"|'[^']*'|[^&gt;])+)?&gt;|&lt;\/\w+&gt;/gi</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stripTags</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(target || <span class="string">""</span>).replace(rtag, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>escapeHTML 方法：将字符串经过html转义得到适合在页面中显示的内容，如将“&lt;”替换为“&lt;”`。此方法用于防止XSS攻击。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/'/g</span>, <span class="string">"&amp;#39;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unescapeHTML</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(target)</span><br><span class="line">    .replace(<span class="regexp">/&amp;#39;/g</span>, <span class="string">'\''</span>)</span><br><span class="line">    .replace(<span class="regexp">/&amp;quot;/g</span>, <span class="string">'"'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&amp;lt;/g</span>, <span class="string">'&lt;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&amp;gt;/g</span>, <span class="string">'&gt;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&amp;amp;/g</span>, <span class="string">'&amp;'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>escapeHTML和unescapeHTML这两个方法，它们不但在replace的参数是反过来的，replace的顺序也是反过来的。它们在做html parser非常有用的。</p><p>pad方法：与trim方法相反，pad可以为字符串的某一端添加字符串。常见的用法如日历在月份前补零，因此也被称之为fillZero。</p><p>这个方法也有很多版本，如下版本，支持更多的参数，允许从左或从右填充，以及使用什么内容进行填充。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pad</span>(<span class="params">target, n, filling, right, radix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = target.toString(radix || <span class="number">10</span>);</span><br><span class="line">    filling = filling || <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">while</span> (num.length &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!right) &#123;</span><br><span class="line">            num = filling + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num += filling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在ECMA262V7规范中，pad方法也有了对应的代替品——padStart，此外，还有从后面补零的方法——padEnd。</p><h4 id="数组的扩展与修复"><a href="#数组的扩展与修复" class="headerlink" title="数组的扩展与修复"></a>数组的扩展与修复</h4><p>原生方法：</p><ul><li>pop方法：出栈操作，删除并返回数组的最后一个元素。</li><li>push方法：入栈操作，向数组的末尾添加一个或更多元素，并返回新的长度。</li><li>shift方法：出队操作，删除并返回数组的第一个元素。</li><li>unshift方法：入队操作，向数组的开头添加一个或更多元素，并返回新的长度。</li><li>slice方法：切片操作，从数组中分离出一个子数组，功能类似于字符串的。</li><li><p>substring、slice和substr是“三兄弟”，常用于转换类数组对象为真正的数组。</p></li><li><p>sort方法：对数组的元素进行排序，有一个可选参数，为比较函数。</p></li><li>reverse方法：颠倒数组中元素的顺序。</li><li>splice方法：可以同时用于原数组的增删操作，数组的remove方法就是基于它写成的。</li><li>concat方法：用于把原数组与参数合并成一个新数组，如果参数为数组，那么它会把其第一维的元素放入新数组中。因此我们可以利用它实现数组的平坦化操作与克隆操作。</li><li>join方法：把数组的所有元素放入一个字符串，元素通过指定的分隔符进行分隔。你可以想象成字符串split的反操作。</li><li>indexOf方法：定位操作，返回数组中第一个等于给定参数的元素的索引值。</li><li>lastIndexOf方法：定位操作，同上，不过是从后遍历。索引操作可以说是字符串同名方法的翻版，存在就返回非负整数，不存在就返回−1。</li><li>forEach方法：迭代操作，将数组的元素依次传入一个函数中执行。Ptototype.js中对应的名字为each。</li><li>map方法：收集操作，将数组的元素依次传入一个函数中执行，然后把它们的返回值组成一个新数组返回。Ptototype.js中对应的名字为collect。</li><li>filter方法：过滤操作，将数组的元素依次传入一个函数中执行，然后把返回值为true的那个元素放入新数组返回。在Prototype.js中，它有3个名字，即select、filter和findAll。</li><li>some方法：只要数组中有一个元素满足条件（放进给定函数返回true），那么它就返回true。Ptototype.js中对应的名字为any。</li><li>every方法：只有数组中所有元素都满足条件（放进给定函数返回true），它才返回true。Ptototype.js中对应的名字为all。</li><li>reduce方法：归化操作，将数组中的元素归化为一个简单的数值。Ptototype.js中对应的名字为inject。</li><li>reduceRight方法：归化操作，同上，不过是从后遍历。</li></ul><p>数组的空位<br>数组的空位是指数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。<br>空位不是undefined，而是一个位置的值等于undefined，但依然是有值的。空位是没有任何值，in运算符可以说明这一点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true </span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p><p>ECMA262V5,大多数情况下会忽略空位。比如，forEach()、filter()、every()和some()都会跳过空位；map()会跳过空位，但会保留这个值；join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> log(i)); <span class="comment">// 1  </span></span><br><span class="line">[<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']  </span></span><br><span class="line">[,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true  </span></span><br><span class="line">[,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false </span></span><br><span class="line">[,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]  </span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"  </span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></span><br></pre></td></tr></table></figure></p><p>ECMA262V6则是明确将空位转为undefined。比如，Array.from方法会将数组的空位转为undefined，也就是说，这个方法不会忽略空位。扩展运算符（…）也会将空位转为undefined。</p><h4 id="数值的扩展与修复"><a href="#数值的扩展与修复" class="headerlink" title="数值的扩展与修复"></a>数值的扩展与修复</h4><p>数值没有什么好扩展的，而且JavaScript的数值精度问题未修复，要修复它们可不是一两行代码了事。 </p><p>一些问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">Infinity</span> &gt; <span class="number">100</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="number">25001509088465005</span>)) <span class="comment">//25001509088465004</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1000000000000000000000000001</span>) <span class="comment">//0.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.100000000000000000000000001</span>) <span class="comment">//0.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1000000000000000000000000456</span>) <span class="comment">//0.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.09999999999999999999999</span>) <span class="comment">//0.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> / <span class="number">3</span>) <span class="comment">//0.3333333333333333</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">23.53</span> + <span class="number">5.88</span> + <span class="number">17.64</span>)<span class="comment">// 47.05</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">23.53</span> + <span class="number">17.64</span> + <span class="number">5.88</span>)<span class="comment">// 47.050000000000004</span></span><br></pre></td></tr></table></figure></p><p>这些其实不是bug，而是我们无法接受这事实。在JavaScript中，数值有3种保存方式。</p><p>（1）字符串形式的数值内容。</p><p>（2）IEEE 754标准双精度浮点数，它最多支持小数点后带15～17位小数，由于存在二进制和十进制的转换问题，具体的位数会发生变化。</p><p>（3）一种类似于C语言的int类型的32位整数，它由4个8 bit的字节构成，可以保存较小的整数。</p><p>当JavaScript遇到一个数值时，它会首先尝试按整数来处理该数值，如果行得通，则把数值保存为31 bit的整数；如果该数值不能视为整数，或超出31 bit的范围，则把数值保存为64位的IEEE 754浮点数。</p><p>这样一个问题：什么时候规规矩矩的整数会突然变成捉摸不定的双精度浮点数？答案是：当它们的值变得非常庞大时，或者进入1和0之间时，规矩矩矩的整数就会变成捉摸不定的双精度浮点数。因此，我们需要注意以下数值。</p><p>首先是1和0；其次是最大的Unicode数值1114111（7位数字，相当于（/x41777777）；最大的RGB颜色值16777215（8位数字，相当于#FFFFFF）；最大的32 bit整数是147483647（10位数字，即Math.pow(2,31)-1）；最少的32位bit整数 -2147483648，因为JavaScript内部会以整数的形式保存所有Unicode值和RGB颜色；再次是2147483647，任何大于该值的数据将保存为双精度格式；最大的浮点数9007199254740992（16位数字，即Math.pow（2,53）），因为输出时类似整数，而所有Date对象（按毫秒计算）都小于该值，因此总是模拟整数的格式输出；最大的双精度数值1.7976931348623157e+308，超出这个范围就要算作无穷大了。</p><p>大数相加出问题是由于精度的不足，小数相加出问题是进制转算时产生误差。第一个好理解，第二个，主要是我们常用的十进制转换为二进制时，变成循环小数及无理数等有无限多位小数的数，计算机要用有限位数的浮点数来表示是无法实现的，只能从某一位进行截短。而且，因为内部表示是二进制，十进制看起来是能除尽的数，往往在二进制是循环小数。</p><p>比如用二进制来表示十进制的0.1，就得写成2的幂（因为小于1，所以幂是负数）相加的形式。若一直持续下去，0.1就成了0.000110011001100110011…这种循环小数。在有效数字的范围内进行舍入，就会产生误差。</p><p><strong>综上，我们就尽量避免小数操作与大数操作，或者转交后台去处理，实在避免不了就引入专业的库来处理。</strong></p><h4 id="函数的扩展与修复"><a href="#函数的扩展与修复" class="headerlink" title="函数的扩展与修复"></a>函数的扩展与修复</h4><p>ECMA262V5对函数唯一的扩展就是bind函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span> &amp;&amp; context == <span class="keyword">void</span> <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> __method = <span class="keyword">this</span>, args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __method.apply(context, args.concat.apply(args, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>curry、partial的应用场景在前端世界[2]真心不多，前端讲究的是即时显示，许多API都是同步的，后端由于IO操作等耗时长，像Node.js提供了大量的异步函数来提高性能，防止堵塞。但是过多异步函数也必然带来回调嵌套的问题，因此我们需要通过curry等函数变换，将套嵌减少到可以接受的程度。</p><h4 id="日期的扩展与修复"><a href="#日期的扩展与修复" class="headerlink" title="日期的扩展与修复"></a>日期的扩展与修复</h4><p>Date构造器是JavaScript中传参形式最丰富的构造器，大致分为4种。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(value);<span class="comment">//传入毫秒数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(dateString);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, month, day <span class="comment">/*, hour, minute, second, millisecond*/</span>);</span><br></pre></td></tr></table></figure></p><p>其中第3种可以玩多种花样，作者建议只使用“2009/07/12 12:34:56”，后面的时分秒可省略。这个所有浏览器都支持。</p><h3 id="浏览器嗅探与特征检测"><a href="#浏览器嗅探与特征检测" class="headerlink" title="浏览器嗅探与特征检测"></a>浏览器嗅探与特征检测</h3><p>浏览器嗅探已经不推荐了，但有些时候还是需要的。具体来说就是判断某个对象有没有此方法或属性，严格一些则看看该方法有没有达到预期效果。标准浏览器中提供了document.implementation.hasfeature方法，但不准确。</p><p>特性侦测的好处是浏览器不会随意去掉某一个功能，但注意不能使用标准属性与方法做判断依据，每个浏览器都有自己的私有实现，用它们做判定就可以了。</p><p>具体的检测方法可以看jquery 1.9以前的嗅探模块源码$.browser</p><h4 id="事件的支持侦测"><a href="#事件的支持侦测" class="headerlink" title="事件的支持侦测"></a>事件的支持侦测</h4><p>判断浏览器对某种事件的支持,jQuery的实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.eventSupport = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, el</span>)</span>&#123;</span><br><span class="line">  el = el || <span class="built_in">document</span>.documentElement;</span><br><span class="line">  eventNmae = <span class="string">'on'</span> + eventName;</span><br><span class="line">  <span class="keyword">var</span> ret = eventName <span class="keyword">in</span> el; <span class="comment">// in 操作符用来判断属性是否存在与对象中,无论该属性存在于实例中还是原型中</span></span><br><span class="line">  <span class="keyword">if</span>(el.setAttribute &amp;&amp; !ret) &#123;</span><br><span class="line">    el.setAttribute(eventName, <span class="string">''</span>);</span><br><span class="line">    ret = <span class="keyword">typeof</span> el[eventName] === <span class="string">'function'</span>;</span><br><span class="line">    el.removeAttribute(eventName);</span><br><span class="line">  &#125;</span><br><span class="line">  el = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>但这种检测只对DOM0事件有效，像DOMMouseSroll，DOMContentLoaded，DOMFocusIn，DOMNodeInserted这些以DOM开头的事件就无能为力了。</p><h4 id="样式的支持侦测"><a href="#样式的支持侦测" class="headerlink" title="样式的支持侦测"></a>样式的支持侦测</h4><p>一般的方法就是W3C推出CSS.supports方法，该API能够探知浏览器是否支持某种样式。但其实还是有很多无法检测。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浏览器提供的原生API总是不够的，因此各个框架都创造了许多方法来弥补这缺陷。这就是语言模块的来源，即添加许多对字符串、数组、函数…的方法来修复或增强语言的能力。主要介绍了一些非常底层的知识点，让我们更熟悉这门语言。&lt;/p&gt;
&lt;h4 id=&quot;字符串的扩展与修复&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="js-framework" scheme="https://github.com/xmoyKING/tags/js-framework/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript框架设计笔记-1-种子模块</title>
    <link href="https://github.com/xmoyKING/2017/12/16/js-framework1/"/>
    <id>https://github.com/xmoyKING/2017/12/16/js-framework1/</id>
    <published>2017-12-16T08:15:31.000Z</published>
    <updated>2017-12-16T08:15:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列笔记来源于《JavaScript框架设计》一书，但是非常尴尬的是，我买的不是第二版的，= =！<a href="http://www.epubit.com.cn/book/details/4849" target="_blank" rel="noopener">《JavaScript框架设计（第2版）》</a>一书，学习JS框架底层库知识，一个框架应该提供那些功能，应该如何区分这些模块等等，第二版前2章在网上有公开的，可以免费阅读。</p><p>注：作者提到的很多都是以<a href="http://avalonjs.coding.me/" target="_blank" rel="noopener">Avalon</a>作为示例的，而本系列笔记仅提取个人记录之处，同时，书中的模块基于CommonJS规范（即Node模块的定义方式）</p><h4 id="种子模块介绍"><a href="#种子模块介绍" class="headerlink" title="种子模块介绍"></a>种子模块介绍</h4><p>种子模块也叫核心模块，是框架的最先执行的部分。即便像jQuery那样的单文件函数库，它的内部也分许多模块，必然有一些模块冲在前面立即执行；有一些模块只有用到才执行；也有一些模块（补丁模块）可有可无，存在感比较弱，只在特定浏览器下才运行。</p><p>既然是最先执行的模块，那么就要求其里面的方法是历经考验、千锤百炼的，并且能将这个模块变得极具扩展性、高可用、稳定性。</p><p>（1）扩展性，是指方便将其他模块的方法或属性加入进来，让种子迅速成长为“一棵大树”。</p><p>（2）高可用，是指这里的方法是极其常用的，其他模块不用重复定义它们。</p><p>（3）稳定性，是指不能轻易在以后版本中删除，要信守承诺。</p><p>参照许多框架与库的实现，作者认为种子模块应该包含如下功能：对象扩展、数组化、类型判定、无冲突处理、domReady。</p><h4 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h4><p>我们需要一种机制，将新功能添加到我们的命名空间上。命名空间，是指我们这个框架在全局作用域暴露的唯一变量，它多是一个对象或一个函数。命名空间通常也就是框架名字。我们可以看一下别人是如何为框架起名字的。 <a href="https://www.zhihu.com/question/46804815" target="_blank" rel="noopener">https://www.zhihu.com/question/46804815</a></p><p>回到主题，对象扩展这种机制，我们一般做成一个方法，叫做extend或mixin。JavaScript对象在属性描述符[3]（Property Descriptor）没有诞生之前，是可以随意添加、更改、删除其成员的，因此扩展一个对象非常便捷。由于此功能这么常用，到后来ES6就干脆支持它了，于是有了 Object.assgin。如果要低端浏览器直接用它，可以使用以下polyfill</p><p>关于polyfill：<em>Polyfilling是由RemySharp提出的一个术语，它是用来描述复制缺少的API和API功能的行为。你可以使用它编写单独应用的代码，而不用担心其他浏览器原生是不是支持。实际上，polyfills并不是新技术，也不是和HTML5捆绑到一起的。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToObject</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object.assign cannot be called with null or undefined'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Object</span>.assign || <span class="function"><span class="keyword">function</span> (<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">var</span> keys;</span><br><span class="line">    <span class="keyword">var</span> to = ToObject(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> s = <span class="number">1</span>; s &lt; <span class="built_in">arguments</span>.length; s++) &#123;</span><br><span class="line">        <span class="keyword">from</span> = <span class="built_in">arguments</span>[s];</span><br><span class="line">        keys = <span class="built_in">Object</span>.keys(<span class="built_in">Object</span>(<span class="keyword">from</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            to[keys[i]] = <span class="keyword">from</span>[keys[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> to;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="数组化"><a href="#数组化" class="headerlink" title="数组化"></a>数组化</h4><p>浏览器下存在许多类数组对象，如function内的arguments，通过document.forms、form.elements、doucment.links、select.options、document.getElementsByName、document.getElementsBy TagName、childNodes、children等方式获取的节点集合（HTMLCollection、NodeList），或依照某些特殊写法的自定义对象。</p><p>通常来说，使用Array.prototype.slice.call就能转换我们的类数组对象了，但旧版本IE下的HTMLCollection、NodeList不是Object的子类，采用如上方法将导致IE执行异常。设法让IE下的Array.prototype.slice能切割节点集合就一帆风顺了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Shim for "fixing" IE's lack of support (IE &lt; 9) for applying slice</span></span><br><span class="line"><span class="comment">* on host objects like NamedNodeMap, NodeList, and HTMLCollection</span></span><br><span class="line"><span class="comment">* (technically, since host objects have been implementation-dependent,</span></span><br><span class="line"><span class="comment">* at least before ES6, IE hasn't needed to work this way).</span></span><br><span class="line"><span class="comment">* Also works on strings, fixes IE &lt; 9 to allow an explicit undefined</span></span><br><span class="line"><span class="comment">* for the 2nd argument (as in Firefox), and prevents errors when</span></span><br><span class="line"><span class="comment">* called on other DOM objects.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _slice = <span class="built_in">Array</span>.prototype.slice</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Can't be used with DOM elements in IE &lt; 9</span></span><br><span class="line">    _slice.call(<span class="built_in">document</span>.documentElement)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// Fails in IE &lt; 9</span></span><br><span class="line">    <span class="comment">// This will work for genuine arrays, array-like objects,</span></span><br><span class="line">    <span class="comment">// NamedNodeMap (attributes, entities, notations),</span></span><br><span class="line">    <span class="comment">// NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),</span></span><br><span class="line">    <span class="comment">// and will not fail on other DOM objects (as do DOM elements in IE &lt; 9)</span></span><br><span class="line">    <span class="built_in">Array</span>.prototype.slice = <span class="function"><span class="keyword">function</span> (<span class="params">begin, end</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// IE &lt; 9 gets unhappy with an undefined end argument</span></span><br><span class="line">        end = (<span class="keyword">typeof</span> end !== <span class="string">'undefined'</span>) ? end : <span class="keyword">this</span>.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For native Array objects, we use the native slice function</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> _slice.call(<span class="keyword">this</span>, begin, end)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For array like object we handle it ourselves.</span></span><br><span class="line">        <span class="keyword">var</span> i, cloned = [],</span><br><span class="line">               size, len = <span class="keyword">this</span>.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle negative value for "begin"</span></span><br><span class="line">        <span class="keyword">var</span> start = begin || <span class="number">0</span></span><br><span class="line">        start = (start &gt;= <span class="number">0</span>) ? start : len + start</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle negative value for "end"</span></span><br><span class="line">        <span class="keyword">var</span> upTo = (end) ? end : len</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           upTo = len + end</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Actual expected size of the slice</span></span><br><span class="line">        size = upTo - start</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cloned = <span class="keyword">new</span> <span class="built_in">Array</span>(size)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.charAt) &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                    cloned[i] = <span class="keyword">this</span>.charAt(start + i)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                    cloned[i] = <span class="keyword">this</span>[start + i]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloned</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avalon.slice = <span class="function"><span class="keyword">function</span> (<span class="params">nodes, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _slice.call(nodes, start, end)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的Array.prototype.slice polyfill可以放到另一个补丁模块，这样确保我们的框架在升级时非常轻松地抛弃这些历史包袱。</p><h4 id="类型的判定"><a href="#类型的判定" class="headerlink" title="类型的判定"></a>类型的判定</h4><p>JavaScript存在两套类型系统：一套是基本数据类型，另一套是对象类型系统。基本数据类型在ES5中包括6种，分别是undefined、string、null、boolean、function和object。基本数据类型是通过typeof来检测的。对象类型系统是以基础类型系统为基础的，通过instanceof来检测。然而，JavaScript自带的这两套识别机制非常不靠谱，于是催生了isXXX系列。就拿typeof来说，它只能粗略识别出string、number、boolean、function、undefined和object这6种数据类型，无法识别Null、RegExp和Argument等细分对象类型。</p><p>这里有很多坑:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span><span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">document</span>.childNodes <span class="comment">//safari "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">document</span>.createElement(<span class="string">'embed'</span>)<span class="comment">//ff3-10 "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">document</span>.createElement(<span class="string">'object'</span>)<span class="comment">//ff3-10 "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">document</span>.createElement(<span class="string">'applet'</span>)<span class="comment">//ff3-10 "function"</span></span><br><span class="line"><span class="keyword">typeof</span> /\d/i <span class="comment">//在实现了ecma262v4的浏览器返回 "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>.alert <span class="comment">//IE678 "object""</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length - <span class="number">1</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br><span class="line">arr.constructor === <span class="built_in">Array</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">window</span>.constructor);<span class="comment">// IE67 undefined</span></span><br><span class="line">    alert(<span class="built_in">document</span>.constructor);<span class="comment">// IE67 undefined</span></span><br><span class="line">    alert(<span class="built_in">document</span>.body.constructor);<span class="comment">// IE67 undefined</span></span><br><span class="line">    alert((<span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>)).constructor);<span class="comment">// IE6789 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"aaa"</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>上面分4组，第一组是typeof的坑。第二组是instanceof的陷阱，只要原型上存在此对象的构造器它就返回true，但如果跨文档比较，iframe里面的数组实例就不是父窗口的Array的实例。第三组是有关constructor的陷阱，在旧版本IE下，DOM与BOM对象的constructor属性是没有暴露出来的。最后有关NaN，NaN对象与null、undefined一样，在序列化时是原样输出的，但isNaN这方法非常不靠谱，把字符串、对象放进去也返回true，这对我们序列化非常不利。</p><p>jQuery发明type方法，这个方法就囊括了isBoolean、isNumber、isString、isFunction、isArray、isDate、isRegExp、isObject及isError。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jquery2.0</span></span><br><span class="line"><span class="keyword">var</span> class2type</span><br><span class="line"><span class="comment">// Populate the class2type map</span></span><br><span class="line">jQuery.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">i, name</span>) </span>&#123;</span><br><span class="line">    class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">jQuery.type = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( obj == <span class="literal">null</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>( obj );</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// Support: Safari &lt;= 5.1 (functionish RegExp)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> || <span class="keyword">typeof</span> obj === <span class="string">"function"</span> ?</span><br><span class="line">            class2type[ core_toString.call(obj) ] || <span class="string">"object"</span> :</span><br><span class="line">            <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>isPlainObject则是用来判定是否为纯净的JavaScript对象，既不是DOM、BOM对象，也不是自定义“类”的实例对象，制造它的最初目的是用于深拷贝，避开像window那样自己引用自己的对象。在avalon中有一个更精简的版本，由于它只支持IE10等非常新的浏览器及不支持跨iframe，就没有干扰因素了，可以大胆使用ecma262v5的新API。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avalon.isPlainObject = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> &amp;&amp; <span class="built_in">Object</span>.getPrototypeOf(obj) === <span class="built_in">Object</span>.prototype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>isWindow<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">avalon.isWindow = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 利用IE6、IE7、IE8 window == document为true,document == window竟然为false的神奇特性</span></span><br><span class="line">    <span class="comment">// 标准浏览器及IE9、IE10等使用正则检测</span></span><br><span class="line">    <span class="keyword">return</span> obj == obj.document &amp;&amp; obj.document != obj </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwindow = <span class="regexp">/^\[object (?:Window|DOMWindow|global)\]$/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span>(<span class="params">obj</span>) </span>&#123;<span class="comment">//现代浏览器使用这个实现</span></span><br><span class="line">    <span class="keyword">return</span> rwindow.test(toString.call(obj))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isWindow(<span class="built_in">window</span>)) &#123;</span><br><span class="line">    avalon.isWindow = isWindow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="domReady"><a href="#domReady" class="headerlink" title="domReady"></a>domReady</h4><p>domReady其实是一种名为DOMContentLoaded事件的别称。不过由于框架的需要，它与真正的DOMContentLoaded有一点区别。在许多JavaScript书籍中，它们都会教导我们把JavaScript逻辑写在window.onload回调中，以防DOM树还没有建完就开始对节点进行操作，导致出错。而对于框架来说，越早介入对DOM的干涉就越好，例如要进行特征侦测之类的。domReady还可以满足用户提前绑定事件的需求。因为有时网页的图片等资源过多，window.onload就迟迟不能触发，这时若还没有绑定事件，用户点击哪个按钮都没反应（除了跳转页面）。因此主流框架都引入domReady机制，并且费了很大劲兼容所有浏览器，具体策略如下。</p><p>（1）对于支持DOMContentLoaded事件的使用DOMContentLoaded事件。</p><p>（2）旧版本IE使用Diego Perini发现的著名hack!<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://javascript.nwbox.com/IEContentLoaded/</span></span><br><span class="line"><span class="comment">//by Diego Perini 2007.10.5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IEContentLoaded</span>(<span class="params">w, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = w.document, done = <span class="literal">false</span>,</span><br><span class="line">            init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;<span class="comment">//只执行一次</span></span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            fn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//在DOM未建完之前调用元素doScroll抛出错误</span></span><br><span class="line">            d.documentElement.doScroll(<span class="string">'left'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;<span class="comment">//延迟再试</span></span><br><span class="line">            setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        init();<span class="comment">//没有错误则执行用户回调</span></span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="comment">// 如果用户是在domReady之后绑定这个函数，则立即执行它</span></span><br><span class="line">    d.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (d.readyState == <span class="string">'complete'</span>) &#123;</span><br><span class="line">            d.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过有个问题，如果我们的种子模块是动态加载的，在它插入DOM树时，DOM树已经建完了，这该怎么触发我们的ready回调呢？jQuery给出的方案是，onload也一起被监听。但是如果用户的脚本是onload之后才加载进来呢？那么只好判定一下document.readyState是否等于complete，如果是，则说明页面早就domReady，可以执行用户的回调。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readyList = [];</span><br><span class="line">avalon.ready = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readyList) &#123;</span><br><span class="line">        readyList.push(fn);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> readyFn, ready = W3C ? <span class="string">"DOMContentLoaded"</span> : <span class="string">"readystatechange"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fireReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = readyList[i++]; ) &#123;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line">    readyList = <span class="literal">null</span>;</span><br><span class="line">    fireReady = avalon.noop; <span class="comment">//惰性函数，防止IE9二次调用_checkDeps</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doScrollCheck</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">//IE下通过doScrollCheck检测DOM树是否建完</span></span><br><span class="line">        html.doScroll(<span class="string">"left"</span>);</span><br><span class="line">        fireReady();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        setTimeout(doScrollCheck);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Firefox 3.6之前，不存在readyState属性</span></span><br><span class="line"><span class="comment">//http://www.cnblogs.com/rubylouvre/archive/2012/12/18/2822912.html</span></span><br><span class="line"><span class="keyword">if</span> (!DOC.readyState) &#123;</span><br><span class="line">    <span class="keyword">var</span> readyState = DOC.readyState = DOC.body ? <span class="string">"complete"</span> : <span class="string">"loading"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DOC.readyState === <span class="string">"complete"</span>) &#123;</span><br><span class="line">    fireReady(); <span class="comment">//如果在domReady之外加载</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    avalon.bind(DOC, ready, readyFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (W3C || DOC.readyState === <span class="string">"complete"</span>) &#123;</span><br><span class="line">            fireReady();</span><br><span class="line">            <span class="keyword">if</span> (readyState) &#123; <span class="comment">//IE下不能改写DOC.readyState</span></span><br><span class="line">                DOC.readyState = <span class="string">"complete"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (html.doScroll) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">//如果跨域会报错，那时肯定证明是存在两个窗口的</span></span><br><span class="line">            <span class="keyword">if</span> (self.eval === parent.eval) &#123;</span><br><span class="line">                doScrollCheck();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            doScrollCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本系列笔记来源于《JavaScript框架设计》一书，但是非常尴尬的是，我买的不是第二版的，= =！&lt;a href=&quot;http://www.epubit.com.cn/book/details/4849&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Ja
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="js-framework" scheme="https://github.com/xmoyKING/tags/js-framework/"/>
    
  </entry>
  
  <entry>
    <title>js插件CountUp源码解析</title>
    <link href="https://github.com/xmoyKING/2017/12/13/js-countup/"/>
    <id>https://github.com/xmoyKING/2017/12/13/js-countup/</id>
    <published>2017-12-13T10:50:19.000Z</published>
    <updated>2017-12-13T10:50:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>该插件Git地址：<a href="http://inorganik.github.io/countUp.js/" target="_blank" rel="noopener">CountUp.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root表示插件所依附的命名空间，一般为全局对象</span></span><br><span class="line"><span class="comment">// factory表示工厂方法，即生成CountUp插件类的工厂</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123; <span class="comment">// AMD规范的包定义</span></span><br><span class="line">    define(factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123; <span class="comment">// CommonJS规范的包定义</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>, exports, <span class="built_in">module</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则直接在浏览器的环境内执行，在window全局变量上添加CountUp方法</span></span><br><span class="line">    root.CountUp = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">countUp.js</span></span><br><span class="line"><span class="comment">by @inorganik</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// target = id of html element or var of previously selected html element where counting occurs</span></span><br><span class="line"><span class="comment">// 目标元素的id或变量</span></span><br><span class="line"><span class="comment">// startVal = the value you want to begin at</span></span><br><span class="line"><span class="comment">//开始数值</span></span><br><span class="line"><span class="comment">// endVal = the value you want to arrive at</span></span><br><span class="line"><span class="comment">//结束数值</span></span><br><span class="line"><span class="comment">// decimals = number of decimal places, default 0</span></span><br><span class="line"><span class="comment">//精确到的小数的位数，默认为0，即没有小数</span></span><br><span class="line"><span class="comment">// duration = duration of animation in seconds, default 2</span></span><br><span class="line"><span class="comment">//动画持续时间，默认2s</span></span><br><span class="line"><span class="comment">// options = optional object of options (see below)</span></span><br><span class="line"><span class="comment">//其他配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CountUp类</span></span><br><span class="line"><span class="keyword">var</span> CountUp = <span class="function"><span class="keyword">function</span>(<span class="params">target, startVal, endVal, decimals, duration, options</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// 保存this变量的引用，后续闭包中this的指向需要用到，也是每个实例化CountUp后的实例对象</span></span><br><span class="line">self.version = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'1.9.3'</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default options 默认配置</span></span><br><span class="line">self.options = &#123;</span><br><span class="line">useEasing: <span class="literal">true</span>, <span class="comment">// toggle easing 开启缓动效果</span></span><br><span class="line">useGrouping: <span class="literal">true</span>, <span class="comment">// 1,000,000 vs 1000000 开启分组，以千为分隔</span></span><br><span class="line">separator: <span class="string">','</span>, <span class="comment">// character to use as a separator 分组默认以,为分隔符</span></span><br><span class="line">decimal: <span class="string">'.'</span>, <span class="comment">// character to use as a decimal 小数点默认以.分隔</span></span><br><span class="line">easingFn: easeOutExpo, <span class="comment">// optional custom easing function, default is Robert Penner's easeOutExpo 自定义缓动效果函数，默认为easeOutExpo效果</span></span><br><span class="line">formattingFn: formatNumber, <span class="comment">// optional custom formatting function, default is formatNumber above 文本格式化，默认使用内部的formatNumber方法</span></span><br><span class="line">prefix: <span class="string">''</span>, <span class="comment">// optional text before the result 结果前缀</span></span><br><span class="line">suffix: <span class="string">''</span>, <span class="comment">// optional text after the result 结果后缀</span></span><br><span class="line">numerals: [] <span class="comment">// optionally pass an array of custom numerals for 0-9 默认为数组0-9，可以传入一个字符数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extend default options with passed options object 将默认配置对应项修改为传入的配置项</span></span><br><span class="line"><span class="keyword">if</span> (options &amp;&amp; <span class="keyword">typeof</span> options === <span class="string">'object'</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> self.options) &#123;</span><br><span class="line"><span class="keyword">if</span> (options.hasOwnProperty(key) &amp;&amp; options[key] !== <span class="literal">null</span>) &#123;</span><br><span class="line">self.options[key] = options[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若配置的分组分隔符为空字符串，则不开启分组</span></span><br><span class="line"><span class="keyword">if</span> (self.options.separator === <span class="string">''</span>) &#123;</span><br><span class="line">self.options.useGrouping = <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// ensure the separator is a string (formatNumber assumes this) 确保分隔符为字符类型</span></span><br><span class="line">self.options.separator = <span class="string">''</span> + self.options.separator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure requestAnimationFrame and cancelAnimationFrame are defined</span></span><br><span class="line"><span class="comment">// polyfill for browsers without native support</span></span><br><span class="line"><span class="comment">// by Opera engineer Erik Möller</span></span><br><span class="line"><span class="comment">// 全局环境下requestAnimationFrame和cancelAnimationFrame方法需要存在</span></span><br><span class="line"><span class="comment">// 若没有原生实现，则使用垫片自定义该方法，</span></span><br><span class="line"><span class="comment">// 关于requestAnimationFrame，可以参考： http://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>, <span class="string">'ms'</span>, <span class="string">'o'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++x) &#123;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vendors[x]+<span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line"><span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelAnimationFrame'</span>] || <span class="built_in">window</span>[vendors[x]+<span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.requestAnimationFrame) &#123;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback, element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16</span> - (currTime - lastTime)); <span class="comment">// 为了得出当前宿主浏览器能够支持的最大帧率</span></span><br><span class="line"><span class="keyword">var</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; callback(currTime + timeToCall); &#125;, timeToCall); <span class="comment">// 在调用回调函数时传入调用时的时间</span></span><br><span class="line">lastTime = currTime + timeToCall;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line"><span class="built_in">window</span>.cancelAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">clearTimeout(id);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部使用格式化数字方法，若有自定义的格式化方法则会被覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> neg = (num &lt; <span class="number">0</span>), <span class="comment">// 负号</span></span><br><span class="line">        x, x1, x2, x3, i, len;</span><br><span class="line">num = <span class="built_in">Math</span>.abs(num).toFixed(self.decimals);</span><br><span class="line">num += <span class="string">''</span>; <span class="comment">// 将num转换为字符串</span></span><br><span class="line">x = num.split(<span class="string">'.'</span>); <span class="comment">// 用split将num分为整数和小数部分，字符串类型</span></span><br><span class="line">x1 = x[<span class="number">0</span>]; <span class="comment">// 整数部分</span></span><br><span class="line">x2 = x.length &gt; <span class="number">1</span> ? self.options.decimal + x[<span class="number">1</span>] : <span class="string">''</span>; <span class="comment">// 小数部分</span></span><br><span class="line"><span class="keyword">if</span> (self.options.useGrouping) &#123; <span class="comment">// 若开启分组，则对整数部分进行分隔</span></span><br><span class="line">x3 = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = x1.length; i &lt; len; ++i) &#123; <span class="comment">// 依次（从右至左）对整数每一位进行处理，每3位添加分隔符</span></span><br><span class="line"><span class="keyword">if</span> (i !== <span class="number">0</span> &amp;&amp; ((i % <span class="number">3</span>) === <span class="number">0</span>)) &#123;</span><br><span class="line">x3 = self.options.separator + x3;</span><br><span class="line">&#125;</span><br><span class="line">x3 = x1[len - i - <span class="number">1</span>] + x3;</span><br><span class="line">&#125;</span><br><span class="line">x1 = x3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// optional numeral substitution 若配置了替代字符，则对每一个数字进行替换</span></span><br><span class="line"><span class="keyword">if</span> (self.options.numerals.length) &#123;</span><br><span class="line">x1 = x1.replace(<span class="regexp">/[0-9]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> self.options.numerals[+w];</span><br><span class="line">&#125;)</span><br><span class="line">x2 = x2.replace(<span class="regexp">/[0-9]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> self.options.numerals[+w];</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (neg ? <span class="string">'-'</span> : <span class="string">''</span>) + self.options.prefix + x1 + x2 + self.options.suffix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Robert Penner's easeOutExpo 缓动效果方法</span></span><br><span class="line"><span class="comment">// * t: current time（当前时间）</span></span><br><span class="line"><span class="comment">// * b: beginning value（初始值）</span></span><br><span class="line"><span class="comment">// * c: change in value（变化量）</span></span><br><span class="line"><span class="comment">// * d: duration（持续时间）</span></span><br><span class="line"><span class="comment">// * 返回当前时间点对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easeOutExpo</span>(<span class="params">t, b, c, d</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> c * (-<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-10</span> * t / d) + <span class="number">1</span>) * <span class="number">1024</span> / <span class="number">1023</span> + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureNumber</span>(<span class="params">n</span>) </span>&#123; <span class="comment">// 检测n是否为数字类型</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">typeof</span> n === <span class="string">'number'</span> &amp;&amp; !<span class="built_in">isNaN</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">self.initialize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (self.initialized) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 初始化标志</span></span><br><span class="line"></span><br><span class="line">self.error = <span class="string">''</span>;</span><br><span class="line">self.d = (<span class="keyword">typeof</span> target === <span class="string">'string'</span>) ? <span class="built_in">document</span>.getElementById(target) : target; <span class="comment">// 获取目标，支持ID或原生元素对象</span></span><br><span class="line"><span class="keyword">if</span> (!self.d) &#123; </span><br><span class="line">self.error = <span class="string">'[CountUp] target is null or undefined'</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">self.startVal = <span class="built_in">Number</span>(startVal);</span><br><span class="line">self.endVal = <span class="built_in">Number</span>(endVal);</span><br><span class="line"><span class="comment">// error checks 检查开始值和结束值是否为数字类型</span></span><br><span class="line"><span class="keyword">if</span> (ensureNumber(self.startVal) &amp;&amp; ensureNumber(self.endVal)) &#123;</span><br><span class="line">self.decimals = <span class="built_in">Math</span>.max(<span class="number">0</span>, decimals || <span class="number">0</span>); <span class="comment">// 最大精度</span></span><br><span class="line">self.dec = <span class="built_in">Math</span>.pow(<span class="number">10</span>, self.decimals); <span class="comment">// 获取最大精度的整数形式，避免小数计算</span></span><br><span class="line">self.duration = <span class="built_in">Number</span>(duration) * <span class="number">1000</span> || <span class="number">2000</span>; <span class="comment">// 持续时间</span></span><br><span class="line">self.countDown = (self.startVal &gt; self.endVal); <span class="comment">// 是否为倒数</span></span><br><span class="line">self.frameVal = self.startVal; <span class="comment">// 将动画值设置为开始值</span></span><br><span class="line">self.initialized = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">self.error = <span class="string">'[CountUp] startVal ('</span>+startVal+<span class="string">') or endVal ('</span>+endVal+<span class="string">') is not a number'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print value to target 设置值到目标元素</span></span><br><span class="line">self.printValue = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = self.options.formattingFn(value); <span class="comment">// 将当前的值传入并获取结果格式化后的数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 依据不同的目标标签类型，设置方法不同</span></span><br><span class="line"><span class="keyword">if</span> (self.d.tagName === <span class="string">'INPUT'</span>) &#123; <span class="comment">// 文本框</span></span><br><span class="line"><span class="keyword">this</span>.d.value = result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (self.d.tagName === <span class="string">'text'</span> || self.d.tagName === <span class="string">'tspan'</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.d.textContent = result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.d.innerHTML = result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 计算方法，传入当前的时间戳，</span></span><br><span class="line">self.count = <span class="function"><span class="keyword">function</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 保存第一次的时间戳为开始时间</span></span><br><span class="line"><span class="keyword">if</span> (!self.startTime) &#123; self.startTime = timestamp; &#125;</span><br><span class="line"></span><br><span class="line">self.timestamp = timestamp;</span><br><span class="line"><span class="keyword">var</span> progress = timestamp - self.startTime; <span class="comment">// 计算当前的进度</span></span><br><span class="line">self.remaining = self.duration - progress; <span class="comment">// 计算剩余时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// to ease or not to ease 根据配置决定是否采用缓动效果，同时需要注意是否为倒数，最后设置当前帧的值</span></span><br><span class="line"><span class="keyword">if</span> (self.options.useEasing) &#123;</span><br><span class="line"><span class="keyword">if</span> (self.countDown) &#123;</span><br><span class="line">self.frameVal = self.startVal - self.options.easingFn(progress, <span class="number">0</span>, self.startVal - self.endVal, self.duration);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">self.frameVal = self.options.easingFn(progress, self.startVal, self.endVal - self.startVal, self.duration);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不采用缓动时，即默认为线性改变</span></span><br><span class="line"><span class="keyword">if</span> (self.countDown) &#123;</span><br><span class="line">self.frameVal = self.startVal - ((self.startVal - self.endVal) * (progress / self.duration));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">self.frameVal = self.startVal + (self.endVal - self.startVal) * (progress / self.duration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// don't go past endVal since progress can exceed duration in the last frame</span></span><br><span class="line"><span class="comment">// 在最后一帧的动画会超过设置的结束值，所以需要验证是否超值</span></span><br><span class="line"><span class="keyword">if</span> (self.countDown) &#123;</span><br><span class="line">self.frameVal = (self.frameVal &lt; self.endVal) ? self.endVal : self.frameVal;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">self.frameVal = (self.frameVal &gt; self.endVal) ? self.endVal : self.frameVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decimal 由于计算时会产生小数误差，此处作用为消除误差：小数-》整数-》小数</span></span><br><span class="line">self.frameVal = <span class="built_in">Math</span>.round(self.frameVal*self.dec)/self.dec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// format and print value 打印值</span></span><br><span class="line">self.printValue(self.frameVal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// whether to continue 动画没结束，则递归调用自身，用requestAnimationFrame代替setTimeout</span></span><br><span class="line"><span class="keyword">if</span> (progress &lt; self.duration) &#123;</span><br><span class="line">self.rAF = requestAnimationFrame(self.count); <span class="comment">// 每次执行将定时器保存下来，主要用于在reset方法中提前取消动画</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 若动画结束，则调用回调函数</span></span><br><span class="line"><span class="keyword">if</span> (self.callback) self.callback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// start your animation 开始执行动画方法</span></span><br><span class="line"><span class="comment">// 同时注意，回调函数不是在配置中指定的，而是在start方法中指定</span></span><br><span class="line">self.start = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!self.initialize()) <span class="keyword">return</span>; <span class="comment">// 检查是否初始化，防止初始化前就调用此实例方法</span></span><br><span class="line">self.callback = callback;</span><br><span class="line">self.rAF = requestAnimationFrame(self.count);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// toggles pause/resume animation 支持暂停和恢复方法，通过内部的paused标志检查状态</span></span><br><span class="line"><span class="comment">// 但暂停仅仅只是取消了定时器，并没有重置已经完成的动画进度</span></span><br><span class="line">self.pauseResume = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!self.paused) &#123; <span class="comment">// 粘贴动画</span></span><br><span class="line">self.paused = <span class="literal">true</span>;</span><br><span class="line">cancelAnimationFrame(self.rAF);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 恢复动画时，将剩余时间设置为持续时间，同时将当前的帧值保存为开始时间</span></span><br><span class="line">self.paused = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">delete</span> self.startTime;</span><br><span class="line">self.duration = self.remaining;</span><br><span class="line">self.startVal = self.frameVal;</span><br><span class="line">requestAnimationFrame(self.count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// reset to startVal so animation can be run again 重置动画</span></span><br><span class="line"><span class="comment">// 与暂停动画方法相比，重置方法将开始时间删除，同时重置初始化标识</span></span><br><span class="line">self.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">self.paused = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">delete</span> self.startTime;</span><br><span class="line">self.initialized = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (self.initialize()) &#123; <span class="comment">// 接着直接开始新一轮动画</span></span><br><span class="line">cancelAnimationFrame(self.rAF);</span><br><span class="line">self.printValue(self.startVal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// pass a new endVal and start animation 在动画未结束前调用时可以动态更新结束值</span></span><br><span class="line">self.update = <span class="function"><span class="keyword">function</span> (<span class="params">newEndVal</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!self.initialize()) <span class="keyword">return</span>; <span class="comment">// 若未初始化则直接返回</span></span><br><span class="line">newEndVal = <span class="built_in">Number</span>(newEndVal);</span><br><span class="line"><span class="keyword">if</span> (!ensureNumber(newEndVal)) &#123;</span><br><span class="line">self.error = <span class="string">'[CountUp] update() - new endVal is not a number: '</span>+newEndVal;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">self.error = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> (newEndVal === self.frameVal) <span class="keyword">return</span>; <span class="comment">// 若更新的值为当前帧的值，则直接返回</span></span><br><span class="line">cancelAnimationFrame(self.rAF); <span class="comment">// 每次更新值则需重置内部的属性，此时流程与暂停后立即恢复的操作类似，但不完全一致</span></span><br><span class="line">self.paused = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">delete</span> self.startTime;</span><br><span class="line">self.startVal = self.frameVal;</span><br><span class="line">self.endVal = newEndVal;</span><br><span class="line">self.countDown = (self.startVal &gt; self.endVal);</span><br><span class="line">self.rAF = requestAnimationFrame(self.count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// format startVal on initialization</span></span><br><span class="line"><span class="keyword">if</span> (self.initialize()) self.printValue(self.startVal);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CountUp;</span><br><span class="line"></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该插件Git地址：&lt;a href=&quot;http://inorganik.github.io/countUp.js/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CountUp.js&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="countup" scheme="https://github.com/xmoyKING/tags/countup/"/>
    
  </entry>
  
  <entry>
    <title>jquery.noConflict无冲突函数原理</title>
    <link href="https://github.com/xmoyKING/2017/12/09/jquery-noconflict/"/>
    <id>https://github.com/xmoyKING/2017/12/09/jquery-noconflict/</id>
    <published>2017-12-09T15:08:08.000Z</published>
    <updated>2017-12-10T02:57:26.699Z</updated>
    
    <content type="html"><![CDATA[<p>无冲突处理也称为多库共存。许多框架都爱用$作为自己的命名空间。jQuery发明了noConflict函数，能解决多库共存问题。</p><p>关于noConflict方法的使用，可以参考<a href="https://www.cnblogs.com/laoyu/p/5189750.html" target="_blank" rel="noopener">三分钟玩转jQuery.noConflict()</a></p><p>关键就是要理解，在页面加载jquery时，jquery自执行初始化对页面中的<code>jQuery</code>和<code>$</code>进行了缓存，无论这两个变量是否已经被占用，在使用noConflict方法后，都可以选择将其释放回缓存的内容。其实noConflict的布尔参数控制着是否释放<code>jQuery</code>变量，而<code>$</code>一定会被释放。</p><p>使用示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jQuery and $ are undefined --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jQuery and $ now point to jQuery 1.10.2 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jQuery and $ now point to jQuery 1.7.0 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">jQuery.noConflict();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jQuery still points to jQuery 1.7.0; $ now points to jQuery 1.10.2 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jQuery and $ now point to jQuery 1.6.4 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"><span class="keyword">var</span> jquery164 = jQuery.noConflict( <span class="literal">true</span> );</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jQuery now points to jQuery 1.7.0; $ now points to jQuery 1.10.2; jquery164 points to jQuery 1.6.4 --&gt;</span></span><br></pre></td></tr></table></figure></p><p>源码解析：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">       <span class="built_in">window</span> = <span class="keyword">this</span>,</span><br><span class="line">       <span class="literal">undefined</span>,</span><br><span class="line">       _jQuery = <span class="built_in">window</span>.jQuery,</span><br><span class="line">       _$ = <span class="built_in">window</span>.$,</span><br><span class="line">       <span class="comment">//把window存入闭包中的同名变量，方便内部函数在调用window时不用费大力气查找它</span></span><br><span class="line">       <span class="comment">//_jQuery与_$用于以后重写</span></span><br><span class="line">       jQuery = <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于返回一个jQuery对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.extend(&#123;</span><br><span class="line">    noConflict: <span class="function"><span class="keyword">function</span>(<span class="params">deep</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//引入jQuery类库后，闭包外面的window.$与window.jQuery都储存着一个函数</span></span><br><span class="line">        <span class="comment">//它是用来生成jQuery对象或在domReady后执行其中的函数</span></span><br><span class="line">        <span class="comment">//回顾最上面的代码，在还没有把function赋给它们时，_jQuery与_$已经被赋值了</span></span><br><span class="line">        <span class="comment">//因此它们俩的值必然是undefined</span></span><br><span class="line">        <span class="comment">//因此这种放弃控制权的技术很简单，就是用undefined把window.$里面的jQuery系的函数清除</span></span><br><span class="line">        <span class="comment">//这时Prototype或mootools的$就可以了</span></span><br><span class="line">        <span class="built_in">window</span>.$ = _$;<span class="comment">//相当于window.$ = undefined</span></span><br><span class="line">        <span class="comment">//这时就要为noConflict添加一个布尔值，为true</span></span><br><span class="line">        <span class="keyword">if</span> (deep)</span><br><span class="line">            <span class="comment">//但我们必须使用一个接纳jQuery对象与jQuery的入口函数</span></span><br><span class="line">            <span class="comment">//闭包里面的内容除非被window等宿主对象引用，否则就是不可见的</span></span><br><span class="line">            <span class="comment">//因此我们把闭包里面的jQuery return出去，外面用一个变量接纳就可以</span></span><br><span class="line">            <span class="built_in">window</span>.jQuery = _jQuery;<span class="comment">//相当window.jQuery = undefined</span></span><br><span class="line">        <span class="keyword">return</span> jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无冲突处理也称为多库共存。许多框架都爱用$作为自己的命名空间。jQuery发明了noConflict函数，能解决多库共存问题。&lt;/p&gt;
&lt;p&gt;关于noConflict方法的使用，可以参考&lt;a href=&quot;https://www.cnblogs.com/laoyu/p/518
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="jquery" scheme="https://github.com/xmoyKING/tags/jquery/"/>
    
      <category term="noConflict" scheme="https://github.com/xmoyKING/tags/noConflict/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-19-代码重构</title>
    <link href="https://github.com/xmoyKING/2017/12/07/js-pattern19/"/>
    <id>https://github.com/xmoyKING/2017/12/07/js-pattern19/</id>
    <published>2017-12-07T06:52:14.000Z</published>
    <updated>2017-12-07T06:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，实际上一直在不停地进行代码级别上的优化。在讲设计模式的章节中，我们总是先写一段反例代码，而后再介绍一段通过设计模式重构之后的更好的代码。这种强烈的对比会加深我们对该模式的理解。</p><p>模式和重构之间有着一种与生俱来的关系。从某种角度来看，设计模式的目的就是为许多重构行为提供目标。</p><p>在实际的项目开发中，除了使用设计模式进行重构之外，还有一些常见而容易忽略的细节，这些细节也是帮助我们达到重构目标的重要手段。一部分思想来自MartinFowler的名著《重构：改善既有代码的设计》，虽然该书是使用Java语言写成的，但这些重构的技巧，有很大一部分可以为JavaScript语言所借鉴。</p><p>虽然会提出一些重构的目标和手段，但它们都是建议，没有哪些是必须严格遵守的标准。具体是否需要重构，以及如何进行重构，这需要我们根据系统的类型、项目工期、人力等外界因素一起决定。</p><h4 id="提炼函数"><a href="#提炼函数" class="headerlink" title="提炼函数"></a>提炼函数</h4><p>在JavaScript开发中，我们大部分时间都在与函数打交道，所以我们希望这些函数有着良好的命名，函数体内包含的逻辑清晰明了。如果一个函数过长，不得不加上若干注释才能让这个函数显得易读一些，那这些函数就很有必要进行重构。如果在函数中有一段代码可以被独立出来，那我们最好把这些代码放进另外一个独立的函数中。这是一种很常见的优化工作，这样做的好处主要有以下几点。</p><ul><li>避免出现超大函数。</li><li>独立出来的函数有助于代码复用。</li><li>独立出来的函数更容易被覆写。</li><li>独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用。</li></ul><p>比如在一个负责取得用户信息的函数里面，我们还需要打印跟用户信息有关的log，那么打印log的语句就可以被封装在一个独立的函数里：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getUserInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ajax(<span class="string">'userInfo'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'userId: '</span> + data.userId);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'userName: '</span> + data.userName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nickName: '</span> + data.nickName);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getUserInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ajax(<span class="string">'userInfo'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    printDetails(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> printDetails = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'userId: '</span> + data.userId);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'userName: '</span> + data.userName);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nickName: '</span> + data.nickName);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="合并重复的条件片段"><a href="#合并重复的条件片段" class="headerlink" title="合并重复的条件片段"></a>合并重复的条件片段</h4><p>如果一个函数体内有一些条件分支语句，而这些条件分支语句内部散布了一些重复的代码，那么就有必要进行合并去重工作。假如我们有一个分页函数paging，该函数接收一个参数currPage，currPage表示即将跳转的页码。在跳转之前，为防止currPage传入过小或者过大的数字，我们要手动对它的值进行修正，详见如下伪代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paging = <span class="function"><span class="keyword">function</span>(<span class="params">currPage</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (currPage &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    currPage = <span class="number">0</span>;</span><br><span class="line">    jump(currPage); <span class="comment">// 跳 转 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class="line">    currPage = totalPage;</span><br><span class="line">    jump(currPage); <span class="comment">// 跳 转 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    jump(currPage); <span class="comment">// 跳 转 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到，负责跳转的代码jump(currPage)在每个条件分支内都出现了，所以完全可以把这句代码独立出来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paging = <span class="function"><span class="keyword">function</span>(<span class="params">currPage</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (currPage &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    currPage = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class="line">    currPage = totalPage;</span><br><span class="line">  &#125;</span><br><span class="line">  jump(currPage); <span class="comment">// 把 jump 函 数 独 立 出 来 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="把条件分支语句提炼成函数"><a href="#把条件分支语句提炼成函数" class="headerlink" title="把条件分支语句提炼成函数"></a>把条件分支语句提炼成函数</h4><p>在程序设计中，复杂的条件分支语句是导致程序难以阅读和理解的重要原因，而且容易导致一个庞大的函数。假设现在有一个需求是编写一个计算商品价格的getPrice函数，商品的计算只有一个规则：如果当前正处于夏季，那么全部商品将以8折出售。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getPrice = <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">if</span> (date.getMonth() &gt;= <span class="number">6</span> &amp;&amp; date.getMonth() &lt;= <span class="number">9</span>) &#123; <span class="comment">// 夏 天 </span></span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>if ( date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9 ){ // ... }</code><br>这句代码要表达的意思很简单，就是判断当前是否正处于夏天（7~10月）。尽管这句代码很短小，但代码表达的意图和代码自身还存在一些距离，阅读代码的人必须要多花一些精力才能明白它传达的意图。其实可以把这句代码提炼成一个单独的函数，既能更准确地表达代码的意思，函数名本身又能起到注释的作用。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSummer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> date.getMonth() &gt;= <span class="number">6</span> &amp;&amp; date.getMonth() &lt;= <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getPrice = <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isSummer()) &#123; <span class="comment">// 夏 天 </span></span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="合理使用循环"><a href="#合理使用循环" class="headerlink" title="合理使用循环"></a>合理使用循环</h4><p>在函数体内，如果有些代码实际上负责的是一些重复性的工作，那么合理利用循环不仅可以完成同样的功能，还可以使代码量更少。下面有一段创建XHR对象的代码，为了简化示例，只考虑版本9以下的IE浏览器，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createXHR = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'MSXML2. XMLHttp. 6.0'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'MSXML2. XMLHttp. 3.0'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'MSXML2. XMLHttp'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure></p><p>下面我们灵活地运用循环，可以得到跟上面代码一样的效果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createXHR = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> versions = [<span class="string">'MSXML2. XMLHttp. 6.0ddd'</span>, <span class="string">'MSXML2. XMLHttp. 3.0'</span>, <span class="string">'MSXML2. XMLHttp'</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, version; version = versions[i++];) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(version);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure></p><h4 id="提前让函数退出代替嵌套条件分支"><a href="#提前让函数退出代替嵌套条件分支" class="headerlink" title="提前让函数退出代替嵌套条件分支"></a>提前让函数退出代替嵌套条件分支</h4><p>许多程序员都有这样一种观念：“每个函数只能有一个入口和一个出口。”现代编程语言都会限制函数只有一个入口。但关于“函数只有一个出口”，往往会有一些不同的看法。下面这段伪代码是遵守“函数只有一个出口的”的典型代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> del = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret;</span><br><span class="line">  <span class="keyword">if</span> (!obj.isReadOnly) &#123; <span class="comment">// 不 为 只 读 的 才 能 被 删 除 </span></span><br><span class="line">    <span class="keyword">if</span> (obj.isFolder) &#123; <span class="comment">// 如 果 是 文 件 夹</span></span><br><span class="line">      ret = deleteFolder(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.isFile) &#123; <span class="comment">// 如 果 是 文 件 </span></span><br><span class="line">      ret = deleteFile(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>嵌套的条件分支语句绝对是代码维护者的噩梦，对于阅读代码的人来说，嵌套的if、else语句相比平铺的if、else，在阅读和理解上更加困难，有时候一个外层if分支的左括号和右括号之间相隔500米之远。用《重构》里的话说，嵌套的条件分支往往是由一些深信“每个函数只能有一个出口的”程序员写出的。但实际上，如果对函数的剩余部分不感兴趣，那就应该立即退出。引导阅读者去看一些没有用的else片段，只会妨碍他们对程序的理解。</p><p>于是我们可以挑选一些条件分支，在进入这些条件分支之后，就立即让这个函数退出。要做到这一点，有一个常见的技巧，即在面对一个嵌套的if分支时，我们可以把外层if表达式进行反转。重构后的del函数如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> del = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.isReadOnly) &#123; <span class="comment">// 反 转 if 表 达 式 </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj.isFolder) &#123;</span><br><span class="line">    <span class="keyword">return</span> deleteFolder(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj.isFile) &#123;</span><br><span class="line">    <span class="keyword">return</span> deleteFile(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="传递对象参数代替过长的参数列表"><a href="#传递对象参数代替过长的参数列表" class="headerlink" title="传递对象参数代替过长的参数列表"></a>传递对象参数代替过长的参数列表</h4><p>有时候一个函数有可能接收多个参数，而参数的数量越多，函数就越难理解和使用。使用该函数的人首先得搞明白全部参数的含义，在使用的时候，还要小心翼翼，以免少传了某个参数或者把两个参数搞反了位置。如果我们想在第3个参数和第4个参数之中增加一个新的参数，就会涉及许多代码的修改，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setUserInfo = <span class="function"><span class="keyword">function</span>(<span class="params">id, name, address, sex, mobile, qq</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'id = '</span> + id);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name = '</span> + name);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'address = '</span> + address);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sex = '</span> + sex);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mobile = '</span> + mobile);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'qq = '</span> + qq);</span><br><span class="line">&#125;;</span><br><span class="line">setUserInfo(<span class="number">1314</span>, <span class="string">'sven'</span>, <span class="string">'shenzhen'</span>, <span class="string">'male'</span>, <span class="string">'137********'</span>, <span class="number">377876679</span>);</span><br></pre></td></tr></table></figure></p><p>这时我们可以把参数都放入一个对象内，然后把该对象传入setUserInfo函数，setUserInfo函数需要的数据可以自行从该对象里获取。现在不用再关心参数的数量和顺序，只要保证参数对应的key值不变就可以了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setUserInfo = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'id = '</span> + obj.id);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name = '</span> + obj.name);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'address = '</span> + obj.address);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sex = '</span> + obj.sex);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mobile = '</span> + obj.mobile);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'qq = '</span> + obj.qq);</span><br><span class="line">&#125;;</span><br><span class="line">setUserInfo(&#123;</span><br><span class="line">  id: <span class="number">1314</span>,</span><br><span class="line">  name: <span class="string">'sven'</span>,</span><br><span class="line">  address: <span class="string">'shenzhen'</span>,</span><br><span class="line">  sex: <span class="string">'male'</span>,</span><br><span class="line">  mobile: <span class="string">'137********'</span>,</span><br><span class="line">  qq: <span class="number">377876679</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="尽量减少参数数量"><a href="#尽量减少参数数量" class="headerlink" title="尽量减少参数数量"></a>尽量减少参数数量</h4><p>如果调用一个函数时需要传入多个参数，那这个函数是让人望而生畏的，我们必须搞清楚这些参数代表的含义，必须小心翼翼地把它们按照顺序传入该函数。而如果一个函数不需要传入任何参数就可以使用，这种函数是深受人们喜爱的。在实际开发中，向函数传递参数不可避免，但我们应该尽量减少函数接收的参数数量。下面举个非常简单的示例。有一个画图函数draw，它现在只能绘制正方形，接收了3个参数，分别是图形的width、heigth以及square：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> draw = <span class="function"><span class="keyword">function</span>(<span class="params"> width, height, square </span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>但实际上正方形的面积是可以通过width和height计算出来的，于是我们可以把参数square从draw函数中去掉：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> draw = <span class="function"><span class="keyword">function</span>(<span class="params"> width, height </span>)</span>&#123; <span class="keyword">var</span> square = width * height; &#125;;</span><br></pre></td></tr></table></figure></p><p>假设以后这个draw函数开始支持绘制圆形，我们需要把参数width和height换成半径radius，但图形的面积square始终不应该由客户传入，而是应该在draw函数内部，由传入的参数加上一定的规则计算得来。此时，我们可以使用策略模式，让draw函数成为一个支持绘制多种图形的函数。</p><h4 id="少用三目运算符"><a href="#少用三目运算符" class="headerlink" title="少用三目运算符"></a>少用三目运算符</h4><p>有一些程序员喜欢大规模地使用三目运算符，来代替传统的if、else。理由是三目运算符性能高，代码量少。不过，这两个理由其实都很难站得住脚。</p><p>即使我们假设三目运算符的效率真的比if、else高，这点差距也是完全可以忽略不计的。在实际的开发中，即使把一段代码循环一百万次，使用三目运算符和使用if、else的时间开销处在同一个级别里。</p><p>同样，相比损失的代码可读性和可维护性，三目运算符节省的代码量也可以忽略不计。让JS文件加载更快的办法有很多种，如压缩、缓存、使用CDN和分域名等。把注意力只放在使用三目运算符节省的字符数量上，无异于一个300斤重的人把超重的原因归罪于头皮屑。</p><p>如果条件分支逻辑简单且清晰，这无碍我们使用三目运算符：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure></p><p>但如果条件分支逻辑非常复杂，如下段代码所示，那我们最好的选择还是按部就班地编写if、else。if、else语句的好处很多，一是阅读相对容易，二是修改的时候比修改三目运算符周围的代码更加方便：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!aup || !bup) &#123;</span><br><span class="line">  <span class="keyword">return</span> a === doc ? <span class="number">-1</span> : </span><br><span class="line">          b === doc ? <span class="number">1</span> : </span><br><span class="line">          aup ? <span class="number">-1</span> : </span><br><span class="line">          bup ? <span class="number">1</span> : </span><br><span class="line">          sortInput ? (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) : </span><br><span class="line">          <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="合理使用链式调用"><a href="#合理使用链式调用" class="headerlink" title="合理使用链式调用"></a>合理使用链式调用</h4><p>经常使用jQuery的程序员相当习惯链式调用方法，在JavaScript中，可以很容易地实现方法的链式调用，即让方法调用结束后返回对象自身，如下代码所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> User = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">User.prototype.setId = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line">User.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> User().setId(<span class="number">1314</span>).setName(<span class="string">'sven'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">var</span> User = &#123;</span><br><span class="line">  id: <span class="literal">null</span>,</span><br><span class="line">  name: <span class="literal">null</span>,</span><br><span class="line">  setId: <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  setName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(User.setId(<span class="number">1314</span>).setName(<span class="string">'sven'</span>));</span><br></pre></td></tr></table></figure></p><p>使用链式调用的方式并不会造成太多阅读上的困难，也确实能省下一些字符和中间变量，但节省下来的字符数量同样是微不足道的。链式调用带来的坏处就是在调试的时候非常不方便，如果我们知道一条链中有错误出现，必须得先把这条链拆开才能加上一些调试log或者增加断点，这样才能定位错误出现的地方。</p><p>如果该链条的结构相对稳定，后期不易发生修改，那么使用链式调用无可厚非。但如果该链条很容易发生变化，导致调试和维护困难，那么还是建议使用普通调用的形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(); </span><br><span class="line"></span><br><span class="line">user.setId( <span class="number">1314</span> ); </span><br><span class="line">user.setName( <span class="string">'sven'</span> );</span><br></pre></td></tr></table></figure></p><h4 id="分解大型类"><a href="#分解大型类" class="headerlink" title="分解大型类"></a>分解大型类</h4><p>在作者编写的HTML5版“街头霸王”的第一版代码中，负责创建游戏人物的Spirit类非常庞大，不仅要负责创建人物精灵，还包括了人物的攻击、防御等动作方法，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Spirit = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Spirit.prototype.attack = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123; <span class="comment">// 攻 击 </span></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'waveBoxing'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': 使 用 波 动 拳'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'whirlKick'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': 使 用 旋 风 腿'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> spirit = <span class="keyword">new</span> Spirit(<span class="string">'RYU'</span>);</span><br><span class="line">spirit.attack(<span class="string">'waveBoxing'</span>); <span class="comment">// 输 出： RYU: 使 用 波 动 拳 </span></span><br><span class="line">spirit.attack(<span class="string">'whirlKick'</span>); <span class="comment">// 输 出： RYU: 使 用 旋 风 腿</span></span><br></pre></td></tr></table></figure></p><p>后来发现，Spirit.prototype.attack这个方法实现是太庞大了，实际上它完全有必要作为一个单独的类存在。面向对象设计鼓励将行为分布在合理数量的更小对象之中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Attack = <span class="function"><span class="keyword">function</span>(<span class="params">spirit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.spirit = spirit;</span><br><span class="line">  &#125;;</span><br><span class="line">Attack.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.list[type].call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Attack.prototype.list = &#123;</span><br><span class="line">  waveBoxing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.spirit.name + <span class="string">': 使 用 波 动 拳'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  whirlKick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.spirit.name + <span class="string">': 使 用 旋 风 腿'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>现在的Spirit类变得精简了很多，不再包括各种各样的攻击方法，而是把攻击动作委托给Attack类的对象来执行，这段代码也是策略模式的运用之一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Spirit = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.attackObj = <span class="keyword">new</span> Attack(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">Spirit.prototype.attack = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123; <span class="comment">// 攻 击 </span></span><br><span class="line">  <span class="keyword">this</span>.attackObj.start(type);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> spirit = <span class="keyword">new</span> Spirit(<span class="string">'RYU'</span>);</span><br><span class="line">spirit.attack(<span class="string">'waveBoxing'</span>); <span class="comment">// 输 出： RYU: 使 用 波 动 拳 </span></span><br><span class="line">spirit.attack(<span class="string">'whirlKick'</span>); <span class="comment">// 输 出： RYU: 使 用 旋 风 腿</span></span><br></pre></td></tr></table></figure></p><h4 id="用return退出多重循环"><a href="#用return退出多重循环" class="headerlink" title="用return退出多重循环"></a>用return退出多重循环</h4><p>假设在函数体内有一个两重循环语句，我们需要在内层循环中判断，当达到某个临界条件时退出外层的循环。我们大多数时候会引入一个控制标记变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">          flag = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flag === <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>第二种做法是设置循环标记：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  outerloop: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    innerloop: <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span> outerloop;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这两种做法无疑都让人头晕目眩，更简单的做法是在需要中止循环的时候直接退出整个方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当然用return直接退出方法会带来一个问题，如果在循环之后还有一些将被执行的代码呢？如果我们提前退出了整个方法，这些代码就得不到被执行的机会：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log( i ); <span class="comment">// 这 句 代 码 没 有 机 会 被 执 行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>为了解决这个问题，我们可以把循环后面的代码放到return后面，如果代码比较多，就应该把它们提炼成一个单独的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> print(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;到目前为止，实际上一直在不停地进行代码级别上的优化。在讲设计模式的章节中，我们总是先写一段反例代码，而后再介绍一段通过设计模式重构之后的更好的代码。这种强烈的对比会加深我们对该模式的理解。&lt;/p&gt;
&lt;p&gt;模式和重构之间有着一种与生俱来的关系。从某种角度来看，设计模式的目的就
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-18-接口和面向接口编程</title>
    <link href="https://github.com/xmoyKING/2017/12/07/js-pattern18/"/>
    <id>https://github.com/xmoyKING/2017/12/07/js-pattern18/</id>
    <published>2017-12-07T01:59:31.000Z</published>
    <updated>2017-12-07T01:59:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>当谈到接口的时候，通常会涉及以下几种含义。</p><p>我们经常说一个库或者模块对外提供了某某API接口。通过主动暴露的接口来通信，可以隐藏软件系统内部的工作细节。这也是我们最熟悉的第一种接口含义。</p><p>第二种接口是一些语言提供的关键字，比如Java的interface。interface关键字可以产生一个完全抽象的类。这个完全抽象的类用来表示一种契约，专门负责建立类与类之间的联系。</p><p>第三种接口即是我们谈论的“面向接口编程”中的接口，接口的含义在这里体现得更为抽象。用《设计模式》中的话说就是：接口是对象能响应的请求的集合。</p><p>主要讨论的是第二种和第三种接口。首先,本章的前半部分都是针对Java语言的讲解，这是因为JavaScript并没有从语言层面提供对抽象类（Abstractclass）或者接口（interface）的支持，我们有必要从一门提供了抽象类和接口的语言开始，逐步了解“面向接口编程”在面向对象程序设计中的作用。</p><h4 id="回到Java的抽象类"><a href="#回到Java的抽象类" class="headerlink" title="回到Java的抽象类"></a>回到Java的抽象类</h4><p>首先让回顾一下动物世界。目前我们有一个鸭子类Duck，还有一个让鸭子发出叫声的AnimalSound类，该类有一个makeSound方法，接收Duck类型的对象作为参数，这几个类一直合作得很愉快，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123; <span class="comment">// 鸭 子 类 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"嘎 嘎 嘎"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalSound</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">(Duck duck)</span> </span>&#123; <span class="comment">// (1) 只 接 受 Duck 类 型 的 参 数 </span></span><br><span class="line">    duck.makeSound();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    AnimalSound animalSound = <span class="keyword">new</span> AnimalSound();</span><br><span class="line">    Duck duck = <span class="keyword">new</span> Duck();</span><br><span class="line">    animalSound.makeSound(duck); <span class="comment">// 输 出： 嘎 嘎 嘎 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目前已经可以顺利地让鸭子发出叫声。后来动物世界里又增加了一些鸡，现在我们想让鸡也叫唤起来，但发现这是一件不可能完成的事情，因为在上面这段代码的(1)处，即AnimalSound类的sound方法里，被规定只能接受Duck类型的对象作为参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> </span>&#123; <span class="comment">// 鸡 类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"咯 咯 咯"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    AnimalSound animalSound = <span class="keyword">new</span> AnimalSound();</span><br><span class="line">    Chicken chicken = <span class="keyword">new</span> Chicken();</span><br><span class="line">    animalSound.makeSound(chicken); <span class="comment">// 报 错， animalSound.makeSound 只 能 接 受 Duck 类 型 的 参 数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在享受静态语言类型检查带来的安全性的同时，也失去了一些编写代码的自由。</p><p>静态类型语言通常设计为可以“向上转型”。当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。就像看到天上有只麻雀，我们既可以说“一只麻雀在飞”，也可以说“一只鸟在飞”，甚至可以说成“一只动物在飞”。通过向上转型，对象的具体类型被隐藏在“超类型”身后。当对象类型之间的耦合关系被解除之后，这些对象才能在类型检查系统的监视下相互替换使用，这样才能看到对象的多态性。</p><p>所以如果想让鸡也叫唤起来，必须先把duck对象和chicken对象都向上转型为它们的超类型Animal类，进行向上转型的工具就是抽象类或者interface。</p><p>先创建一个Animal抽象类,然后让Duck类和Chicken类都继承自抽象类Animal：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>; <span class="comment">// 抽 象 方 法 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"咯 咯 咯"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"嘎 嘎 嘎"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以把Animal定义为一个具体类而不是抽象类，但一般不这么做。Scott Meyers曾指出，只要有可能，不要从具体类继承。现在剩下的就是让AnimalSound类的makeSound方法接收Animal类型的参数，而不是具体的Duck类型或者Chicken类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalSound</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">(Animal animal)</span> </span>&#123; <span class="comment">// 接 收 Animal 类 型 的 参 数， 而 非 Duck 类 型 或 Chicken 类 型 </span></span><br><span class="line">    animal.makeSound();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    AnimalSound animalSound = <span class="keyword">new</span> AnimalSound();</span><br><span class="line">    Animal duck = <span class="keyword">new</span> Duck(); <span class="comment">// 向 上 转 型 Animal </span></span><br><span class="line">    Chicken chicken = <span class="keyword">new</span> Chicken(); <span class="comment">// 向 上 转 型 </span></span><br><span class="line">    animalSound.makeSound(duck); <span class="comment">// 输 出： 嘎 嘎 嘎 </span></span><br><span class="line">    animalSound.makeSound(chicken); <span class="comment">// 输 出： 咯 咯 咯 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过抽象类完成了一个体现对象多态性的例子。但重点并非讲解多态，而是在于说明抽象类。抽象类在这里主要有以下两个作用。</p><ul><li>向上转型。让Duck对象和Chicken对象的类型都隐藏在Animal类型身后，隐藏对象的具体类型之后，duck对象和chicken对象才能被交换使用，这是让对象表现出多态性的必经之路。</li><li>建立一些契约。继承自抽象类的具体类都会继承抽象类里的abstract方法，并且要求覆写它们。这些契约在实际编程中非常重要，可以帮助我们编写可靠性更高的代码。比如在命令模式中，各个子命令类都必须实现execute方法，才能保证在调用command.execute的时候不会抛出异常。如果让子命令类OpenTvCommand继承自抽象类Command：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;　</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenTvCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OpenTvCommand</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"打 开 电 视 机"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么自然有编译器帮助我们检查和保证子命令类OpenTvCommand覆写了抽象类Command中的execute抽象方法。如果没有这样做，编译器会尽可能早地抛出错误来提醒正在编写这段代码的程序员。</p><p>总而言之，不关注对象的具体类型，而仅仅针对超类型中的“契约方法”来编写程序，可以产生可靠性高的程序，也可以极大地减少子系统实现之间的相互依赖关系，即：面向接口编程，而不是面向实现编程。</p><p>奇怪的是，抽象类跟接口又有什么关系呢？实际上这里的接口并不是指interface，而是一个抽象的概念。</p><p>从过程上来看，“面向接口编程”其实是“面向超类型编程”。当对象的具体类型被隐藏在超类型身后时，这些对象就可以相互替换使用，我们的关注点才能从对象的类型上转移到对象的行为上。“面向接口编程”也可以看成面向抽象编程，即针对超类型中的abstract方法编程，接口在这里被当成abstract方法中约定的契约行为。这些契约行为暴露了一个类或者对象能够做什么，但是不关心具体如何去做。</p><h4 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h4><p>除了用抽象类来完成面向接口编程之外，使用interface也可以达到同样的效果。虽然很多人在实际使用中刻意区分抽象类和interface，但使用interface实际上也是继承的一种方式，叫作接口继承。</p><p>相对于单继承的抽象类，一个类可以实现多个interface。抽象类中除了abstract方法之外，还可以有一些供子类公用的具体方法。interface使抽象的概念更进一步，它产生一个完全抽象的类，不提供任何具体实现和方法体（Java8提供实现方法的interface），但允许该interface的创建者确定方法名、参数列表和返回类型，这相当于提供一些行为上的约定，但不关心该行为的具体实现过程。</p><p>interface同样可以用于向上转型，这也是让对象表现出多态性的一条途径，实现了同一个接口的两个类就可以被相互替换使用。</p><p>再回到用抽象类实现让鸭子和鸡发出叫声的故事。这个故事得以完美收场的关键是让抽象类Animal给duck和chicken进行向上转型。但此时也引入了一个限制，抽象类是基于单继承的，也就是说我们不可能让Duck和Chicken再继承自另一个家禽类。如果使用interface，可以仅仅针对发出叫声这个行为来编写程序，同时一个类也可以实现多个interface。</p><p>下面用interface来改写基于抽象类的代码。我们先定义Animal接口，所有实现了Animal接口的动物类都将拥有Animal接口中约定的行为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123; <span class="comment">// 重 写 Animal 接 口 的 makeSound 抽 象 方 法 </span></span><br><span class="line">    System.out.println(<span class="string">"嘎 嘎 嘎"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123; <span class="comment">// 重 写 Animal 接 口 的 makeSound 抽 象 方 法 </span></span><br><span class="line">    System.out.println(<span class="string">"咯 咯 咯"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalSound</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">    animal.makeSound();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Animal duck = <span class="keyword">new</span> Duck();</span><br><span class="line">    Animal chicken = <span class="keyword">new</span> Chicken();</span><br><span class="line">    AnimalSound animalSound = <span class="keyword">new</span> AnimalSound();</span><br><span class="line">    animalSound.makeSound(duck); <span class="comment">// 输 出： 嘎 嘎 嘎 </span></span><br><span class="line">    animalSound.makeSound(chicken); <span class="comment">// 输 出： 咯 咯 咯 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="JavaScript语言是否需要抽象类和interface"><a href="#JavaScript语言是否需要抽象类和interface" class="headerlink" title="JavaScript语言是否需要抽象类和interface"></a>JavaScript语言是否需要抽象类和interface</h4><p>抽象类和interface的作用主要都是以下两点。</p><ul><li>通过向上转型来隐藏对象的真正类型，以表现对象的多态性。</li><li>约定类与类之间的一些契约行为。</li></ul><p>对于JavaScript而言，因为JavaScript是一门动态类型语言，类型本身在JavaScript中是一个相对模糊的概念。也就是说，不需要利用抽象类或者interface给对象进行“向上转型”。除了number、string、boolean等基本数据类型之外，其他的对象都可以被看成“天生”被“向上转型”成了Object类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></p><p>如果JavaScript是一门静态类型语言，上面的代码也许可以理解为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span> ary = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"><span class="built_in">Date</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">Object</span> ary = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"><span class="built_in">Object</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure></p><p>很少有人在JavaScript开发中去关心对象的真正类型。在动态类型语言中，对象的多态性是与生俱来的，但在另外一些静态类型语言中，对象类型之间的解耦非常重要，甚至有一些设计模式的主要目的就是专门隐藏对象的真正类型。</p><p>因为不需要进行向上转型，接口在JavaScript中的最大作用就退化到了检查代码的规范性。比如检查某个对象是否实现了某个方法，或者检查是否给函数传入了预期类型的参数。如果忽略了这两点，有可能会在代码中留下一些隐藏的bug。比如我们尝试执行obj对象的show方法，但是obj对象本身却没有实现这个方法，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.show(); <span class="comment">// Uncaught TypeError: undefined is not a function </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;; <span class="comment">// myObject 对 象 没 有 show 方 法 </span></span><br><span class="line">show(myObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.show(); <span class="comment">// TypeError: number is not a function </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="comment">// myObject.show 不 是 Function 类 型 </span></span><br><span class="line">  show: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">show(myObject);</span><br></pre></td></tr></table></figure></p><p>此时，我们不得不加上一些防御性代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj.show === <span class="string">'function'</span>) &#123;</span><br><span class="line">    obj.show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    obj.show();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;; <span class="comment">// myObject 对 象 没 有 show 方 法 </span></span><br><span class="line"><span class="comment">// var myObject = &#123; // myObject.show 不 是 Function 类 型 </span></span><br><span class="line"><span class="comment">// show: 1 </span></span><br><span class="line"><span class="comment">// &#125;; </span></span><br><span class="line">show(myObject);</span><br></pre></td></tr></table></figure></p><p>如果JavaScript有编译器帮我们检查代码的规范性，那事情要比现在美好得多，不用在业务代码中到处插入一些跟业务逻辑无关的防御性代码。作为一门解释执行的动态类型语言，把希望寄托在编译器上是不可能了。如果要处理这类异常情况，只有手动编写一些接口检查的代码。</p><h4 id="用鸭子类型进行接口检查"><a href="#用鸭子类型进行接口检查" class="headerlink" title="用鸭子类型进行接口检查"></a>用鸭子类型进行接口检查</h4><p>鸭子类型的概念：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”</p><p>鸭子类型是动态类型语言面向对象设计中的一个重要概念。利用鸭子类型的思想，不必借助超类型的帮助，就能在动态类型语言中轻松地实现本章提到的设计原则：面向接口编程，而不是面向实现编程。比如，一个对象如果有push和pop方法，并且提供了正确的实现，它就能被当作栈来使用；一个对象如果有length属性，也可以依照下标来存取属性，这个对象就可以被当作数组来使用。如果两个对象拥有相同的方法，则有很大的可能性它们可以被相互替换使用。</p><p>在<code>Object.prototype.toString.call([])===&#39;[object Array]&#39;</code>被发现之前，经常用鸭子类型的思想来判断一个对象是否是一个数组，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj.length === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> obj.splice === <span class="string">'function'</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>当然在JavaScript开发中，总是进行接口检查是不明智的，也是没有必要的，毕竟现在还找不到一种好用并且通用的方式来模拟接口检查，跟业务逻辑无关的接口检查也会让很多JavaScript程序员觉得不值得和不习惯。在Ross Harmes和Dustin Diaz合著的Pro JavaScript Design Pattrns一书中，提供了一种根据鸭子类型思想模拟接口检查的方法，但这种基于双重循环的检查方法并不是很实用，而且只能检查对象的某个属性是否属于Function类型。</p><h4 id="用TypeScript编写基于interface的命令模式"><a href="#用TypeScript编写基于interface的命令模式" class="headerlink" title="用TypeScript编写基于interface的命令模式"></a>用TypeScript编写基于interface的命令模式</h4><p>虽然在大多数时候interface给JavaScript开发带来的价值并不像在静态类型语言中那么大，但如果正在编写一个复杂的应用，还是会经常怀念接口的帮助。</p><p>下面以基于命令模式的示例来说明interface如何规范程序员的代码编写，这段代码本身并没有什么实用价值，在JavaScript中，一般用闭包和高阶函数来实现命令模式。</p><p>假设正在编写一个用户界面程序，页面中有成百上千个子菜单。因为项目很复杂，决定让整个程序都基于命令模式来编写，即编写菜单集合界面的是某个程序员，而负责实现每个子菜单具体功能的工作交给了另外一些程序员。</p><p>那些负责实现子菜单功能的程序员，在完成自己的工作之后，会把子菜单封装成一个命令对象，然后把这个命令对象交给编写菜单集合界面的程序员。已经约定好，当调用子菜单对象的execute方法时，会执行对应的子菜单命令。</p><p>虽然在开发文档中详细注明了每个子菜单对象都必须有自己的execute方法，但还是有一个粗心的JavaScript程序员忘记给他负责的子菜单对象实现execute方法，于是当执行这个命令的时候，便会报出错误，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">RefreshMenuBarCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'刷 新 菜 单 界 面'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AddSubMenuCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">AddSubMenuCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'增 加 子 菜 单'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DelSubMenuCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="comment">/***** 没 有 实 现 DelSubMenuCommand.prototype.execute *****/</span></span><br><span class="line"><span class="comment">// DelSubMenuCommand.prototype.execute = function()&#123;</span></span><br><span class="line"><span class="comment">// &#125;; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = <span class="keyword">new</span> RefreshMenuBarCommand(),</span><br><span class="line">  addSubMenuCommand = <span class="keyword">new</span> AddSubMenuCommand(),</span><br><span class="line">  delSubMenuCommand = <span class="keyword">new</span> DelSubMenuCommand();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params">command</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'exeCommand'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">setCommand(refreshMenuBarCommand); <span class="comment">// 点 击 按 钮 后 输 出：" 刷 新 菜 单 界 面"</span></span><br><span class="line">setCommand(addSubMenuCommand); <span class="comment">// 点 击 按 钮 后 输 出：" 增 加 子 菜 单" </span></span><br><span class="line">setCommand(delSubMenuCommand); <span class="comment">// 点 击 按 钮 后 报 错。 Uncaught TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure></p><p>为了防止粗心的程序员忘记给某个子命令对象实现execute方法，我们只能在高层函数里添加一些防御性的代码，这样当程序在最终被执行的时候，有可能抛出异常来提醒我们，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params">command</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'exeCommand'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> command.execute !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"command 对 象 必 须 实 现 execute 方 法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果确实不喜欢重复编写这些防御性代码，还可以尝试使用TypeScript来编写这个程序。</p><p>TypeScript是微软开发的一种编程语言，是JavaScript的一个超集。跟CoffeeScript类似，TypeScript代码最终会被编译成原生的JavaScript代码执行。通过TypeScript，可以使用静态语言的方式来编写JavaScript程序。用TypeScript来实现一些设计模式，显得更加原汁原味。</p><p>TypeScript提供了interface,下面编写一个TypeScript版本的命令模式。首先定义Command接口,接下来定义RefreshMenuBarCommand、AddSubMenuCommand和DelSubMenuCommand这3个类，它们分别都实现了Command接口，这可以保证它们都拥有execute方法：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Command &#123;</span><br><span class="line">  execute: <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> RefreshMenuBarCommand <span class="keyword">implements</span> Command &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  execute() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'刷 新 菜 单 界 面'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> AddSubMenuCommand <span class="keyword">implements</span> Command &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  execute() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'增 加 子 菜 单'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> DelSubMenuCommand <span class="keyword">implements</span> Command &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 忘 记 重 写 execute 方 法 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = <span class="keyword">new</span> RefreshMenuBarCommand(),</span><br><span class="line">  addSubMenuCommand = <span class="keyword">new</span> AddSubMenuCommand(),</span><br><span class="line">  delSubMenuCommand = <span class="keyword">new</span> DelSubMenuCommand();</span><br><span class="line"></span><br><span class="line">refreshMenuBarCommand.execute(); <span class="comment">// 输 出： 刷 新 菜 单 界 面 </span></span><br><span class="line">addSubMenuCommand.execute(); <span class="comment">// 输 出： 增 加 子 菜 单 </span></span><br><span class="line">delSubMenuCommand.execute(); <span class="comment">// 输 出： Uncaught TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure></p><p>当我们忘记在DelSubMenuCommand类中重写execute方法时，TypeScript提供的编译器及时给出了错误提示。</p><p>TypeScript代码翻译过来的JavaScript代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RefreshMenuBarCommand = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">RefreshMenuBarCommand</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  RefreshMenuBarCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">' 刷 新 菜 单 界 面'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> RefreshMenuBarCommand;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AddSubMenuCommand = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">AddSubMenuCommand</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  AddSubMenuCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">' 增 加 子 菜 单'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> AddSubMenuCommand;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DelSubMenuCommand = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">DelSubMenuCommand</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> DelSubMenuCommand;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = <span class="keyword">new</span> RefreshMenuBarCommand(),</span><br><span class="line">  addSubMenuCommand = <span class="keyword">new</span> AddSubMenuCommand(),</span><br><span class="line">  delSubMenuCommand = <span class="keyword">new</span> DelSubMenuCommand();</span><br><span class="line"></span><br><span class="line">refreshMenuBarCommand.execute();</span><br><span class="line">addSubMenuCommand.execute();</span><br><span class="line">delSubMenuCommand.execute();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当谈到接口的时候，通常会涉及以下几种含义。&lt;/p&gt;
&lt;p&gt;我们经常说一个库或者模块对外提供了某某API接口。通过主动暴露的接口来通信，可以隐藏软件系统内部的工作细节。这也是我们最熟悉的第一种接口含义。&lt;/p&gt;
&lt;p&gt;第二种接口是一些语言提供的关键字，比如Java的inter
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-17-设计原则：单一职责原则/最少知识原则/开放-封闭原则</title>
    <link href="https://github.com/xmoyKING/2017/12/06/js-pattern17/"/>
    <id>https://github.com/xmoyKING/2017/12/06/js-pattern17/</id>
    <published>2017-12-06T01:37:10.000Z</published>
    <updated>2017-12-06T01:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。设计原则通常指的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则。</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>就一个类而言，应该仅有一个引起它变化的原因。在JavaScript中，需要用到类的场景并不太多，单一职责原则更多地是被运用在对象或者方法级别上。</p><p>单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。</p><p>此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。因此，SRP原则体现为：一个对象（方法）只做一件事情。</p><h4 id="设计模式中的SRP原则"><a href="#设计模式中的SRP原则" class="headerlink" title="设计模式中的SRP原则"></a>设计模式中的SRP原则</h4><p>SRP原则在很多设计模式中都有着广泛的运用，例如代理模式、迭代器模式、单例模式和装饰者模式。</p><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>图片预加载的例子,通过增加虚拟代理的方式，把预加载图片的职责放到代理对象中，而本体仅仅负责往页面中添加img标签，这也是它最原始的职责。</p><p>myImage负责往页面中添加img标签：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      imgNode.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>proxyImage负责预加载图片，并在预加载完成之后把请求交给本体myImage：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    myImage.setSrc(<span class="keyword">this</span>.src);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      myImage.setSrc(<span class="string">'loading.gif'</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyImage.setSrc(<span class="string">'photo.jpg'</span>);</span><br></pre></td></tr></table></figure></p><p>把添加img标签的功能和预加载图片的职责分开放到两个对象中，这两个对象各自都只有一个被修改的动机。在它们各自发生改变的时候，也不会影响另外的对象。</p><h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><p>假设一段代码，先遍历一个集合，然后往页面中添加一些div，这些div的innerHTML分别对应集合里的元素：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = data.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      div.innerHTML = data[i];</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">appendDiv([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure></p><p>这其实是一段很常见的代码，经常用于ajax请求之后，在回调函数中遍历ajax请求返回的数据，然后在页面中渲染节点。</p><p>appendDiv函数本来只是负责渲染数据，但是在这里它还承担了遍历聚合对象data的职责。如果返回的data数据格式从array变成了object，那我们遍历data的代码就会出现问题，必须改成<code>for(var i in data)</code>的方式，这时候必须去修改appendDiv里的代码，否则因为遍历方式的改变，导致不能顺利往页面中添加div节点。</p><p>有必要把遍历data的职责提取出来，这正是迭代器模式的意义，迭代器模式提供了一种方法来访问聚合对象，而不用暴露这个对象的内部表示。</p><p>当把迭代聚合对象的职责单独封装在each函数中后，即使以后还要增加新的迭代方式，我们只需要修改each函数即可，appendDiv函数不会受到牵连，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> each = <span class="function"><span class="keyword">function</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value, i = <span class="number">0</span>,</span><br><span class="line">      length = obj.length,</span><br><span class="line">      isArray = isArraylike(obj); <span class="comment">// isArraylike 函 数 未 实 现， 可 以 翻 阅 jQuery 源 代 码 </span></span><br><span class="line">    <span class="keyword">if</span> (isArray) &#123; <span class="comment">// 迭 代 类 数 组 </span></span><br><span class="line">      <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        callback.call(obj[i], i, obj[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> obj) &#123; <span class="comment">// 迭 代 object 对 象</span></span><br><span class="line">        value = callback.call(obj[i], i, obj[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    each(data, <span class="function"><span class="keyword">function</span>(<span class="params">i, n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      div.innerHTML = n;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">appendDiv([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">appendDiv(&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">  d: <span class="number">4</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>惰性单例例子中，最开始的代码是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createLoginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> div;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!div) &#123;</span><br><span class="line">      div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      div.innerHTML = <span class="string">'我 是 登 录 浮 窗'</span>;</span><br><span class="line">      div.style.display = <span class="string">'none'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>现在把管理单例的职责和创建登录浮窗的职责分别封装在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一登录浮窗的功能，下面的代码显然是更好的做法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123; <span class="comment">// 获 取 单 例 </span></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 创 建 登 录 浮 窗 </span></span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.innerHTML = <span class="string">'我 是 登 录 浮 窗'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle(createLoginLayer);</span><br><span class="line"><span class="keyword">var</span> loginLayer1 = createSingleLoginLayer();</span><br><span class="line"><span class="keyword">var</span> loginLayer2 = createSingleLoginLayer();</span><br><span class="line">alert(loginLayer1 === loginLayer2); <span class="comment">// 输 出： true</span></span><br></pre></td></tr></table></figure></p><h5 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h5><p>使用装饰者模式的时候，通常让类或者对象一开始只具有一些基础的职责，更多的职责在代码运行时被动态装饰到对象上面。装饰者模式可以为对象动态增加职责，从另一个角度来看，这也是分离职责的一种方式。</p><p>下面的例子把数据上报的功能单独放在一个函数里，然后把这个函数动态装饰到业务函数上面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打 开 登 录 浮 层'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'上 报 标 签 为: '</span> + <span class="keyword">this</span>.getAttribute(<span class="string">'tag'</span>));</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = showLogin.after(log); <span class="comment">// 打 开 登 录 浮 层 之 后 上 报 数 据</span></span><br></pre></td></tr></table></figure></p><p>SRP原则的应用难点是如何去分离职责。</p><h4 id="何时应该分离职责"><a href="#何时应该分离职责" class="headerlink" title="何时应该分离职责"></a>何时应该分离职责</h4><p>SRP原则是所有原则中最简单也是最难正确运用的原则之一。</p><p>要明确的是，并不是所有的职责都应该一一分离。</p><p>一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在ajax请求的时候，创建xhr对象和发送xhr请求几乎总是在一起的，那么创建xhr对象的职责和发送xhr请求的职责就没有必要分开。</p><p>另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。</p><h4 id="违反SRP原则"><a href="#违反SRP原则" class="headerlink" title="违反SRP原则"></a>违反SRP原则</h4><p>在人的常规思维中，总是习惯性地把一组相关的行为放到一起，如何正确地分离职责不是一件容易的事情。</p><p>我们也许从来没有考虑过如何分离职责，但这并不妨碍我们编写代码完成需求。对于SRP原则，许多专家委婉地表示“This is some times hard to see.”。</p><p>一方面，我们受设计原则的指导，另一方面，我们未必要在任何时候都一成不变地遵守原则。在实际开发中，因为种种原因违反SRP的情况并不少见。比如jQuery的attr等方法，就是明显违反SRP原则的做法。jQuery的attr是个非常庞大的方法，既负责赋值，又负责取值，这对于jQuery的维护者来说，会带来一些困难，但对于jQuery的用户来说，却简化了用户的使用。</p><p>在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。比如如果一个电视机内置了DVD机，当电视机坏了的时候，DVD机也没法正常使用，那么一个DVD发烧友通常不会选择这样的电视机。但如果我们的客厅本来就小得夸张，或者更在意DVD在使用上的方便，那让电视机和DVD机耦合在一起就是更好的选择。</p><h4 id="SRP原则的优缺点"><a href="#SRP原则的优缺点" class="headerlink" title="SRP原则的优缺点"></a>SRP原则的优缺点</h4><p>SRP原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。</p><p>但SRP原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。</p><h3 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h3><p>最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。主要针对对象来说明这个原则，下面引用《面向对象设计原理与模式》一书中的例子来解释最少知识原则：</p><p>某军队中的将军需要挖掘一些散兵坑。下面是完成任务的一种方式：将军可以通知上校让他叫来少校，然后让少校找来上尉，并让上尉通知一个军士，最后军士唤来一个士兵，然后命令士兵挖掘一些散兵坑。</p><p>这种方式十分荒谬，不是吗？不过，我们还是先来看一下这个过程的等价代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gerneral.getColonel(c).getMajor(m).getCaptain(c).getSergeant(s).getPrivate(p).digFoxhole();</span><br></pre></td></tr></table></figure></p><p>让代码通过这么长的消息链才能完成一个任务，这就像让将军通过那么多繁琐的步骤才能命令别人挖掘散兵坑一样荒谬！而且，这条链中任何一个对象的改动都会影响整条链的结果。</p><p>最有可能的是，将军自己根本就不会考虑挖散兵坑这样的细节信息。但是如果将军真的考虑了这个问题的话，他一定会通知某个军官：“我不关心这个工作如何完成，但是你得命令人去挖散兵坑。”</p><h4 id="减少对象之间的联系"><a href="#减少对象之间的联系" class="headerlink" title="减少对象之间的联系"></a>减少对象之间的联系</h4><p>单一职责原则指导我们把对象划分成较小的粒度，这可以提高对象的可复用性。但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。对象和对象耦合在一起，有可能会降低它们的可复用性。在程序中，对象的“朋友”太多并不是一件好事，“城门失火，殃及池鱼”和“一人犯法，株连九族”的故事时有发生。</p><p>最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。</p><h4 id="设计模式中的最少知识原则"><a href="#设计模式中的最少知识原则" class="headerlink" title="设计模式中的最少知识原则"></a>设计模式中的最少知识原则</h4><p>最少知识原则在设计模式中体现得最多的地方是中介者模式和外观模式。</p><h5 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h5><p>曾讲过一个博彩公司的例子。</p><p>在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能的事情。博彩公司作为中介，每个人都只和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就赔给博彩公司。</p><p>中介者模式很好地体现了最少知识原则。通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象即可。</p><h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h5><p>外观模式在JavaScript中的使用场景并不多。外观模式主要是为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使子系统更加容易使用，如图所示。<br><img src="1.png" alt="外观模式"><br>外观模式的作用是对客户屏蔽一组子系统的复杂性。外观模式对客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现。大多数客户都可以通过请求外观接口来达到访问子系统的目的。但在一段使用了外观模式的程序中，请求外观并不是强制的。如果外观不能满足客户的个性化需求，那么客户也可以选择越过外观来直接访问子系统。</p><p>拿全自动洗衣机的一键洗衣按钮举例，这个一键洗衣按钮就是一个外观。如果是老式洗衣机，客户要手动选择浸泡、洗衣、漂洗、脱水这4个步骤。如果这种洗衣机被淘汰了，新式洗衣机的漂洗方式发生了改变，那我们还得学习新的漂洗方式。而全自动洗衣机的好处很明显，不管洗衣机内部如何进化，客户要操作的，始终只是一个一键洗衣的按钮。这个按钮就是为一组子系统所创建的外观。但如果一键洗衣程序设定的默认漂洗时间是20分钟，而客户希望这个漂洗时间是30分钟，那么客户自然可以选择越过一键洗衣程序，自己手动来控制这些“子系统”运转。</p><p>外观模式容易跟普通的封装实现混淆。这两者都封装了一些事物，但外观模式的关键是定义一个高层接口去封装一组“子系统”。子系统在C++或者Java中指的是一组类的集合，这些类相互协作可以组成系统中一个相对独立的部分。在JavaScript中我们通常不会过多地考虑“类”，如果将外观模式映射到JavaScript中，这个子系统至少应该指的是一组函数的集合。</p><p>最简单的外观模式应该是类似下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; a1(); a2(); &#125; </span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; b1(); b2(); &#125; </span><br><span class="line"><span class="keyword">var</span> facade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; A(); B(); &#125; </span><br><span class="line"></span><br><span class="line">facade();</span><br></pre></td></tr></table></figure></p><p>许多JavaScript设计模式的图书或者文章喜欢把jQuery的$.ajax函数当作外观模式的实现，这是不合适的。如果$.ajax函数属于外观模式，那几乎所有的函数都可以被称为“外观模式”。问题是我们根本没有办法越过$.ajax“外观”去直接使用该函数中的某一段语句。</p><p>现在再来看看外观模式和最少知识原则之间的关系。外观模式的作用主要有两点。</p><ul><li>为一组子系统提供一个简单便利的访问入口。</li><li>隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。</li></ul><p>从第二点来，外观模式是符合最少知识原则的。比如全自动洗衣机的一键洗衣按钮，隔开了客户和浸泡、洗衣、漂洗、脱水这些子系统的直接联系，客户不用去了解这些子系统的具体实现。</p><p>假设我们在编写这个老式洗衣机的程序，客户至少要和浸泡、洗衣、漂洗、脱水这4个子系统打交道。如果其中的一个子系统发生了改变，那么客户的调用代码就得发生改变。而通过外观将客户和这些子系统隔开之后，如果修改子系统内部，只要外观不变，就不会影响客户的调用。同样，对外观的修改也不会影响到子系统，它们可以分别变化而互不影响。</p><h4 id="封装在最少知识原则中的体现"><a href="#封装在最少知识原则中的体现" class="headerlink" title="封装在最少知识原则中的体现"></a>封装在最少知识原则中的体现</h4><p>封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细节隐藏起来，只暴露必要的接口API供外界访问。对象之间难免产生联系，当一个对象必须引用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的范围之内。</p><p>同时，封装也用来限制变量的作用域。在JavaScript中对变量作用域的规定是：</p><ul><li>变量在全局声明，或者在代码的任何位置隐式申明（不用var），则该变量在全局可见；</li><li>变量在函数内显式申明（使用var），则在函数内可见。</li></ul><p>把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小。这也是广义的最少知识原则的一种体现。</p><p>假设我们要编写一个具有缓存效果的计算乘积的函数<code>function mult(){}</code>，我们需要一个对象<code>var cache={}</code>来保存已经计算过的结果。cache对象显然只对mult有用，把cache对象放在mult形成的闭包中，显然比把它放在全局作用域更加合适，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>);</span><br><span class="line">    <span class="keyword">if</span> (cache[args]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[args];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">      a = a * <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[args] = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">mult(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输 出： 6</span></span><br></pre></td></tr></table></figure></p><p>其实，最少知识原则也叫迪米特法则（Law of Demeter，LoD），“迪米特”这个名字源自1987年美国东北大学一个名为“Demeter”的研究项目。</p><p>许多人更倾向于使用迪米特法则这个名字，也许是因为显得更酷一点。但参考《Head First Design Patterns》的建议，称之为最少知识原则。一是因为这个名字更能体现其含义，另一个原因是“法则”给人的感觉是必须强制遵守，而原则只是一种指导，没有哪条原则是在实际开发中必须遵守的。比如，虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则，要根据具体的环境来定。</p><h3 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h3><p>在面向对象的程序设计中，开放-封闭原则（OCP）是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放-封闭原则的。</p><p>开放-封闭原则最早由Eiffel语言的设计者Bertrand Meyer在其著作Object-Oriented Software Construction中提出。它的定义如下：</p><blockquote><p>软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。</p></blockquote><p>在明白开放-封闭原则的定义之前，先看一个示例，在window.onload函数中添加一些新的功能。</p><h4 id="扩展window-onload函数"><a href="#扩展window-onload函数" class="headerlink" title="扩展window.onload函数"></a>扩展window.onload函数</h4><p>假设我们是一个大型Web项目的维护人员，在接手这个项目时，发现它已经拥有10万行以上的JavaScript代码和数百个JS文件。</p><p>不久后接到了一个新的需求，即在window.onload函数中打印出页面中的所有节点数量。于是搜索出window.onload函数在文件中的位置，在函数内部添加以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 原 有 代 码 略 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>).length ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在项目需求变迁的过程中，经常会找到相关代码，然后改写它们。这似乎是理所当然的事情，不改动代码怎么满足新的需求呢？想要扩展一个模块，最常用的方式当然是修改它的源代码。如果一个模块不允许修改，那么它的行为常常是固定的。然而，改动代码是一种危险的行为，也许我们都遇到过bug越改越多的场景。刚刚改好了一个bug，但是又在不知不觉中引发了其他的bug。</p><p>如果目前的window.onload函数是一个拥有500行代码的巨型函数，里面密布着各种变量和交叉的业务逻辑，而需求又不仅仅是打印一个log这么简单。那么“改好一个bug，引发其他bug”这样的事情就很可能会发生。我们永远不知道刚刚的改动会有什么副作用，很可能会引发一系列的连锁反应。</p><p>那么，有没有办法在不修改代码的情况下，就能满足新需求呢？通过增加代码，而不是修改代码的方式，来给window.onload函数添加新的功能，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = (<span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>).length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>通过动态装饰函数的方式，我们完全不用理会从前window.onload函数的内部实现，无论它的实现优雅或是丑陋。就算我们作为维护者，拿到的是一份混淆压缩过的代码也没有关系。只要它从前是个稳定运行的函数，那么以后也不会因为我们的新增需求而产生错误。新增的代码和原有的代码可以井水不犯河水。</p><h4 id="开放和封闭"><a href="#开放和封闭" class="headerlink" title="开放和封闭"></a>开放和封闭</h4><p>为window.onload函数扩展功能时，用到了两种方式。一种是修改原有的代码，另一种是增加一段新的代码。使用哪种方式效果更好，已经不言而喻。</p><p>现在可以引出开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。</p><p>在现实生活中，我们也能找到一些跟开放-封闭原则相关的故事。</p><p>有一家生产肥皂的大企业，从欧洲花巨资引入了一条生产线。这条生产线可以自动完成从原材料加工到包装成箱的整个流程，但美中不足的是，生产出来的肥皂有一定的空盒几率。于是老板又从欧洲找来一支专家团队，花费数百万元改造这一生产线，终于解决了生产出空盒肥皂的问题。</p><p>另一家企业也引入了这条生产线，他们同样遇到了空盒肥皂的问题。但他们的解决办法很简单：用一个大风扇在生产线旁边吹，空盒肥皂就会被吹走。</p><p>这个故事告诉我们，相比修改源程序，如果通过增加几行代码就能解决问题，那这显然更加简单和优雅，而且增加代码并不会影响原系统的稳定。讲述这个故事，目的不在于说明风扇的成本有多低，而是想说明，如果使用风扇这样简单的方式可以解决问题，根本没有必要去大动干戈地改造原有的生产线。</p><h4 id="用对象的多态性消除条件分支"><a href="#用对象的多态性消除条件分支" class="headerlink" title="用对象的多态性消除条件分支"></a>用对象的多态性消除条件分支</h4><p>过多的条件分支语句是造成程序违反开放-封闭原则的一个常见原因。每当需要增加一个新的if语句时，都要被迫改动原函数。把if换成switch-case是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的if或者swtich-case语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。</p><p>利用对象的多态性来让程序遵守开放-封闭原则，是一个常用的技巧。例如让动物发出叫声的例子。下面先提供一段不符合开放-封闭原则的代码。每当我们增加一种新的动物时，都需要改动makeSound函数的内部实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Duck) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'嘎 嘎 嘎'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Chicken) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'咯 咯 咯'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">makeSound(<span class="keyword">new</span> Duck()); <span class="comment">// 输 出： 嘎 嘎 嘎</span></span><br><span class="line">makeSound(<span class="keyword">new</span> Chicken()); <span class="comment">// 输 出： 咯 咯 咯</span></span><br></pre></td></tr></table></figure></p><p>利用多态的思想，我们把程序中不变的部分隔离出来（动物都会叫），然后把可变的部分封装起来（不同类型的动物发出不同的叫声），这样一来程序就具有了可扩展性。当我们想让一只狗发出叫声时，只需增加一段代码即可，而不用去改动原有的makeSound函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">    animal.sound();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Duck.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'嘎 嘎 嘎'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Chicken.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'咯 咯 咯'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">makeSound(<span class="keyword">new</span> Duck()); <span class="comment">// 嘎 嘎 嘎 </span></span><br><span class="line">makeSound(<span class="keyword">new</span> Chicken()); <span class="comment">// 咯 咯 咯 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********* 增 加 动 物 狗， 不 用 改 动 原 有 的 makeSound 函 数 ****************/</span></span><br><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Dog.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'汪 汪 汪'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">makeSound(<span class="keyword">new</span> Dog()); <span class="comment">// 汪 汪 汪</span></span><br></pre></td></tr></table></figure></p><h4 id="找出变化的地方"><a href="#找出变化的地方" class="headerlink" title="找出变化的地方"></a>找出变化的地方</h4><p>开放-封闭原则是一个看起来比较虚幻的原则，并没有实际的模板教导我们怎样亦步亦趋地实现它。但我们还是能找到一些让程序尽量遵守开放-封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。</p><p>通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需要改变的。</p><p>在例子中，由于每种动物的叫声都不同，所以动物具体怎么叫是可变的，于是我们把动物具体怎么叫的逻辑从makeSound函数中分离出来。</p><p>而动物都会叫这是不变的，makeSound函数里的实现逻辑只跟动物都会叫有关，这样一来，makeSound就成了一个稳定和封闭的函数。</p><p>除了利用对象的多态性之外，还有其他方式可以帮助我们编写遵守开放-封闭原则的代码。</p><h5 id="放置挂钩"><a href="#放置挂钩" class="headerlink" title="放置挂钩"></a>放置挂钩</h5><p>放置挂钩（hook）也是分离变化的一种方式。在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。</p><p>在jQuery源代码中，jQuery从1.4版本开始，陆续加入了fixHooks、keyHooks、mouseHooks、cssHooks等挂钩。</p><p>Template Method模式中的父类是一个相当稳定的类，它封装了子类的算法骨架和执行步骤。</p><p>由于子类的数量是无限制的，总会有一些“个性化”的子类迫使我们不得不去改变已经封装好的算法骨架。于是我们可以在父类中的某个容易变化的地方放置挂钩，挂钩的返回结果由具体子类决定。这样一来，程序就拥有了变化的可能。</p><h5 id="使用回调函数"><a href="#使用回调函数" class="headerlink" title="使用回调函数"></a>使用回调函数</h5><p>在JavaScript中，函数可以作为参数传递给另外一个函数，这是高阶函数的意义之一。在这种情况下，通常会把这个函数称为回调函数。在JavaScript版本的设计模式中，策略模式和命令模式等都可以用回调函数轻松实现。</p><p>回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。</p><p>比如，通过ajax异步请求用户信息之后要做一些事情，请求用户信息的过程是不变的，而获取到用户信息之后要做什么事情，则是可能变化的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getUserInfo = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    $.ajax(<span class="string">'getUserInfo'</span>, callback);</span><br><span class="line">&#125;;</span><br><span class="line">getUserInfo(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.userName);</span><br><span class="line">&#125;);</span><br><span class="line">getUserInfo(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.userId);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>另外一个例子是关于Array.prototype.map的。在不支持Array.prototype.map的浏览器中，可以简单地模拟实现一个map函数。</p><p>arrayMap函数的作用是把一个数组“映射”为另外一个数组。映射的步骤是不变的，而映射的规则是可变的，于是把这部分规则放在回调函数中，传入arrayMap函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayMap = <span class="function"><span class="keyword">function</span>(<span class="params">ary, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>,</span><br><span class="line">    length = ary.length,</span><br><span class="line">    value, ret = [];</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">    value = callback(i, ary[i]);</span><br><span class="line">    ret.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = arrayMap([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">i, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> b = arrayMap([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">i, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输 出：[ 2, 4, 6 ] </span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输 出：[ 3, 6, 9 ]</span></span><br></pre></td></tr></table></figure></p><h4 id="设计模式中的开放－封闭原则"><a href="#设计模式中的开放－封闭原则" class="headerlink" title="设计模式中的开放－封闭原则"></a>设计模式中的开放－封闭原则</h4><p>有一种说法是，设计模式就是给做的好的设计取个名字。几乎所有的设计模式都是遵守开放-封闭原则的，我们见到的好设计，通常都经得起开放-封闭原则的考验。不管是具体的各种设计模式，还是更抽象的面向对象设计原则，比如单一职责原则、最少知识原则、依赖倒置原则等，都是为了让程序遵守开放-封闭原则而出现的。可以这样说，开放-封闭原则是编写一个好程序的目标，其他设计原则都是达到这个目标的过程。</p><p>例举几个模式，来更深一步地了解设计模式在遵守开放-封闭原则方面做出的努力。</p><h5 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h5><p>发布-订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。</p><h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>我们曾提到，模板方法模式是一种典型的通过封装变化来提高系统扩展性的设计模式。在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放-封闭原则的。</p><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。</p><p>策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码。</p><h5 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h5><p>拿预加载图片举例，我们现在已有一个给图片设置src的函数myImage，当我们想为它增加图片预加载功能时，一种做法是改动myImage函数内部的代码，更好的做法是提供一个代理函数proxyMyImage，代理函数负责图片预加载，在图片预加载完成之后，再将请求转交给原来的myImage函数，myImage在这个过程中不需要任何改动。</p><p>预加载图片的功能和给图片设置src的功能被隔离在两个函数里，它们可以单独改变而互不影响。myImage不知晓代理的存在，它可以继续专注于自己的职责——给图片设置src。</p><h5 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h5><p>例如把一个巨大的订单函数分别拆成了500元订单、200元订单以及普通订单的3个函数。这3个函数通过职责链连接在一起，客户的请求会在这条链条里面依次传递：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> order500yuan = <span class="keyword">new</span> Chain( <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 具 体 代 码 略 </span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> order200yuan = <span class="keyword">new</span> Chain( <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 具 体 代 码 略 </span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="keyword">new</span> Chain( <span class="function"><span class="keyword">function</span>(<span class="params"> orderType, pay, stock </span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 具 体 代 码 略 </span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">order500yuan.setNextSuccessor( order200yuan ).setNextSuccessor( orderNormal ); </span><br><span class="line">order500yuan.passRequest( <span class="number">1</span>, <span class="literal">true</span>, <span class="number">10</span> ); <span class="comment">// 500 元 定 金 预 购， 得 到 100 优 惠 券</span></span><br></pre></td></tr></table></figure></p><p>可以看到，当增加一个新类型的订单函数时，不需要改动原有的订单函数代码，只需要在链条中增加一个新的节点。</p><h4 id="开放－封闭原则的相对性"><a href="#开放－封闭原则的相对性" class="headerlink" title="开放－封闭原则的相对性"></a>开放－封闭原则的相对性</h4><p>在职责链模式代码中，也许会产生疑问：开放-封闭原则要求我们只能通过增加源代码的方式扩展程序的功能，而不允许修改源代码。那当我们往职责链中增加一个新的100元订单函数节点时，不也必须改动设置链条的代码吗？代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order500yuan.setNextSuccessor(order200yuan).setNextSuccessor(orderNormal);</span><br></pre></td></tr></table></figure></p><p>变为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order500yuan.setNextSuccessor(order200yuan).setNextSuccessor(order100yuan).setNextSuccessor(orderNormal);</span><br></pre></td></tr></table></figure></p><p>实际上，让程序保持完全封闭是不容易做到的。就算技术上做得到，也需要花费太多的时间和精力。而且让程序符合开放-封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增大代码的复杂度。</p><p>更何况，有一些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化。作为程序员，可以做到的有下面两点。</p><ul><li>挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。</li><li>在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单。</li></ul><p>比如那个巨大的订单函数，它包含了各种订单的逻辑，有500元和200元的，也有普通订单的。这个函数是最有可能发生变化的，一旦增加新的订单，就必须修改这个巨大的函数。而用职责链模式重构之后，我们只需要新增一个节点，然后重新设置链条中节点的连接顺序。重构后的修改方式显然更加清晰简单。</p><h4 id="接受第一次愚弄"><a href="#接受第一次愚弄" class="headerlink" title="接受第一次愚弄"></a>接受第一次愚弄</h4><p>下面这段话引自Bob大叔的《敏捷软件开发原则、模式与实践》。</p><p>有句古老的谚语说：“愚弄我一次，应该羞愧的是你。再次愚弄我，应该羞愧的是我。”这也是一种有效的对待软件设计的态度。为了防止软件背着不必要的复杂性，我们会允许自己被愚弄一次。</p><p>让程序一开始就尽量遵守开放-封闭原则，并不是一件很容易的事情。一方面，我们需要尽快知道程序在哪些地方会发生变化，这要求我们有一些“未卜先知”的能力。另一方面，留给程序员的需求排期并不是无限的，所以我们可以说服自己去接受不合理的代码带来的第一次愚弄。在最初编写代码的时候，先假设变化永远不会发生，这有利于我们迅速完成需求。当变化发生并且对我们接下来的工作造成影响的时候，可以再回过头来封装这些变化的地方。然后确保我们不会掉进同一个坑里，这有点像星矢说的：“圣斗士不会被同样的招数击倒第二次。”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。设计原则通常指的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则。&lt;/p&gt;
&lt;h3 id=&quot;单一职责原则&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-16-适配器模式</title>
    <link href="https://github.com/xmoyKING/2017/12/04/js-pattern16/"/>
    <id>https://github.com/xmoyKING/2017/12/04/js-pattern16/</id>
    <published>2017-12-04T15:02:47.000Z</published>
    <updated>2017-12-04T15:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。适配器的别名是包装器（wrapper），这是一个相对简单的模式。在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道。</p><h4 id="现实中的适配器"><a href="#现实中的适配器" class="headerlink" title="现实中的适配器"></a>现实中的适配器</h4><p>适配器在现实生活的应用非常广泛，接下来我们来看几个现实生活中的适配器模式。</p><ol><li>港式插头转换器港式的电器插头比大陆的电器插头体积要大一些。如果从香港买了一个Macbook，我们会发现充电器无法插在家里的插座上，为此而改造家里的插座显然不方便，所以我们需要一个适配器</li><li>电源适配器Macbook电池支持的电压是20V，我们日常生活中的交流电压一般是220V。除了我们了解的220V交流电压，日本和韩国的交流电压大多是100V，而英国和澳大利亚的是240V。笔记本电脑的电源适配器就承担了转换电压的作用，电源适配器使笔记本电脑在100V~240V的电压之内都能正常工作，这也是它为什么被称为电源“适配器”的原因。<br>3.USB转接口在以前的电脑上，PS2接口是连接鼠标、键盘等其他外部设备的标准接口。但随着技术的发展，越来越多的电脑开始放弃了PS2接口，转而仅支持USB接口。所以那些过去生产出来的只拥有PS2接口的鼠标、键盘、游戏手柄等，需要一个USB转接口才能继续正常工作，这是PS2-USB适配器诞生的原因。</li></ol><h4 id="适配器模式的应用"><a href="#适配器模式的应用" class="headerlink" title="适配器模式的应用"></a>适配器模式的应用</h4><p>如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。适配器模式是一种“亡羊补牢”的模式，没有人会在程序的设计之初就使用它。因为没有人可以完全预料到未来的事情，也许现在好好工作的接口，未来的某天却不再适用于新系统，那么我们可以用适配器模式把旧接口包装成一个新的接口，使它继续保持生命力。比如在JSON格式流行之前，很多cgi返回的都是XML格式的数据，如果今天仍然想继续使用这些接口，显然我们可以创造一个XML-JSON的适配器。</p><p>下面这个实例可以帮助深刻了解适配器模式。<br>当我们向googleMap和baiduMap都发出“显示”请求时，googleMap和baiduMap分别以各自的方式在页面中展现了地图：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> googleMap = &#123;</span><br><span class="line">show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开 始 渲 染 谷 歌 地 图'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> baiduMap = &#123;</span><br><span class="line">show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开 始 渲 染 百 度 地 图'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">map.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap(googleMap); <span class="comment">// 输 出： 开 始 渲 染 谷 歌 地 图</span></span><br><span class="line">renderMap(baiduMap); <span class="comment">// 输 出： 开 始 渲 染 百 度 地 图</span></span><br></pre></td></tr></table></figure></p><p>这段程序得以顺利运行的关键是googleMap和baiduMap提供了一致的show方法，但第三方的接口方法并不在我们自己的控制范围之内，假如baiduMap提供的显示地图的方法不叫show而叫display呢？</p><p>baiduMap这个对象来源于第三方，正常情况下我们都不应该去改动它。此时我们可以通过增加baiduMapAdapter来解决问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baiduMapAdapter = &#123; <span class="attr">show</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> baiduMap.display(); &#125; &#125;;</span><br><span class="line">renderMap( baiduMapAdapter ); <span class="comment">// 输 出： 开 始 渲 染 百 度 地 图</span></span><br></pre></td></tr></table></figure></p><p>再来看看另外一个例子。假设我们正在编写一个渲染广东省地图的页面。目前从第三方资源里获得了广东省的所有城市以及它们所对应的ID，并且成功地渲染到页面中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getGuangdongCity = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> guangdongCity = [&#123;</span><br><span class="line">name: <span class="string">'shenzhen'</span>,</span><br><span class="line">id: <span class="number">11</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: <span class="string">'guangzhou'</span>,</span><br><span class="line">id: <span class="number">12</span>,</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">return</span> guangdongCity;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开 始 渲 染 广 东 省 地 图'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">JSON</span>.stringify(fn()));</span><br><span class="line">&#125;;</span><br><span class="line">render(getGuangdongCity);</span><br></pre></td></tr></table></figure></p><p>利用这些数据，我们编写完成了整个页面，并且在线上稳定地运行了一段时间。但后来发现这些数据不太可靠，里面还缺少很多城市。于是我们又在网上找到了另外一些数据资源，这次的数据更加全面，但遗憾的是，数据结构和正运行在项目中的并不一致。新的数据结构如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> guangdongCity = &#123; <span class="attr">shenzhen</span>: <span class="number">11</span>, <span class="attr">guangzhou</span>: <span class="number">12</span>, <span class="attr">zhuhai</span>: <span class="number">13</span> &#125;;</span><br></pre></td></tr></table></figure></p><p>除了大动干戈地改写渲染页面的前端代码之外，另外一种更轻便的解决方式就是新增一个数据格式转换的适配器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addressAdapter = <span class="function"><span class="keyword">function</span>(<span class="params">oldAddressfn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> address = &#123;&#125;,</span><br><span class="line">oldAddress = oldAddressfn();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, c; c = oldAddress[i + +];) &#123;</span><br><span class="line">address[c.name] = c.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">render(addressAdapter(getGuangdongCity));</span><br></pre></td></tr></table></figure></p><p>那么接下来需要做的，就是把代码中调用getGuangdongCity的地方，用经过addressAdapter适配器转换之后的新函数来代替。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>适配器模式是一对相对简单的模式。在本书提到的设计模式中，有一些模式跟适配器模式的结构非常相似，比如装饰者模式、代理模式和外观模式。这几种模式都属于“包装模式”，都是由一个对象来包装另一个对象。区别它们的关键仍然是模式的意图。</p><ul><li>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。</li><li>装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。</li><li>外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。适配器的别名是包装器（wrapper），这是一个相对简单的模式。在程序开发中有许多这样的场景：当我们试图调用模块或者对象的某个接口时，却发现这
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-15-状态模式</title>
    <link href="https://github.com/xmoyKING/2017/12/04/js-pattern15/"/>
    <id>https://github.com/xmoyKING/2017/12/04/js-pattern15/</id>
    <published>2017-12-04T11:28:59.000Z</published>
    <updated>2017-12-04T11:28:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>状态模式是一种非同寻常的优秀模式，它也许是解决某些需求场景的最好方法。虽然状态模式并不是一种简单到一目了然的模式（它往往还会带来代码量的增加），但你一旦明白了状态模式的精髓，以后一定会感谢它带给你的无与伦比的好处。</p><p>状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。</p><h4 id="初识状态模式"><a href="#初识状态模式" class="headerlink" title="初识状态模式"></a>初识状态模式</h4><p>我们来想象这样一个场景：有一个电灯，电灯上面只有一个开关。当电灯开着的时候，此时按下开关，电灯会切换到关闭状态；再按一次开关，电灯又将被打开。同一个开关按钮，在不同的状态下，表现出来的行为是不一样的。</p><p>现在用代码来描述这个场景，首先定义一个Light类，可以预见，电灯对象light将从Light类创建而出，light对象将拥有两个属性，我们用state来记录电灯当前的状态，用button表示具体的开关按钮。下面来编写这个电灯程序的例子。</p><h5 id="第一个例子：电灯程序"><a href="#第一个例子：电灯程序" class="headerlink" title="第一个例子：电灯程序"></a>第一个例子：电灯程序</h5><p>首先给出不用状态模式的电灯程序实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'off'</span>; <span class="comment">// 给 电 灯 设 置 初 始 状 态 off </span></span><br><span class="line">  <span class="keyword">this</span>.button = <span class="literal">null</span>; <span class="comment">// 电 灯 开 关 按 钮 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来定义Light.prototype.init方法，该方法负责在页面中创建一个真实的button节点，假设这个button就是电灯的开关按钮，当button的onclick事件被触发时，就是电灯开关被按下的时候，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>),</span><br><span class="line">    self = <span class="keyword">this</span>;</span><br><span class="line">  button.innerHTML = <span class="string">'开 关'</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.buttonWasPressed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当开关被按下时，程序会调用self.buttonWasPressed方法，开关按下之后的所有行为，都将被封装在这个方法里，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Light.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'off'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开 灯'</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'on'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'on'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'关 灯'</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'off'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><p>OK，现在可以看到，我们已经编写了一个强壮的状态机，这个状态机的逻辑既简单又缜密，看起来这段代码设计得无懈可击，这个程序没有任何bug。实际上这种代码我们已经编写过无数遍，比如要交替切换一个button的class，跟此例一样，往往先用一个变量state来记录按钮的当前状态，在事件发生时，再根据这个状态来决定下一步的行为。</p><p>令人遗憾的是，这个世界上的电灯并非只有一种。许多酒店里有另外一种电灯，这种电灯也只有一个开关，但它的表现是：第一次按下打开弱光，第二次按下打开强光，第三次才是关闭电灯。现在必须改造上面的代码来完成这种新型电灯的制造：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Light.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'off'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'弱 光'</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'weakLight'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'weakLight'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'强 光'</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'strongLight'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'strongLight'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'关 灯'</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'off'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>现在这个反例先告一段落，我们来考虑一下上述程序的缺点。</p><ul><li>很明显buttonWasPressed方法是违反开放-封闭原则的，每次新增或者修改light的状态，都需要改动buttonWasPressed方法中的代码，这使得buttonWasPressed成为了一个非常不稳定的方法。</li><li>所有跟状态有关的行为，都被封装在buttonWasPressed方法里，如果以后这个电灯又增加了强强光、超强光和终极强光，那我们将无法预计这个方法将膨胀到什么地步。当然为了简化示例，此处在状态发生改变的时候，只是简单地打印一条log和改变button的innerHTML。在实际开发中，要处理的事情可能比这多得多，也就是说，buttonWasPressed方法要比现在庞大得多。</li><li>状态的切换非常不明显，仅仅表现为对state变量赋值，比如this.state=’weakLight’。在实际开发中，这样的操作很容易被程序员不小心漏掉。我们也没有办法一目了然地明白电灯一共有多少种状态，除非耐心地读完buttonWasPressed方法里的所有代码。当状态的种类多起来的时候，某一次切换的过程就好像被埋藏在一个巨大方法的某个阴暗角落里。</li><li>状态之间的切换关系，不过是往buttonWasPressed方法里堆砌if、else语句，增加或者修改一个状态可能需要改变若干个操作，这使buttonWasPressed更加难以阅读和维护。</li></ul><h5 id="状态模式改进电灯程序"><a href="#状态模式改进电灯程序" class="headerlink" title="状态模式改进电灯程序"></a>状态模式改进电灯程序</h5><p>使用状态模式改进电灯的程序。通常谈到封装，一般都会优先封装对象的行为，而不是对象的状态。但在状态模式中刚好相反，状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部，所以button被按下的的时候，只需要在上下文中，把这个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为，<br><img src="1.png" alt="状态行为"><br>同时我们还可以把状态的切换规则事先分布在状态类中，这样就有效地消除了原本存在的大量条件分支语句:<br><img src="2.png" alt="状态转换"></p><p>下面进入状态模式的代码编写阶段，首先将定义3个状态类，分别是OffLightState、WeakLightState、StrongLightState。这3个类都有一个原型方法buttonWasPressed，代表在各自状态下，按钮被按下时将发生的行为，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OffLightState： </span></span><br><span class="line"><span class="keyword">var</span> OffLightState = <span class="function"><span class="keyword">function</span>(<span class="params">light</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.light = light;</span><br><span class="line">&#125;;</span><br><span class="line">OffLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'弱 光'</span>); <span class="comment">// offLightState 对 应 的 行 为 </span></span><br><span class="line">  <span class="keyword">this</span>.light.setState(<span class="keyword">this</span>.light.weakLightState); <span class="comment">// 切 换 状 态 到 weakLightState </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakLightState： </span></span><br><span class="line"><span class="keyword">var</span> WeakLightState = <span class="function"><span class="keyword">function</span>(<span class="params">light</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.light = light;</span><br><span class="line">&#125;;</span><br><span class="line">WeakLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'强 光'</span>); <span class="comment">// weakLightState 对 应 的 行 为 </span></span><br><span class="line">  <span class="keyword">this</span>.light.setState(<span class="keyword">this</span>.light.strongLightState); <span class="comment">// 切 换 状 态 到 strongLightState </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// StrongLightState： </span></span><br><span class="line"><span class="keyword">var</span> StrongLightState = <span class="function"><span class="keyword">function</span>(<span class="params">light</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.light = light;</span><br><span class="line">&#125;;</span><br><span class="line">StrongLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'关 灯'</span>); <span class="comment">// strongLightState 对 应 的 行 为 </span></span><br><span class="line">  <span class="keyword">this</span>.light.setState(<span class="keyword">this</span>.light.offLightState); <span class="comment">// 切 换 状 态 到 offLightState </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来改写Light类，现在不再使用一个字符串来记录当前的状态，而是使用更加立体化的状态对象。我们在Light类的构造函数里为每个状态类都创建一个状态对象，这样一来我们可以很明显地看到电灯一共有多少种状态，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.offLightState = <span class="keyword">new</span> OffLightState(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.weakLightState = <span class="keyword">new</span> WeakLightState(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.strongLightState = <span class="keyword">new</span> StrongLightState(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在button按钮被按下的事件里，Context也不再直接进行任何实质性的操作，而是通过self.currState.buttonWasPressed()将请求委托给当前持有的状态对象去执行，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>),</span><br><span class="line">    self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">  <span class="keyword">this</span>.button.innerHTML = <span class="string">'开 关'</span>;</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.offLightState; <span class="comment">// 设 置 当 前 状 态 </span></span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.currState.buttonWasPressed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最后还要提供一个Light.prototype.setState方法，状态对象可以通过这个方法来切换light对象的状态。前面已经说过，状态的切换规律事先被完好定义在各个状态类中。在Context中再也找不到任何一个跟状态切换相关的条件分支语句：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Light.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params"> newState </span>)</span>&#123; <span class="keyword">this</span>.currState = newState; &#125;;</span><br></pre></td></tr></table></figure></p><p>测试：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> Light(); </span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><p>不出意外的话，执行结果跟之前的代码一致，但是使用状态模式的好处很明显，它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。</p><p>另外，状态之间的切换都被分布在状态类内部，这使得我们无需编写过多的if、else条件分支语言来控制状态之间的转换。</p><p>当我们需要为light对象增加一种新的状态时，只需要增加一个新的状态类，再稍稍改变一些现有的代码即可。假设现在light对象多了一种超强光的状态，那就先增加SuperStrongLightState类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SuperStrongLightState = <span class="function"><span class="keyword">function</span>(<span class="params">light</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.light = light;</span><br><span class="line">  &#125;;</span><br><span class="line">SuperStrongLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'关 灯'</span>);</span><br><span class="line">  <span class="keyword">this</span>.light.setState(<span class="keyword">this</span>.light.offLightState);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后在Light构造函数里新增一个superStrongLightState对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.offLightState = <span class="keyword">new</span> OffLightState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.weakLightState = <span class="keyword">new</span> WeakLightState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.strongLightState = <span class="keyword">new</span> StrongLightState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.superStrongLightState = <span class="keyword">new</span> SuperStrongLightState(<span class="keyword">this</span>); <span class="comment">// 新 增 superStrongLightState 对 象 </span></span><br><span class="line">    <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>最后改变状态类之间的切换规则，从StrongLightState—-&gt;OffLightState变为StrongLightState—-&gt;SuperStrongLightState—-&gt;OffLightState：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrongLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'超 强 光'</span> ); <span class="comment">// strongLightState 对 应 的 行 为 </span></span><br><span class="line">  <span class="keyword">this</span>.light.setState( <span class="keyword">this</span>.light.superStrongLightState ); <span class="comment">// 切 换 状 态 到 superStrongLightState </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="状态模式的定义"><a href="#状态模式的定义" class="headerlink" title="状态模式的定义"></a>状态模式的定义</h4><p>通过电灯的例子，对于状态模式已经有了一定程度的了解。现在回头来看GoF中对状态模式的定义：</p><blockquote><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p></blockquote><p>以逗号分割，把这句话分为两部分来看。</p><ul><li>第一部分的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。电灯的例子足以说明这一点，在off和on这两种不同的状态下，点击同一个按钮，得到的行为反馈是截然不同的。</li><li>第二部分是从客户的角度来看，使用的对象在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。</li></ul><h4 id="状态模式的通用结构"><a href="#状态模式的通用结构" class="headerlink" title="状态模式的通用结构"></a>状态模式的通用结构</h4><p>在前面的电灯例子中，完成了一个状态模式程序的编写。首先定义了Light类，Light类在这里也被称为上下文（Context）。随后在Light的构造函数中，要创建每一个状态类的实例对象，Context将持有这些状态对象的引用，以便把请求委托给状态对象。用户的请求，即点击button的动作也是实现在Context中的，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.offLightState = <span class="keyword">new</span> OffLightState(<span class="keyword">this</span>); <span class="comment">// 持 有 状 态 对 象 的 引 用 </span></span><br><span class="line">    <span class="keyword">this</span>.weakLightState = <span class="keyword">new</span> WeakLightState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.strongLightState = <span class="keyword">new</span> StrongLightState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.superStrongLightState = <span class="keyword">new</span> SuperStrongLightState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>),</span><br><span class="line">    self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">  <span class="keyword">this</span>.button.innerHTML = <span class="string">'开 关'</span>;</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.offLightState; <span class="comment">// 设 置 默 认 初 始 状 态 </span></span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 定 义 用 户 的 请 求 动 作 </span></span><br><span class="line">    self.currState.buttonWasPressed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来可能是个苦力活，要编写各种状态类，light对象被传入状态类的构造函数，状态对象也需要持有light对象的引用，以便调用light中的方法或者直接操作light对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> OffLightState = <span class="function"><span class="keyword">function</span>(<span class="params"> light </span>)</span>&#123; <span class="keyword">this</span>.light = light; &#125;; </span><br><span class="line"></span><br><span class="line">OffLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'弱 光'</span> ); </span><br><span class="line">  <span class="keyword">this</span>.light.setState( <span class="keyword">this</span>.light.weakLightState ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="缺少抽象类的变通方式"><a href="#缺少抽象类的变通方式" class="headerlink" title="缺少抽象类的变通方式"></a>缺少抽象类的变通方式</h4><p>在状态类中将定义一些共同的行为方法，Context最终会将请求委托给状态对象的这些方法，在这个例子里，这个方法就是buttonWasPressed。无论增加了多少种状态类，它们都必须实现buttonWasPressed方法。</p><p>在Java中，所有的状态类必须继承自一个State抽象父类，当然如果没有共同的功能值得放入抽象父类中，也可以选择实现State接口。这样做的原因一方面是向上转型，另一方面是保证所有的状态子类都实现了buttonWasPressed方法。遗憾的是，JavaScript既不支持抽象类，也没有接口的概念。所以在使用状态模式的时候要格外小心，如果编写一个状态子类时，忘记了给这个状态子类实现buttonWasPressed方法，则会在状态切换的时候抛出异常。因为Context总是把请求委托给状态对象的buttonWasPressed方法。</p><p>不论怎样严格要求程序员，也许都避免不了犯错的那一天，毕竟如果没有编译器的帮助，只依靠程序员的自觉以及一点好运气，是不靠谱的。这里建议的解决方案跟《模板方法模式》中一致，让抽象父类的抽象方法直接抛出一个异常，这个异常至少会在程序运行期间就被发现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> State = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">State.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'父 类 的 buttonWasPressed 方 法 必 须 被 重 写'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> SuperStrongLightState = <span class="function"><span class="keyword">function</span>(<span class="params">light</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.light = light;</span><br><span class="line">  &#125;;</span><br><span class="line">SuperStrongLightState.prototype = <span class="keyword">new</span> State(); <span class="comment">// 继 承 抽 象 父 类 </span></span><br><span class="line">SuperStrongLightState.prototype.buttonWasPressed = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 重 写 buttonWasPressed 方 法 </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'关 灯'</span>);</span><br><span class="line">  <span class="keyword">this</span>.light.setState(<span class="keyword">this</span>.light.offLightState);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="另一个状态模式示例——文件上传"><a href="#另一个状态模式示例——文件上传" class="headerlink" title="另一个状态模式示例——文件上传"></a>另一个状态模式示例——文件上传</h4><p>源自作者的一个项目，微云上传模块，实际上，不论是文件上传，还是音乐、视频播放器，都可以找到一些明显的状态区分。比如文件上传程序中有扫描、正在上传、暂停、上传成功、上传失败这几种状态，音乐播放器可以分为加载中、正在播放、暂停、播放完毕这几种状态。点击同一个按钮，在上传中和暂停状态下的行为表现是不一样的，同时它们的样式class也不同。</p><p>以文件上传为例进行说明。上传中，点击按钮暂停,暂停中，点击按钮继续播放，看到这里，再联系一下电灯的例子和之前对状态模式的了解，已经找了使用状态模式的理由。</p><h5 id="更复杂的切换条件"><a href="#更复杂的切换条件" class="headerlink" title="更复杂的切换条件"></a>更复杂的切换条件</h5><p>相对于电灯的例子，文件上传不同的地方在于，条件切换关系更加复杂。在电灯的例子中，电灯的状态总是从关到开再到关，或者从关到弱光、弱光到强光、强光再到关。看起来总是循规蹈矩的A→B→C→A，所以即使不使用状态模式来编写电灯的程序，而是使用原始的if、else来控制状态切换，我们也不至于在逻辑编写中迷失自己，因为状态的切换总是遵循一些简单的规律，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'off'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开 弱 光'</span>);</span><br><span class="line">  <span class="keyword">this</span>.button.innerHTML = <span class="string">'下 一 次 按 我 是 强 光'</span>;</span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'weakLight'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'weakLight'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开 强 光'</span>);</span><br><span class="line">  <span class="keyword">this</span>.button.innerHTML = <span class="string">'下 一 次 按 我 是 关 灯'</span>;</span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'strongLight'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state === <span class="string">'strongLight'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'关 灯'</span>);</span><br><span class="line">  <span class="keyword">this</span>.button.innerHTML = <span class="string">'下 一 次 按 我 是 弱 光'</span>;</span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'off'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而文件上传的状态切换相比要复杂得多，控制文件上传的流程需要两个节点按钮，第一个用于暂停和继续上传，第二个用于删除文件，</p><p>现在看看文件在不同的状态下，点击这两个按钮将分别发生什么行为。</p><ul><li>文件在扫描状态中，是不能进行任何操作的，既不能暂停也不能删除文件，只能等待扫描完成。扫描完成之后，根据文件的md5值判断，若确认该文件已经存在于服务器，则直接跳到上传完成状态。如果该文件的大小超过允许上传的最大值，或者该文件已经损坏，则跳往上传失败状态。剩下的情况下才进入上传中状态。</li><li>上传过程中可以点击暂停按钮来暂停上传，暂停后点击同一个按钮会继续上传。</li><li>扫描和上传过程中，点击删除按钮无效，只有在暂停、上传完成、上传失败之后，才能删除文件。</li></ul><h5 id="一些准备工作"><a href="#一些准备工作" class="headerlink" title="一些准备工作"></a>一些准备工作</h5><p>有一些浏览器插件帮助完成文件上传。插件类型根据浏览器的不同，有可能是ActiveObject，也有可能是WebkitPlugin。</p><p>上传是一个异步的过程，所以控件会不停地调用JavaScript提供的一个全局函数window.external.upload，来通知JavaScript目前的上传进度，控件会把当前的文件状态作为参数state塞进window.external.upload。可以简单地用setTimeout来模拟文件的上传进度，window.external.upload函数在此例中也只负责打印一些log：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.external.upload = <span class="function"><span class="keyword">function</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(state); <span class="comment">// 可 能 为 sign、 uploading、 done、 error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>另外我们需要在页面中放置一个用于上传的插件对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plugin = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> plugin = <span class="built_in">document</span>.createElement(<span class="string">'embed'</span>);</span><br><span class="line">  plugin.style.display = <span class="string">'none'</span>;</span><br><span class="line">  plugin.type = <span class="string">'application/txftn-webkit'</span>;</span><br><span class="line">  plugin.sign = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开 始 文 件 扫 描'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  plugin.pause = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'暂 停 文 件 上 传'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  plugin.uploading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'开 始 文 件 上 传'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  plugin.del = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'删 除 文 件 上 传'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  plugin.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文 件 上 传 完 成'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(plugin);</span><br><span class="line">  <span class="keyword">return</span> plugin;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h5 id="开始编写代码"><a href="#开始编写代码" class="headerlink" title="开始编写代码"></a>开始编写代码</h5><p>接下来开始完成其他代码，先定义Upload类，控制上传过程的对象将从Upload类中创建而来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.plugin = plugin;</span><br><span class="line">    <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">this</span>.button1 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.button2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'sign'</span>; <span class="comment">// 设 置 初 始 状 态 为 waiting </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Upload.prototype.init方法会进行一些初始化工作，包括创建页面中的一些节点。在这些节点里，起主要作用的是两个用于控制上传流程的按钮，第一个按钮用于暂停和继续上传，第二个用于删除文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="keyword">this</span>.dom.innerHTML = </span><br><span class="line">  <span class="string">'&lt;span&gt; 文 件 名 称:'</span> + <span class="keyword">this</span>.fileName + <span class="string">' &lt;/span&gt;\ </span></span><br><span class="line"><span class="string">  &lt;button data-action="button1"&gt; 扫 描 中 &lt;/button&gt;\</span></span><br><span class="line"><span class="string">  &lt;button data-action="button2"&gt; 删 除 &lt;/button&gt;'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.dom);</span><br><span class="line">  <span class="keyword">this</span>.button1 = <span class="keyword">this</span>.dom.querySelector(<span class="string">'[data-action="button1"]'</span>); <span class="comment">// 第 一 个 按 钮 </span></span><br><span class="line">  <span class="keyword">this</span>.button2 = <span class="keyword">this</span>.dom.querySelector(<span class="string">'[data-action="button2"]'</span>); <span class="comment">// 第 二 个 按 钮 </span></span><br><span class="line">  <span class="keyword">this</span>.bindEvent();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来需要给两个按钮分别绑定点击事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.button1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.state === <span class="string">'sign'</span>) &#123; <span class="comment">// 扫 描 状 态 下， 任 何 操 作 无 效 </span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'扫 描 中， 点 击 无 效...'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.state === <span class="string">'uploading'</span>) &#123; <span class="comment">// 上 传 中， 点 击 切 换 到 暂 停 </span></span><br><span class="line">      self.changeState(<span class="string">'pause'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.state === <span class="string">'pause'</span>) &#123; <span class="comment">// 暂 停 中， 点 击 切 换 到 上 传 中 </span></span><br><span class="line">      self.changeState(<span class="string">'uploading'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.state === <span class="string">'done'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文 件 已 完 成 上 传, 点 击 无 效'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.state === <span class="string">'error'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文 件 上 传 失 败, 点 击 无 效'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.button2.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.state === <span class="string">'done'</span> || self.state === <span class="string">'error'</span> || self.state === <span class="string">'pause'</span>) &#123; <span class="comment">// 上 传 完 成、 上 传 失 败 和 暂 停 状 态 下 可 以 删 除 </span></span><br><span class="line">      self.changeState(<span class="string">'del'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.state === <span class="string">'sign'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文 件 正 在 扫 描 中， 不 能 删 除'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (self.state === <span class="string">'uploading'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'文 件 正 在 上 传 中， 不 能 删 除'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再接下来是Upload.prototype.changeState方法，它负责切换状态之后的具体行为，包括改变按钮的innerHTML，以及调用插件开始一些“真正”的操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.changeState = <span class="function"><span class="keyword">function</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'sign'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.sign();</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'扫 描 中， 任 何 操 作 无 效'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'uploading'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.uploading();</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'正 在 上 传， 点 击 暂 停'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'pause'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.pause();</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'已 暂 停， 点 击 继 续 上 传'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'done'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.done();</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'上 传 完 成'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'error'</span>:</span><br><span class="line">    <span class="keyword">this</span>.button1.innerHTML = <span class="string">'上 传 失 败'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'del'</span>:</span><br><span class="line">    <span class="keyword">this</span>.plugin.del();</span><br><span class="line">    <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'删 除 完 成'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.state = state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最后我们来进行一些测试工作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uploadObj = <span class="keyword">new</span> Upload(<span class="string">'JavaScript 设 计 模 式 与 开 发 实 践'</span>);</span><br><span class="line">uploadObj.init();</span><br><span class="line"><span class="built_in">window</span>.external.upload = <span class="function"><span class="keyword">function</span>(<span class="params">state</span>) </span>&#123; <span class="comment">// 插 件 调 用 JavaScript 的 方 法 </span></span><br><span class="line">  uploadObj.changeState(state);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.external.upload(<span class="string">'sign'</span>); <span class="comment">// 文 件 开 始 扫 描 </span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.external.upload(<span class="string">'uploading'</span>); <span class="comment">// 1 秒 后 开 始 上 传 </span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.external.upload(<span class="string">'done'</span>); <span class="comment">// 5 秒 后 上 传 完 成</span></span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure></p><p>至此就完成了一个简单的文件上传程序的编写。当然这仍然是一个反例，这里的缺点跟电灯例子中的第一段代码一样，程序中充斥着if、else条件分支，状态和行为都被耦合在一个巨大的方法里，我们很难修改和扩展这个状态机。文件状态之间的联系如此复杂，这个问题显得更加严重了。</p><h5 id="状态模式重构文件上传程序"><a href="#状态模式重构文件上传程序" class="headerlink" title="状态模式重构文件上传程序"></a>状态模式重构文件上传程序</h5><p>状态模式在文件上传的程序中，是最优雅的解决办法之一。</p><p>通过电灯的例子，已经熟知状态模式的结构了，下面就开始一步步地重构它。</p><p>第一步仍然是提供window.external.upload函数，在页面中模拟创建上传插件，这部分代码没有改变。</p><p>第二步，改造Upload构造函数，在构造函数中为每种状态子类都创建一个实例对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.plugin = plugin;</span><br><span class="line">    <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">this</span>.button1 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.button2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.signState = <span class="keyword">new</span> SignState(<span class="keyword">this</span>); <span class="comment">// 设 置 初 始 状 态 为 waiting </span></span><br><span class="line">    <span class="keyword">this</span>.uploadingState = <span class="keyword">new</span> UploadingState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.pauseState = <span class="keyword">new</span> PauseState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.doneState = <span class="keyword">new</span> DoneState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.errorState = <span class="keyword">new</span> ErrorState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.currState = <span class="keyword">this</span>.signState; <span class="comment">// 设 置 当 前 状 态</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>第三步，Upload.prototype.init方法无需改变，仍然负责往页面中创建跟上传流程有关的DOM节点，并开始绑定按钮的事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="keyword">this</span>.dom.innerHTML = </span><br><span class="line">  <span class="string">'&lt;span&gt; 文 件 名 称:'</span> + <span class="keyword">this</span>.fileName + <span class="string">' &lt;/span&gt;\ </span></span><br><span class="line"><span class="string">  &lt;button data-action="button1"&gt; 扫 描 中 &lt;/button&gt;\ </span></span><br><span class="line"><span class="string">  &lt;button data-action="button2"&gt; 删 除 &lt;/button&gt;'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.dom);</span><br><span class="line">  <span class="keyword">this</span>.button1 = <span class="keyword">this</span>.dom.querySelector(<span class="string">'[data-action="button1"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.button2 = <span class="keyword">this</span>.dom.querySelector(<span class="string">'[data-action="button2"]'</span>);</span><br><span class="line">  <span class="keyword">this</span>.bindEvent();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>第四步，负责具体的按钮事件实现，在点击了按钮之后，Context并不做任何具体的操作，而是把请求委托给当前的状态类来执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.bindEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.button1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.currState.clickHandler1();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.button2.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.currState.clickHandler2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>第四步中的代码有一些变化，把状态对应的逻辑行为放在Upload类中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.sign = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.plugin.sign();</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.signState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.uploading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.button1.innerHTML = <span class="string">'正 在 上 传， 点 击 暂 停'</span>;</span><br><span class="line">  <span class="keyword">this</span>.plugin.uploading();</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.uploadingState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.pause = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.button1.innerHTML = <span class="string">'已 暂 停， 点 击 继 续 上 传'</span>;</span><br><span class="line">  <span class="keyword">this</span>.plugin.pause();</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.pauseState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.button1.innerHTML = <span class="string">'上 传 完 成'</span>;</span><br><span class="line">  <span class="keyword">this</span>.plugin.done();</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.doneState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.error = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.button1.innerHTML = <span class="string">'上 传 失 败'</span>;</span><br><span class="line">  <span class="keyword">this</span>.currState = <span class="keyword">this</span>.errorState;</span><br><span class="line">&#125;;</span><br><span class="line">Upload.prototype.del = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.plugin.del();</span><br><span class="line">  <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>第五步，工作略显乏味，编写各个状态类的实现。值得注意的是，我们使用了StateFactory，从而避免因为JavaScript中没有抽象类所带来的问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> StateFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> State = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  State.prototype.clickHandler1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子 类 必 须 重 写 父 类 的 clickHandler1 方 法'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  State.prototype.clickHandler2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子 类 必 须 重 写 父 类 的 clickHandler2 方 法'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params">uploadObj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uploadObj = uploadObj;</span><br><span class="line">      &#125;;</span><br><span class="line">    F.prototype = <span class="keyword">new</span> State();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> param) &#123;</span><br><span class="line">      F.prototype[i] = param[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> SignState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'扫 描 中， 点 击 无 效...'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文 件 正 在 上 传 中， 不 能 删 除'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> UploadingState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadObj.pause();</span><br><span class="line">  &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文 件 正 在 上 传 中， 不 能 删 除'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> PauseState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadObj.uploading();</span><br><span class="line">  &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadObj.del();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> DoneState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文 件 已 完 成 上 传, 点 击 无 效'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadObj.del();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> ErrorState = StateFactory(&#123;</span><br><span class="line">  clickHandler1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文 件 上 传 失 败, 点 击 无 效'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  clickHandler2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadObj.del();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="状态模式的优缺点"><a href="#状态模式的优缺点" class="headerlink" title="状态模式的优缺点"></a>状态模式的优缺点</h4><p>通过两个状态模式的例子，总结状态模式的优缺点。状态模式的优点如下</p><ul><li>状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。</li><li>避免Context无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了Context中原本过多的条件分支。</li><li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。</li><li>Context中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。</li></ul><p>状态模式的缺点是会在系统中定义许多状态类，编写20个状态类是一项枯燥乏味的工作，而且系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。</p><h4 id="状态模式中的性能优化点"><a href="#状态模式中的性能优化点" class="headerlink" title="状态模式中的性能优化点"></a>状态模式中的性能优化点</h4><p>在这两个例子中，我们并没有太多地从性能方面考虑问题，实际上，这里有一些比较大的优化点。</p><ul><li>有两种选择来管理state对象的创建和销毁。第一种是仅当state对象被需要时才创建并随后销毁，另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。如果state对象比较庞大，可以用第一种方式来节省内存，这样可以避免创建一些不会用到的对象并及时地回收它们。但如果状态的改变很频繁，最好一开始就把这些state对象都创建出来，也没有必要销毁它们，因为可能很快将再次用到它们。</li><li>在例子中为每个Context对象都创建了一组state对象，实际上这些state对象之间是可以共享的，各Context对象可以共享一个state对象，这也是享元模式的应用场景之一。</li></ul><h4 id="状态模式和策略模式的关系"><a href="#状态模式和策略模式的关系" class="headerlink" title="状态模式和策略模式的关系"></a>状态模式和策略模式的关系</h4><p>状态模式和策略模式像一对双胞胎，它们都封装了一系列的算法或者行为，它们的类图看起来几乎一模一样，但在意图上有很大不同，因此它们是两种迥然不同的模式。</p><p>策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。</p><p>它们之间的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。</p><h4 id="JavaScript版本的状态机"><a href="#JavaScript版本的状态机" class="headerlink" title="JavaScript版本的状态机"></a>JavaScript版本的状态机</h4><p>前面两个示例都是模拟传统面向对象语言的状态模式实现，我们为每种状态都定义一个状态子类，然后在Context中持有这些状态对象的引用，以便把currState设置为当前的状态对象。</p><p>状态模式是状态机的实现之一，但在JavaScript这种“无类”语言中，没有规定让状态对象一定要从类中创建而来。另外一点，JavaScript可以非常方便地使用委托技术，并不需要事先让一个对象持有另一个对象。下面的状态机选择了通过Function.prototype.call方法直接把请求委托给某个字面量对象来执行。</p><p>改写电灯的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FSM = &#123;</span><br><span class="line">  off: &#123;</span><br><span class="line">    buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'关 灯'</span>);</span><br><span class="line">      <span class="keyword">this</span>.button.innerHTML = <span class="string">'下 一 次 按 我 是 开 灯'</span>;</span><br><span class="line">      <span class="keyword">this</span>.currState = FSM.on;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  on: &#123;</span><br><span class="line">    buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'开 灯'</span>);</span><br><span class="line">      <span class="keyword">this</span>.button.innerHTML = <span class="string">'下 一 次 按 我 是 关 灯'</span>;</span><br><span class="line">      <span class="keyword">this</span>.currState = FSM.off;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.currState = FSM.off; <span class="comment">// 设 置 当 前 状 态</span></span><br><span class="line">  <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>),</span><br><span class="line">    self = <span class="keyword">this</span>;</span><br><span class="line">  button.innerHTML = <span class="string">'已 关 灯'</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.currState.buttonWasPressed.call(self); <span class="comment">// 把 请 求 委 托 给 FSM 状 态 机 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><p>接下来尝试另外一种方法，利用下面的delegate函数完成状态机。这是面向对象设计和闭包互换的一个例子，前者把变量保存为对象的属性，而后者把变量封闭在闭包形成的环境中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate = <span class="function"><span class="keyword">function</span>(<span class="params">client, delegation</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 将 客 户 的 操 作 委 托 给 delegation 对 象 </span></span><br><span class="line">      <span class="keyword">return</span> delegation.buttonWasPressed.apply(client, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.offState = delegate(<span class="keyword">this</span>, FSM.off);</span><br><span class="line">    <span class="keyword">this</span>.onState = delegate(<span class="keyword">this</span>, FSM.on);</span><br><span class="line">    <span class="keyword">this</span>.currState = <span class="keyword">this</span>.offState; <span class="comment">// 设 置 初 始 状 态 为 关 闭 状 态 </span></span><br><span class="line">    <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>),</span><br><span class="line">    self = <span class="keyword">this</span>;</span><br><span class="line">  button.innerHTML = <span class="string">'已 关 灯'</span>;</span><br><span class="line">  <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">  <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.currState.buttonWasPressed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="表驱动的有限状态机"><a href="#表驱动的有限状态机" class="headerlink" title="表驱动的有限状态机"></a>表驱动的有限状态机</h4><p>其实还有另外一种实现状态机的方法，这种方法的核心是基于表驱动的。我们可以在表中很清楚地看到下一个状态是由当前状态和行为共同决定的。这样一来，我们就可以在表中查找状态，而不必定义很多条件分支，刚好GitHub上有一个对应的库实现，通过这个库，可以很方便地创建出FSM：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fsm = StateMachine.create(&#123;</span><br><span class="line">  initial: <span class="string">'off'</span>,</span><br><span class="line">  events: [&#123;</span><br><span class="line">    name: <span class="string">'buttonWasPressed'</span>,</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">'off'</span>,</span><br><span class="line">    to: <span class="string">'on'</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: <span class="string">'buttonWasPressed'</span>,</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">'on'</span>,</span><br><span class="line">    to: <span class="string">'off'</span></span><br><span class="line">  &#125;],</span><br><span class="line">  callbacks: &#123;</span><br><span class="line">    onbuttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params">event, from, to</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, from, to, args, errorCode, errorMessage</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// 从 一 种 状 态 试 图 切 换 到 一 种 不 可 能 到 达 的 状 态 的 时 候</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fsm.buttonWasPressed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于这个库：<a href="https://github.com/jakesgordon/javascript-state-machine">javascript-state-machine</a></p><h4 id="实际项目中的其他状态机"><a href="#实际项目中的其他状态机" class="headerlink" title="实际项目中的其他状态机"></a>实际项目中的其他状态机</h4><p>在实际开发中，很多场景都可以用状态机来模拟，比如一个下拉菜单在hover动作下有显示、悬浮、隐藏等状态；一次TCP请求有建立连接、监听、关闭等状态；一个格斗游戏中人物有攻击、防御、跳跃、跌倒等状态。</p><p>状态机在游戏开发中也有着广泛的用途，特别是游戏AI的逻辑编写。在作者曾经开发的HTML5版街头霸王游戏里，游戏主角Ryu有走动、攻击、防御、跌倒、跳跃等多种状态。这些状态之间既互相联系又互相约束。比如Ryu在走动的过程中如果被攻击，就会由走动状态切换为跌倒状态。在跌倒状态下，Ryu既不能攻击也不能防御。同样，Ryu也不能在跳跃的过程中切换到防御状态，但是可以进行攻击。这种场景就很适合用状态机来描述。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FSM = &#123;</span><br><span class="line">  walk: &#123;</span><br><span class="line">    attack: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'攻 击'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    defense: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'防 御'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    jump: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'跳 跃'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  attack: &#123;</span><br><span class="line">    walk: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'攻 击 的 时 候 不 能 行 走'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    defense: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'攻 击 的 时 候 不 能 防 御'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    jump: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'攻 击 的 时 候 不 能 跳 跃'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过几个例子，讲解了状态模式在实际开发中的应用。状态模式也许是被大家低估的模式之一。实际上，通过状态模式重构代码之后，很多杂乱无章的代码会变得清晰。虽然状态模式一开始并不是非常容易理解，但我们有必须去好好掌握这种设计模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;状态模式是一种非同寻常的优秀模式，它也许是解决某些需求场景的最好方法。虽然状态模式并不是一种简单到一目了然的模式（它往往还会带来代码量的增加），但你一旦明白了状态模式的精髓，以后一定会感谢它带给你的无与伦比的好处。&lt;/p&gt;
&lt;p&gt;状态模式的关键是区分事物内部的状态，事物内部
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-14-装饰器模式</title>
    <link href="https://github.com/xmoyKING/2017/12/02/js-pattern14/"/>
    <id>https://github.com/xmoyKING/2017/12/02/js-pattern14/</id>
    <published>2017-12-02T00:39:08.000Z</published>
    <updated>2017-12-06T14:50:09.321Z</updated>
    
    <content type="html"><![CDATA[<p>在程序开发中，许多时候都并不希望某个类天生就非常庞大，一次性包含许多职责。那么我们就可以使用装饰者模式。装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。</p><p>在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活，还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；另一方面，继承这种功能复用方式通常被称为“白箱复用”，“白箱”是相对可见性而言的，在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。</p><p>使用继承还会带来另外一个问题，在完成一些功能复用的同时，有可能创建出大量的子类，使子类的数量呈爆炸性增长。比如现在有4种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这3种配件。如果使用继承的方式来给每种自行车创建子类，则需要4×3=12个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3个类。</p><p>这种给对象动态地增加职责的方式称为装饰者（decorator）模式。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式，比如天冷了就多穿一件外套，需要飞行时就在头上插一支竹蜻蜓，遇到一堆食尸鬼时就点开AOE（范围攻击）技能。</p><h4 id="模拟传统面向对象语言的装饰者模式"><a href="#模拟传统面向对象语言的装饰者模式" class="headerlink" title="模拟传统面向对象语言的装饰者模式"></a>模拟传统面向对象语言的装饰者模式</h4><p>首先要提出来的是，作为一门解释执行的语言，给JavaScript中的对象动态添加或者改变职责是一件再简单不过的事情，虽然这种做法改动了对象自身，跟传统定义中的装饰者模式并不一样，但这无疑更符合JavaScript的语言特色。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'sven'</span>, <span class="attr">address</span>: <span class="string">'深 圳 市'</span> &#125;; </span><br><span class="line">obj.address = obj.address + <span class="string">'福 田 区'</span>;</span><br></pre></td></tr></table></figure></p><p>传统面向对象语言中的装饰者模式在JavaScript中适用的场景并不多，如上面代码所示，通常我们并不太介意改动对象自身。尽管如此，还是稍微模拟一下传统面向对象语言中的装饰者模式实现。</p><p>假设我们在编写一个飞机大战的游戏，随着经验值的增加，我们操作的飞机对象可以升级成更厉害的飞机，一开始这些飞机只能发射普通的子弹，升到第二级时可以发射导弹，升到第三级时可以发射原子弹。</p><p>下面来看代码实现，首先是原始的飞机类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Plane = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">Plane.prototype.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'发 射 普 通 子 弹'</span> ); &#125;</span><br></pre></td></tr></table></figure></p><p>接下来增加两个装饰类，分别是导弹和原子弹：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MissileDecorator = <span class="function"><span class="keyword">function</span>(<span class="params"> plane </span>)</span>&#123; <span class="keyword">this</span>.plane = plane; &#125;</span><br><span class="line">MissileDecorator.prototype.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.plane.fire();</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'发 射 导 弹'</span> ); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AtomDecorator = <span class="function"><span class="keyword">function</span>(<span class="params"> plane </span>)</span>&#123; <span class="keyword">this</span>.plane = plane; &#125;</span><br><span class="line">AtomDecorator.prototype.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.plane.fire(); </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'发 射 原 子 弹'</span> ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>导弹类和原子弹类的构造函数都接受参数plane对象，并且保存好这个参数，在它们的fire方法中，除了执行自身的操作之外，还调用plane对象的fire方法。</p><p>这种给对象动态增加职责的方式，并没有真正地改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口（fire方法），当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。</p><p>因为装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是透明的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得我们可以递归地嵌套任意多个装饰者对象.<br><img src="1.png" alt="嵌套多个装饰者对象"></p><p>测试：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane(); </span><br><span class="line">plane = <span class="keyword">new</span> MissileDecorator( plane ); </span><br><span class="line">plane = <span class="keyword">new</span> AtomDecorator( plane ); </span><br><span class="line"></span><br><span class="line">plane.fire(); <span class="comment">// 分 别 输 出： 发 射 普 通 子 弹、 发 射 导 弹、 发 射 原 子 弹</span></span><br></pre></td></tr></table></figure></p><p><img src="2.png" alt="嵌套多个装饰者对象输出"></p><h4 id="装饰者也是包装器"><a href="#装饰者也是包装器" class="headerlink" title="装饰者也是包装器"></a>装饰者也是包装器</h4><p>在《设计模式》成书之前，GoF原想把装饰者（decorator）模式称为包装器（wrapper）模式。从功能上而言，decorator能很好地描述这个模式，但从结构上看，wrapper的说法更加贴切。装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。请求随着这条链依次传递到所有的对象，每个对象都有处理这条请求的机会。</p><h4 id="回到JavaScript的装饰者"><a href="#回到JavaScript的装饰者" class="headerlink" title="回到JavaScript的装饰者"></a>回到JavaScript的装饰者</h4><p>JavaScript语言动态改变对象相当容易，我们可以直接改写对象或者对象的某个方法，并不需要使用“类”来实现装饰者模式，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plane = &#123; <span class="attr">fire</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'发 射 普 通 子 弹'</span> ); &#125; &#125; </span><br><span class="line"><span class="keyword">var</span> missileDecorator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'发 射 导 弹'</span> ); &#125; </span><br><span class="line"><span class="keyword">var</span> atomDecorator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'发 射 原 子 弹'</span> ); &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fire1 = plane.fire; </span><br><span class="line">plane.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; fire1(); missileDecorator(); &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fire2 = plane.fire; </span><br><span class="line">plane.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; fire2(); atomDecorator(); &#125; </span><br><span class="line"></span><br><span class="line">plane.fire(); <span class="comment">// 分 别 输 出： 发 射 普 通 子 弹、 发 射 导 弹、 发 射 原 子 弹</span></span><br></pre></td></tr></table></figure></p><h4 id="装饰函数"><a href="#装饰函数" class="headerlink" title="装饰函数"></a>装饰函数</h4><p>在JavaScript中，几乎一切都是对象，其中函数又被称为一等对象。在平时的开发工作中，也许大部分时间都在和函数打交道。在JavaScript中可以很方便地给某个对象扩展属性和方法，但却很难在不改动某个函数源代码的情况下，给该函数添加一些额外的功能。在代码的运行期间，我们很难切入某个函数的执行环境。</p><p>要想为函数添加一些功能，最简单粗暴的方式就是直接改写该函数，但这是最差的办法，直接违反了开放-封闭原则：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert (<span class="number">1</span>); &#125; </span><br><span class="line"><span class="comment">// 改 成： </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert (<span class="number">1</span>); alert (<span class="number">2</span>); &#125;</span><br></pre></td></tr></table></figure></p><p>很多时候我们不想去碰原函数，也许原函数是由其他同事编写的，里面的实现非常杂乱。现在需要一个办法，在不改变函数源代码的情况下，能给函数增加功能，这正是开放-封闭原则。</p><p>其实通过保存原引用的方式就可以改写某个函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _a = a; </span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; _a(); alert (<span class="number">2</span>); &#125; </span><br><span class="line">a();</span><br></pre></td></tr></table></figure></p><p>这是实际开发中很常见的一种做法，比如我们想给window绑定onload事件，但是又不确定这个事件是不是已经被其他人绑定过，为了避免覆盖掉之前的window.onload函数中的行为，我们一般都会先保存好原先的window.onload，把它放入新的window.onload里执行.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert (<span class="number">1</span>); &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _onload = <span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; _onload(); alert (<span class="number">2</span>); &#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码当然是符合开放-封闭原则的，我们在增加新功能的时候，确实没有修改原来的window.onload代码，但是这种方式存在以下两个问题。</p><ul><li>必须维护_onload这个中间变量，虽然看起来并不起眼，但如果函数的装饰链较长，或者需要装饰的函数变多，这些中间变量的数量也会越来越多。</li><li>其实还遇到了this被劫持的问题，在window.onload的例子中没有这个烦恼，是因为调用普通函数_onload时，this也指向window，跟调用window.onload时一样（函数作为对象的方法被调用时，this指向该对象，所以此处this也只指向window）。现在把window.onload换成document.getElementById，代码如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _getElementById = <span class="built_in">document</span>.getElementById; 　 　 </span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>)</span>&#123; </span><br><span class="line">  alert (<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">return</span> _getElementById( id ); <span class="comment">// (1) </span></span><br><span class="line">&#125; 　 　 </span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> );</span><br></pre></td></tr></table></figure></li></ul><p>执行这段代码，我们看到在弹出alert(1)之后，紧接着控制台抛出了异常.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">TypeError</span>: Illegal invocation</span><br></pre></td></tr></table></figure></p><p>异常发生在(1)处的_getElementById(id)这句代码上，此时_getElementById是一个全局函数，当调用一个全局函数时，this是指向window的，而document.getElementById方法的内部实现需要使用this引用，this在这个方法内预期是指向document，而不是window,这是错误发生的原因，所以使用现在的方式给函数增加功能并不保险。</p><p>改进后的代码可以满足需求，我们要手动把document当作上下文this传入_getElementById：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert (<span class="number">1</span>); </span><br><span class="line">  <span class="keyword">return</span> _getElementById.apply( <span class="built_in">document</span>, <span class="built_in">arguments</span> ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但这样做显然很不方便，引入AOP来提供一种完美的方法给函数动态增加功能。</p><h4 id="用AOP装饰函数"><a href="#用AOP装饰函数" class="headerlink" title="用AOP装饰函数"></a>用AOP装饰函数</h4><p>首先给出Function.prototype.before方法和Function.prototype.after方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>; <span class="comment">// 保 存 原 函 数 的 引 用 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 返 回 包 含 了 原 函 数 和 新 函 数 的" 代 理" 函 数 </span></span><br><span class="line">    beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执 行 新 函 数， 且 保 证 this 不 被 劫 持， 新 函 数 接 受 的 参 数 </span></span><br><span class="line">    <span class="comment">// 也 会 被 原 封 不 动 地 传 入 原 函 数， 新 函 数 在 原 函 数 之 前 执 行 </span></span><br><span class="line">    <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执 行 原 函 数 并 返 回 原 函 数 的 执 行 结 果， </span></span><br><span class="line">    <span class="comment">// 并 且 保 证 this 不 被 劫 持 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Function.prototype.before接受一个函数当作参数，这个函数即为新添加的函数，它装载了新添加的功能代码。</p><p>接下来把当前的this保存起来，这个this指向原函数，然后返回一个“代理”函数，这个“代理”函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原函数之前执行（前置装饰），这样就实现了动态装饰的效果。</p><p>我们注意到，通过Function.prototype.apply来动态传入正确的this，保证了函数在被装饰之后，this不会被劫持。</p><p>Function.prototype.after的原理跟Function.prototype.before一模一样，唯一不同的地方在于让新添加的函数在原函数执行之后再执行。下面来试试用Function.prototype.before的威力：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="built_in">document</span>.getElementById.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(button);</span><br></pre></td></tr></table></figure></p><p>回到window.onload的例子，看看用Function.prototype.after来增加新的window.onload事件是多么简单：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = (<span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">2</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">3</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>值得提到的是，上面的AOP实现是在Function.prototype上添加before和after方法，但许多人不喜欢这种污染原型的方式，那么我们可以做一些变通，把原函数和新函数都作为参数传入before或者after方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> before = <span class="function"><span class="keyword">function</span>(<span class="params">fn, beforefn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> a = before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">3</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">2</span>)</span><br><span class="line">&#125;);</span><br><span class="line">a = before(a, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">a();</span><br></pre></td></tr></table></figure></p><h4 id="AOP的应用实例"><a href="#AOP的应用实例" class="headerlink" title="AOP的应用实例"></a>AOP的应用实例</h4><p>用AOP装饰函数的技巧在实际开发中非常有用。不论是业务代码的编写，还是在框架层面，我们都可以把行为依照职责分成粒度更细的函数，随后通过装饰把它们合并到一起，这有助于我们编写一个松耦合和高复用性的系统。</p><h5 id="数据统计上报"><a href="#数据统计上报" class="headerlink" title="数据统计上报"></a>数据统计上报</h5><p>分离业务代码和数据统计代码，无论在什么语言中，都是AOP的经典应用之一。在项目开发的结尾阶段难免要加上很多统计数据的代码，这些过程可能让我们被迫改动早已封装好的函数。</p><p>比如页面中有一个登录button，点击这个button会弹出登录浮层，与此同时要进行数据上报，来统计有多少用户点击了这个登录button：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打 开 登 录 浮 层'</span>);</span><br><span class="line">    log(<span class="keyword">this</span>.getAttribute(<span class="string">'tag'</span>));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'上 报 标 签 为: '</span> + tag);</span><br><span class="line">    <span class="comment">//(newImage).src='http://xxx.com/report?tag='+tag;</span></span><br><span class="line">    <span class="comment">//真正的上报代码略</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = showLogin;</span><br></pre></td></tr></table></figure></p><p>在showLogin函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面的功能，在此处却被耦合在一个函数里。使用AOP分离之后，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打 开 登 录 浮 层'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'上 报 标 签 为: '</span> + <span class="keyword">this</span>.getAttribute(<span class="string">'tag'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">showLogin = showLogin.after(log); <span class="comment">// 打 开 登 录 浮 层 之 后 上 报 数 据 </span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = showLogin;</span><br></pre></td></tr></table></figure></p><h5 id="用AOP动态改变函数的参数"><a href="#用AOP动态改变函数的参数" class="headerlink" title="用AOP动态改变函数的参数"></a>用AOP动态改变函数的参数</h5><p>观察Function.prototype.before方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// (1) </span></span><br><span class="line">    <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// (2) </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这段代码的(1)处和(2)处可以看到，beforefn和原函数<code>__self</code>共用一组参数列表arguments，当我们在beforefn的函数体内改变arguments的时候，原函数<code>__self</code>接收的参数列表自然也会变化。下面的例子展示了如何通过Function.prototype.before方法给函数func的参数param动态地添加属性b：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"> param </span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( param ); <span class="comment">// 输 出： &#123;a: "a", b: "b"&#125; </span></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">func = func.before( <span class="function"><span class="keyword">function</span>(<span class="params"> param </span>)</span>&#123; param.b = <span class="string">'b'</span>; &#125;); </span><br><span class="line">func( &#123;<span class="attr">a</span>: <span class="string">'a'</span>&#125; );</span><br></pre></td></tr></table></figure></p><p>现在有一个用于发起ajax请求的函数，这个函数负责项目中所有的ajax异步请求：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params"> type, url, param </span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.dir( param); <span class="comment">// 发 送 ajax 请 求 的 代 码 略 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">ajax( <span class="string">'get'</span>, <span class="string">'http://xxx.com/userinfo'</span>, &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125; );</span><br></pre></td></tr></table></figure></p><p>上面的伪代码表示向后台cgi发起一个请求来获取用户信息，传递给cgi的参数是{name:’sven’}。ajax函数在项目中一直运转良好，跟cgi的合作也很愉快。直到有一天，网站遭受了CSRF攻击。解决CSRF攻击最简单的一个办法就是在HTTP请求中带上一个Token参数。</p><p>假设我们已经有一个用于生成Token的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getToken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">'Token'</span>; &#125;</span><br></pre></td></tr></table></figure></p><p>现在的任务是给每个ajax请求都加上Token参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params"> type, url, param </span>)</span>&#123; </span><br><span class="line">  param = param || &#123;&#125;; </span><br><span class="line">  Param.Token = getToken(); <span class="comment">// 发 送 ajax 请 求 的 代 码 略... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>虽然已经解决了问题，但我们的ajax函数相对变得僵硬了，每个从ajax函数里发出的请求都自动带上了Token参数，虽然在现在的项目中没有什么问题，但如果将来把这个函数移植到其他项目上，或者把它放到一个开源库中供其他人使用，Token参数都将是多余的。</p><p>也许另一个项目不需要验证Token，或者是Token的生成方式不同，无论是哪种情况，都必须重新修改ajax函数。</p><p>为了解决这个问题，先把ajax函数还原成一个干净的函数,然后把Token参数通过Function.prototyte.before装饰到ajax函数的参数param对象中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params"> type, url, param </span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.dir( param); <span class="comment">// 发 送 ajax 请 求 的 代 码 略 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getToken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">ajax = ajax.before(<span class="function"><span class="keyword">function</span>(<span class="params">type, url, param</span>) </span>&#123;</span><br><span class="line">  param.Token = getToken();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'http://xxx.com/userinfo'</span>, &#123;</span><br><span class="line">  name: <span class="string">'sven'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>明显可以看到，用AOP的方式给ajax函数动态装饰上Token参数，保证了ajax函数是一个相对纯净的函数，提高了ajax函数的可复用性，它在被迁往其他项目的时候，不需要做任何修改。</p><h5 id="插件式的表单验证"><a href="#插件式的表单验证" class="headerlink" title="插件式的表单验证"></a>插件式的表单验证</h5><p>我们很多人都写过许多表单验证的代码，在一个Web项目中，可能存在非常多的表单，如注册、登录、修改用户信息等。在表单数据提交给后台之前，常常要做一些校验，比如登录的时候需要验证用户名和密码是否为空，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>),</span><br><span class="line">  password = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>),</span><br><span class="line">  submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">'submitBtn'</span>);</span><br><span class="line"><span class="keyword">var</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (username.value === <span class="string">''</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> alert(<span class="string">'用 户 名 不 能 为 空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password.value === <span class="string">''</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> alert(<span class="string">'密 码 不 能 为 空'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> param = &#123;</span><br><span class="line">      username: username.value,</span><br><span class="line">      password: password.value</span><br><span class="line">    &#125;</span><br><span class="line">    ajax(<span class="string">'http:// xxx.com/ login'</span>, param); <span class="comment">// ajax 具 体 实 现 略 </span></span><br><span class="line">  &#125;</span><br><span class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  formSubmit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>formSubmit函数在此处承担了两个职责，除了提交ajax请求之外，还要验证用户输入的合法性。这种代码一来会造成函数臃肿，职责混乱，二来谈不上任何可复用性。</p><p>目的是分离校验输入和提交ajax请求的代码，我们把校验输入的逻辑放到validata函数中，并且约定当validata函数返回false的时候，表示校验未通过，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> validata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (username.value === <span class="string">''</span>) &#123;</span><br><span class="line">      alert(<span class="string">'用 户 名 不 能 为 空'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password.value === <span class="string">''</span>) &#123;</span><br><span class="line">      alert(<span class="string">'密 码 不 能 为 空'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (validata() === <span class="literal">false</span>) &#123; <span class="comment">// 校 验 未 通 过</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> param = &#123;</span><br><span class="line">      username: username.value,</span><br><span class="line">      password: password.value</span><br><span class="line">    &#125;</span><br><span class="line">    ajax(<span class="string">'http:// xxx.com/ login'</span>, param);</span><br><span class="line">  &#125;</span><br><span class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  formSubmit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在的代码已经有了一些改进，我们把校验的逻辑都放到了validata函数中，但formSubmit函数的内部还要计算validata函数的返回值，因为返回值的结果表明了是否通过校验。</p><p>接下来进一步优化这段代码，使validata和formSubmit完全分离开来。首先要改写Function.prototype.before，如果beforefn的执行结果返回false，表示不再执行后面的原函数，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) === <span class="literal">false</span>) &#123; <span class="comment">// beforefn 返 回 false 的 情 况 直 接 return， 不 再 执 行 后 面 的 原 函 数</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> validata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (username.value === <span class="string">''</span>) &#123;</span><br><span class="line">      alert(<span class="string">'用 户 名 不 能 为 空'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password.value === <span class="string">''</span>) &#123;</span><br><span class="line">      alert(<span class="string">'密 码 不 能 为 空'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> param = &#123;</span><br><span class="line">      username: username.value,</span><br><span class="line">      password: password.value</span><br><span class="line">    &#125;</span><br><span class="line">    ajax(<span class="string">'http:// xxx.com/ login'</span>, param);</span><br><span class="line">  &#125;</span><br><span class="line">formSubmit = formSubmit.before(validata);</span><br><span class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  formSubmit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这段代码中，校验输入和提交表单的代码完全分离开来，它们不再有任何耦合关系，formSubmit=formSubmit.before(validata)这句代码，如同把校验规则动态接在formSubmit函数之前，validata成为一个即插即用的函数，它甚至可以被写成配置文件的形式，这有利于我们分开维护这两个函数。再利用策略模式稍加改造，我们就可以把这些校验规则都写成插件的形式，用在不同的项目当中。</p><p>注意，因为函数通过Function.prototype.before或者Function.prototype.after被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert( <span class="number">1</span> ); &#125; </span><br><span class="line">func.a = <span class="string">'a'</span>; </span><br><span class="line">func = func.after( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert( <span class="number">2</span> ); &#125;); </span><br><span class="line">alert ( func.a ); <span class="comment">// 输 出： undefined</span></span><br></pre></td></tr></table></figure></p><p>另外，这种装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一些影响。</p><h4 id="装饰者模式和代理模式"><a href="#装饰者模式和代理模式" class="headerlink" title="装饰者模式和代理模式"></a>装饰者模式和代理模式</h4><p>装饰者模式和代理模式的结构看起来非常相像，这两种模式都描述了怎样为对象提供一定程度上的间接引用，它们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。</p><p>代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy与它的实体之间的关系），这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链。</p><p>在虚拟代理实现图片预加载的例子中，本体负责设置img节点的src，代理则提供了预加载的功能，这看起来也是“加入行为”的一种方式，但这种加入行为的方式和装饰者模式的偏重点是不一样的。装饰者模式是实实在在的为对象增加新的职责和行为，而代理做的事情还是跟本体一样，最终都是设置src。但代理可以加入一些“聪明”的功能，比如在图片真正加载好之前，先使用一张占位的loading图片反馈给客户。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过数据上报、统计函数的执行时间、动态改变函数参数以及插件式的表单验证这4个例子，了解了装饰函数，它是JavaScript中独特的装饰者模式。这种模式在实际开发中非常有用，除了上面提到的例子，它在框架开发中也十分有用。作为框架作者，希望框架里的函数提供的是一些稳定而方便移植的功能，那些个性化的功能可以在框架之外动态装饰上去，这可以避免为了让框架拥有更多的功能，而去使用一些if、else语句预测用户的实际需要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在程序开发中，许多时候都并不希望某个类天生就非常庞大，一次性包含许多职责。那么我们就可以使用装饰者模式。装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。&lt;/p&gt;
&lt;p&gt;在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-13-中介者模式</title>
    <link href="https://github.com/xmoyKING/2017/11/30/js-pattern13/"/>
    <id>https://github.com/xmoyKING/2017/11/30/js-pattern13/</id>
    <published>2017-11-30T08:50:39.000Z</published>
    <updated>2017-12-06T14:50:09.306Z</updated>
    
    <content type="html"><![CDATA[<p>在我们生活的世界中，每个人每个物体之间都会产生一些错综复杂的联系。在应用程序里也是一样，程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。</p><p>平时我们大概能记住10个朋友的电话、30家餐馆的位置。在程序里，也许一个对象会和其他10个对象打交道，所以它会保持10个对象的引用。当程序的规模增大，对象会越来越多，它们之间的关系也越来越复杂，难免会形成网状的交叉引用。当我们改变或删除其中一个对象的时候，很可能需要通知所有引用到它的对象。这样一来，就像在心脏旁边拆掉一根毛细血管一般，即使一点很小的修改也必须小心翼翼，</p><p>面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度对象之间的联系激增，又有可能会反过来降低它们的可复用性。</p><p>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。<br><img src="0.png" alt="引用关系"><br>图中，如果对象A发生了改变，则需要同时通知跟A发生引用关系的B、D、E、F这4个对象；而使用中介者模式改进之后，A发生改变时则只需要通知这个中介者对象即可。<br><img src="1.png" alt="中介者"></p><h4 id="现实中的中介者"><a href="#现实中的中介者" class="headerlink" title="现实中的中介者"></a>现实中的中介者</h4><p>在现实生活中也有很多中介者的例子，例如</p><ol><li>机场指挥塔<br>中介者也被称为调停者，我们想象一下机场的指挥塔，如果没有指挥塔的存在，每一架飞机要和方圆100公里内的所有飞机通信，才能确定航线以及飞行状况，后果是不可想象的。现实中的情况是，每架飞机都只需要和指挥塔通信。指挥塔作为调停者，知道每一架飞机的飞行状况，所以它可以安排所有飞机的起降时间，及时做出航线调整。</li><li>博彩公司<br>打麻将的人经常遇到这样的问题，打了几局之后开始计算钱，A自摸了两把，B杠了三次，C点炮一次给D，谁应该给谁多少钱已经很难计算清楚，而这还是在只有4个人参与的情况下。在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能实现的事情。有了博彩公司作为中介，每个人只需和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就交给博彩公司。</li></ol><h4 id="中介者模式的例子——泡泡堂游戏"><a href="#中介者模式的例子——泡泡堂游戏" class="headerlink" title="中介者模式的例子——泡泡堂游戏"></a>中介者模式的例子——泡泡堂游戏</h4><p>大家可能都还记得泡泡堂游戏，作者曾经写过一个JS版的泡泡堂，现在我们来一起回顾这个游戏，在游戏之初只支持两个玩家同时进行对战。</p><p>先定义一个玩家构造函数，它有3个简单的原型方法：Play.prototype.win、Play.prototype.lose以及表示玩家死亡的Play.prototype.die。</p><p>因为玩家的数目是2，所以当其中一个玩家死亡的时候游戏便结束,同时通知它的对手胜利。这段代码看起来很简单：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.enemy = <span class="literal">null</span>; <span class="comment">// 敌 人 </span></span><br><span class="line">&#125;;</span><br><span class="line">Player.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' won '</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Player.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' lost'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Player.prototype.die = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.lose();</span><br><span class="line">  <span class="keyword">this</span>.enemy.win();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来创建2个玩家对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player1 = <span class="keyword">new</span> Player( <span class="string">'皮 蛋'</span> ); </span><br><span class="line"><span class="keyword">var</span> player2 = <span class="keyword">new</span> Player( <span class="string">'小 乖'</span> );</span><br></pre></td></tr></table></figure></p><p>给玩家相互设置敌人：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">player1.enemy = player2; </span><br><span class="line">player2.enemy = player1;</span><br></pre></td></tr></table></figure></p><p>当玩家player1被泡泡炸死的时候，只需要调用这一句代码便完成了一局游戏：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">player1.die();<span class="comment">//输出：皮蛋lost、小乖won</span></span><br></pre></td></tr></table></figure></p><p>只有2个玩家其实没什么意思，真正的泡泡堂游戏至多可以有8个玩家，并分成红蓝两队进行游戏。</p><h5 id="为游戏增加队伍"><a href="#为游戏增加队伍" class="headerlink" title="为游戏增加队伍"></a>为游戏增加队伍</h5><p>改进一下游戏。因为玩家数量变多，用下面的方式来设置队友和敌人无疑很低效：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">player1.partners = [player1, player2, player3, player4];</span><br><span class="line">player1.enemies = [player5, player6, player7, player8];</span><br><span class="line">Player5.partners = [player5, player6, player7, player8];</span><br><span class="line">Player5.enemies = [player1, player2, player3, player4];</span><br></pre></td></tr></table></figure></p><p>所以我们定义一个数组players来保存所有的玩家，在创建玩家之后，循环players来给每个玩家设置队友和敌人,再改写构造函数Player，使每个玩家对象都增加一些属性，分别是队友列表、敌人列表、玩家当前状态、角色名字以及玩家所在的队伍颜色：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.partners = []; <span class="comment">// 队 友 列 表 </span></span><br><span class="line">  <span class="keyword">this</span>.enemies = []; <span class="comment">// 敌 人 列 表</span></span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'live'</span>; <span class="comment">// 玩 家 状 态 </span></span><br><span class="line">  <span class="keyword">this</span>.name = name; <span class="comment">// 角 色 名 字 </span></span><br><span class="line">  <span class="keyword">this</span>.teamColor = teamColor; <span class="comment">// 队 伍 颜 色 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>玩家胜利和失败之后的展现依然很简单，只是在每个玩家的屏幕上简单地弹出提示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Player.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="built_in">console</span>.log( <span class="string">'winner: '</span> + <span class="keyword">this</span>.name ); &#125;;</span><br><span class="line">Player.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="built_in">console</span>.log( <span class="string">'loser: '</span> + <span class="keyword">this</span>.name ); &#125;;</span><br></pre></td></tr></table></figure></p><p>玩家死亡的方法要变得稍微复杂一点，我们需要在每个玩家死亡的时候，都遍历其他队友的生存状况，如果队友全部死亡，则这局游戏失败，同时敌人队伍的所有玩家都取得胜利，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Player.prototype.die = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 玩 家 死 亡 </span></span><br><span class="line">  <span class="keyword">var</span> all_dead = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'dead'</span>; <span class="comment">// 设 置 玩 家 状 态 为 死 亡 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, partner; partner = <span class="keyword">this</span>.partners[i++];) &#123; <span class="comment">// 遍 历 队 友 列 表 </span></span><br><span class="line">    <span class="keyword">if</span> (partner.state !== <span class="string">'dead'</span>) &#123; <span class="comment">// 如 果 还 有 一 个 队 友 没 有 死 亡， 则 游 戏 还 未 失 败 </span></span><br><span class="line">      all_dead = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (all_dead === <span class="literal">true</span>) &#123; <span class="comment">// 如 果 队 友 全 部 死 亡 this.lose(); // 通 知 自 己 游 戏 失 败 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, partner; partner = <span class="keyword">this</span>.partners[i++];) &#123; <span class="comment">// 通 知 所 有 队 友 玩 家 游 戏 失 败 </span></span><br><span class="line">      partner.lose();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, enemy; enemy = <span class="keyword">this</span>.enemies[i++];) &#123; <span class="comment">// 通 知 所 有 敌 人 游 戏 胜 利 </span></span><br><span class="line">      enemy.win();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最后定义一个工厂来创建玩家：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerFactory = <span class="function"><span class="keyword">function</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newPlayer = <span class="keyword">new</span> Player(name, teamColor); <span class="comment">// 创 建 新 玩 家 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, player; player = players[i++];) &#123; <span class="comment">// 通 知 所 有 的 玩 家， 有 新 角 色 加 入 </span></span><br><span class="line">      <span class="keyword">if</span> (player.teamColor === newPlayer.teamColor) &#123; <span class="comment">// 如 果 是 同 一 队 的 玩 家 </span></span><br><span class="line">        player.partners.push(newPlayer); <span class="comment">// 相 互 添 加 到 队 友 列 表 </span></span><br><span class="line">        newPlayer.partners.push(player);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        player.enemies.push(newPlayer); <span class="comment">// 相 互 添 加 到 敌 人 列 表 </span></span><br><span class="line">        newPlayer.enemies.push(player);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    players.push(newPlayer);</span><br><span class="line">    <span class="keyword">return</span> newPlayer;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>创建8个玩家，并让红队玩家全部死亡，查看输出结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红 队： </span></span><br><span class="line"><span class="keyword">var</span> player1 = playerFactory(<span class="string">'皮 蛋'</span>, <span class="string">'red'</span>),</span><br><span class="line">  player2 = playerFactory(<span class="string">'小 乖'</span>, <span class="string">'red'</span>),</span><br><span class="line">  player3 = playerFactory(<span class="string">'宝 宝'</span>, <span class="string">'red'</span>),</span><br><span class="line">  player4 = playerFactory(<span class="string">'小 强'</span>, <span class="string">'red'</span>);</span><br><span class="line"><span class="comment">// 蓝 队：</span></span><br><span class="line"><span class="keyword">var</span> player5 = playerFactory(<span class="string">'黑 妞'</span>, <span class="string">'blue'</span>),</span><br><span class="line">  player6 = playerFactory(<span class="string">'葱 头'</span>, <span class="string">'blue'</span>),</span><br><span class="line">  player7 = playerFactory(<span class="string">'胖 墩'</span>, <span class="string">'blue'</span>),</span><br><span class="line">  player8 = playerFactory(<span class="string">'海 盗'</span>, <span class="string">'blue'</span>);</span><br><span class="line"></span><br><span class="line">player1.die(); </span><br><span class="line">player2.die(); </span><br><span class="line">player4.die(); </span><br><span class="line">player3.die();</span><br></pre></td></tr></table></figure></p><h5 id="玩家增多带来的困扰"><a href="#玩家增多带来的困扰" class="headerlink" title="玩家增多带来的困扰"></a>玩家增多带来的困扰</h5><p>现在我们已经可以随意地为游戏增加玩家或者队伍，但问题是，每个玩家和其他玩家都是紧紧耦合在一起的。在此段代码中，每个玩家对象都有两个属性，this.partners和this.enemies，用来保存其他玩家对象的引用。当每个对象的状态发生改变，比如角色移动、吃到道具或者死亡时，都必须要显式地遍历通知其他对象。</p><p>在这个例子中只创建了8个玩家，或许还没有对你产生足够多的困扰，而如果在一个大型网络游戏中，画面里有成百上千个玩家，几十支队伍在互相厮杀。如果有一个玩家掉线，必须从所有其他玩家的队友列表和敌人列表中都移除这个玩家。游戏也许还有解除队伍和添加到别的队伍的功能，红色玩家可以突然变成蓝色玩家，这就不再仅仅是循环能够解决的问题了。面对这样的需求，上面的代码可完全没有办法解决。</p><h5 id="用中介者模式改造泡泡堂游戏"><a href="#用中介者模式改造泡泡堂游戏" class="headerlink" title="用中介者模式改造泡泡堂游戏"></a>用中介者模式改造泡泡堂游戏</h5><p>现在我们开始用中介者模式来改造上面的泡泡堂游戏，首先仍然是定义Player构造函数和player对象的原型方法，在player对象的这些原型方法中，不再负责具体的执行逻辑，而是把操作转交给中介者对象，我们把中介者对象命名为playerDirector：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name; <span class="comment">// 角 色 名 字 </span></span><br><span class="line">  <span class="keyword">this</span>.teamColor = teamColor; <span class="comment">// 队 伍 颜 色 </span></span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'alive'</span>; <span class="comment">// 玩 家 生 存 状 态 </span></span><br><span class="line">&#125;;</span><br><span class="line">Player.prototype.win = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' won '</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Player.prototype.lose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' lost'</span>);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/******************* 玩 家 死 亡*****************/</span></span><br><span class="line">Player.prototype.die = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.state = <span class="string">'dead'</span>;</span><br><span class="line">  playerDirector.ReceiveMessage(<span class="string">'playerDead'</span>, <span class="keyword">this</span>); <span class="comment">// 给 中 介 者 发 送 消 息， 玩 家 死 亡 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/******************* 移 除 玩 家*****************/</span></span><br><span class="line">Player.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  playerDirector.ReceiveMessage(<span class="string">'removePlayer'</span>, <span class="keyword">this</span>); <span class="comment">// 给 中 介 者 发 送 消 息， 移 除 一 个 玩 家 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/******************* 玩 家 换 队*****************/</span> </span><br><span class="line">Player.prototype.changeTeam = <span class="function"><span class="keyword">function</span>(<span class="params"> color </span>)</span>&#123; </span><br><span class="line">  playerDirector.ReceiveMessage( <span class="string">'changeTeam'</span>, <span class="keyword">this</span>, color ); <span class="comment">// 给 中 介 者 发 送 消 息， 玩 家 换 队 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再继续改写之前创建玩家对象的工厂函数，可以看到，因为工厂函数里不再需要给创建的玩家对象设置队友和敌人，这个工厂函数几乎失去了工厂的意义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerFactory = <span class="function"><span class="keyword">function</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newPlayer = <span class="keyword">new</span> Player(name, teamColor); <span class="comment">// 创 造 一 个 新 的 玩 家 对 象</span></span><br><span class="line">    playerDirector.ReceiveMessage(<span class="string">'addPlayer'</span>, newPlayer); <span class="comment">// 给 中 介 者 发 送 消 息， 新 增 玩 家 </span></span><br><span class="line">    <span class="keyword">return</span> newPlayer;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>最后，我们需要实现这个中介者playerDirector对象，一般有以下两种方式。</p><ul><li>利用发布—订阅模式。将playerDirector实现为订阅者，各player作为发布者，一旦player的状态发生改变，便推送消息给playerDirector，playerDirector处理消息后将反馈发送给其他player。</li><li>在playerDirector中开放一些接收消息的接口，各player可以直接调用该接口来给playerDirector发送消息，player只需传递一个参数给playerDirector，这个参数的目的是使playerDirector可以识别发送者。同样，playerDirector接收到消息之后会将处理结果反馈给其他player。</li></ul><p>这两种方式的实现没什么本质上的区别。在这里我们使用第二种方式，playerDirector开放一个对外暴露的接口ReceiveMessage，负责接收player对象发送的消息，而player对象发送消息的时候，总是把自身this作为参数发送给playerDirector，以便playerDirector识别消息来自于哪个玩家对象，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerDirector = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> players = &#123;&#125;, <span class="comment">// 保 存 所 有 玩 家 </span></span><br><span class="line">    operations = &#123;&#125;; <span class="comment">// 中 介 者 可 以 执 行 的 操 作 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**************** 新 增 一 个 玩 家***************************/</span></span><br><span class="line">  operations.addPlayer = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> teamColor = player.teamColor; <span class="comment">// 玩 家 的 队 伍 颜 色 </span></span><br><span class="line">    players[teamColor] = players[teamColor] || []; <span class="comment">// 如 果 该 颜 色 的 玩 家 还 没 有 成 立 队 伍， 则 新 成 立 一 个 队 伍 </span></span><br><span class="line">    players[teamColor].push(player); <span class="comment">// 添 加 玩 家 进 队 伍 </span></span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/**************** 移 除 一 个 玩 家***************************/</span></span><br><span class="line">  operations.removePlayer = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> teamColor = player.teamColor,</span><br><span class="line">      <span class="comment">// 玩 家 的 队 伍 颜 色 </span></span><br><span class="line">      teamPlayers = players[teamColor] || []; <span class="comment">// 该 队 伍 所 有 成 员 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = teamPlayers.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 遍 历 删 除 </span></span><br><span class="line">      <span class="keyword">if</span> (teamPlayers[i] === player) &#123;</span><br><span class="line">        teamPlayers.splice(i, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**************** 玩 家 换 队***************************/</span></span><br><span class="line">  operations.changeTeam = <span class="function"><span class="keyword">function</span>(<span class="params">player, newTeamColor</span>) </span>&#123; <span class="comment">// 玩 家 换 队 </span></span><br><span class="line">    operations.removePlayer(player); <span class="comment">// 从 原 队 伍 中 删 除 </span></span><br><span class="line">    player.teamColor = newTeamColor; <span class="comment">// 改 变 队 伍 颜 色 </span></span><br><span class="line">    operations.addPlayer(player); <span class="comment">// 增 加 到 新 队 伍 中 </span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  operations.playerDead = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123; <span class="comment">// 玩 家 死 亡 </span></span><br><span class="line">    <span class="keyword">var</span> teamColor = player.teamColor,</span><br><span class="line">      teamPlayers = players[teamColor]; <span class="comment">// 玩 家 所 在 队 伍</span></span><br><span class="line">    <span class="keyword">var</span> all_dead = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[i++];) &#123;</span><br><span class="line">      <span class="keyword">if</span> (player.state !== <span class="string">'dead'</span>) &#123;</span><br><span class="line">        all_dead = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (all_dead === <span class="literal">true</span>) &#123; <span class="comment">// 全 部 死 亡</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[i++];) &#123;</span><br><span class="line">        player.lose(); <span class="comment">// 本 队 所 有 玩 家 lose </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> color <span class="keyword">in</span> players) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color !== teamColor) &#123;</span><br><span class="line">          <span class="keyword">var</span> teamPlayers = players[color]; <span class="comment">// 其 他 队 伍 的 玩 家</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, player; player = teamPlayers[i++];) &#123;</span><br><span class="line">            player.win(); <span class="comment">// 其 他 队 伍 所 有 玩 家 win</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ReceiveMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> message = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>); <span class="comment">// arguments 的 第 一 个 参 数 为 消 息 名 称</span></span><br><span class="line">      operations[message].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ReceiveMessage: ReceiveMessage</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>可以看到，除了中介者本身，没有一个玩家知道其他任何玩家的存在，玩家与玩家之间的耦合关系已经完全解除，某个玩家的任何操作都不需要通知其他玩家，而只需要给中介者发送一个消息，中介者处理完消息之后会把处理结果反馈给其他的玩家对象。我们还可以继续给中介者扩展更多功能，以适应游戏需求的不断变化。</p><h4 id="中介者模式的例子——购买商品"><a href="#中介者模式的例子——购买商品" class="headerlink" title="中介者模式的例子——购买商品"></a>中介者模式的例子——购买商品</h4><p>假设我们正在编写一个手机购买的页面，在购买流程中，可以选择手机的颜色以及输入购买数量，同时页面中有两个展示区域，分别向用户展示刚刚选择好的颜色和数量。还有一个按钮动态显示下一步的操作，我们需要查询该颜色手机对应的库存，如果库存数量少于这次的购买数量，按钮将被禁用并且显示库存不足，反之按钮可以点击并且显示放入购物车。</p><p>这个需求是非常容易实现的，假设我们已经提前从后台获取到了所有颜色手机的库存量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123; <span class="comment">// 手 机 库 存 </span></span><br><span class="line">  <span class="string">"red"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"blue"</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>那么页面有可能显示为如下几种场景：</p><ul><li>选择红色手机，购买4个，库存不足。</li><li>选择蓝色手机，购买5个，库存充足，可以加入购物车。</li><li>或者是没有输入购买数量的时候，按钮将被禁用并显示相应提示。</li></ul><p>我们大概已经能够猜到，接下来将遇到至少5个节点，分别是：</p><ul><li>下拉选择框colorSelect</li><li>文本输入框numberInput</li><li>展示颜色信息colorInfo</li><li>展示购买数量信息numberInfo</li><li>决定下一步操作的按钮nextBtn</li></ul><p>接下来将分别监听colorSelect的onchange事件函数和numberInput的oninput事件函数，然后在这两个事件中作出相应处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorSelect = <span class="built_in">document</span>.getElementById(<span class="string">'colorSelect'</span>),</span><br><span class="line">  numberInput = <span class="built_in">document</span>.getElementById(<span class="string">'numberInput'</span>),</span><br><span class="line">  colorInfo = <span class="built_in">document</span>.getElementById(<span class="string">'colorInfo'</span>),</span><br><span class="line">  numberInfo = <span class="built_in">document</span>.getElementById(<span class="string">'numberInfo'</span>),</span><br><span class="line">  nextBtn = <span class="built_in">document</span>.getElementById(<span class="string">'nextBtn'</span>);</span><br><span class="line"><span class="keyword">var</span> goods = &#123; <span class="comment">// 手 机 库 存 </span></span><br><span class="line">  <span class="string">"red"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"blue"</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line">colorSelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> color = <span class="keyword">this</span>.value,<span class="comment">// 颜 色 </span></span><br><span class="line">    number = numberInput.value, <span class="comment">// 数 量 </span></span><br><span class="line">    stock = goods[color]; <span class="comment">// 该 颜 色 手 机 对 应 的 当 前 库 存 </span></span><br><span class="line">  colorInfo.innerHTML = color;</span><br><span class="line">  <span class="keyword">if</span> (!color) &#123;</span><br><span class="line">    nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.innerHTML = <span class="string">'请 选 择 手 机 颜 色'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (((number - <span class="number">0</span>) | <span class="number">0</span>) !== number - <span class="number">0</span>) &#123; <span class="comment">// 用 户 输 入 的 购 买 数 量 是 否 为 正 整 数 </span></span><br><span class="line">    nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.innerHTML = <span class="string">'请 输 入 正 确 的 购 买 数 量'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (number &gt; stock) &#123; <span class="comment">// 当 前 选 择 数 量 超 过 库 存 量 </span></span><br><span class="line">    nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.innerHTML = <span class="string">'库 存 不 足'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  nextBtn.disabled = <span class="literal">false</span>;</span><br><span class="line">  nextBtn.innerHTML = <span class="string">'放 入 购 物 车'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="对象之间的联系"><a href="#对象之间的联系" class="headerlink" title="对象之间的联系"></a>对象之间的联系</h5><p>来考虑一下，当触发了colorSelect的onchange之后，会发生什么事情。</p><p>首先我们要让colorInfo中显示当前选中的颜色，然后获取用户当前输入的购买数量，对用户的输入值进行一些合法性判断。再根据库存数量来判断nextBtn的显示状态。numberInput的事件相关代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">numberInput.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> color = colorSelect.value,</span><br><span class="line">    <span class="comment">// 颜 色 </span></span><br><span class="line">    number = <span class="keyword">this</span>.value,</span><br><span class="line">    <span class="comment">// 数 量 </span></span><br><span class="line">    stock = goods[color]; <span class="comment">// 该 颜 色 手 机 对 应 的 当 前 库 存 </span></span><br><span class="line">  numberInfo.innerHTML = number;</span><br><span class="line">  <span class="keyword">if</span> (!color) &#123;</span><br><span class="line">    nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.innerHTML = <span class="string">'请 选 择 手 机 颜 色'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (((number - <span class="number">0</span>) | <span class="number">0</span>) !== number - <span class="number">0</span>) &#123; <span class="comment">// 输 入 购 买 数 量 是 否 为 正 整 数 </span></span><br><span class="line">    nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.innerHTML = <span class="string">'请 输 入 正 确 的 购 买 数 量'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (number &gt; stock) &#123; <span class="comment">// 当 前 选 择 数 量 没 有 超 过 库 存 量 </span></span><br><span class="line">    nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.innerHTML = <span class="string">'库 存 不 足'</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  nextBtn.disabled = <span class="literal">false</span>;</span><br><span class="line">  nextBtn.innerHTML = <span class="string">'放 入 购 物 车'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>虽然目前顺利完成了代码编写，但随之而来的需求改变有可能给我们带来麻烦。假设现在要求去掉colorInfo和numberInfo这两个展示区域，我们就要分别改动colorSelect.onchange和numberInput.oninput里面的代码，因为在先前的代码中，这些对象确实是耦合在一起的。</p><p>目前我们面临的对象还不算太多，当这个页面里的节点激增到10个或者15个时，它们之间的联系可能变得更加错综复杂，任何一次改动都将变得很棘手。</p><p>假设页面中将新增另外一个下拉选择框，代表选择手机内存。现在我们需要计算颜色、内存和购买数量，来判断nextBtn是显示库存不足还是放入购物车。</p><p>而具体实现则需要先修改表示存库的JSON对象以及修改colorSelect的onchange事件函数，同样要改写numberInput的事件相关代码，具体代码的改变跟colorSelect大同小异，最后还要新增memorySelect的onchange事件函数。</p><p>仅仅是增加一个内存的选择条件，就要改变如此多的代码，这是因为在目前的实现中，每个节点对象都是耦合在一起的，改变或者增加任何一个节点对象，都要通知到与其相关的对象。</p><h5 id="引入中介者"><a href="#引入中介者" class="headerlink" title="引入中介者"></a>引入中介者</h5><p>现在我们来引入中介者对象，所有的节点对象只跟中介者通信。当下拉选择框colorSelect、memorySelect和文本输入框numberInput发生了事件行为时，它们仅仅通知中介者它们被改变了，同时把自身当作参数传入中介者，以便中介者辨别是谁发生了改变。剩下的所有事情都交给中介者对象来完成，这样一来，无论是修改还是新增节点，都只需要改动中介者对象里的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123; <span class="comment">// 手 机 库 存 </span></span><br><span class="line">  <span class="string">"red | 32G"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"red | 16G"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"blue | 32G"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"blue | 16G"</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> mediator = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> colorSelect = <span class="built_in">document</span>.getElementById(<span class="string">'colorSelect'</span>),</span><br><span class="line">    memorySelect = <span class="built_in">document</span>.getElementById(<span class="string">'memorySelect'</span>),</span><br><span class="line">    numberInput = <span class="built_in">document</span>.getElementById(<span class="string">'numberInput'</span>),</span><br><span class="line">    colorInfo = <span class="built_in">document</span>.getElementById(<span class="string">'colorInfo'</span>),</span><br><span class="line">    memoryInfo = <span class="built_in">document</span>.getElementById(<span class="string">'memoryInfo'</span>),</span><br><span class="line">    numberInfo = <span class="built_in">document</span>.getElementById(<span class="string">'numberInfo'</span>),</span><br><span class="line">    nextBtn = <span class="built_in">document</span>.getElementById(<span class="string">'nextBtn'</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    changed: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> color = colorSelect.value, <span class="comment">// 颜 色 </span></span><br><span class="line">        memory = memorySelect.value, <span class="comment">// 内 存 </span></span><br><span class="line">        number = numberInput.value, <span class="comment">// 数 量 </span></span><br><span class="line">        stock = goods[color + <span class="string">'|'</span> + memory]; <span class="comment">// 颜 色 和 内 存 对 应 的 手 机 库 存 数 量 </span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (obj === colorSelect) &#123; <span class="comment">// 如 果 改 变 的 是 选 择 颜 色 下 拉 框 </span></span><br><span class="line">        colorInfo.innerHTML = color;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj === memorySelect) &#123;</span><br><span class="line">        memoryInfo.innerHTML = memory;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj === numberInput) &#123;</span><br><span class="line">        numberInfo.innerHTML = number;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!color) &#123;</span><br><span class="line">        nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.innerHTML = <span class="string">'请 选 择 手 机 颜 色'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!memory) &#123;</span><br><span class="line">        nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.innerHTML = <span class="string">'请 选 择 内 存 大 小'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (((number - <span class="number">0</span>) | <span class="number">0</span>) !== number - <span class="number">0</span>) &#123; <span class="comment">// 输 入 购 买 数 量 是 否 为 正 整 数 </span></span><br><span class="line">        nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.innerHTML = <span class="string">'请 输 入 正 确 的 购 买 数 量'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      nextBtn.disabled = <span class="literal">false</span>;</span><br><span class="line">      nextBtn.innerHTML = <span class="string">'放 入 购 物 车'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(); </span><br><span class="line"><span class="comment">// 事 件 函 数： </span></span><br><span class="line">colorSelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  mediator.changed(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">memorySelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  mediator.changed(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">numberInput.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  mediator.changed(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以想象，某天我们又要新增一些跟需求相关的节点，比如CPU型号，那我们只需要稍稍改动mediator对象即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123; <span class="comment">// 手 机 库 存 </span></span><br><span class="line">  <span class="string">"red | 32G | 800"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// 颜 色 red， 内 存 32G， cpu800， 对 应 库 存 数 量 为 3 </span></span><br><span class="line">  <span class="string">"red | 16G | 801"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"blue | 32G | 800"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"blue | 16G | 801"</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> mediator = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 略 </span></span><br><span class="line">  <span class="keyword">var</span> cpuSelect = <span class="built_in">document</span>.getElementById(<span class="string">'cpuSelect'</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    change: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 略 </span></span><br><span class="line">      <span class="keyword">var</span> cpu = cpuSelect.value,</span><br><span class="line">        stock = goods[color + <span class="string">'|'</span> + memory + <span class="string">'|'</span> + cpu];</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> (obj === cpuSelect) &#123;</span><br><span class="line">        cpuInfo.innerHTML = cpu;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 略 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象（类似不和陌生人说话）。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他的对象，跟“城门失火，殃及池鱼”的道理是一样的。而在中介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。</p><p>因此，中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。</p><p>不过，中介者模式也存在一些缺点。其中，最大的缺点是系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。</p><p>我们都知道，毒贩子虽然使吸毒者和制毒者之间的耦合度降低，但毒贩子也要抽走一部分利润。同样，在程序中，中介者对象要占去一部分内存。而且毒贩本身还要防止被警察抓住，因为它了解整个犯罪链条中的所有关系，这表明中介者对象自身往往是一个难以维护的对象。</p><p>中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我们生活的世界中，每个人每个物体之间都会产生一些错综复杂的联系。在应用程序里也是一样，程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。&lt;/p&gt;
&lt;p&gt;平时我们大概能记住10个朋友的电话、30家餐馆的位置。在程序里，也许一个对象会和其他10个对象打交道
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-12-职责链模式</title>
    <link href="https://github.com/xmoyKING/2017/11/28/js-pattern12/"/>
    <id>https://github.com/xmoyKING/2017/11/28/js-pattern12/</id>
    <published>2017-11-28T07:58:27.000Z</published>
    <updated>2017-12-06T14:50:09.306Z</updated>
    
    <content type="html"><![CDATA[<p>职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点。</p><h4 id="现实中的职责链模式"><a href="#现实中的职责链模式" class="headerlink" title="现实中的职责链模式"></a>现实中的职责链模式</h4><p>职责链模式的例子在现实中并不难找到，以下就是两个常见的跟职责链模式有关的场景。</p><ul><li>如果早高峰能顺利挤上公交车的话，那么估计这一天都会过得很开心。因为公交车上人实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在N个人手上传递，才能最终到达售票员的手里。</li><li>中学时代的期末考试，如果你平时不太老实，考试时就会被安排在第一个位置。遇到不会答的题目，就把题目编号写在小纸条上往后传递，坐在后面的同学如果也不会答，他就会把这张小纸条继续递给他后面的人。</li></ul><p>从这两个例子中，我们很容易找到职责链模式的最大优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。如果不使用职责链模式，那么在公交车上，我就得先搞清楚谁是售票员，才能把硬币递给他。同样，在期末考试中，也许我就要先了解同学中有哪些可以解答这道题。</p><h4 id="实际开发中的职责链模式"><a href="#实际开发中的职责链模式" class="headerlink" title="实际开发中的职责链模式"></a>实际开发中的职责链模式</h4><p>假设我们负责一个售卖手机的电商网站，经过分别交纳500元定金和200元定金的两轮预定后（订单已在此时生成），现在已经到了正式购买的阶段。</p><p>公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过500元定金的用户会收到100元的商城优惠券，200元定金的用户可以收到50元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。</p><p>我们的订单页面是PHP吐出的模板，在页面加载之初，PHP会传递给页面几个字段。</p><p>-orderType：表示订单类型（定金用户或者普通购买用户），code的值为1的时候是500元定金用户，为2的时候是200元定金用户，为3的时候是普通购买用户。<br>-pay：表示用户是否已经支付定金，值为true或者false，虽然用户已经下过500元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。<br>-stock：表示当前用于普通购买的手机库存数量，已经支付过500元或者200元定金的用户不受此限制。</p><p>下面我们把这个流程写成代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> order = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">1</span>) &#123; <span class="comment">// 500 元 定 金 购 买 模 式 </span></span><br><span class="line">    <span class="keyword">if</span> (pay === <span class="literal">true</span>) &#123; <span class="comment">// 已 支 付 定 金 </span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'500 元 定 金 预 购, 得 到 100 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未 支 付 定 金， 降 级 到 普 通 购 买 模 式 </span></span><br><span class="line">      <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123; <span class="comment">// 用 于 普 通 购 买 的 手 机 还 有 库 存 </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'普 通 购 买, 无 优 惠 券'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'手 机 库 存 不 足'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType === <span class="number">2</span>) &#123; <span class="comment">// 200 元 定 金 购 买 模 式 </span></span><br><span class="line">    <span class="keyword">if</span> (pay === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'200 元 定 金 预 购, 得 到 50 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'普 通 购 买, 无 优 惠 券'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'手 机 库 存 不 足'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'普 通 购 买, 无 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'手 机 库 存 不 足'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">order(<span class="number">1</span>,<span class="literal">true</span>,<span class="number">500</span>);<span class="comment">//输出：500元定金预购,得到100优惠券</span></span><br></pre></td></tr></table></figure></p><p>虽然我们得到了意料中的运行结果，但这远远算不上一段值得夸奖的代码。order函数不仅巨大到难以阅读，而且需要经常进行修改。虽然目前项目能正常运行，但接下来的维护工作无疑是个梦魇。恐怕只有最“新手”的程序员才会写出这样的代码。</p><h4 id="用职责链模式重构代码"><a href="#用职责链模式重构代码" class="headerlink" title="用职责链模式重构代码"></a>用职责链模式重构代码</h4><p>现在我们采用职责链模式重构这段代码，先把500元订单、200元订单以及普通购买分成3个函数。</p><p>接下来把orderType、pay、stock这3个字段当作参数传递给500元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的200元订单函数，如果200元订单函数依然不能处理该请求，则继续传递请求给普通购买函数，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//500元订单</span></span><br><span class="line"><span class="keyword">var</span> order500 = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'500 元 定 金 预 购, 得 到 100 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      order200(orderType, pay, stock); <span class="comment">// 将 请 求 传 递 给 200 元 订 单 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 200 元 订 单 </span></span><br><span class="line"><span class="keyword">var</span> order200 = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (orderType === <span class="number">2</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'200 元 定 金 预 购, 得 到 50 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      orderNormal(orderType, pay, stock); <span class="comment">// 将 请 求 传 递 给 普 通 订 单 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 普 通 购 买 订 单 </span></span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'普 通 购 买, 无 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'手 机 库 存 不 足'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 测 试 结 果： </span></span><br><span class="line">order500(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>); <span class="comment">// 输 出： 500 元 定 金 预 购, 得 到 100 优 惠 券 </span></span><br><span class="line">order500(<span class="number">1</span>, <span class="literal">false</span>, <span class="number">500</span>); <span class="comment">// 输 出： 普 通 购 买, 无 优 惠 券 </span></span><br><span class="line">order500(<span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span>); <span class="comment">// 输 出： 200 元 定 金 预 购, 得 到 50 优 惠 券 </span></span><br><span class="line">order500(<span class="number">3</span>, <span class="literal">false</span>, <span class="number">500</span>); <span class="comment">// 输 出： 普 通 购 买, 无 优 惠 券 </span></span><br><span class="line">order500(<span class="number">3</span>, <span class="literal">false</span>, <span class="number">0</span>); <span class="comment">// 输 出： 手 机 库 存 不 足</span></span><br></pre></td></tr></table></figure></p><p>可以看到，执行结果和前面那个巨大的order函数完全一样，但是代码的结构已经清晰了很多，我们把一个大函数拆分了3个小函数，去掉了许多嵌套的条件分支语句。</p><p>目前已经有了不小的进步，但我们不会满足于此，虽然已经把大函数拆分成了互不影响的3个小函数，但可以看到，请求在链条传递中的顺序非常僵硬，传递请求的代码被耦合在了业务函数之中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//500元订单</span></span><br><span class="line"><span class="keyword">var</span> order500 = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'500 元 定 金 预 购, 得 到 100 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      order200(orderType, pay, stock); <span class="comment">// order200 和 order500 耦 合 在 一 起</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>这依然是违反开放-封闭原则的，如果有天我们要增加300元预订或者去掉200元预订，意味着就必须改动这些业务函数内部。就像一根环环相扣打了死结的链条，如果要增加、拆除或者移动一个节点，就必须得先砸烂这根链条。</p><h4 id="灵活可拆分的职责链节点"><a href="#灵活可拆分的职责链节点" class="headerlink" title="灵活可拆分的职责链节点"></a>灵活可拆分的职责链节点</h4><p>采用一种更灵活的方式，来改进上面的职责链模式，目标是让链中的各个节点可以灵活拆分和重组。</p><p>首先需要改写一下分别表示3种购买模式的节点函数，我们约定，如果某个节点不能处理请求，则返回一个特定的字符串’nextSuccessor’来表示该请求需要继续往后面传递：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> order500 = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'500 元 定 金 预 购， 得 到 100 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>; <span class="comment">// 我 不 知 道 下 一 个 节 点 是 谁， 反 正 把 请 求 往 后 面 传 递 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> order200 = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (orderType === <span class="number">2</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'200 元 定 金 预 购， 得 到 50 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'普 通 购 买， 无 优 惠 券'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'手 机 库 存 不 足'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>接下来需要把函数包装进职责链节点，我们定义一个构造函数Chain，在<code>new Chain</code>的时候传递的参数即为需要被包装的函数，同时它还拥有一个实例属性this.successor，表示在链中的下一个节点。此外Chain的prototype中还有两个函数，它们的作用如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chain.prototype.setNextSuccessor 指 定 在 链 中 的 下 一 个 节 点 </span></span><br><span class="line"><span class="comment">// Chain.prototype.passRequest 传 递 请 求 给 某 个 节 点 </span></span><br><span class="line"><span class="keyword">var</span> Chain = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    <span class="keyword">this</span>.successor = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">Chain.prototype.setNextSuccessor = <span class="function"><span class="keyword">function</span>(<span class="params">successor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.successor = successor;</span><br><span class="line">&#125;;</span><br><span class="line">Chain.prototype.passRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">this</span>.fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret === <span class="string">'nextSuccessor'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.successor &amp;&amp; <span class="keyword">this</span>.successor.passRequest.apply(<span class="keyword">this</span>.successor, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>现在我们把3个订单函数分别包装成职责链的节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chainOrder500 = <span class="keyword">new</span> Chain( order500 ); </span><br><span class="line"><span class="keyword">var</span> chainOrder200 = <span class="keyword">new</span> Chain( order200 ); </span><br><span class="line"><span class="keyword">var</span> chainOrderNormal = <span class="keyword">new</span> Chain( orderNormal );</span><br></pre></td></tr></table></figure></p><p>然后指定节点在职责链中的顺序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chainOrder500.setNextSuccessor( chainOrder200 ); </span><br><span class="line">chainOrder200.setNextSuccessor( chainOrderNormal );</span><br></pre></td></tr></table></figure></p><p>最后把请求传递给第一个节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chainOrder500.passRequest( <span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span> ); <span class="comment">// 输 出： 500 元 定 金 预 购， 得 到 100 优 惠 券 </span></span><br><span class="line">chainOrder500.passRequest( <span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span> ); <span class="comment">// 输 出： 200 元 定 金 预 购， 得 到 50 优 惠 券 </span></span><br><span class="line">chainOrder500.passRequest( <span class="number">3</span>, <span class="literal">true</span>, <span class="number">500</span> ); <span class="comment">// 输 出： 普 通 购 买， 无 优 惠 券 </span></span><br><span class="line">chainOrder500.passRequest( <span class="number">1</span>, <span class="literal">false</span>, <span class="number">0</span> ); <span class="comment">// 输 出： 手 机</span></span><br></pre></td></tr></table></figure></p><p>通过改进，我们可以自由灵活地增加、移除和修改链中的节点顺序，假如某天网站运营人员又想出了支持300元定金购买，那我们就在该链中增加一个节点即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> order300 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 具 体 实 现 略 </span></span><br><span class="line">&#125;; </span><br><span class="line">chainOrder300 = <span class="keyword">new</span> Chain( order300 ); </span><br><span class="line">chainOrder500.setNextSuccessor( chainOrder300); </span><br><span class="line">chainOrder300.setNextSuccessor( chainOrder200);</span><br></pre></td></tr></table></figure></p><p>对于程序员来说，我们总是喜欢去改动那些相对容易改动的地方，就像改动框架的配置文件远比改动框架的源代码简单得多。在这里完全不用理会原来的订单函数代码，我们要做的只是增加一个节点，然后重新设置链中相关节点的顺序。</p><h4 id="异步的职责链"><a href="#异步的职责链" class="headerlink" title="异步的职责链"></a>异步的职责链</h4><p>在上面的职责链模式中，我们让每个节点函数同步返回一个特定的值”nextSuccessor”，来表示是否把请求传递给下一个节点。而在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个ajax异步请求，异步请求返回的结果才能决定是否继续在职责链中passRequest。</p><p>这时候让节点函数同步返回”nextSuccessor”已经没有意义了，所以要给Chain类再增加一个原型方法Chain.prototype.next，表示手动传递请求给职责链中的下一个节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.successor &amp;&amp; <span class="keyword">this</span>.successor.passRequest.apply( <span class="keyword">this</span>.successor, <span class="built_in">arguments</span> ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>来看一个异步职责链的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> Chain(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> Chain(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.next();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="keyword">new</span> Chain(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line">fn1.setNextSuccessor(fn2).setNextSuccessor(fn3);</span><br><span class="line">fn1.passRequest();</span><br></pre></td></tr></table></figure></p><p>现在我们得到了一个特殊的链条，请求在链中的节点里传递，但节点有权利决定什么时候把请求交给下一个节点。可以想象，异步的职责链加上命令模式（把ajax请求封装成命令对象），我们可以很方便地创建一个异步ajax队列库。</p><h4 id="职责链模式的优缺点"><a href="#职责链模式的优缺点" class="headerlink" title="职责链模式的优缺点"></a>职责链模式的优缺点</h4><p>前面已经说过，职责链模式的最大优点就是解耦了请求发送者和N个接收者之间的复杂关系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需把请求传递给第一个节点即可.</p><p>在手机商城的例子中，本来我们要被迫维护一个充斥着条件分支语句的巨大的函数，在例子里的购买过程中只打印了一条log语句。其实在现实开发中，这里要做更多事情，比如根据订单种类弹出不同的浮层提示、渲染不同的UI节点、组合不同的参数发送给不同的cgi等。用了职责链模式之后，每种订单都有各自的处理函数而互不影响。</p><p>其次，使用了职责链模式之后，链中的节点对象可以灵活地拆分重组。增加或者删除一个节点，或者改变节点在链中的位置都是轻而易举的事情。这一点我们也已经看到，在上面的例子中，增加一种订单完全不需要改动其他订单函数中的代码。</p><p>职责链模式还有一个优点，那就是可以手动指定起始节点，请求并不是非得从链中的第一个节点开始传递。比如在公交车的例子中，如果我明确在我前面的第一个人不是售票员，那我当然可以越过他把公交卡递给他前面的人，这样可以减少请求在链中的传递次数，更快地找到合适的请求接受者。这在普通的条件分支语句下是做不到的，我们没有办法让请求越过某一个if判断。</p><p>拿代码来证明这一点，假设某一天网站中支付过定金的订单已经全部结束购买流程，我们在接下来的时间里只需要处理普通购买订单，所以我们可以直接把请求交给普通购买订单节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderNormal.passRequest( <span class="number">1</span>, <span class="literal">false</span>, <span class="number">500</span> ); <span class="comment">// 普 通 购 买, 无 优 惠 券</span></span><br></pre></td></tr></table></figure></p><p>如果运用得当，职责链模式可以很好地帮助我们组织代码，但这种模式也并非没有弊端，首先我们不能保证某个请求一定会被链中的节点处理。比如在期末考试的例子中，小纸条上的题目也许没有任何一个同学知道如何解答，此时的请求就得不到答复，而是径直从链尾离开，或者抛出一个错误异常。在这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。</p><p>另外，职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避免过长的职责链带来的性能损耗。</p><h4 id="用AOP实现职责链"><a href="#用AOP实现职责链" class="headerlink" title="用AOP实现职责链"></a>用AOP实现职责链</h4><p>在之前的职责链实现中，我们利用了一个Chain类来把普通函数包装成职责链的节点。其实利用JavaScript的函数式特性，有一种更加方便的方法来创建职责链。</p><p>改写Function.prototype.after函数，使得第一个函数返回’nextSuccessor’时，将请求继续传递给下一个函数，无论是返回字符串’nextSuccessor’或者false都只是一个约定，当然在这里我们也可以让函数返回false表示传递请求，选择’nextSuccessor’字符串是因为它看起来更能表达我们的目的，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret === <span class="string">'nextSuccessor'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> order = order500yuan.after(order200yuan).after(orderNormal);</span><br><span class="line">order(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>); <span class="comment">// 输 出： 500 元 定 金 预 购， 得 到 100 优 惠 券 </span></span><br><span class="line">order(<span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span>); <span class="comment">// 输 出： 200 元 定 金 预 购， 得 到 50 优 惠 券 </span></span><br><span class="line">order(<span class="number">1</span>, <span class="literal">false</span>, <span class="number">500</span>); <span class="comment">// 输 出： 普 通 购 买， 无 优 惠 券</span></span><br></pre></td></tr></table></figure></p><p>用AOP来实现职责链既简单又巧妙，但这种把函数叠在一起的方式，同时也叠加了函数的作用域，如果链条太长的话，也会对性能有较大的影响。</p><h4 id="用职责链模式获取文件上传对象"><a href="#用职责链模式获取文件上传对象" class="headerlink" title="用职责链模式获取文件上传对象"></a>用职责链模式获取文件上传对象</h4><p>前面有一个用迭代器获取文件上传对象的例子：当时我们创建了一个迭代器来迭代获取合适的文件上传对象，其实用职责链模式可以更简单，我们完全不用创建这个多余的迭代器，完整代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getActiveUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"TXFTNActiveX.FTNUpload"</span>); <span class="comment">// IE 上 传 控 件 </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> getFlashUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (supportFlash()) &#123;</span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">'&lt;object type="application/x-shockwave-flash" &gt; &lt;/object &gt;'</span>;</span><br><span class="line">      <span class="keyword">return</span> $(str).appendTo($(<span class="string">' body'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> getFormUpladObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(<span class="string">'&lt;form&gt;&lt;input name="file" type="file"/&gt;&lt;/form&gt;'</span>).appendTo($(<span class="string">'body'</span>));</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> getUploadObj = getActiveUploadObj.after(getFlashUploadObj).after(getFormUpladObj);</span><br><span class="line"><span class="built_in">console</span>.log(getUploadObj());</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在JavaScript开发中，职责链模式是最容易被忽视的模式之一。实际上只要运用得当，职责链模式可以很好地帮助我们管理代码，降低发起请求的对象和处理请求的对象之间的耦合性。职责链中的节点数量和顺序是可以自由变化的，我们可以在运行时决定链中包含哪些节点。</p><p>无论是作用域链、原型链，还是DOM节点中的事件冒泡，我们都能从中找到职责链模式的影子。职责链模式还可以和组合模式结合在一起，用来连接部件和父部件，或是提高组合对象的效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。&lt;/p&gt;
&lt;p&gt;职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间依次传递
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-11-享元模式</title>
    <link href="https://github.com/xmoyKING/2017/11/27/js-pattern11/"/>
    <id>https://github.com/xmoyKING/2017/11/27/js-pattern11/</id>
    <published>2017-11-27T13:35:57.000Z</published>
    <updated>2017-12-06T14:50:09.306Z</updated>
    
    <content type="html"><![CDATA[<p>享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在JavaScript中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。享元模式的概念初听起来并不太好理解，所以在深入讲解之前，我们先看一个例子。</p><h4 id="初识享元模式"><a href="#初识享元模式" class="headerlink" title="初识享元模式"></a>初识享元模式</h4><p>假设有个内衣工厂，目前的产品有50种男式内衣和50种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。正常情况下需要50个男模特和50个女模特，然后让他们每人分别穿上一件内衣来拍照。不使用享元模式的情况下，在程序里也许会这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Model=<span class="function"><span class="keyword">function</span>(<span class="params">sex,underwear</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">    <span class="keyword">this</span>.underwear=underwear;</span><br><span class="line">&#125;;</span><br><span class="line">Model.prototype.takePhoto=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sex='</span>+<span class="keyword">this</span>.sex+<span class="string">' underwear='</span>+<span class="keyword">this</span>.underwear);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">var</span> maleModel=<span class="keyword">new</span> Model(<span class="string">'male'</span>,<span class="string">'underwear'</span>+i);</span><br><span class="line">  maleModel.takePhoto();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=<span class="number">50</span>;j++)&#123;</span><br><span class="line">  <span class="keyword">var</span> femaleModel=<span class="keyword">new</span> Model(<span class="string">'female'</span>,<span class="string">'underwear'</span>+j);</span><br><span class="line">  femaleModel.takePhoto();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>要得到一张照片，每次都需要传入sex和underwear参数，如上所述，现在一共有50种男内衣和50种女内衣，所以一共会产生100个对象。如果将来生产了10000种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃。</p><p>下面我们来考虑一下如何优化这个场景。虽然有100种内衣，但很显然并不需要50个男模特和50个女模特。其实男模特和女模特各自有一个就足够了，他们可以分别穿上不同的内衣来拍照。现在来改写一下代码，既然只需要区别男女模特，那我们先把underwear参数从构造函数中移除，构造函数只接收sex参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Model=<span class="function"><span class="keyword">function</span>(<span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">  &#125;;</span><br><span class="line">Model.prototype.takePhoto=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sex='</span>+<span class="keyword">this</span>.sex+<span class="string">' underwear='</span>+<span class="keyword">this</span>.underwear);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>分别创建一个男模特对象和一个女模特对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maleModel=<span class="keyword">new</span> Model(<span class="string">'male'</span>),</span><br><span class="line">femaleModel=<span class="keyword">new</span> Model(<span class="string">'female'</span>);</span><br></pre></td></tr></table></figure></p><p>给男模特依次穿上所有的男装，并进行拍照：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vari=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">  maleModel.underwear=<span class="string">'underwear'</span>+i;</span><br><span class="line">  maleModel.takePhoto();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>同样，给女模特依次穿上所有的女装，并进行拍照,可以看到，改进之后的代码，只需要两个对象便完成了同样的功能。</p><h4 id="内部状态与外部状态"><a href="#内部状态与外部状态" class="headerlink" title="内部状态与外部状态"></a>内部状态与外部状态</h4><p>内衣例子便是享元模式的雏形，享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引。</p><ul><li>内部状态存储于对象内部。</li><li>内部状态可以被一些对象共享。</li><li>内部状态独立于具体的场景，通常不会改变。</li><li>外部状态取决于具体的场景，并根据场景而变化，</li><li>外部状态不能被共享。</li></ul><p>这样一来，我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从对象身上剥离出来，并储存在外部。</p><p>剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。</p><p>在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要2个对象。</p><p>使用享元模式的关键是如何区别内部状态和外部状态。可以被对象共享的属性通常被划分为内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，模特的性别就可以作为内部状态储存在共享对象的内部。而外部状态取决于具体的场景，并根据场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态。</p><h4 id="享元模式的通用结构"><a href="#享元模式的通用结构" class="headerlink" title="享元模式的通用结构"></a>享元模式的通用结构</h4><p>内衣例子初步展示了享元模式的威力，但这还不是一个完整的享元模式，在这个例子中还存在以下两个问题。</p><ul><li>我们通过构造函数显式new出了男女两个model对象，在其他系统中，也许并不是一开始就需要所有的共享对象。</li><li>给model对象手动设置了underwear外部状态，在更复杂的系统中，这不是一个最好的方式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难。</li></ul><p>我们通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，它才从工厂中被创建出来。对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。</p><h4 id="文件上传的例子"><a href="#文件上传的例子" class="headerlink" title="文件上传的例子"></a>文件上传的例子</h4><p>作者在微云上传模块的开发中，曾经借助享元模式提升了程序的性能。下面就讲述这个例子。</p><h5 id="对象爆炸"><a href="#对象爆炸" class="headerlink" title="对象爆炸"></a>对象爆炸</h5><p>在微云上传模块的开发中，曾经经历过对象爆炸的问题。微云的文件上传功能虽然可以选择依照队列，一个一个地排队上传，但也支持同时选择2000个文件。每一个文件都对应着一个JavaScript上传对象的创建，在第一版开发中，的确往程序里同时new了2000个upload对象，结果可想而知，Chrome中还勉强能够支撑，IE下直接进入假死状态。</p><p>微云支持好几种上传方式，比如浏览器插件、Flash和表单上传等，为了简化例子，我们先假设只有插件和Flash这两种。不论是插件上传，还是Flash上传，原理都是一样的，当用户选择了文件之后，插件和Flash都会通知调用Window下的一个全局JavaScript函数，它的名字是startUpload，用户选择的文件列表被组合成一个数组files塞进该函数的参数列表里，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.startUpload = <span class="function"><span class="keyword">function</span>(<span class="params">uploadType, files</span>) </span>&#123; <span class="comment">// uploadType 区 分 是 控 件 还 是 flash </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, file; file = files[i++];) &#123;</span><br><span class="line">    <span class="keyword">var</span> uploadObj = <span class="keyword">new</span> Upload(uploadType, file.fileName, file.fileSize);</span><br><span class="line">    uploadObj.init(id++); <span class="comment">// 给 upload 对 象 设 置 一 个 唯 一 的 id </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当用户选择完文件之后，startUpload函数会遍历files数组来创建对应的upload对象。接下来定义Upload构造函数，它接受3个参数，分别是插件类型、文件名和文件大小。这些信息都已经被插件组装在files数组里返回，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span>(<span class="params">uploadType, fileName, fileSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.uploadType = uploadType;</span><br><span class="line">    <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">this</span>.fileSize = fileSize;</span><br><span class="line">    <span class="keyword">this</span>.dom = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">Upload.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="keyword">this</span>.dom.innerHTML = <span class="string">'&lt;span&gt;文件名称:'</span>+<span class="keyword">this</span>.fileName+<span class="string">',文件大小:'</span>+<span class="keyword">this</span>.fileSize+<span class="string">'&lt;/span&gt;'</span>+<span class="string">'&lt;buttonclass="delFile"&gt;删除&lt;/button&gt;'</span>;</span><br><span class="line">  <span class="keyword">this</span>.dom.querySelector(<span class="string">'.delFile'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    that.delFile();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.dom);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>同样为了简化示例，暂且去掉了upload对象的其他功能，只保留删除文件的功能，对应的方法是Upload.prototype.delFile。该方法中有一个逻辑：当被删除的文件小于3000KB时，该文件将被直接删除。否则页面中会弹出一个提示框，提示用户是否确认要删除该文件，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.delFile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.fileSize &lt; <span class="number">3000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.confirm(<span class="string">'确 定 要 删 除 该 文 件 吗? '</span> + <span class="keyword">this</span>.fileName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来分别创建3个插件上传对象和3个Flash上传对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">startUpload(<span class="string">'plugin'</span>, [&#123;</span><br><span class="line">  fileName: <span class="string">'1.txt'</span>,</span><br><span class="line">  fileSize: <span class="number">1000</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  fileName: <span class="string">'2.html'</span>,</span><br><span class="line">  fileSize: <span class="number">3000</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  fileName: <span class="string">'3.txt'</span>,</span><br><span class="line">  fileSize: <span class="number">5000</span></span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">startUpload(<span class="string">'flash'</span>, [&#123;</span><br><span class="line">  fileName: <span class="string">'4.txt'</span>,</span><br><span class="line">  fileSize: <span class="number">1000</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  fileName: <span class="string">'5.html'</span>,</span><br><span class="line">  fileSize: <span class="number">3000</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  fileName: <span class="string">'6.txt'</span>,</span><br><span class="line">  fileSize: <span class="number">5000</span></span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure></p><p>当点击删除最后一个文件时弹出了是否确认删除的提示</p><h5 id="享元模式重构文件上传"><a href="#享元模式重构文件上传" class="headerlink" title="享元模式重构文件上传"></a>享元模式重构文件上传</h5><p>第一版的文件上传代码里有多少个需要上传的文件，就一共创建了多少个upload对象，接下来用享元模式重构它。</p><p>首先，我们需要确认插件类型uploadType是内部状态，那为什么单单uploadType是内部状态呢？前面讲过，划分内部状态和外部状态的关键主要有以下几点。</p><ul><li>内部状态储存于对象内部。</li><li>内部状态可以被一些对象共享。</li><li>内部状态独立于具体的场景，通常不会改变。</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。</li></ul><p>在文件上传的例子里，upload对象必须依赖uploadType属性才能工作，这是因为插件上传、Flash上传、表单上传的实际工作原理有很大的区别，它们各自调用的接口也是完全不一样的，必须在对象创建之初就明确它是什么类型的插件，才可以在程序的运行过程中，让它们分别调用各自的start、pause、cancel、del等方法。</p><p>实际上在微云的真实代码中，虽然插件和Flash上传对象最终创建自一个大的工厂类，但它们实际上根据uploadType值的不同，分别是来自于两个不同类的对象。（目前为了简化代码，把插件和Flash的构造函数合并成了一个。）</p><p>一旦明确了uploadType，无论我们使用什么方式上传，这个上传对象都是可以被任何文件共用的。而fileName和fileSize是根据场景而变化的，每个文件的fileName和fileSize都不一样，fileName和fileSize没有办法被共享，它们只能被划分为外部状态。</p><h5 id="剥离外部状态"><a href="#剥离外部状态" class="headerlink" title="剥离外部状态"></a>剥离外部状态</h5><p>明确了uploadType作为内部状态之后，我们再把其他的外部状态从构造函数中抽离出来，Upload构造函数中只保留uploadType参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Upload = <span class="function"><span class="keyword">function</span>(<span class="params"> uploadType</span>)</span>&#123; <span class="keyword">this</span>.uploadType = uploadType; &#125;;</span><br></pre></td></tr></table></figure></p><p>Upload.prototype.init函数也不再需要，因为upload对象初始化的工作被放在了uploadManager.add函数里面，接下来只需要定义Upload.prototype.del函数即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Upload.prototype.delFile = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  uploadManager.setExternalState(id, <span class="keyword">this</span>); <span class="comment">// (1) </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.fileSize &lt; <span class="number">3000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.confirm(<span class="string">'确 定 要 删 除 该 文 件 吗? '</span> + <span class="keyword">this</span>.fileName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dom.parentNode.removeChild(<span class="keyword">this</span>.dom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在开始删除文件之前，需要读取文件的实际大小，而文件的实际大小被储存在外部管理器uploadManager中，所以在这里需要通过uploadManager.setExternalState方法给共享对象设置正确的fileSize，上段代码中的(1)处表示把当前id对应的对象的外部状态都组装到共享对象中。</p><h5 id="工厂进行对象实例化"><a href="#工厂进行对象实例化" class="headerlink" title="工厂进行对象实例化"></a>工厂进行对象实例化</h5><p>工厂进行对象实例化接下来定义一个工厂来创建upload对象，如果某种内部状态对应的共享对象已经被创建过，那么直接返回这个对象，否则创建一个新的对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UploadFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> createdFlyWeightObjs = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params">uploadType</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (createdFlyWeightObjs[uploadType]) &#123;</span><br><span class="line">        <span class="keyword">return</span> createdFlyWeightObjs[uploadType];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> createdFlyWeightObjs[uploadType] = <span class="keyword">new</span> Upload(uploadType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h5 id="管理器封装外部状态"><a href="#管理器封装外部状态" class="headerlink" title="管理器封装外部状态"></a>管理器封装外部状态</h5><p>现在我们来完善前面提到的uploadManager对象，它负责向UploadFactory提交创建对象的请求，并用一个uploadDatabase对象保存所有upload对象的外部状态，以便在程序运行过程中给upload共享对象设置外部状态，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uploadManager = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uploadDatabase = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">id, uploadType, fileName, fileSize</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> flyWeightObj = UploadFactory.create(uploadType);</span><br><span class="line">      <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      dom.innerHTML = <span class="string">'&lt;span&gt;文件名称:'</span>+fileName+<span class="string">',文件大小:'</span>+fileSize+<span class="string">'&lt;/span&gt;'</span>+<span class="string">'&lt;buttonclass="delFile"&gt;删除&lt;/button&gt;'</span>;</span><br><span class="line">      dom.querySelector(<span class="string">'.delFile'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        flyWeightObj.delFile(id);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(dom);</span><br><span class="line">      uploadDatabase[id] = &#123;</span><br><span class="line">        fileName: fileName,</span><br><span class="line">        fileSize: fileSize,</span><br><span class="line">        dom: dom</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> flyWeightObj;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    setExternalState: <span class="function"><span class="keyword">function</span>(<span class="params">id, flyWeightObj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> uploadData = uploadDatabase[id];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> uploadData) &#123;</span><br><span class="line">        flyWeightObj[i] = uploadData[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>然 后 是 开 始 触 发 上 传 动 作 的 startUpload 函 数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.startUpload = <span class="function"><span class="keyword">function</span>(<span class="params">uploadType, files</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, file; file = files[i++];) &#123;</span><br><span class="line">    <span class="keyword">var</span> uploadObj = uploadManager.add(++id, uploadType, file.fileName, file.fileSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最后是测试时间，运行测试的代码后，可以发现运行结果跟用享元模式重构之前一致</p><p>享元模式重构之前的代码里一共创建了6个upload对象，而通过享元模式重构之后，对象的数量减少为2，更幸运的是，就算现在同时上传2000个文件，需要创建的upload对象数量依然是2。</p><h4 id="享元模式的适用性"><a href="#享元模式的适用性" class="headerlink" title="享元模式的适用性"></a>享元模式的适用性</h4><p>享元模式是一种很好的性能优化方案，但它也会带来一些复杂性的问题，从前面两组代码的比较可以看到，使用了享元模式之后，我们需要分别多维护一个factory对象和一个manager对象，在大部分不必要使用享元模式的环境下，这些开销是可以避免的。</p><p>享元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时便可以使用享元模式。</p><ul><li>一个程序中使用了大量的相似对象。</li><li>由于使用了大量对象，造成很大的内存开销。</li><li>对象的大多数状态都可以变为外部状态。</li><li>剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。<br>可以看到，文件上传的例子完全符合这四点。</li></ul><h4 id="再谈内部状态和外部状态"><a href="#再谈内部状态和外部状态" class="headerlink" title="再谈内部状态和外部状态"></a>再谈内部状态和外部状态</h4><p>如果顺利的话，通过前面的例子我们已经了解了内部状态和外部状态的概念以及享元模式的工作原理。我们知道，实现享元模式的关键是把内部状态和外部状态分离开来。有多少种内部状态的组合，系统中便最多存在多少个共享对象，而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。现在来考虑两种极端的情况，即对象没有外部状态和没有内部状态的时候。</p><h5 id="没有内部状态的享元"><a href="#没有内部状态的享元" class="headerlink" title="没有内部状态的享元"></a>没有内部状态的享元</h5><p>在文件上传的例子中，我们分别进行过插件调用和Flash调用，即startUpload(‘plugin’,[])和startUpload(‘flash’,[])，导致程序中创建了内部状态不同的两个共享对象。也许你会奇怪，在文件上传程序里，一般都会提前通过特性检测来选择一种上传方式，如果浏览器支持插件就用插件上传，如果不支持插件，就用Flash上传。那么，什么情况下既需要插件上传又需要Flash上传呢？</p><p>实际上这个需求是存在的，很多网盘都提供了极速上传（控件）与普通上传（Flash）两种模式，如果极速上传不好使（可能是没有安装控件或者控件损坏），用户还可以随时切换到普通上传模式，所以这里确实是需要同时存在两个不同的upload共享对象。</p><p>但不是每个网站都必须做得如此复杂，很多小一些的网站就只支持单一的上传方式。假设我们是这个网站的开发者，不需要考虑极速上传与普通上传之间的切换，这意味着在之前的代码中作为内部状态的uploadType属性是可以删除掉的。</p><p>在继续使用享元模式的前提下，构造函数Upload就变成了无参数的形式：<code>var Upload = function(){};</code></p><p>其他属性如fileName、fileSize、dom依然可以作为外部状态保存在共享对象外部。在uploadType作为内部状态的时候，它可能为控件，也可能为Flash，所以当时最多可以组合出两个共享对象。而现在已经没有了内部状态，这意味着只需要唯一的一个共享对象。现在我们要改写创建享元对象的工厂，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UploadFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uploadObj;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (uploadObj) &#123;</span><br><span class="line">        <span class="keyword">return</span> uploadObj;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> uploadObj = <span class="keyword">new</span> Upload();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>管理器部分的代码不需要改动，还是负责剥离和组装外部状态。可以看到，当对象没有内部状态的时候，生产共享对象的工厂实际上变成了一个单例工厂。虽然这时候的共享对象没有内部状态的区分，但还是有剥离外部状态的过程，我们依然倾向于称之为享元模式。</p><h5 id="没有外部状态的享元"><a href="#没有外部状态的享元" class="headerlink" title="没有外部状态的享元"></a>没有外部状态的享元</h5><p>网上许多资料中，经常把Java或者C#的字符串看成享元，这种说法是否正确呢？通过下面这段Java代码来分析一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 代 码 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    String a1 = <span class="keyword">new</span> String(<span class="string">"a"</span>).intern();</span><br><span class="line">    String a2 = <span class="keyword">new</span> String(<span class="string">"a"</span>).intern();</span><br><span class="line">    System.out.println(a1 == a2); <span class="comment">// true </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这段Java代码里，分别new了两个字符串对象a1和a2。intern是一种对象池技术，newString(“a”).intern()的含义如下。</p><ul><li>如果值为a的字符串对象已经存在于对象池中，则返回这个对象的引用。</li><li>反之，将字符串a的对象添加进对象池，并返回这个对象的引用。</li></ul><p>所以a1==a2的结果是true，但这并不是使用了享元模式的结果，享元模式的关键是区别内部状态和外部状态。享元模式的过程是剥离外部状态，并把外部状态保存在其他地方，在合适的时刻再把外部状态组装进共享对象。这里并没有剥离外部状态的过程，a1和a2指向的完全就是同一个对象，所以如果没有外部状态的分离，即使这里使用了共享的技术，但并不是一个纯粹的享元模式。</p><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>前面已经提到了Java中String的对象池，这是一种共享的技术。对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后，再进入池子等待被下次获取。</p><p>对象池的原理很好理解，比如我们组人手一本《JavaScript权威指南》，从节约的角度来讲，这并不是很划算，因为大部分时间这些书都被闲置在各自的书架上，所以我们一开始就只买一本，或者一起建立一个小型图书馆（对象池），需要看书的时候就从图书馆里借，看完了之后再把书还回图书馆。</p><p>如果同时有三个人要看这本书，而现在图书馆里只有两本，那我们再马上去书店买一本放入图书馆。对象池技术的应用非常广泛，HTTP连接池和数据库连接池都是其代表应用。在Web前端开发中，对象池使用最多的场景大概就是跟DOM有关的操作。很多空间和时间都消耗在了DOM节点上，如何避免频繁地创建和删除DOM节点就成了一个有意义的话题。</p><h5 id="对象池实现"><a href="#对象池实现" class="headerlink" title="对象池实现"></a>对象池实现</h5><p>假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它toolTip。</p><p>在搜索我家附近地图的时候，页面里出现了2个小气泡。当我再搜索附近的兰州拉面馆时，页面中出现了6个小气泡。按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2个小气泡删除掉，而是把它们放进对象池。这样在第二次的搜索结果页面里，我们只需要再创建4个小气泡而不是6个.</p><p>先定义一个获取小气泡节点的工厂，作为对象池的数组成为私有属性被包含在工厂闭包里，这个工厂有两个暴露对外的方法，create表示获取一个div节点，recover表示回收一个div节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toolTipFactory = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> toolTipPool = []; <span class="comment">// toolTip 对 象 池 </span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (toolTipPool.length === <span class="number">0</span>) &#123; <span class="comment">// 如 果 对 象 池 为 空 </span></span><br><span class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// 创 建 一 个 dom </span></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">        <span class="keyword">return</span> div;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如 果 对 象 池 里 不 为 空 </span></span><br><span class="line">        <span class="keyword">return</span> toolTipPool.shift(); <span class="comment">// 则 从 对 象 池 中 取 出 一 个 dom </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    recover: <span class="function"><span class="keyword">function</span>(<span class="params">tooltipDom</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> toolTipPool.push(tooltipDom); <span class="comment">// 对 象 池 回 收 dom </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>现在把时钟拨回进行第一次搜索的时刻，目前需要创建2个小气泡节点，为了方便回收，用一个数组ary来记录它们：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, str; str = [<span class="string">'A'</span>, <span class="string">'B'</span>][i++];) &#123;</span><br><span class="line">  <span class="keyword">var</span> toolTip = toolTipFactory.create();</span><br><span class="line">  toolTip.innerHTML = str;</span><br><span class="line">  ary.push(toolTip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果你愿意稍稍测试一下，可以看到页面中出现了innerHTML分别为A和B的两个div节点。</p><p>接下来假设地图需要开始重新绘制，在此之前要把这两个节点回收进对象池：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, toolTip; toolTip = ary[i++];) &#123;</span><br><span class="line">  toolTipFactory.recover(toolTip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再创建6个小气泡：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, str; str = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>][i++];) &#123;</span><br><span class="line">  <span class="keyword">var</span> toolTip = toolTipFactory.create();</span><br><span class="line">  toolTip.innerHTML = str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>现在再测试一番，页面中出现了内容分别为A、B、C、D、E、F的6个节点，上一次创建好的节点被共享给了下一次操作。对象池跟享元模式的思想有点相似，虽然innerHTML的值A、B、C、D等也可以看成节点的外部状态，但在这里我们并没有主动分离内部状态和外部状态的过程。</p><h5 id="通用对象池实现"><a href="#通用对象池实现" class="headerlink" title="通用对象池实现"></a>通用对象池实现</h5><p>我们还可以在对象池工厂里，把创建对象的具体过程封装起来，实现一个通用的对象池：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objectPoolFactory = <span class="function"><span class="keyword">function</span>(<span class="params">createObjFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectPool = [];</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> obj = objectPool.length === <span class="number">0</span> ? createObjFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) : objectPool.shift();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;,</span><br><span class="line">      recover: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        objectPool.push(obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用如下，比如利用objectPoolFactory来创建一个装载一些iframe的对象池：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeFactory = objectPoolFactory(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">  iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.onload = <span class="literal">null</span>; <span class="comment">// 防 止 iframe 重 复 加 载 的 bug </span></span><br><span class="line">    iframeFactory.recover(iframe); <span class="comment">// iframe 加 载 完 成 之 后 回 收 节 点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iframe;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> iframe1 = iframeFactory.create();</span><br><span class="line">iframe1.src = <span class="string">'http://baidu.com'</span>;</span><br><span class="line"><span class="keyword">var</span> iframe2 = iframeFactory.create();</span><br><span class="line">iframe2.src = <span class="string">'http://QQ.com'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iframe3 = iframeFactory.create();</span><br><span class="line">  iframe3.src = <span class="string">'http://163.com'</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><p>对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。用享元模式完成的文件上传的例子，其实也可以用对象池+事件委托来代替实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量级。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在JavaScript中，浏览器特别是移动端
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-10-模板方法模式</title>
    <link href="https://github.com/xmoyKING/2017/11/24/js-pattern10/"/>
    <id>https://github.com/xmoyKING/2017/11/24/js-pattern10/</id>
    <published>2017-11-24T13:06:31.000Z</published>
    <updated>2017-12-06T14:50:09.306Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript开发中用到继承的场景其实并不是很多，很多时候我们都喜欢用mix-in的方式给对象扩展属性。但这不代表继承在JavaScript里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。模板方法（TemplateMethod）模式是一种基于继承的设计模式</p><h4 id="模板方法模式的定义和组成"><a href="#模板方法模式的定义和组成" class="headerlink" title="模板方法模式的定义和组成"></a>模板方法模式的定义和组成</h4><p>模板方法模式是一种只需使用继承就可以实现的非常简单的模式。模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p><p>假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬移到另外一个单一的地方，模板方法模式就是为解决这个问题而生的。在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。这也很好地体现了泛化的思想。</p><h4 id="第一个例子——CoffeeorTea"><a href="#第一个例子——CoffeeorTea" class="headerlink" title="第一个例子——CoffeeorTea"></a>第一个例子——CoffeeorTea</h4><p>咖啡与茶是一个经典的例子，经常用来讲解模板方法模式，这个例子的原型来自《HeadFirst设计模式》。用JavaScript来实现这个例子。</p><h5 id="先泡一杯咖啡"><a href="#先泡一杯咖啡" class="headerlink" title="先泡一杯咖啡"></a>先泡一杯咖啡</h5><p>首先，我们先来泡一杯咖啡，如果没有什么太个性化的需求，泡咖啡的步骤通常如下：</p><ol><li>把水煮沸</li><li>用沸水冲泡咖啡</li><li>把咖啡倒进杯子</li><li>加糖和牛奶<br>通过下面这段代码，我们就能得到一杯香浓的咖啡：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Coffee = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Coffee.prototype.boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'把 水 煮 沸'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.brewCoffeeGriends = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'用 沸 水 冲 泡 咖 啡'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'把 咖 啡 倒 进 杯 子'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.addSugarAndMilk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'加 糖 和 牛 奶'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.boilWater();</span><br><span class="line">  <span class="keyword">this</span>.brewCoffeeGriends();</span><br><span class="line">  <span class="keyword">this</span>.pourInCup();</span><br><span class="line">  <span class="keyword">this</span>.addSugarAndMilk();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">coffee.init();</span><br></pre></td></tr></table></figure></li></ol><h5 id="泡一壶茶"><a href="#泡一壶茶" class="headerlink" title="泡一壶茶"></a>泡一壶茶</h5><p>接下来，开始准备我们的茶，泡茶的步骤跟泡咖啡的步骤相差并不大：</p><ol><li>把水煮沸</li><li>用沸水浸泡茶叶</li><li>把茶水倒进杯子</li><li>加柠檬<br>同样用一段代码来实现泡茶的步骤:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Tea.prototype.boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'把 水 煮 沸'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Tea.prototype.steepTeaBag = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'用 沸 水 浸 泡 茶 叶'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Tea.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'把 茶 水 倒 进 杯 子'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Tea.prototype.addLemon = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'加 柠 檬'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Tea.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.boilWater();</span><br><span class="line">  <span class="keyword">this</span>.steepTeaBag();</span><br><span class="line">  <span class="keyword">this</span>.pourInCup();</span><br><span class="line">  <span class="keyword">this</span>.addLemon();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> Tea();</span><br><span class="line">tea.init();</span><br></pre></td></tr></table></figure></li></ol><h5 id="分离出共同点"><a href="#分离出共同点" class="headerlink" title="分离出共同点"></a>分离出共同点</h5><p>现在我们分别泡好了一杯咖啡和一壶茶，经过思考和比较，我们发现咖啡和茶的冲泡过程是大同小异的，</p><p>我们找到泡咖啡和泡茶主要有以下不同点。</p><ul><li>原料不同。一个是咖啡，一个是茶，但我们可以把它们都抽象为“饮料”。</li><li>泡的方式不同。咖啡是冲泡，而茶叶是浸泡，我们可以把它们都抽象为“泡”。</li><li>加入的调料不同。一个是糖和牛奶，一个是柠檬，但我们可以把它们都抽象为“调料”。<br>经过抽象之后，不管是泡咖啡还是泡茶，我们都能整理为下面四步：</li></ul><ol><li>把水煮沸</li><li>用沸水冲泡饮料</li><li>把饮料倒进杯子</li><li>加调料<br>所以，不管是冲泡还是浸泡，我们都能给它一个新的方法名称，比如说brew()。同理，不管是加糖和牛奶，还是加柠檬，我们都可以称之为addCondiments()。让我们忘记最开始创建的Coffee类和Tea类。现在可以创建一个抽象父类来表示泡一杯饮料的整个过程。不论是Coffee，还是Tea，都被我们用Beverage来表示，代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Beverage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Beverage.prototype.boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'把 水 煮 沸'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Beverage.prototype.brew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 空 方 法， 应 该 由 子 类 重 写 </span></span><br><span class="line">Beverage.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 空 方 法， 应 该 由 子 类 重 写 </span></span><br><span class="line">Beverage.prototype.addCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 空 方 法， 应 该 由 子 类 重 写 </span></span><br><span class="line">Beverage.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.boilWater();</span><br><span class="line">  <span class="keyword">this</span>.brew();</span><br><span class="line">  <span class="keyword">this</span>.pourInCup();</span><br><span class="line">  <span class="keyword">this</span>.addCondiments();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h5 id="创建Coffee子类和Tea子类"><a href="#创建Coffee子类和Tea子类" class="headerlink" title="创建Coffee子类和Tea子类"></a>创建Coffee子类和Tea子类</h5><p>现在创建一个Beverage类的对象对我们来说没有意义，因为世界上能喝的东西没有一种真正叫“饮料”的，饮料在这里还只是一个抽象的存在。接下来我们要创建咖啡类和茶类，并让它们继承饮料类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Coffee = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line">Coffee.prototype = <span class="keyword">new</span> Beverage();</span><br></pre></td></tr></table></figure></p><p>接下来要重写抽象父类中的一些方法，只有“把水煮沸”这个行为可以直接使用父类Beverage中的boilWater方法，其他方法都需要在Coffee子类中重写，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Coffee.prototype.brew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'用 沸 水 冲 泡 咖 啡'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'把 咖 啡 倒 进 杯 子'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Coffee.prototype.addCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'加 糖 和 牛 奶'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">Coffee.init();</span><br></pre></td></tr></table></figure></p><p>至此我们的Coffee类已经完成了，当调用coffee对象的init方法时，由于coffee对象和Coffee构造器的原型prototype上都没有对应的init方法，所以该请求会顺着原型链，被委托给Coffee的“父类”Beverage原型上的init方法。</p><p>而Beverage.prototype.init方法中已经规定好了泡饮料的顺序，所以我们能成功地泡出一杯咖啡，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Beverage.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.boilWater();</span><br><span class="line">  <span class="keyword">this</span>.brew();</span><br><span class="line">  <span class="keyword">this</span>.pourInCup();</span><br><span class="line">  <span class="keyword">this</span>.addCondiments();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来照葫芦画瓢，来创建我们的Tea类.</p><p>一直讨论的是模板方法模式，那么在上面的例子中，到底谁才是所谓的模板方法呢？答案是Beverage.prototype.init。</p><p>Beverage.prototype.init被称为模板方法的原因是，该方法中封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。在Beverage.prototype.init方法中，算法内的每一个步骤都清楚地展示在我们眼前。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>首先要说明的是，模板方法模式是一种严重依赖抽象类的设计模式。JavaScript在语言层面并没有提供对抽象类的支持，我们也很难模拟抽象类的实现。将着重讨论Java中抽象类的作用，以及JavaScript没有抽象类时所做出的让步和变通。</p><h5 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h5><p>在Java中，类分为两种，一种为具体类，另一种为抽象类。具体类可以被实例化，抽象类不能被实例化。要了解抽象类不能被实例化的原因，我们可以思考“饮料”这个抽象类。</p><p>想象这样一个场景：我们口渴了，去便利店想买一瓶饮料，我们不能直接跟店员说：“来一瓶饮料。”如果我们这样说了，那么店员接下来肯定会问：“要什么饮料？”饮料只是一个抽象名词，只有当我们真正明确了的饮料类型之后，才能得到一杯咖啡、茶、或者可乐。</p><p>由于抽象类不能被实例化，如果有人编写了一个抽象类，那么这个抽象类一定是用来被某些具体类继承的。</p><p>抽象类和接口一样可以用于向上转型（可参考关于多态的内容），在静态类型语言中，编译器对类型的检查总是一个绕不过的话题与困扰。虽然类型检查可以提高程序的安全性，但繁琐而严格的类型检查也时常会让程序员觉得麻烦。把对象的真正类型隐藏在抽象类或者接口之后，这些对象才可以被互相替换使用。这可以让我们的Java程序尽量遵守依赖倒置原则。</p><p>除了用于向上转型，抽象类也可以表示一种契约。继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口。如果我们在子类中删掉了这些方法中的某一个，那么将不能通过编译器的检查，这在某些场景下是非常有用的，比如模板方法模式，Beverage类的init方法里规定了冲泡一杯饮料的顺序如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.boilWater();</span><br><span class="line"><span class="keyword">this</span>.brew();</span><br><span class="line"><span class="keyword">this</span>.pourInCup();</span><br><span class="line"><span class="keyword">this</span>.addCondiments();</span><br></pre></td></tr></table></figure></p><p>如果在Coffee子类中没有实现对应的brew方法，那么我们百分之百得不到一杯咖啡。既然父类规定了子类的方法和执行这些方法的顺序，子类就应该拥有这些方法，并且提供正确的实现。</p><h5 id="抽象方法和具体方法"><a href="#抽象方法和具体方法" class="headerlink" title="抽象方法和具体方法"></a>抽象方法和具体方法</h5><p>抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，是一些“哑”方法。比如Beverage类中的brew方法、pourInCup方法和addCondiments方法，都被声明为抽象方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。</p><p>除了抽象方法之外，如果每个子类中都有一些同样的具体实现方法，那这些方法也可以选择放在抽象类中，这可以节省代码以达到复用的效果，这些方法叫作具体方法。当代码需要改变时，我们只需要改动抽象类里的具体方法就可以了。比如饮料中的boilWater方法，假设冲泡所有的饮料之前，都要先把水煮沸，那我们自然可以把boilWater方法放在抽象类Beverage中。</p><h5 id="JavaScript没有抽象类的缺点和解决方案"><a href="#JavaScript没有抽象类的缺点和解决方案" class="headerlink" title="JavaScript没有抽象类的缺点和解决方案"></a>JavaScript没有抽象类的缺点和解决方案</h5><p>JavaScript并没有从语法层面提供对抽象类的支持。抽象类的第一个作用是隐藏对象的具体类型，由于JavaScript是一门“类型模糊”的语言，所以隐藏对象的类型在JavaScript中并不重要。</p><p>另一方面，当我们在JavaScript中使用原型继承来模拟传统的类式继承时，并没有编译器帮助我们进行任何形式的检查，我们也没有办法保证子类会重写父类中的“抽象方法”。</p><p>我们知道，Beverage.prototype.init方法作为模板方法，已经规定了子类的算法框架.</p><p>如果我们的Coffee类或者Tea类忘记实现这4个方法中的一个呢？拿brew方法举例，如果我们忘记编写Coffee.prototype.brew方法，那么当请求coffee对象的brew时，请求会顺着原型链找到Beverage“父类”对应的Beverage.prototype.brew方法，而Beverage.prototype.brew方法到目前为止是一个空方法，这显然是不能符合我们需要的。</p><p>在Java中编译器会保证子类会重写父类中的抽象方法，但在JavaScript中却没有进行这些检查工作。我们在编写代码的时候得不到任何形式的警告，完全寄托于程序员的记忆力和自觉性是很危险的，特别是当我们使用模板方法模式这种完全依赖继承而实现的设计模式时。</p><p>下面提供两种变通的解决方案。</p><ol><li>第1种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟业务逻辑无关的代码。</li><li>第2种方案是让Beverage.prototype.brew等方法直接抛出一个异常，如果因为粗心忘记编写Coffee.prototype.brew方法，那么至少我们会在程序运行时得到一个错误：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Beverage.prototype.brew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'子 类 必 须 重 写 brew 方 法'</span> ); &#125;; 　 　 </span><br><span class="line">Beverage.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'子 类 必 须 重 写 pourInCup 方 法'</span> ); &#125;;</span><br></pre></td></tr></table></figure></li></ol><p>第2种解决方案的优点是实现简单，付出的额外代价很少；缺点是我们得到错误信息的时间点太靠后。</p><p>我们一共有3次机会得到这个错误信息，第1次是在编写代码的时候，通过编译器的检查来得到错误信息；第2次是在创建对象的时候用鸭子类型来进行“接口检查”；而目前我们不得不利用最后一次机会，在程序运行过程中才知道哪里发生了错误。</p><h4 id="模板方法模式的使用场景"><a href="#模板方法模式的使用场景" class="headerlink" title="模板方法模式的使用场景"></a>模板方法模式的使用场景</h4><p>从大的方面来讲，模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架，程序员继承框架的结构之后，负责往里面填空，比如Java程序员大多使用过HttpServlet技术来开发项目。</p><p>一个基于HttpServlet的程序包含7个生命周期，这7个生命周期分别对应一个do方法。<code>doGet() doHead() doPost() doPut() doDelete() doOption() doTrace()</code></p><p>HttpServlet类还提供了一个service方法，它就是这里的模板方法，service规定了这些do方法的执行顺序，而这些do方法的具体实现则需要HttpServlet的子类来提供。</p><p>在Web开发中也能找到很多模板方法模式的适用场景，比如我们在构建一系列的UI组件，这些组件的构建过程一般如下所示：</p><ol><li>初始化一个div容器；</li><li>通过ajax请求拉取相应的数据；</li><li>把数据渲染到div容器里面，完成组件的构造；</li><li>通知用户组件渲染完毕。<br>我们看到，任何组件的构建都遵循上面的4步，其中第(1)步和第(4)步是相同的。第(2)步不同的地方只是请求ajax的远程地址，第(3)步不同的地方是渲染数据的方式。</li></ol><p>于是我们可以把这4个步骤都抽象到父类的模板方法里面，父类中还可以顺便提供第(1)步和第(4)步的具体实现。当子类继承这个父类之后，会重写模板方法里面的第(2)步和第(3)步。</p><h4 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h4><p>通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用于大多数子类的，但如果有一些特别“个性”的子类呢？比如我们在饮料类Beverage中封装了饮料的冲泡顺序.</p><p>这4个冲泡饮料的步骤适用于咖啡和茶，在我们的饮料店里，根据这4个步骤制作出来的咖啡和茶，一直顺利地提供给绝大部分客人享用。但有一些客人喝咖啡是不加调料（糖和牛奶）的。既然Beverage作为父类，已经规定好了冲泡饮料的4个步骤，那么有什么办法可以让子类不受这个约束呢？</p><p>钩子方法（hook）可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。</p><p>在这个例子里，我们把挂钩的名字定为customerWantsCondiments，接下来将挂钩放入Beverage类，看看我们如何得到一杯不需要糖和牛奶的咖啡，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Beverage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Beverage.prototype.boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'把 水 煮 沸'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Beverage.prototype.brew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子 类 必 须 重 写 brew 方 法'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Beverage.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子 类 必 须 重 写 pourInCup 方 法'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Beverage.prototype.addCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子 类 必 须 重 写 addCondiments 方 法'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Beverage.prototype.customerWantsCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 默 认 需 要 调 料 </span></span><br><span class="line">&#125;;</span><br><span class="line">Beverage.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.boilWater();</span><br><span class="line">  <span class="keyword">this</span>.brew();</span><br><span class="line">  <span class="keyword">this</span>.pourInCup();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.customerWantsCondiments()) &#123; <span class="comment">// 如 果 挂 钩 返 回 true， 则 需 要 调 料 </span></span><br><span class="line">    <span class="keyword">this</span>.addCondiments();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> CoffeeWithHook = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">CoffeeWithHook.prototype = <span class="keyword">new</span> Beverage();</span><br><span class="line">CoffeeWithHook.prototype.brew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'用 沸 水 冲 泡 咖 啡'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">CoffeeWithHook.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'把 咖 啡 倒 进 杯 子'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">CoffeeWithHook.prototype.addCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'加 糖 和 牛 奶'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">CoffeeWithHook.prototype.customerWantsCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.confirm(<span class="string">'请 问 需 要 调 料 吗？'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> coffeeWithHook = <span class="keyword">new</span> CoffeeWithHook();</span><br><span class="line">coffeeWithHook.init();</span><br></pre></td></tr></table></figure></p><h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><p>学习完模板方法模式之后，我们要引入一个新的设计原则——著名的“好莱坞原则”。好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。”</p><p>在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。</p><p>模板方法模式是好莱坞原则的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用。作为子类，只负责提供一些设计上的细节。</p><p>除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布-订阅模式和回调函数。</p><ul><li>在发布—订阅模式中，发布者会把消息推送给订阅者，这取代了原先不断去fetch消息的形式。例如假设我们乘坐出租车去一个不了解的地方，除了每过5秒钟就问司机“是否到达目的地”之外，还可以在车上美美地睡上一觉，然后跟司机说好，等目的地到了就叫醒你。这也相当于好莱坞原则中提到的“别调用我们，我们会调用你”。</li><li>在ajax异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传入发起ajax异步请求的函数。当数据返回之后，这个回调函数才被执行，这也是好莱坞原则的一种体现。把需要执行的操作封装在回调函数里，然后把主动权交给另外一个函数。至于回调函数什么时候被执行，则是另外一个函数控制的。</li></ul><h4 id="真的需要“继承”吗"><a href="#真的需要“继承”吗" class="headerlink" title="真的需要“继承”吗"></a>真的需要“继承”吗</h4><p>模板方法模式是基于继承的一种设计模式，父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好莱坞原则很好地诠释了这种设计技巧，即高层组件调用底层组件。</p><p>通过模板方法模式，编写了一个CoffeeorTea的例子。模板方法模式是为数不多的基于继承的设计模式，但JavaScript语言实际上没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。也就是说，虽然我们在形式上借鉴了提供类式继承的语言，但本次学习到的模板方法模式并不十分正宗。而且在JavaScript这般灵活的语言中，实现这样一个例子，是否真的需要继承这种重武器呢？</p><p>在好莱坞原则的指导之下，下面这段代码可以达到和继承一样的效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Beverage = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把 水 煮 沸'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> brew = param.brew || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必 须 传 递 brew 方 法'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> pourInCup = param.pourInCup || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必 须 传 递 pourInCup 方 法'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> addCondiments = param.addCondiments || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必 须 传 递 addCondiments 方 法'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    boilWater();</span><br><span class="line">    brew();</span><br><span class="line">    pourInCup();</span><br><span class="line">    addCondiments();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Coffee = Beverage(&#123;</span><br><span class="line">  brew: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用 沸 水 冲 泡 咖 啡'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  pourInCup: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把 咖 啡 倒 进 杯 子'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  addCondiments: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加 糖 和 牛 奶'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Tea = Beverage(&#123;</span><br><span class="line">  brew: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用 沸 水 浸 泡 茶 叶'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  pourInCup: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把 茶 倒 进 杯 子'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  addCondiments: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加 柠 檬'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">coffee.init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> Tea();</span><br><span class="line">tea.init();</span><br></pre></td></tr></table></figure></p><p>在这段代码中，我们把brew、pourInCup、addCondiments这些方法依次传入Beverage函数，Beverage函数被调用之后返回构造器F。F类中包含了“模板方法”F.prototype.init。跟继承得到的效果一样，该“模板方法”里依然封装了饮料子类的算法框架。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放-封闭原则的。</p><p>但在JavaScript中，我们很多时候都不需要依样画瓢地去实现一个模版方法模式，高阶函数是更好的选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在JavaScript开发中用到继承的场景其实并不是很多，很多时候我们都喜欢用mix-in的方式给对象扩展属性。但这不代表继承在JavaScript里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。模板方法（TemplateM
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-9-组合模式</title>
    <link href="https://github.com/xmoyKING/2017/11/21/js-pattern9/"/>
    <id>https://github.com/xmoyKING/2017/11/21/js-pattern9/</id>
    <published>2017-11-21T15:58:02.000Z</published>
    <updated>2017-12-06T14:50:09.337Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道地球和一些其他行星围绕着太阳旋转，也知道在一个原子中，有许多电子围绕着原子核旋转。在程序设计中，也有一些和“事物是由相似的子事物构成”类似的思想。组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的。</p><h4 id="回顾宏命令"><a href="#回顾宏命令" class="headerlink" title="回顾宏命令"></a>回顾宏命令</h4><p>在命令模式中讲解过宏命令的结构和作用。宏命令对象包含了一组具体的子命令对象，不管是宏命令对象，还是子命令对象，都有一个execute方法负责执行命令。回顾万能遥控器上的宏命令代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123; <span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="title">console</span>.<span class="title">log</span>(<span class="params"> <span class="string">'关 门'</span> </span>); &#125; &#125;; </span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">openPcCommand</span> = </span>&#123; execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="title">nsole</span>.<span class="title">log</span>(<span class="params"> <span class="string">'开 电 脑'</span> </span>); &#125; &#125;; </span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">openQQCommand</span> = </span>&#123; execute: functio)<span class="built_in">console</span>.log( <span class="string">'登 录 QQ'</span> ); &#125; &#125;; </span><br><span class="line"><span class="keyword">var</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">  return &#123; </span></span></span><br><span class="line"><span class="function"><span class="params">    commandsList: [], </span></span></span><br><span class="line"><span class="function"><span class="params">    add: function( command </span>)</span>&#123; <span class="keyword">this</span>.commandsList.push( command ); &#125;, </span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="keyword">this</span>.commandsList[ i++ ]; )&#123; </span><br><span class="line">        command.execute(); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add( closeDoorCommand ); </span><br><span class="line">macroCommand.add( openPcCommand ); </span><br><span class="line">macroCommand.add( openQQCommand ); </span><br><span class="line">macroCommand.execute();</span><br></pre></td></tr></table></figure></p><p>通过观察这段代码，我们很容易发现，宏命令中包含了一组子命令，它们组成了一个树形结构，这里是一棵结构非常简单的树。</p><p>其中，marcoCommand被称为组合对象，closeDoorCommand、openPcCommand、openQQCommand都是叶对象。在macroCommand的execute方法里，并不执行真正的操作，而是遍历它所包含的叶对象，把真正的execute请求委托给这些叶对象。</p><p>macroCommand表现得像一个命令，但它实际上只是一组真正命令的“代理”。并非真正的代理，虽然结构上相似，但macroCommand只负责传递请求给叶对象，它的目的不在于控制对叶对象的访问。</p><h4 id="组合模式的用途"><a href="#组合模式的用途" class="headerlink" title="组合模式的用途"></a>组合模式的用途</h4><p>组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，下面分别说明。</p><ul><li>表示树形结构。通过回顾上面的例子，我们很容易找到组合模式的一个优点：提供了一种遍历树形结构的方案，通过调用组合对象的execute方法，程序会递归调用组合对象下面的叶对象的execute方法，所以我们的万能遥控器只需要一次操作，便能依次完成关门、打开电脑、登录QQ这几件事情。组合模式可以非常方便地描述对象部分-整体层次结构。</li><li>利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象。</li></ul><p>这在实际开发中会给客户带来相当大的便利性，当我们往万能遥控器里面添加一个命令的时候，并不关心这个命令是宏命令还是普通子命令。这点对于我们不重要，我们只需要确定它是一个命令，并且这个命令拥有可执行的execute方法，那么这个命令就可以被添加进万能遥控器。当宏命令和普通子命令接收到执行execute方法的请求时，宏命令和普通子命令都会做它们各自认为正确的事情。这些差异是隐藏在客户背后的，在客户看来，这种透明性可以让我们非常自由地扩展这个万能遥控器。</p><h4 id="请求在树中传递的过程"><a href="#请求在树中传递的过程" class="headerlink" title="请求在树中传递的过程"></a>请求在树中传递的过程</h4><p>在组合模式中，请求在树中传递的过程总是遵循一种逻辑。以宏命令为例，请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象（普通子命令），叶对象自身会对请求作出相应的处理；如果当前处理请求的对象是组合对象（宏命令），组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。</p><p>总而言之，如果子节点是叶对象，叶对象自身会处理这个请求，而如果子节点还是组合对象，请求会继续往下传递。叶对象下面不会再有其他子节点，一个叶对象就是树的这条枝叶的尽头，组合对象下面可能还会有子节点.</p><p>请求从上到下沿着树进行传递，直到树的尽头。作为客户，只需要关心树最顶层的组合对象，客户只需要请求这个组合对象，请求便会沿着树往下传递，依次到达所有的叶对象。</p><p>在刚刚的例子中，由于宏命令和子命令组成的树太过简单，我们还不能清楚地看到组合模式带来的好处，如果只是简单地遍历一组子节点，迭代器便能解决所有的问题。接下来我们将创造一个更强大的宏命令，这个宏命令中又包含了另外一些宏命令和普通子命令，看起来是一棵相对较复杂的树。</p><h4 id="更强大的宏命令"><a href="#更强大的宏命令" class="headerlink" title="更强大的宏命令"></a>更强大的宏命令</h4><p>目前的万能遥控器，包含了关门、开电脑、登录QQ这3个命令。现在我们需要一个“超级万能遥控器”，可以控制家里所有的电器，这个遥控器拥有以下功能：</p><ul><li>打开空调</li><li>打开电视和音响</li><li>关门、开电脑、登录QQ<br>首先在节点中放置一个按钮button来表示这个超级万能遥控器，超级万能遥控器上安装了一个宏命令，当执行这个宏命令时，会依次遍历执行它所包含的子命令，代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      commandsList: [],</span><br><span class="line">      add: <span class="function"><span class="keyword">function</span>(<span class="params">command</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commandsList.push(command);</span><br><span class="line">      &#125;,</span><br><span class="line">      execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="keyword">this</span>.commandsList[i++];) &#123;</span><br><span class="line">          command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> openAcCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'打 开 空 调'</span>);&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/********** 家 里 的 电 视 和 音 响 是 连 接 在 一 起 的， 所 以 可 以 用 一 个 宏 命 令 来 组 合 打 开 电 视 和 打 开 音 响 的 命 令*********/</span></span><br><span class="line"><span class="keyword">var</span> openTvCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'打 开 电 视'</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> openSoundCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'打 开 音 响'</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> macroCommand1 = MacroCommand();</span><br><span class="line">macroCommand1.add(openTvCommand);</span><br><span class="line">macroCommand1.add(openSoundCommand); </span><br><span class="line"></span><br><span class="line"><span class="comment">/********* 关 门、 打 开 电 脑 和 打 登 录 QQ 的 命 令****************/</span></span><br><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'关 门'</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> openPcCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'开 电 脑'</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> openQQCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'登 录 QQ'</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> macroCommand2 = MacroCommand();</span><br><span class="line">macroCommand2.add(closeDoorCommand);</span><br><span class="line">macroCommand2.add(openPcCommand);</span><br><span class="line">macroCommand2.add(openQQCommand); </span><br><span class="line"></span><br><span class="line"><span class="comment">/********* 现 在 把 所 有 的 命 令 组 合 成 一 个“ 超 级 命 令”**********/</span></span><br><span class="line"><span class="keyword">var</span> macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add(openAcCommand);</span><br><span class="line">macroCommand.add(macroCommand1);</span><br><span class="line">macroCommand.add(macroCommand2); </span><br><span class="line"></span><br><span class="line"><span class="comment">/********* 最 后 给 遥 控 器 绑 定“ 超 级 命 令”**********/</span></span><br><span class="line"><span class="keyword">var</span> setCommand = (<span class="function"><span class="keyword">function</span>(<span class="params">command</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(macroCommand);</span><br></pre></td></tr></table></figure></li></ul><p>当按下遥控器的按钮时，所有命令都将被依次执行,从这个例子中可以看到，基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，这样不断递归下去，这棵树的结构可以支持任意多的复杂度。在树最终被构造完成之后，让整颗树最终运转起来的步骤非常简单，只需要调用最上层对象的execute方法。每当对最上层的对象进行一次请求时，实际上是在对整个树进行深度优先的搜索，而创建组合对象的程序员并不关心这些内在的细节，往这棵树里面添加一些新的节点对象是非常容易的事情。</p><h4 id="抽象类在组合模式中的作用"><a href="#抽象类在组合模式中的作用" class="headerlink" title="抽象类在组合模式中的作用"></a>抽象类在组合模式中的作用</h4><p>前面说到，组合模式最大的优点在于可以一致地对待组合对象和基本对象。客户不需要知道当前处理的是宏命令还是普通命令，只要它是一个命令，并且有execute方法，这个命令就可以被添加到树中。</p><p>这种透明性带来的便利，在静态类型语言中体现得尤为明显。比如在Java中，实现组合模式的关键是Composite类和Leaf类都必须继承自一个Compenent抽象类。这个Compenent抽象类既代表组合对象，又代表叶对象，它也能够保证组合对象和叶对象拥有同样名字的方法，从而可以对同一消息都做出反馈。组合对象和叶对象的具体类型被隐藏在Compenent抽象类身后。</p><p>针对Compenent抽象类来编写程序，客户操作的始终是Compenent对象，而不用去区分到底是组合对象还是叶对象。所以我们往同一个对象里的add方法里，既可以添加组合对象，也可以添加叶对象。</p><p>然而在JavaScript这种动态类型语言中，对象的多态性是与生俱来的，也没有编译器去检查变量的类型，所以我们通常不会去模拟一个“怪异”的抽象类，JavaScript中实现组合模式的难点在于要保证组合对象和叶对象对象拥有同样的方法，这通常需要用鸭子类型的思想对它们进行接口检查。在JavaScript中实现组合模式，看起来缺乏一些严谨性，我们的代码算不上安全，但能更快速和自由地开发，这既是JavaScript的缺点，也是它的优点。</p><p>####透明性带来的安全问题<br>组合模式的透明性使得发起请求的客户不用去顾忌树中组合对象和叶对象的区别，但它们在本质上有是区别的。</p><p>组合对象可以拥有子节点，叶对象下面就没有子节点，所以我们也许会发生一些误操作，比如试图往叶对象中添加子节点。解决方案通常是给叶对象也增加add方法，并且在调用这个方法时，抛出一个异常来及时提醒客户：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      commandsList: [],</span><br><span class="line">      add: <span class="function"><span class="keyword">function</span>(<span class="params">command</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commandsList.push(command);</span><br><span class="line">      &#125;,</span><br><span class="line">      execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="keyword">this</span>.commandsList[i++];) &#123;</span><br><span class="line">          command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> openTvCommand = &#123;</span><br><span class="line">  execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'打 开 电 视'</span>); &#125;,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'叶 对 象 不 能 添 加 子 节 点'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add(openTvCommand);</span><br><span class="line">openTvCommand.add(macroCommand) <span class="comment">// Uncaught Error: 叶 对 象 不 能 添 加 子 节 点</span></span><br></pre></td></tr></table></figure></p><h4 id="组合模式的例子——扫描文件夹"><a href="#组合模式的例子——扫描文件夹" class="headerlink" title="组合模式的例子——扫描文件夹"></a>组合模式的例子——扫描文件夹</h4><p>文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹里既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树，组合模式在文件夹的应用中有以下两层好处。</p><ul><li>例如，我在同事的移动硬盘里找到了一些电子书，想把它们复制到F盘中的学习资料文件夹。在复制这些电子书的时候，我并不需要考虑这批文件的类型，不管它们是单独的电子书还是被放在了文件夹中。组合模式让Ctrl+V、Ctrl+C成为了一个统一的操作。</li><li>当我用杀毒软件扫描该文件夹时，往往不会关心里面有多少文件和子文件夹，组合模式使得我们只需要操作最外层的文件夹进行扫描。<br>现在我们来编写代码，首先分别定义好文件夹Folder和文件File这两个类。见如下代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************* Folder ******************************/</span></span><br><span class="line"><span class="keyword">var</span> Folder = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.files = [];</span><br><span class="line">  &#125;;</span><br><span class="line">Folder.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.files.push(file);</span><br><span class="line">&#125;;</span><br><span class="line">Folder.prototype.scan = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'开 始 扫 描 文 件 夹: '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, file, files = ts.files; file = files[i++];) &#123;</span><br><span class="line">    file.scan();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/******************************* File ******************************/</span></span><br><span class="line"><span class="keyword">var</span> File = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;;</span><br><span class="line">File.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'文 件 下 面 不 能 再 添 加 文 件'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">File.prototype.scan = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'开 始 扫 描 文 件: '</span> + <span class="keyword">this</span>.name);;</span><br></pre></td></tr></table></figure></li></ul><p>接下来创建一些文件夹和文件对象，并且让它们组合成一棵树，这棵树就是我们F盘里的现有文件目录结构：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> folder = <span class="keyword">new</span> Folder(<span class="string">'学 习 资 料'</span>);</span><br><span class="line"><span class="keyword">var</span> folder1 = <span class="keyword">new</span> Folder(<span class="string">'JavaScript'</span>);</span><br><span class="line"><span class="keyword">var</span> folder2 = <span class="keyword">new</span> Folder(<span class="string">'jQuery'</span>);</span><br><span class="line"><span class="keyword">var</span> file1 = <span class="keyword">new</span> File(<span class="string">'JavaScript 设 计 模 式 与 开 发 实 践'</span>);</span><br><span class="line"><span class="keyword">var</span> file2 = <span class="keyword">new</span> File(<span class="string">'精 通 jQuery'</span>);</span><br><span class="line"><span class="keyword">var</span> file3 = <span class="keyword">new</span> File(<span class="string">'重 构 与 模 式'</span>) folder1.add(file1);</span><br><span class="line"></span><br><span class="line">folder2.add(file2);</span><br><span class="line">folder.add(folder1);</span><br><span class="line">folder.add(folder2);</span><br><span class="line">folder.add(file3);</span><br></pre></td></tr></table></figure></p><p>现在的需求是把移动硬盘里的文件和文件夹都复制到这棵树中，假设我们已经得到了这些文件对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> folder3 = <span class="keyword">new</span> Folder(<span class="string">'Nodejs'</span>);</span><br><span class="line"><span class="keyword">var</span> file4 = <span class="keyword">new</span> File(<span class="string">'深 入 浅 出 Node.js'</span>);</span><br><span class="line">folder3.add(file4);</span><br><span class="line"><span class="keyword">var</span> file5 = <span class="keyword">new</span> File(<span class="string">'JavaScript 语 言 精 髓 与 编 程 实 践'</span>);</span><br></pre></td></tr></table></figure></p><p>接下来就是把这些文件都添加到原有的树中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">folder.add( folder3 ); </span><br><span class="line">folder.add( file5 );</span><br></pre></td></tr></table></figure></p><p>通过这个例子，我们再次看到客户是如何同等对待组合对象和叶对象。在添加一批文件的操作过程中，客户不用分辨它们到底是文件还是文件夹。新增加的文件和文件夹能够很容易地添加到原来的树结构中，和树里已有的对象一起工作。我们改变了树的结构，增加了新的数据，却不用修改任何一句原有的代码，这是符合开放-封闭原则的。运用了组合模式之后，扫描整个文件夹的操作也是轻而易举的，我们只需要操作树的最顶端对象：<code>folder.scan();</code></p><h4 id="一些值得注意的地方"><a href="#一些值得注意的地方" class="headerlink" title="一些值得注意的地方"></a>一些值得注意的地方</h4><p>在使用组合模式的时候，还有以下几个值得我们注意的地方。</p><h5 id="组合模式不是父子关系"><a href="#组合模式不是父子关系" class="headerlink" title="组合模式不是父子关系"></a>组合模式不是父子关系</h5><p>组合模式的树型结构容易让人误以为组合对象和叶对象是父子关系，这是不正确的。组合模式是一种HAS-A（聚合）的关系，而不是IS-A。组合对象包含一组叶对象，但Leaf并不是Composite的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。为了方便描述，有时候把上下级对象称为父子节点，但它们并非真正意义上的父子关系。</p><h5 id="对叶对象操作的一致性"><a href="#对叶对象操作的一致性" class="headerlink" title="对叶对象操作的一致性"></a>对叶对象操作的一致性</h5><p>组合模式除了要求组合对象和叶对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性。比如公司要给全体员工发放元旦的过节费1000块，这个场景可以运用组合模式，但如果公司给今天过生日的员工发送一封生日祝福的邮件，组合模式在这里就没有用武之地了，除非先把今天过生日的员工挑选出来。只有用一致的方式对待列表中的每个叶对象的时候，才适合使用组合模式。</p><h5 id="双向映射关系"><a href="#双向映射关系" class="headerlink" title="双向映射关系"></a>双向映射关系</h5><p>发放过节费的通知步骤是从公司到各个部门，再到各个小组，最后到每个员工的邮箱里。这本身是一个组合模式的好例子，但要考虑的一种情况是，也许某些员工属于多个组织架构。比如某位架构师既隶属于开发组，又隶属于架构组，对象之间的关系并不是严格意义上的层次结构，在这种情况下，是不适合使用组合模式的，该架构师很可能会收到两份过节费。这种复合情况下我们必须给父节点和子节点建立双向映射关系，一个简单的方法是给小组和员工对象都增加集合来保存对方的引用。但是这种相互间的引用相当复杂，而且对象之间产生了过多的耦合性，修改或者删除一个对象都变得困难，此时我们可以引入中介者模式来管理这些对象。</p><h5 id="用职责链模式提高组合模式性能"><a href="#用职责链模式提高组合模式性能" class="headerlink" title="用职责链模式提高组合模式性能"></a>用职责链模式提高组合模式性能</h5><p>在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。有时候我们确实可以借助一些技巧，在实际操作中避免遍历整棵树，有一种现成的方案是借助职责链模式。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。</p><h4 id="引用父对象"><a href="#引用父对象" class="headerlink" title="引用父对象"></a>引用父对象</h4><p>在前面的例子中，组合对象保存了它下面的子节点的引用，这是组合模式的特点，此时树结构是从上至下的。但有时候我们需要在子节点上保持对父节点的引用，比如在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当我们删除某个文件的时候，实际上是从这个文件所在的上层文件夹中删除该文件的。</p><p>现在来改写扫描文件夹的代码，使得在扫描整个文件夹之前，我们可以先移除某一个具体的文件。首先改写Folder类和File类，在这两个类的构造函数中，增加this.parent属性，并且在调用add方法的时候，正确设置文件或者文件夹的父节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Folder = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = name; </span><br><span class="line">  <span class="keyword">this</span>.parent = <span class="literal">null</span>; <span class="comment">// 增 加 this.parent 属 性 </span></span><br><span class="line">  <span class="keyword">this</span>.files = []; </span><br><span class="line">&#125;; </span><br><span class="line">Folder.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"> file </span>)</span>&#123; </span><br><span class="line">  file.parent = <span class="keyword">this</span>; <span class="comment">// 设 置 父 对 象 </span></span><br><span class="line">  <span class="keyword">this</span>.files.push( file ); </span><br><span class="line">&#125;; </span><br><span class="line">Folder.prototype.scan = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'开 始 扫 描 文 件 夹: '</span> + <span class="keyword">this</span>.name ); </span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, file, files = <span class="keyword">this</span>.files; file = files[ i++ ]; )&#123; </span><br><span class="line">    file.scan(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来增加Folder.prototype.remove方法，表示移除该文件夹：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Folder.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span> ( !<span class="keyword">this</span>.parent )&#123; <span class="comment">// 根 节 点 或 者 树 外 的 游 离 节 点 </span></span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> files = <span class="keyword">this</span>.parent.files, l = files.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l-- )&#123;</span><br><span class="line">    <span class="keyword">var</span> file = files[ l ]; </span><br><span class="line">    <span class="keyword">if</span> ( file === <span class="keyword">this</span> )&#123; files.splice( l, <span class="number">1</span> ); &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在File.prototype.remove方法里，首先会判断this.parent，如果this.parent为null，那么这个文件夹要么是树的根节点，要么是还没有添加到树的游离节点，这时候没有节点需要从树中移除，我们暂且让remove方法直接return，表示不做任何操作。如果this.parent不为null，则说明该文件夹有父节点存在，此时遍历父节点中保存的子节点列表，删除想要删除的子节点。</p><p>File类的实现基本一致：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> File = <span class="function"><span class="keyword">function</span>(<span class="params"> name </span>)</span>&#123; <span class="keyword">this</span>.name = name; <span class="keyword">this</span>.parent = <span class="literal">null</span>; &#125;; </span><br><span class="line"></span><br><span class="line">File.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'不 能 添 加 在 文 件 下 面'</span> ); &#125;; </span><br><span class="line">File.prototype.scan = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开 始 扫 描 文 件: '</span> + <span class="keyword">this</span>.name ); &#125;; </span><br><span class="line">File.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span> ( !<span class="keyword">this</span>.parent )&#123; <span class="keyword">return</span>; &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> files = <span class="keyword">this</span>.parent.files, l = files.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l-- )&#123; </span><br><span class="line">    <span class="keyword">var</span> file = files[ l ]; </span><br><span class="line">    <span class="keyword">if</span> ( file === <span class="keyword">this</span> )&#123; files.splice( l, <span class="number">1</span> ); &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="何时使用组合模式"><a href="#何时使用组合模式" class="headerlink" title="何时使用组合模式"></a>何时使用组合模式</h4><p>组合模式如果运用得当，可以大大简化客户的代码。一般来说，组合模式适用于以下这两种情况。</p><ul><li>表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放-封闭原则。</li><li>客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆if、else语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。</li></ul><p>组合模式可以让我们使用树形方式创建对象的结构。我们可以把相同的操作应用在组合对象和单个对象上。在大多数情况下，我们都可以忽略掉组合对象和单个对象之间的差别，从而用一致的方式来处理它们。</p><p>然而，组合模式并不是完美的，它可能会产生一个这样的系统：系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解。此外，如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道地球和一些其他行星围绕着太阳旋转，也知道在一个原子中，有许多电子围绕着原子核旋转。在程序设计中，也有一些和“事物是由相似的子事物构成”类似的思想。组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的。&lt;/p&gt;
&lt;h4 id=&quot;
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-8-命令模式</title>
    <link href="https://github.com/xmoyKING/2017/11/19/js-pattern8/"/>
    <id>https://github.com/xmoyKING/2017/11/19/js-pattern8/</id>
    <published>2017-11-19T15:51:14.000Z</published>
    <updated>2017-12-06T14:50:09.337Z</updated>
    
    <content type="html"><![CDATA[<p>假设有一个快餐店，而我是该餐厅的点餐服务员，那么我一天的工作应该是这样的：</p><p>当某位客人点餐或者打来订餐电话后，我会把他的需求都写在清单上，然后交给厨房，客人不用关心是哪些厨师帮他炒菜。我们餐厅还可以满足客人需要的定时服务，比如客人可能当前正在回家的路上，要求1个小时后才开始炒他的菜，只要订单还在，厨师就不会忘记。</p><p>客人也可以很方便地打电话来撤销订单。另外如果有太多的客人点餐，厨房可以按照订单的顺序排队炒菜。这些记录着订餐信息的清单，便是命令模式中的命令对象。</p><h4 id="命令模式的用途"><a href="#命令模式的用途" class="headerlink" title="命令模式的用途"></a>命令模式的用途</h4><p>命令模式是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令。</p><p>命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p><p>拿订餐来说，客人需要向厨师发送请求，但是完全不知道这些厨师的名字和联系方式，也不知道厨师炒菜的方式和步骤。命令模式把客人订餐的请求封装成command对象，也就是订餐中的订单对象。这个对象可以在程序中被四处传递，就像订单可以从服务员手中传到厨师的手中。这样一来，客人不需要知道厨师的名字，从而解开了请求调用者和请求接收者之间的耦合关系。</p><p>另外，相对于过程化的请求调用，command对象拥有更长的生命周期。对象的生命周期是跟初始请求无关的，因为这个请求已经被封装在了command对象的方法中，成为了这个对象的行为。我们可以在程序运行的任意时刻去调用这个方法，就像厨师可以在客人预定1个小时之后才帮他炒菜，相当于程序在1个小时之后才开始执行command对象的方法。</p><p>除了这两点之外，命令模式还支持撤销、排队等操作.</p><h4 id="命令模式的例子——菜单程序"><a href="#命令模式的例子——菜单程序" class="headerlink" title="命令模式的例子——菜单程序"></a>命令模式的例子——菜单程序</h4><p>假设我们正在编写一个用户界面程序，该用户界面上至少有数十个Button按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。</p><p>在大型项目开发中，这是很正常的分工。对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新菜单界面，也可能用来增加一些子菜单，他只知道点击这个按钮会发生某些事情。那么当完成这个按钮的绘制之后，应该如何给它绑定onclick事件呢？</p><p>回想一下命令模式的应用场景：</p><p>有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p><p>我们很快可以找到在这里运用命令模式的理由：点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。</p><p>设计模式的主题总是把不变的事物和变化的事物分离开来，命令模式也不例外。按下按钮之后会发生一些事情是不变的，而具体会发生什么事情是可变的。通过command对象的帮助，将来我们可以轻易地改变这种关联，因此也可以在将来再次改变按钮的行为。</p><p>首先在页面中完成3个button按钮的“绘制”，接下来定义setCommand函数，setCommand函数负责往按钮上面安装命令。可以肯定的是，点击按钮会执行某个command命令，执行命令的动作被约定为调用command对象的execute()方法。虽然还不知道这些命令究竟代表什么操作，但负责绘制按钮的程序员不关心这些事情，他只需要预留好安装命令的接口，command对象自然知道如何和正确的对象沟通：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> button, command </span>)</span>&#123; button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; command.execute(); &#125; &#125;;</span><br></pre></td></tr></table></figure></p><p>最后，负责编写点击按钮之后的具体行为的程序员总算交上了他们的成果，他们完成了刷新菜单界面、增加子菜单和删除子菜单这几个功能，这几个功能被分布在MenuBar和SubMenu这两个对象中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MenuBar = &#123; </span><br><span class="line">  refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'刷 新 菜 单 目 录'</span> ); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SubMenu = &#123; </span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'增 加 子 菜 单'</span> ); &#125;, </span><br><span class="line">  del: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'删 除 子 菜 单'</span> ); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在让button变得有用起来之前，我们要先把这些行为都封装在命令类中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver </span>)</span>&#123; <span class="keyword">this</span>.receiver = receiver; &#125;; </span><br><span class="line">RefreshMenuBarCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.receiver.refresh(); &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AddSubMenuCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver </span>)</span>&#123; <span class="keyword">this</span>.receiver = receiver; &#125;; </span><br><span class="line">AddSubMenuCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.receiver.add();&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DelSubMenuCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver </span>)</span>&#123; <span class="keyword">this</span>.receiver = receiver; &#125;; </span><br><span class="line">DelSubMenuCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'删 除 子 菜 单'</span> ); &#125;;</span><br></pre></td></tr></table></figure></p><p>最后就是把命令接收者传入到command对象中，并且把command对象安装到button上面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = <span class="keyword">new</span> RefreshMenuBarCommand( MenuBar ); </span><br><span class="line"><span class="keyword">var</span> addSubMenuCommand = <span class="keyword">new</span> AddSubMenuCommand( SubMenu ); </span><br><span class="line"><span class="keyword">var</span> delSubMenuCommand = <span class="keyword">new</span> DelSubMenuCommand( SubMenu ); </span><br><span class="line"></span><br><span class="line">setCommand( button1, refreshMenuBarCommand );</span><br><span class="line">setCommand( button2, addSubMenuCommand ); </span><br><span class="line">setCommand( button3, delSubMenuCommand );</span><br></pre></td></tr></table></figure></p><p>以上只是一个很简单的命令模式示例，但从中可以看到我们是如何把请求发送者和请求接收者解耦开的。</p><h4 id="JavaScript中的命令模式"><a href="#JavaScript中的命令模式" class="headerlink" title="JavaScript中的命令模式"></a>JavaScript中的命令模式</h4><p>也许我们会感到很奇怪，所谓的命令模式，看起来就是给对象的某个方法取了execute的名字。引入command对象和receiver这两个无中生有的角色无非是把简单的事情复杂化了，即使不用什么模式，用下面寥寥几行代码就可以实现相同的功能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bindClick = <span class="function"><span class="keyword">function</span>(<span class="params"> button, func </span>)</span>&#123; button.onclick = func; &#125;; </span><br><span class="line"><span class="keyword">var</span> MenuBar = &#123; </span><br><span class="line">  refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'刷 新 菜 单 界 面'</span> ); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> SubMenu = &#123; </span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'增 加 子 菜 单'</span> ); &#125;, </span><br><span class="line">  del: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'删 除 子 菜 单'</span> ); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">bindClick( button1, MenuBar.refresh ); </span><br><span class="line">bindClick( button2, SubMenu.add );</span><br><span class="line">bindClick( button3, SubMenu.del );</span><br></pre></td></tr></table></figure></p><p>这种说法是正确的，上面的示例代码是模拟传统面向对象语言的命令模式实现。命令模式将过程式的请求调用封装在command对象的execute方法里，通过封装方法调用，我们可以把运算块包装成形。command对象可以被四处传递，所以在调用命令的时候，客户（Client）不需要关心事情是如何进行的。</p><p>命令模式的由来，其实是回调（callback）函数的一个面向对象的替代品。</p><p>JavaScript作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到了JavaScript语言之中。运算块不一定要封装在command.execute方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以被四处传递。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。</p><p>在面向对象设计中，命令模式的接收者被当成command对象的属性保存起来，同时约定执行命令的操作调用command.execute方法。在使用闭包的命令模式实现中，接收者被封闭在闭包产生的环境中，执行命令的操作可以更加简单，仅仅执行回调函数即可。无论接收者被保存为对象的属性，还是被封闭在闭包产生的环境中，在将来执行命令的时候，接收者都能被顺利访问。用闭包实现的命令模式如下代码所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> button, func </span>)</span>&#123; button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; func(); &#125; &#125;; </span><br><span class="line"><span class="keyword">var</span> MenuBar = &#123; <span class="attr">refresh</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'刷 新 菜 单 界 面'</span> ); &#125; &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver </span>)</span>&#123; <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; receiver.refresh(); &#125; &#125;; </span><br><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar ); </span><br><span class="line"></span><br><span class="line">setCommand( button1, refreshMenuBarCommand );</span><br></pre></td></tr></table></figure></p><p>当然，如果想更明确地表达当前正在使用命令模式，或者除了执行命令之外，将来有可能还要提供撤销命令等操作。那我们最好还是把执行函数改为调用execute方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver </span>)</span>&#123; <span class="keyword">return</span> &#123; <span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; receiver.refresh(); &#125; &#125; &#125;; </span><br><span class="line"><span class="keyword">var</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> button, command </span>)</span>&#123; button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; command.execute(); &#125; &#125;; </span><br><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar ); </span><br><span class="line"></span><br><span class="line">setCommand( button1, refreshMenuBarCommand );</span><br></pre></td></tr></table></figure></p><h4 id="撤销命令"><a href="#撤销命令" class="headerlink" title="撤销命令"></a>撤销命令</h4><p>命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。就像订餐时客人可以通过电话来取消订单一样。下面来看撤销命令的例子。本节的目标是利用Animate类来编写一个动画，这个动画的表现是让页面上的小球移动到水平方向的某个位置。现在页面中有一个input文本框和一个button按钮，文本框中可以输入一些数字，表示小球移动后的水平位置，小球在用户点击按钮后立刻开始移动，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ball = <span class="built_in">document</span>.getElementById( <span class="string">'ball'</span> ); </span><br><span class="line"><span class="keyword">var</span> pos = <span class="built_in">document</span>.getElementById( <span class="string">'pos'</span> ); </span><br><span class="line"><span class="keyword">var</span> moveBtn = <span class="built_in">document</span>.getElementById( <span class="string">'moveBtn'</span> ); </span><br><span class="line"></span><br><span class="line">moveBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> animate = <span class="keyword">new</span> Animate( ball ); </span><br><span class="line">  animate.start( <span class="string">'left'</span>, pos.value, <span class="number">1000</span>, <span class="string">'strongEaseOut'</span> ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果文本框输入200，然后点击moveBtn按钮，可以看到小球顺利地移动到水平方向200px的位置。现在我们需要一个方法让小球还原到开始移动之前的位置。当然也可以在文本框中再次输入-200，并且点击moveBtn按钮，这也是一个办法，不过显得很笨拙。页面上最好有一个撤销按钮，点击撤销按钮之后，小球便能回到上一次的位置。在给页面中增加撤销按钮之前，先把目前的代码改为用命令模式实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ball = <span class="built_in">document</span>.getElementById( <span class="string">'ball'</span> );</span><br><span class="line"><span class="keyword">var</span> pos = <span class="built_in">document</span>.getElementById( <span class="string">'pos'</span> ); </span><br><span class="line"><span class="keyword">var</span> moveBtn = <span class="built_in">document</span>.getElementById( <span class="string">'moveBtn'</span> ); </span><br><span class="line"><span class="keyword">var</span> MoveCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver, pos </span>)</span>&#123; <span class="keyword">this</span>.receiver = receiver; <span class="keyword">this</span>.pos = pos; &#125;; </span><br><span class="line"></span><br><span class="line">MoveCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.receiver.start( <span class="string">'left'</span>, <span class="keyword">this</span>.pos, <span class="number">1000</span>, <span class="string">'strongEaseOut'</span> ); &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> moveCommand; </span><br><span class="line">moveBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> animate = <span class="keyword">new</span> Animate( ball ); </span><br><span class="line">  moveCommand = <span class="keyword">new</span> MoveCommand( animate, pos.value ); </span><br><span class="line">  moveCommand.execute(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来增加撤销按钮,撤销操作的实现一般是给命令对象增加一个名为unexecude或者undo的方法，在该方法里执行execute的反向操作。在command.execute方法让小球开始真正运动之前，我们需要先记录小球的当前位置，在unexecude或者undo操作中，再让小球回到刚刚记录下的位置，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ball = <span class="built_in">document</span>.getElementById(<span class="string">'ball'</span>);</span><br><span class="line"><span class="keyword">var</span> pos = <span class="built_in">document</span>.getElementById(<span class="string">'pos'</span>);</span><br><span class="line"><span class="keyword">var</span> moveBtn = <span class="built_in">document</span>.getElementById(<span class="string">'moveBtn'</span>);</span><br><span class="line"><span class="keyword">var</span> cancelBtn = <span class="built_in">document</span>.getElementById(<span class="string">'cancelBtn'</span>);</span><br><span class="line"><span class="keyword">var</span> MoveCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver, pos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    <span class="keyword">this</span>.pos = pos;</span><br><span class="line">    <span class="keyword">this</span>.oldPos = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">MoveCommand.prototype.execute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.receiver.start(<span class="string">'left'</span>, <span class="keyword">this</span>.pos, <span class="number">1000</span>, <span class="string">'strongEaseOut'</span>);</span><br><span class="line">  <span class="keyword">this</span>.oldPos = <span class="keyword">this</span>.receiver.dom.getBoundingClientRect()[<span class="keyword">this</span>.receiver.propertyName]; <span class="comment">// 记 录 小 球 开 始 移 动 前 的 位 置 </span></span><br><span class="line">&#125;; </span><br><span class="line">MoveCommand.prototype.undo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.receiver.start( <span class="string">'left'</span>, <span class="keyword">this</span>.oldPos, <span class="number">1000</span>, <span class="string">'strongEaseOut'</span> ); <span class="comment">// 回 到 小 球 移 动 前 记 录 的 位 置 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> moveCommand; moveBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> animate = <span class="keyword">new</span> Animate( ball ); </span><br><span class="line">  moveCommand = <span class="keyword">new</span> MoveCommand( animate, pos.value ); </span><br><span class="line">  moveCommand.execute(); </span><br><span class="line">&#125;; </span><br><span class="line">cancelBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  moveCommand.undo(); <span class="comment">// 撤 销 命 令 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>现在通过命令模式轻松地实现了撤销功能。如果用普通的方法调用来实现，也许需要每次都手工记录小球的运动轨迹，才能让它还原到之前的位置。而命令模式中小球的原始位置在小球开始移动前已经作为command对象的属性被保存起来，所以只需要再提供一个undo方法，并且在undo方法中让小球回到刚刚记录的原始位置就可以了。撤销是命令模式里一个非常有用的功能，试想一下开发一个围棋程序的时候，我们把每一步棋子的变化都封装成命令，则可以轻而易举地实现悔棋功能。同样，撤销命令还可以用于实现文本编辑器的Ctrl+Z功能。</p><h4 id="撤消和重做"><a href="#撤消和重做" class="headerlink" title="撤消和重做"></a>撤消和重做</h4><p>上一节我们讨论了如何撤销一个命令。很多时候，我们需要撤销一系列的命令。比如在一个围棋程序中，现在已经下了10步棋，我们需要一次性悔棋到第5步。在这之前，我们可以把所有执行过的下棋命令都储存在一个历史列表中，然后倒序循环来依次执行这些命令的undo操作，直到循环执行到第5个命令为止。</p><p>然而，在某些情况下无法顺利地利用undo操作让对象回到execute之前的状态。比如在一个Canvas画图的程序中，画布上有一些点，我们在这些点之间画了N条曲线把这些点相互连接起来，当然这是用命令模式来实现的。但是我们却很难为这里的命令对象定义一个擦除某条曲线的undo操作，因为在Canvas画图中，擦除一条线相对不容易实现。</p><p>这时候最好的办法是先清除画布，然后把刚才执行过的命令全部重新执行一遍，这一点同样可以利用一个历史列表堆栈办到。记录命令日志，然后重复执行它们，这是逆转不可逆命令的一个好办法。</p><p>在HTML5版《街头霸王》游戏中，命令模式可以用来实现播放录像功能。原理跟Canvas画图的例子一样，我们把用户在键盘的输入都封装成命令，执行过的命令将被存放到堆栈中。播放录像的时候只需要从头开始依次执行这些命令便可，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Ryu = &#123;</span><br><span class="line">  attack: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'攻 击'</span> ); &#125;, </span><br><span class="line">  defense: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'防 御'</span> ); &#125;, </span><br><span class="line">  jump: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'跳 跃'</span> ); &#125;, </span><br><span class="line">  crouch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'蹲 下'</span> ); &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> makeCommand = <span class="function"><span class="keyword">function</span>(<span class="params"> receiver, state </span>)</span>&#123; <span class="comment">// 创 建 命 令 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; receiver[ state ](); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> commands = &#123; </span><br><span class="line">  <span class="string">"119"</span>: <span class="string">"jump"</span>, <span class="comment">// W </span></span><br><span class="line">  <span class="string">"115"</span>: <span class="string">"crouch"</span>, <span class="comment">// S </span></span><br><span class="line">  <span class="string">"97"</span>: <span class="string">"defense"</span>, <span class="comment">// A </span></span><br><span class="line">  <span class="string">"100"</span>: <span class="string">"attack"</span> <span class="comment">// D </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> commandStack = []; <span class="comment">// 保 存 命 令 的 堆 栈 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params"> ev </span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> keyCode = ev.keyCode, </span><br><span class="line">      command = makeCommand( Ryu, commands[ keyCode ] );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( command )&#123; </span><br><span class="line">    command(); <span class="comment">// 执 行 命 令 </span></span><br><span class="line">    commandStack.push( command ); <span class="comment">// 将 刚 刚 执 行 过 的 命 令 保 存 进 堆 栈 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">'replay'</span> ).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 点 击 播 放 录 像 </span></span><br><span class="line">  <span class="keyword">var</span> command; </span><br><span class="line">  <span class="keyword">while</span>( command = commandStack.shift() )&#123; <span class="comment">// 从 堆 栈 里 依 次 取 出 命 令 并 执 行 </span></span><br><span class="line">    command(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="命令队列"><a href="#命令队列" class="headerlink" title="命令队列"></a>命令队列</h4><p>在订餐的故事中，如果订单的数量过多而厨师的人手不够，则可以让这些订单进行排队处理。第一个订单完成之后，再开始执行跟第二个订单有关的操作。</p><p>队列在动画中的运用场景也非常多，比如之前的小球运动程序有可能遇到另外一个问题：有些用户反馈，这个程序只适合于APM小于20的人群，大部分用户都有快速连续点击按钮的习惯，当用户第二次点击button的时候，此时小球的前一个动画可能尚未结束，于是前一个动画会骤然停止，小球转而开始第二个动画的运动过程。但这并不是用户的期望，用户希望这两个动画会排队进行。</p><p>把请求封装成命令对象的优点在这里再次体现了出来，对象的生命周期几乎是永久的，除非我们主动去回收它。也就是说，命令对象的生命周期跟初始请求发生的时间无关，command对象的execute方法可以在程序运行的任何时刻执行，即使点击按钮的请求早已发生，但我们的命令对象仍然是有生命的。</p><p>所以我们可以把div的这些运动过程都封装成命令对象，再把它们压进一个队列堆栈，当动画执行完，也就是当前command对象的职责完成之后，会主动通知队列，此时取出正在队列中等待的第一个命令对象，并且执行它。</p><p>我们比较关注的问题是，一个动画结束后该如何通知队列。通常可以使用回调函数来通知队列，除了回调函数之外，还可以选择发布-订阅模式。即在一个动画结束后发布一个消息，订阅者接收到这个消息之后，便开始执行队列里的下一个动画。</p><h4 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h4><p>宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。想象一下，家里有一个万能遥控器，每天回家的时候，只要按一个特别的按钮，它就会帮我们关上房间门，顺便打开电脑并登录QQ。</p><p>下面我们看看如何逐步创建一个宏命令。首先，我们依然要创建好各种Command：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123; <span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'关 门'</span> ); &#125; &#125;; </span><br><span class="line"><span class="keyword">var</span> openPcCommand = &#123; <span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'开 电 脑'</span> ); &#125; &#125;; </span><br><span class="line"><span class="keyword">var</span> openQQCommand = &#123; <span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'登 录 QQ'</span> ); &#125; &#125;;</span><br></pre></td></tr></table></figure></p><p>接下来定义宏命令MacroCommand，它的结构也很简单。macroCommand.add方法表示把子命令添加进宏命令对象，当调用宏命令对象的execute方法时，会迭代这一组子命令对象，并且依次执行它们的execute方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MacroCommand = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    commandsList: [], </span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"> command </span>)</span>&#123; <span class="keyword">this</span>.commandsList.push( command ); &#125;, </span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="keyword">this</span>.commandsList[ i++ ]; )&#123; </span><br><span class="line">        command.execute(); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> macroCommand = MacroCommand();</span><br><span class="line">macroCommand.add( closeDoorCommand ); </span><br><span class="line">macroCommand.add( openPcCommand ); </span><br><span class="line">macroCommand.add( openQQCommand ); </span><br><span class="line">macroCommand.execute();</span><br></pre></td></tr></table></figure></p><p>当然我们还可以为宏命令添加撤销功能，跟macroCommand.execute类似，当调用macroCommand.undo方法时，宏命令里包含的所有子命令对象要依次执行各自的undo操作。宏命令是命令模式与组合模式的联用产物，关于组合模式，将在后面详细介绍。</p><h4 id="智能命令与傻瓜命令"><a href="#智能命令与傻瓜命令" class="headerlink" title="智能命令与傻瓜命令"></a>智能命令与傻瓜命令</h4><p>再看一下我们创建的关门命令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123; <span class="attr">execute</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'关 门'</span> ); &#125; &#125;;</span><br></pre></td></tr></table></figure></p><p>很奇怪，closeDoorCommand中没有包含任何receiver的信息，它本身就包揽了执行请求的行为，这跟我们之前看到的命令对象都包含了一个receiver是矛盾的。</p><p>一般来说，命令模式都会在command对象中保存一个接收者来负责真正执行客户的请求，这种情况下命令对象是“傻瓜式”的，它只负责把客户的请求转交给接收者来执行，这种模式的好处是请求发起者和请求接收者之间尽可能地得到了解耦。</p><p>但是我们也可以定义一些更“聪明”的命令对象，“聪明”的命令对象可以直接实现请求，这样一来就不再需要接收者的存在，这种“聪明”的命令对象也叫作智能命令。没有接收者的智能命令，退化到和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们意图的不同。策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标的不同手段，它们的内部实现是针对“算法”而言的。而智能命令模式指向的问题域更广，command对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JavaScript可以用高阶函数非常方便地实现命令模式。命令模式在JavaScript语言中是一种隐形的模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设有一个快餐店，而我是该餐厅的点餐服务员，那么我一天的工作应该是这样的：&lt;/p&gt;
&lt;p&gt;当某位客人点餐或者打来订餐电话后，我会把他的需求都写在清单上，然后交给厨房，客人不用关心是哪些厨师帮他炒菜。我们餐厅还可以满足客人需要的定时服务，比如客人可能当前正在回家的路上，要求1
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-7-发布-订阅模式（观察者模式）</title>
    <link href="https://github.com/xmoyKING/2017/11/17/js-pattern7/"/>
    <id>https://github.com/xmoyKING/2017/11/17/js-pattern7/</id>
    <published>2017-11-17T14:38:20.000Z</published>
    <updated>2017-12-06T14:50:09.337Z</updated>
    
    <content type="html"><![CDATA[<p>发布-订阅模式（观察者模式）定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布—订阅模式。</p><p>不论是在程序世界里还是现实生活中，发布—订阅模式的应用都非常之广泛。先看一个现实中的例子。</p><p>小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼MM告诉小明，不久后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。</p><p>于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个星期过后，售楼MM决定辞职，因为厌倦了每天回答1000个相同内容的电话。</p><p>当然现实中没有这么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在了售楼处。售楼MM答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼MM会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。</p><h4 id="发布－订阅模式的作用"><a href="#发布－订阅模式的作用" class="headerlink" title="发布－订阅模式的作用"></a>发布－订阅模式的作用</h4><p>在刚刚的例子中，发送短信通知就是一个典型的发布—订阅模式，小明、小红等购买者都是订阅者，他们订阅了房子开售的消息。售楼处作为发布者，会在合适的时候遍历花名册上的电话号码，依次给购房者发布消息。<br>可以发现，在这个例子中使用发布—订阅模式有着显而易见的优点。</p><ul><li>购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。</li><li>购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购房者的任何情况，不管购房者是男是女还是一只猴子。而售楼处的任何变动也不会影响购买者，比如售楼MM离职，售楼处从一楼搬到二楼，这些改变都跟购房者无关，只要售楼处记得发短信这件事情。</li></ul><p>第一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅ajax请求的error、succ等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。</p><p>第二点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</p><h4 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h4><p>实际上，只要我们曾经在DOM节点上面绑定过事件函数，那我们就曾经使用过发布—订阅模式，来看看下面这两句简单的代码发生了什么事情：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert( <span class="number">2</span>); </span><br><span class="line">&#125;, <span class="literal">false</span> ); </span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.click(); <span class="comment">// 模 拟 用 户 点 击</span></span><br></pre></td></tr></table></figure></p><p>在这里需要监控用户点击document.body的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅document.body上的click事件，当body节点被点击时，body节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息后等待售楼处发布消息。</p><p>当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert( <span class="number">2</span>); &#125;, <span class="literal">false</span> );</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert( <span class="number">3</span>); &#125;, <span class="literal">false</span> );</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert( <span class="number">4</span>); &#125;, <span class="literal">false</span> ); </span><br><span class="line"><span class="built_in">document</span>.body.click();<span class="comment">//模拟用户点击</span></span><br></pre></td></tr></table></figure></p><p>注意，手动触发事件更好的做法是IE下用fireEvent，标准浏览器下用dispatchEvent实现。</p><h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>除了DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布—订阅模式可以用于任何JavaScript代码中。现在看看如何一步步实现发布—订阅模式。</p><ol><li>首先要指定好谁充当发布者（比如售楼处）；</li><li>然后给发布者添加一个缓存列表（售楼处的花名册），用于存放回调函数以便通知订阅者；</li><li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）。</li></ol><p>另外，我们还可以往回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如售楼处可以在发给订阅者的短信里加上房子的单价、面积、容积率等信息，订阅者接收到这些信息之后可以进行各自的处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;; <span class="comment">// 定 义 售 楼 处 </span></span><br><span class="line">salesOffices.clientList = []; <span class="comment">// 缓 存 列 表， 存 放 订 阅 者 的 回 调 函 数 </span></span><br><span class="line"></span><br><span class="line">salesOffices.listen = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>)</span>&#123; <span class="comment">// 增 加 订 阅 者 </span></span><br><span class="line">  <span class="keyword">this</span>.clientList.push( fn ); <span class="comment">// 订 阅 的 消 息 添 加 进 缓 存 列 表 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">salesOffices.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 发 布 消 息 </span></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = <span class="keyword">this</span>.clientList[ i++ ]; )&#123; </span><br><span class="line">    fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); <span class="comment">// (2) // arguments 是 发 布 消 息 时 带 上 的 参 数 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>进行一些简单的测试：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">salesOffices.listen( <span class="function"><span class="keyword">function</span>(<span class="params"> price, squareMeter </span>)</span>&#123; <span class="comment">// 小 明 订 阅 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'squareMeter = '</span> + squareMeter ); </span><br><span class="line">&#125;); </span><br><span class="line">salesOffices.listen( <span class="function"><span class="keyword">function</span>(<span class="params"> price, squareMeter </span>)</span>&#123; <span class="comment">// 小 红 订 阅 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'squareMeter = '</span> + squareMeter ); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">salesOffices.trigger( <span class="number">2000000</span>, <span class="number">88</span> ); <span class="comment">// 2次输 出： 200 万， 88 平 方 米 </span></span><br><span class="line">salesOffices.trigger( <span class="number">3000000</span>, <span class="number">110</span> ); <span class="comment">// 2次输 出： 300 万， 110 平 方 米</span></span><br></pre></td></tr></table></figure></p><p>这里还存在一些问题。我们看到订阅者接收到了发布者发布的每个消息（每个消息都输出了2次），虽然小明只想买88平方米的房子，但是发布者把110平方米的信息也推送给了小明，这对小明来说是不必要的困扰。所以我们有必要增加一个标示key，让订阅者只订阅自己感兴趣的消息。改写后的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;; <span class="comment">// 定 义 售 楼 处 </span></span><br><span class="line">salesOffices.clientList = &#123;&#125;; <span class="comment">// 缓 存 列 表， 存 放 订 阅 者 的 回 调 函 数 </span></span><br><span class="line">salesOffices.listen = <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span> ( !<span class="keyword">this</span>.clientList[ key ] )&#123; <span class="comment">// 如 果 还 没 有 订 阅 过 此 类 消 息， 给 该 类 消 息 创 建 一 个 缓 存 列 表 </span></span><br><span class="line">    <span class="keyword">this</span>.clientList[ key ] = []; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">this</span>.clientList[ key ].push( fn ); <span class="comment">// 订 阅 的 消 息 添 加 进 消 息 缓 存 列 表 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 发 布 消 息 </span></span><br><span class="line">  <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call( <span class="built_in">arguments</span> ), <span class="comment">// 取 出 消 息 类 型 </span></span><br><span class="line">  fns = <span class="keyword">this</span>.clientList[ key ]; <span class="comment">// 取 出 该 消 息 对 应 的 回 调 函 数 集 合 </span></span><br><span class="line">  <span class="keyword">if</span> ( !fns || fns.length === <span class="number">0</span> )&#123; <span class="comment">// 如 果 没 有 订 阅 该 消 息， 则 返 回   </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[ i++ ]; )&#123; </span><br><span class="line">    fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); <span class="comment">// arguments 是 发 布 消 息 时 附 送 的 参 数 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter88'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小 明 订 阅 88 平 方 米 房 子 的 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); <span class="comment">// 输 出： 2000000 </span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter110'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小 红 订 阅 110 平 方 米 房 子 的 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); <span class="comment">// 输 出： 3000000 </span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">salesOffices.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 发 布 88 平 方 米 房 子 的 价 格</span></span><br><span class="line"></span><br><span class="line">salesOffices.trigger( <span class="string">'squareMeter110'</span>, <span class="number">3000000</span> ); <span class="comment">// 发 布 110 平 方 米 房 子 的 价 格</span></span><br></pre></td></tr></table></figure></p><p>很明显，现在订阅者可以只订阅自己感兴趣的事件了。</p><h4 id="发布－订阅模式的通用实现"><a href="#发布－订阅模式的通用实现" class="headerlink" title="发布－订阅模式的通用实现"></a>发布－订阅模式的通用实现</h4><p>现在我们已经看到了如何让售楼处拥有接受订阅和发布事件的功能。假设现在小明又去另一个售楼处买房子，那么这段代码是否必须在另一个售楼处对象上重写一次呢，有没有办法可以让所有对象都拥有发布—订阅功能呢？</p><p>JavaScript作为一门解释执行的语言，给对象动态添加职责是理所当然的事情。所以我们把发布—订阅的功能提取出来，放在一个单独的对象内：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = &#123; </span><br><span class="line">  clientList: [], </span><br><span class="line">  listen: <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span> ( !<span class="keyword">this</span>.clientList[ key ] )&#123; </span><br><span class="line">      <span class="keyword">this</span>.clientList[ key ] = []; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">this</span>.clientList[ key ].push( fn ); <span class="comment">// 订 阅 的 消 息 添 加 进 缓 存 列 表 </span></span><br><span class="line">  &#125;, </span><br><span class="line">  trigger: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call( <span class="built_in">arguments</span> ), <span class="comment">// (1); </span></span><br><span class="line">        fns = <span class="keyword">this</span>.clientList[ key ]; </span><br><span class="line">    <span class="keyword">if</span> ( !fns || fns.length === <span class="number">0</span> )&#123; <span class="comment">// 如 果 没 有 绑 定 对 应 的 消 息 </span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[ i++ ]; )&#123; </span><br><span class="line">      fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); <span class="comment">// (2) // arguments 是 trigger 时 带 上 的 参 数 </span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再定义一个installEvent函数，这个函数可以给所有的对象都动态安装发布—订阅功能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> installEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123; </span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> event )&#123; </span><br><span class="line">    obj[ i ] = event[ i ]; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>来测试一番，我们给售楼处对象salesOffices动态增加发布—订阅功能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;; </span><br><span class="line">installEvent( salesOffices ); </span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter88'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小 明 订 阅 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter100'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小 红 订 阅 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">salesOffices.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 输 出： 2000000 </span></span><br><span class="line">salesOffices.trigger( <span class="string">'squareMeter100'</span>, <span class="number">3000000</span> ); <span class="comment">// 输 出： 3000000</span></span><br></pre></td></tr></table></figure></p><h4 id="取消订阅的事件"><a href="#取消订阅的事件" class="headerlink" title="取消订阅的事件"></a>取消订阅的事件</h4><p>有时候，我们也许需要取消订阅事件的功能。比如小明突然不想买房子了，为了避免继续接收到售楼处推送过来的短信，小明需要取消之前订阅的事件。现在我们给event对象增加remove方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">event.remove = <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fns = <span class="keyword">this</span>.clientList[ key ]; </span><br><span class="line">  <span class="keyword">if</span> ( !fns )&#123; <span class="comment">// 如 果 key 对 应 的 消 息 没 有 被 人 订 阅， 则 直 接 返 回 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !fn )&#123; <span class="comment">// 如 果 没 有 传 入 具 体 的 回 调 函 数， 表 示 需 要 取 消 key 对 应 消 息 的 所 有 订 阅 </span></span><br><span class="line">    fns &amp;&amp; ( fns.length = <span class="number">0</span> ); </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> l = fns.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l-- )&#123; <span class="comment">// 反 向 遍 历 订 阅 的 回 调 函 数 列 表 </span></span><br><span class="line">      <span class="keyword">var</span> _fn = fns[ l ]; </span><br><span class="line">      <span class="keyword">if</span> ( _fn === fn )&#123; </span><br><span class="line">        fns.splice( l, <span class="number">1</span> ); <span class="comment">// 删 除 订 阅 者 的 回 调 函 数 </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> installEvent = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123; </span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> event )&#123; </span><br><span class="line">    obj[ i ] = event[ i ]; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">installEvent( salesOffices ); </span><br><span class="line"></span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter88'</span>, fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小 明 订 阅 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); </span><br><span class="line">&#125;); </span><br><span class="line">salesOffices.listen( <span class="string">'squareMeter88'</span>, fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小 红 订 阅 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); </span><br><span class="line">&#125;); </span><br><span class="line">salesOffices.remove( <span class="string">'squareMeter88'</span>, fn1 ); <span class="comment">// 删 除 小 明 的 订 阅 </span></span><br><span class="line">salesOffices.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 输 出： 2000000</span></span><br></pre></td></tr></table></figure></p><h4 id="例子——网站登录"><a href="#例子——网站登录" class="headerlink" title="例子——网站登录"></a>例子——网站登录</h4><p>假如我们正在开发一个商城网站，网站里有header头部、nav导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用ajax异步请求获取用户的登录信息。这是很正常的，比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。<br>至于ajax请求什么时候能成功返回用户信息，这点我们没有办法确定。现在的情节看起来像极了售楼处的例子，小明不知道什么时候开发商的售楼手续能够成功办下来。</p><p>但现在还不足以说服我们在此使用发布—订阅模式，因为异步的问题通常也可以用回调函数来解决。更重要的一点是，我们不知道除了header头部、nav导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面这样的形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">login.succ( <span class="function"><span class="keyword">function</span>(<span class="params"> data</span>)</span>&#123; </span><br><span class="line">  header.setAvatar( data.avatar); <span class="comment">// 设 置 header 模 块 的 头 像 </span></span><br><span class="line">  nav.setAvatar( data.avatar ); <span class="comment">// 设 置 导 航 模 块 的 头 像 </span></span><br><span class="line">  message.refresh(); <span class="comment">// 刷 新 消 息 列 表 </span></span><br><span class="line">  cart.refresh(); <span class="comment">// 刷 新 购 物 车 列 表 </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>现在登录模块是我们负责编写的，但我们还必须了解header模块里设置头像的方法叫setAvatar、购物车模块里刷新的方法叫refresh，这种耦合性会使程序变得僵硬，header模块不能随意再改变setAvatar的方法名，它自身的名字也不能被改为header1、header2。这是针对具体实现编程的典型例子，针对具体实现编程是不被赞同的。</p><p>等到有一天，项目中又新增了一个收货地址管理的模块，这个模块本来是另一个同事所写的，而此时你正在马来西亚度假，但是他却不得不给你打电话：“Hi，登录之后麻烦刷新一下收货地址列表。”于是你又翻开你3个月前写的登录模块，在最后部分加上这行代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">login.succ( <span class="function"><span class="keyword">function</span>(<span class="params"> data</span>)</span>&#123; </span><br><span class="line">  header.setAvatar( data.avatar); <span class="comment">// 设 置 header 模 块 的 头 像 </span></span><br><span class="line">  nav.setAvatar( data.avatar ); <span class="comment">// 设 置 导 航 模 块 的 头 像 </span></span><br><span class="line">  message.refresh(); <span class="comment">// 刷 新 消 息 列 表 </span></span><br><span class="line">  cart.refresh(); <span class="comment">// 刷 新 购 物 车 列 表 </span></span><br><span class="line"></span><br><span class="line">  address.refresh(); <span class="comment">// 增 加 这 行 代 码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我们就会越来越疲于应付这些突如其来的业务要求，要么跳槽了事，要么必须来重构这些代码。</p><p>用发布—订阅模式重写之后，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解它们的内部细节。改善后的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">'http://xxx.com?login'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data</span>)</span>&#123; <span class="comment">// 登 录 成 功 </span></span><br><span class="line">  login.trigger( <span class="string">'loginSucc'</span>, data); <span class="comment">// 发 布 登 录 成 功 的 消 息 </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>各模块监听登录成功的消息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> header = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// header 模 块 </span></span><br><span class="line">  login.listen( <span class="string">'loginSucc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data</span>)</span>&#123; header.setAvatar( data.avatar ); &#125;); </span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">setAvatar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'设 置 header 模 块 的 头 像'</span> ); &#125; &#125; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nav = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// nav 模 块 </span></span><br><span class="line">  login.listen( <span class="string">'loginSucc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123; nav.setAvatar( data.avatar ); &#125;); </span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">setAvatar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> avatar </span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'设 置 nav 模 块 的 头 像'</span> ); &#125; &#125; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>如上所述，我们随时可以把setAvatar的方法名改成setTouxiang。如果有一天在登录完成之后，又增加一个刷新收货地址列表的行为，那么只要在收货地址模块里加上监听消息的方法即可，而这可以让开发该模块的同事自己完成，你作为登录模块的开发者，永远不用再关心这些行为了。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> address = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="comment">// address 模 块 </span></span><br><span class="line">  login.listen( <span class="string">'loginSucc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123; address.refresh( obj ); &#125;); </span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">refresh</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> avatar </span>)</span>&#123; <span class="built_in">console</span>.log( <span class="string">'刷 新 收 货 地 址 列 表'</span> ); &#125; &#125; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h4 id="全局的发布－订阅对象"><a href="#全局的发布－订阅对象" class="headerlink" title="全局的发布－订阅对象"></a>全局的发布－订阅对象</h4><p>回想下刚刚实现的发布—订阅模式，我们给售楼处对象和登录对象都添加了订阅和发布的功能，这里还存在两个小问题。</p><ul><li>我们给每个发布者对象都添加了listen和trigger方法，以及一个缓存列表clientList，这其实是一种资源浪费。</li><li>小明跟售楼处对象还是存在一定的耦合性，小明至少要知道售楼处对象的名字是salesOffices，才能顺利的订阅到事件。<br>见如下代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">salesOffices.listen( <span class="string">'squareMeter100'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 小 明 订 阅 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>如果小明还关心300平方米的房子，而这套房子的卖家是salesOffices2，这意味着小明要开始订阅salesOffices2对象。</p><p>其实在现实中，买房子未必要亲自去售楼处，我们只要把订阅的请求交给中介公司，而各大房产公司也只需要通过中介公司来发布房子信息。这样一来，我们不用关心消息是来自哪个房产公司，我们在意的是能否顺利收到消息。当然，为了保证订阅者和发布者能顺利通信，订阅者和发布者都必须知道这个中介公司。</p><p>同样在程序中，发布—订阅模式可以用一个全局的Event对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event作为一个类似“中介者”的角色，把订阅者和发布者联系起来。见如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Event = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> clientList = &#123;&#125;, </span><br><span class="line">      listen, </span><br><span class="line">      trigger, </span><br><span class="line">      remove; </span><br><span class="line"></span><br><span class="line">  listen = <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span> ( !clientList[ key ] )&#123; </span><br><span class="line">      clientList[ key ] = []; </span><br><span class="line">    &#125; </span><br><span class="line">    clientList[ key ].push( fn ); </span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call( <span class="built_in">arguments</span> ), </span><br><span class="line">        fns = clientList[ key ]; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ( !fns || fns.length === <span class="number">0</span> )&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[ i++ ]; )&#123; </span><br><span class="line">      fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;; </span><br><span class="line">  </span><br><span class="line">  remove = <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> fns = clientList[ key ]; </span><br><span class="line">    <span class="keyword">if</span> ( !fns )&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( !fn )&#123; </span><br><span class="line">      fns &amp;&amp; ( fns.length = <span class="number">0</span> ); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> l = fns.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l-- )&#123; </span><br><span class="line">        <span class="keyword">var</span> _fn = fns[ l ]; </span><br><span class="line">        <span class="keyword">if</span> ( _fn === fn )&#123; fns.splice( l, <span class="number">1</span> ); &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">listen</span>: listen, <span class="attr">trigger</span>: trigger, <span class="attr">remove</span>: remove &#125; </span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Event.listen( <span class="string">'squareMeter88'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小 红 订 阅 消 息 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'价 格 = '</span> + price ); <span class="comment">// 输 出：' 价 格 = 2000000' </span></span><br><span class="line">&#125;); </span><br><span class="line">Event.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 售 楼 处 发 布 消 息</span></span><br></pre></td></tr></table></figure></p><h4 id="模块间通信"><a href="#模块间通信" class="headerlink" title="模块间通信"></a>模块间通信</h4><p>基于一个全局的Event对象实现的发布—订阅模式中，我们利用它可以在两个封装良好的模块中进行通信，这两个模块可以完全不知道对方的存在。就如同有了中介公司之后，我们不再需要知道房子开售的消息来自哪个售楼处。</p><p>比如现在有两个模块，a模块里面有一个按钮，每次点击按钮之后，b模块里的div中会显示按钮的总点击次数，我们用全局发布—订阅模式完成下面的代码，使得a模块和b模块可以在保持封装性的前提下进行通信。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById( <span class="string">'count'</span> ); </span><br><span class="line">  button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; Event.trigger( <span class="string">'add'</span>, count++ ); &#125; </span><br><span class="line">&#125;)(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById( <span class="string">'show'</span> ); </span><br><span class="line">  Event.listen( <span class="string">'add'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> count </span>)</span>&#123; div.innerHTML = count; &#125;); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>但在这里我们要留意另一个问题，模块之间如果用了太多的全局发布—订阅模式来通信，那么模块与模块之间的联系就被隐藏到了背后。我们最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块，这又会给我们的维护带来一些麻烦，也许某个模块的作用就是暴露一些接口给其他模块调用。</p><h4 id="必须先订阅再发布吗"><a href="#必须先订阅再发布吗" class="headerlink" title="必须先订阅再发布吗"></a>必须先订阅再发布吗</h4><p>我们所了解到的发布—订阅模式，都是订阅者必须先订阅一个消息，随后才能接收到发布者发布的消息。如果把顺序反过来，发布者先发布一条消息，而在此之前并没有对象来订阅它，这条消息无疑将消失在宇宙中。</p><p>在某些情况下，我们需要先将这条消息保存下来，等到有对象来订阅它的时候，再重新把消息发布给订阅者。就如同QQ中的离线消息一样，离线消息被保存在服务器中，接收人下次登录上线之后，可以重新收到这条消息。</p><p>这种需求在实际项目中是存在的，比如在之前的商城网站中，获取到用户信息之后才能渲染用户导航模块，而获取用户信息的操作是一个ajax异步请求。当ajax请求成功返回之后会发布一个事件，在此之前订阅了此事件的用户导航模块可以接收到这些用户信息。</p><p>但是这只是理想的状况，因为异步的原因，我们不能保证ajax请求返回的时间，有时候它返回得比较快，而此时用户导航模块的代码还没有加载好（还没有订阅相应事件），特别是在用了一些模块化惰性加载的技术后，这是很可能发生的事情。也许我们还需要一个方案，使得我们的发布—订阅对象拥有先发布后订阅的能力。</p><p>为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像QQ的未读消息只会被重新阅读一次，所以刚才的操作我们只能进行一次。</p><h4 id="全局事件的命名冲突"><a href="#全局事件的命名冲突" class="headerlink" title="全局事件的命名冲突"></a>全局事件的命名冲突</h4><p>全局的发布—订阅对象里只有一个clinetList来存放消息名和回调函数，大家都通过它来订阅和发布各种消息，久而久之，难免会出现事件名冲突的情况，所以我们还可以给Event对象提供创建命名空间的功能。</p><p>在提供最终的代码之前，我们来感受一下怎么使用这两个新增的功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************** 先 发 布 后 订 阅 ********************/</span> </span><br><span class="line">Event.trigger( <span class="string">'click'</span>, <span class="number">1</span> ); </span><br><span class="line">Event.listen( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> a </span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 输 出： 1 </span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">/************** 使 用 命 名 空 间 ********************/</span> </span><br><span class="line">Event.create( <span class="string">'namespace1'</span> ).listen( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> a </span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 输 出： 1 </span></span><br><span class="line">&#125;); </span><br><span class="line">Event.create( <span class="string">'namespace1'</span> ).trigger( <span class="string">'click'</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">Event.create( <span class="string">'namespace2'</span> ).listen( <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> a </span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 输 出： 2 </span></span><br><span class="line">&#125;); </span><br><span class="line">Event.create( <span class="string">'namespace2'</span> ).trigger( <span class="string">'click'</span>, <span class="number">2</span> );</span><br></pre></td></tr></table></figure></p><p>具体实现代码<a href="event.js">Event.js</a></p><h4 id="JavaScript实现发布－订阅模式的便利性"><a href="#JavaScript实现发布－订阅模式的便利性" class="headerlink" title="JavaScript实现发布－订阅模式的便利性"></a>JavaScript实现发布－订阅模式的便利性</h4><p>这里要提出的是，我们一直讨论的发布—订阅模式，跟一些别的语言（比如Java）中的实现还是有区别的。在Java中实现一个自己的发布—订阅模式，通常会把订阅者对象自身当成引用传入发布者对象中，同时订阅者对象还需提供一个名为诸如update的方法，供发布者对象在适合的时候调用。而在JavaScript中，我们用注册回调函数的形式来代替传统的发布—订阅模式，显得更加优雅和简单。</p><p>另外，在JavaScript中，我们无需去选择使用推模型还是拉模型。推模型是指在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。拉模型不同的地方是，发布者仅仅通知订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。拉模型的好处是可以让订阅者“按需获取”，但同时有可能让发布者变成一个“门户大开”的对象，同时增加了代码量和复杂度。</p><p>刚好在JavaScript中，arguments可以很方便地表示参数列表，所以我们一般都会选择推模型，使用Function.prototype.apply方法把所有参数都推送给订阅者。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是MVC还是MVVM，都少不了发布—订阅模式的参与，而且JavaScript本身也是一门基于事件驱动的语言。</p><p>当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug不是件轻松的事情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;发布-订阅模式（观察者模式）定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布—订阅模式。&lt;/p&gt;
&lt;p&gt;不论是在程序世界里还是现实生活中，发布—订阅模式的应用都非常
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式-6-迭代器模式</title>
    <link href="https://github.com/xmoyKING/2017/11/15/js-pattern6/"/>
    <id>https://github.com/xmoyKING/2017/11/15/js-pattern6/</id>
    <published>2017-11-15T15:08:39.000Z</published>
    <updated>2017-12-06T14:50:09.337Z</updated>
    
    <content type="html"><![CDATA[<p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p><p>目前，恐怕只有在一些“古董级”的语言中才会为实现一个迭代器模式而烦恼，现在流行的大部分语言如Java、Ruby等都已经有了内置的迭代器实现，许多浏览器也支持JavaScript的Array.prototype.forEach。</p><p>迭代器模式无非就是循环访问聚合对象中的各个元素。比如jQuery中的$.each函数，其中回调函数中的参数i为当前索引，n为当前元素，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="function"><span class="keyword">function</span>(<span class="params">i,n</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'当前下标为：'</span>+i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'当前值为:'</span>+n);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>###实现自己的迭代器<br>现在我们来自己实现一个each函数，each函数接受2个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回调函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> each=<span class="function"><span class="keyword">function</span>(<span class="params">ary,callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(vari=<span class="number">0</span>,l=ary.length;i&lt;l;i++)&#123;</span><br><span class="line">    callback.call(ary[i],i,ary[i]);<span class="comment">//把下标和元素当作参数传给callback函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="function"><span class="keyword">function</span>(<span class="params">i,n</span>)</span>&#123;</span><br><span class="line">  alert([i,n]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="内部迭代器和外部迭代器"><a href="#内部迭代器和外部迭代器" class="headerlink" title="内部迭代器和外部迭代器"></a>内部迭代器和外部迭代器</h3><p>迭代器可以分为内部迭代器和外部迭代器，它们有各自的适用场景。</p><h4 id="内部迭代器"><a href="#内部迭代器" class="headerlink" title="内部迭代器"></a>内部迭代器</h4><p>刚刚编写的each函数属于内部迭代器，each函数的内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。</p><p>内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，上面的each函数就无法同时迭代2个数组了。</p><p>比如现在有个需求，要判断2个数组里元素的值是否完全相等，如果不改写each函数本身的代码，我们能够入手的地方似乎只剩下each的回调函数了，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compare=<span class="function"><span class="keyword">function</span>(<span class="params">ary1,ary2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ary1.length!==ary2.length)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'ary1和ary2不相等'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  each(ary1,<span class="function"><span class="keyword">function</span>(<span class="params">i,n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n!==ary2[i])&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'ary1和ary2不相等'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  alert(<span class="string">'ary1和ary2相等'</span>); </span><br><span class="line">&#125;;</span><br><span class="line">compare([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]);<span class="comment">//thrownewError('ary1和ary2不相等');</span></span><br></pre></td></tr></table></figure></p><p>说实话，这个compare函数一点都算不上好看，我们目前能够顺利完成需求，还要感谢在JavaScript里可以把函数当作参数传递的特性，但在其他语言中未必就能如此幸运。在一些没有闭包的语言中，内部迭代器本身的实现也相当复杂。比如C语言中的内部迭代器是用函数指针来实现的，循环处理所需要的数据都要以参数的形式明确地从外面传递进去。</p><h4 id="外部迭代器"><a href="#外部迭代器" class="headerlink" title="外部迭代器"></a>外部迭代器</h4><p>外部迭代器必须显式地请求迭代下一个元素。外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。</p><p>下面这个外部迭代器的实现来自《松本行弘的程序世界》第4章，原例用Ruby写成，这里我们翻译成JavaScript：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Iterator=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> next=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;current+=<span class="number">1</span>;&#125;;</span><br><span class="line">  <span class="keyword">var</span> isDone=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;returncurrent&gt;=obj.length;&#125;;</span><br><span class="line">  <span class="keyword">var</span> getCurrItem=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;returnobj[current];&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>&#123;<span class="attr">next</span>:next,<span class="attr">isDone</span>:isDone,<span class="attr">getCurrItem</span>:getCurrItem&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写compare函数：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compare = <span class="function"><span class="keyword">function</span>(<span class="params"> iterator1, iterator2 </span>)</span>&#123; </span><br><span class="line">  <span class="keyword">while</span>( !iterator1.isDone() &amp;&amp; !iterator2.isDone() )&#123; </span><br><span class="line">    <span class="keyword">if</span> ( iterator1.getCurrItem() !== iterator2.getCurrItem() )&#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'iterator1 和 iterator2 不 相 等'</span> ); </span><br><span class="line">    &#125; </span><br><span class="line">    iterator1.next(); </span><br><span class="line">    iterator2.next(); </span><br><span class="line">  &#125; </span><br><span class="line">  alert( <span class="string">'iterator1 和 iterator2 相 等'</span> ); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> iterator1 = Iterator( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] ); </span><br><span class="line"><span class="keyword">var</span> iterator2 = Iterator( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ] );</span><br></pre></td></tr></table></figure></p><p>外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。内部迭代器和外部迭代器在实际生产中没有优劣之分，究竟使用哪个要根据需求场景而定。</p><h4 id="迭代类数组对象和字面量对象"><a href="#迭代类数组对象和字面量对象" class="headerlink" title="迭代类数组对象和字面量对象"></a>迭代类数组对象和字面量对象</h4><p>迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象。比如arguments、{“0”:’a’,”1”:’b’}等。通过上面的代码可以观察到，无论是内部迭代器还是外部迭代器，只要被迭代的聚合对象拥有length属性而且可以用下标访问，那它就可以被迭代。</p><p>在JavaScript中，for in语句可以用来迭代普通字面量对象的属性。jQuery中提供了$.each函数来封装各种迭代行为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$.each = <span class="function"><span class="keyword">function</span>(<span class="params"> obj, callback </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> value, </span><br><span class="line">      i = <span class="number">0</span>, </span><br><span class="line">      length = obj.length, </span><br><span class="line">      isArray = isArraylike( obj ); </span><br><span class="line">  <span class="keyword">if</span> ( isArray ) &#123; <span class="comment">// 迭 代 类 数 组 </span></span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; length; i ++ ) &#123; </span><br><span class="line">      value = callback.call( obj[ i ], i, obj[ i ] ); </span><br><span class="line">      <span class="keyword">if</span> ( value === <span class="literal">false</span> ) &#123; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) &#123; <span class="comment">// 迭 代 object 对 象 </span></span><br><span class="line">      value = callback.call( obj[ i ], i, obj[ i ] ); </span><br><span class="line">      <span class="keyword">if</span> ( value === <span class="literal">false</span> ) &#123; <span class="keyword">break</span>; &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> obj; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="倒序迭代器"><a href="#倒序迭代器" class="headerlink" title="倒序迭代器"></a>倒序迭代器</h4><p>由于GoF中对迭代器模式的定义非常松散，所以我们可以有多种多样的迭代器实现。总的来说，迭代器模式提供了循环访问一个聚合对象中每个元素的方法，但它没有规定我们以顺序、倒序还是中序来循环遍历聚合对象。</p><h4 id="中止迭代器"><a href="#中止迭代器" class="headerlink" title="中止迭代器"></a>中止迭代器</h4><p>迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。jQuery的each函数里有这样一句：<code>if(value === false){break;}</code>这句代码的意思是，约定如果回调函数的执行结果返回false，则提前终止循环。下面我们把之前的each函数改写一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> each = <span class="function"><span class="keyword">function</span>(<span class="params"> ary, callback </span>)</span>&#123; </span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = ary.length; i &lt; l; i++ )&#123; </span><br><span class="line">    <span class="keyword">if</span> ( callback( i, ary[ i ] ) === <span class="literal">false</span> )&#123; <span class="comment">// callback 的 执 行 结 果 返 回 false， 提 前 终 止 迭 代 </span></span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line">each( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ], <span class="function"><span class="keyword">function</span>(<span class="params"> i, n </span>)</span>&#123; <span class="keyword">if</span> ( n &gt; <span class="number">3</span> )&#123; <span class="comment">// n 大 于 3 的 时 候 终 止 循 环 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( n ); <span class="comment">// 分 别 输 出： 1, 2, 3</span></span><br></pre></td></tr></table></figure></p><h4 id="迭代器模式的应用举例"><a href="#迭代器模式的应用举例" class="headerlink" title="迭代器模式的应用举例"></a>迭代器模式的应用举例</h4><p>某个项目中文件上传模块的代码，它的目的是根据不同的浏览器获取相应的上传组件对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"TXFTNActiveX.FTNUpload"</span>); <span class="comment">// IE 上 传 控 件 </span></span><br><span class="line">  &#125;<span class="keyword">catch</span>( e)&#123; </span><br><span class="line">    <span class="keyword">if</span> ( supportFlash() )&#123; <span class="comment">// supportFlash 函 数 未 提 供 </span></span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">'&lt;object type=" application/x-shockwave-flash" &gt; &lt;/object&gt;'</span>;</span><br><span class="line">      <span class="keyword">return</span> $( str ). appendTo( $(<span class="string">'body'</span>) ); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">      <span class="keyword">var</span> str = <span class="string">'&lt;input name=" file" type=" file" /&gt;'</span>; <span class="comment">// 表 单 上 传 </span></span><br><span class="line">      <span class="keyword">return</span> $( str ).appendTo( $(<span class="string">'body'</span>) ); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在不同的浏览器环境下，选择的上传方式是不一样的。因为使用浏览器的上传控件进行上传速度快，可以暂停和续传，所以我们首先会优先使用控件上传。如果浏览器没有安装上传控件，则使用Flash上传，如果连Flash也没安装，那就只好使用浏览器原生的表单上传了。</p><p>看看上面的代码，为了得到一个upload对象，这个getUploadObj函数里面充斥了try，catch以及if条件分支。缺点是显而易见的。第一是很难阅读，第二是严重违反开闭原则。在开发和调试过程中，我们需要来回切换不同的上传方式，每次改动都相当痛苦。后来我们还增加支持了一些另外的上传方式，比如，HTML5上传，这时候唯一的办法是继续往getUploadObj函数里增加条件分支。</p><p>现在来梳理一下问题，目前一共有3种可能的上传方式，我们不知道目前正在使用的浏览器支持哪几种。就好比我们有一个钥匙串，其中共有3把钥匙，我们想打开一扇门但是不知道该使用哪把钥匙，于是从第一把钥匙开始，迭代钥匙串进行尝试，直到找到了正确的钥匙为止。</p><p>同样，我们把每种获取upload对象的方法都封装在各自的函数里，然后使用一个迭代器，迭代获取这些upload对象，直到获取到一个可用的为止：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getActiveUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">try</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"TXFTNActiveX.FTNUpload"</span> ); <span class="comment">// IE 上 传 控 件 </span></span><br><span class="line">  &#125;<span class="keyword">catch</span>( e)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getFlashUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span> ( supportFlash() )&#123; <span class="comment">// supportFlash 函 数 未 提 供 </span></span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">'&lt;object type="application/x-shockwave-flash"&gt; &lt;/object&gt;'</span>; </span><br><span class="line">    <span class="keyword">return</span> $( str ).appendTo( $(<span class="string">'body'</span>) ); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getFormUpladObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">'&lt;input name="file" type="file" /&gt;'</span>; <span class="comment">// 表 单 上 传 </span></span><br><span class="line">  <span class="keyword">return</span> $( str ).appendTo( $(<span class="string">'body'</span>) ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在getActiveUploadObj、getFlashUploadObj、getFormUpladObj这3个函数中都有同一个约定：如果该函数里面的upload对象是可用的，则让函数返回该对象，反之返回false，提示迭代器继续往后面进行迭代。</p><p>所以我们的迭代器只需进行下面这几步工作。</p><ul><li>提供一个可以被迭代的方法，使得getActiveUploadObj，getFlashUploadObj以及getFlashUploadObj依照优先级被循环迭代。</li><li>如果正在被迭代的函数返回一个对象，则表示找到了正确的upload对象，反之如果该函数返回false，则让迭代器继续工作。</li></ul><p>迭代器代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iteratorUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = <span class="built_in">arguments</span>[ i++ ]; )&#123; </span><br><span class="line">    <span class="keyword">var</span> uploadObj = fn(); </span><br><span class="line">    <span class="keyword">if</span> ( uploadObj !== <span class="literal">false</span> )&#123; </span><br><span class="line">      <span class="keyword">return</span> uploadObj; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUpladObj );</span><br></pre></td></tr></table></figure></p><p>重构代码之后，我们可以看到，获取不同上传对象的方法被隔离在各自的函数里互不干扰，try、catch和if分支不再纠缠在一起，使得我们可以很方便地的维护和扩展代码。比如，后来我们又给上传项目增加了Webkit控件上传和HTML5上传，我们要做的仅仅是下面一些工作。</p><p>1.增加分别获取Webkit控件上传对象和HTML5上传对象的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getWebkitUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 具 体 代 码 略 </span></span><br><span class="line">&#125;; 　 </span><br><span class="line"><span class="keyword">var</span> getHtml5UploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 具 体 代 码 略 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>2.依照优先级把它们添加进迭代器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uploadObj = iteratorUploadObj( getActiveUploadObj, getWebkitUploadObj, getFlashUploadObj, getHtml5UploadObj, getFormUpladObj );</span><br></pre></td></tr></table></figure></p><p>迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。&lt;/p&gt;
&lt;p&gt;目前，恐怕只有在一些“古董级”的语言中
      
    
    </summary>
    
      <category term="js" scheme="https://github.com/xmoyKING/categories/js/"/>
    
    
      <category term="js" scheme="https://github.com/xmoyKING/tags/js/"/>
    
      <category term="design pattern" scheme="https://github.com/xmoyKING/tags/design-pattern/"/>
    
  </entry>
  
</feed>
